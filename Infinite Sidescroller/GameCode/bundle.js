(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// This file contains shortcuts for the methods of the Box2D library that are used
// too often to type their long names

var B2d = function(){

};

B2d.prototype.init = function(){
	include();

	this.b2Vec2 = Box2D.Common.Math.b2Vec2;
	this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
	this.b2Body = Box2D.Dynamics.b2Body;
	this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
	this.b2Fixture = Box2D.Dynamics.b2Fixture;
	this.b2World = Box2D.Dynamics.b2World;
	this.b2MassData = Box2D.Collision.Shapes.b2MassData;
	this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
	this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
	this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw; 
	this.b2ContactListener = Box2D.Dynamics.b2ContactListener;

};

module.exports = new B2d;

var Includes = require("./Includes.js"); var include_data = Includes.get_include_data({
	current_module: "B2d", 
	include_options: Includes.choices.OTHER_STUFF
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"./Includes.js":19}],2:[function(require,module,exports){
var Config = function(){
	this.SCREEN_W = 0; // set up when the page is loaded (to 95% of width of containing element) 
	this.SCREEN_H = 600;

	this.MAIN_CANVAS_NAME = "display_canvas";
	this.DEBUG_CANVAS_NAME = "debug_canvas";

	// Frames Per Second. Essentially, frequency of createjs.Ticker 
	// Warning! Frequency of the Box2D physics updates may be different
	// (Currently not implemented)
	this.FPS = 30; 
	
	//the movement edge, controls terrain generation
	this.movement_edge = 0;

	// Box2D stuff >>>
	this.B2D = {
		SCALE: 30,
		SPS: 60, 			// Steps Per Second
		VELOCITY_ITR: 8,	// velocity iterations
		POSITION_ITR: 3,	// position iterations
		debug_draw: false
	};

	this.TerrainSlice = {
		grid_rows: 20,
		grid_columns: 20,
		cell_w: 1, // in meters

		// is automatically incremented each time new TerrainSliceModel is instantiated:
		next_slice_id: 0 
	};

	this.World = {
		maxy: 22,

	};
	this.Remote = {
		master: false, // am I the one with whome other players sync? 
		connected: false, // am I in multiplayer mode
		connection_timeout: 1000, // ms
		notification_wait: 3000, // ms !!! SHOULD BE AT LEAST 1000 bigger THAN THE PREVIOUS ONE
	};
	
	this.Init = {
		session_id: null,
		player_id: null,
		mode: null,

		// for multiplayer game you have certain time limit
		// to join the game. In this time limit players shouldn't be able to go past
		// certain point of the map.
		movement_blocked: true,
		time_limit: 15, // seconds
		// we should begin automatically after everyone is joined

	}
};

module.exports = new Config;

},{}],3:[function(require,module,exports){

var AssetController = (function(){
	/*
	   AssetController is in charge of setting up all bitmaps/animations/other resources
	   for everyone else.
   */

	// use AssetModel.loader.getResult("id_of_the_asset");

	var init = function(asset_path){
		include();	

		/* TODO make model with the easily managed tables of resources which will be
		   added to the loader automatically
		*/

		//loader = new createjs.LoadQueue(false); // loading resourses using preload.js
		//loader.addEventListener("complete", handleComplete);
		var manifest = AssetModel.manifest;	
		AssetModel.loader.loadManifest(manifest, true, asset_path);
		
	};

	var post_init = function(){
		/* this function will be done differently at some point
		 * it'll have something to do with refactoring InitController
		 */

		//AssetModel.animations["ant"] = new createjs.SpriteSheet({
			//"framerate": 0.2,
			//"images": [get_asset("Ant1"), get_asset("Ant2"), get_asset("Ant3")],
			//"frames": { "regX": 3, "regY": 6, "height": 25, "width": 50, "count": 6},
			//"animations": {
				//"walk": [0, 1, "walk"],
				//"upside_down": [2, 3, "upside_down"],
				//"death": [4, 5, "death"]
			//}
		//})

	};
	

	var get_asset = function(id){

		var result = AssetModel.loader.getResult(id);

		if(!result){
			throw "Error: asset with id " + id + " could not be loaded." +
				" Check that id is valid and that assets were properly loaded";
		}
		
		return result;
	};
		


	
	return {
		init: init,
		get_asset: get_asset,
	};

})();

module.exports = AssetController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "AssetController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],4:[function(require,module,exports){
var EntityController = (function () {
    /* Description
    */

    var type_logic_table;

    var Count = 0;

    var init = function () {
        /* is ran from the InitController once when the game is loaded */

        include(); // satisfy requirements
		//type_logic_table = {
		//	"ant": AntLogic,
		//	"hero": HeroLogic,
		//	"companion": EsteemedCompanionLogic,
		//};

        type_logic_table = {
            "ant": AntLogic,
            "hero": HeroLogic,
            "Griffin": GriffinLogic,
            "Hyena": HyenaLogic,
			"Medusa": MedusaLogic,
			"pizza": PizzaLogic,
            "Centaur": CentaurLogic,
        };
        

        for (type in type_logic_table) {
            var logic = type_logic_table[type];
            logic.init();

            if (logic.begin_contact) {
                PhysicsController.listen_for_contact_with(type, "BeginContact", logic.begin_contact);
            }

            if (logic.end_contact) {
                PhysicsController.listen_for_contact_with(type, "EndContact", logic.end_contact);
            }

            if (logic.pre_solve) {
                PhysicsController.listen_for_contact_with(type, "PreSolve", logic.pre_solve);
            }

            if (logic.post_solve) {
                PhysicsController.listen_for_contact_with(type, "PostSolve", logic.post_solve);
            }

        }

    };


	var update = function(delta){
		/* is ran each tick from the GameController.update_all */
		var debug_commands = KeyboardController.debug_commands();

		// demonstration purposes
		if(debug_commands("spawn_ant")){
		    spawn((Math.random() * 50 + 10 + WorldController.get_movement_edge()), 10, "ant");
		}

		if (debug_commands("spawn_pizza")) {
		    spawn((Math.random() * 50 + 10 + WorldController.get_movement_edge()), 16, "pizza");
		}

		if(debug_commands("request_hero") && !EntityModel.hero_spawned){
			// if hero is requested, and not spawned yet,
			// spawn hero
			
			EntityModel.hero_spawned = true;
			spawn(WorldController.get_movement_edge() + 10,10, "hero");
		}

		if (debug_commands("spawn_griffin") && Count > 5) {
            var new_griffin = spawn(Math.random() * 50 + WorldController.get_movement_edge(), -20, "Griffin");
            Count = 0;
        }
        Count++;

        if (debug_commands("spawn_griffin")) {
            var new_griffin = spawn(Math.random() * 50 + WorldController.get_movement_edge(), 10, "Griffin");
        }


        // demonstration purposes for hyena
        if (debug_commands("spawn_hyena")) {
            var new_hyena = spawn(Math.random() * 50 + WorldController.get_movement_edge(), 10, "Hyena");
        }
		
		// demonstration purposes for Medusa
        if (debug_commands("spawn_medusa")) {
            var new_Medusa = spawn(Math.random() * 50 + WorldController.get_movement_edge(), 10, "Medusa");
        }

	    // demonstration purposes for Centaur
        if (debug_commands("spawn_centaur")) {
            var new_Centaur = spawn(Math.random() * 50 + WorldController.get_movement_edge(), 10, "Centaur");
        }
		

		/*
		//This should be handled in the update of MultiplayerSync
		if(Config.Remote.master){//if master, parse requests
			MultiplayerSyncController.receive_spawn_request();
		}else if(Config.Remote.connected){//if slave, parse notifications
			MultiplayerSyncController.receive_spawn_notification();
		}
		*/
		for (var type in EntityModel.for_logic_update) {
            var table = EntityModel.for_logic_update[type];

            var logic = type_logic_table[type];
            for (var id in table) {
                var entity = table[id];

                if (beyond_world_boundary(entity)) {
                    // if outside boundaries of the world, despawn
                    entity.point_value = 0;
                    despawn(entity);
                    if (entity.type == "hero") {
                        entity.hp = 0;
                    }
                    console.log("entity of type", type, "deleted due to the world boundary");
                } else {
                    // else tick its AI
                    logic.tick_AI(entity);
                }
            }

        } // end for in 

		sync_hero();

	};

	var spawn = function(x, y, type){
		/**
		* spawn entity of type >type<
		* at position (x, y)
		* ! notice that it doesn't spawn entity directly, but instead sends the request
		* ! for the entity deletion, so undeterminate amount of time may pass from the
		* ! moment this function returned, until the entity is actually spawned
		* this time will usually be relatively small, probably 2-20 ticks or so for multiplayer
		*/

		MultiplayerSyncController.route_outcoming_packet({
			op: "spawn",
			type: type,
			x: x,
			y: y
		});
	};

	var handle_spawn = function(packet){
		/**
		* takes the packet with >op< "spawn"
		* containing properties >x<, >y<, >type<, and possibly more
		* handles creation of the entity, id assignment, etc.
		*/

		
		var x = packet.x,
			y = packet.y,
			type = packet.type;

		if(type_logic_table[type] == null){
			throw "No logic found for the type" + String(type);
		}

		var logic = type_logic_table[type];
		var entity = logic.spawn(x, y);

		if(type == "hero"){
			// TODO: move this whole thing into the HeroLogic.spawn?
			var player_id = packet.player_id;
			if(player_id == null){
				throw "player_id is undefined";
			}
			// identify the hero
			entity.player_id = player_id;
			// store it for EntityController purposes
			EntityModel.heroes[player_id] = entity;
		}

		IdentificationController.assign_id(entity);

		reg_for_logic_update(entity);

		RegisterAsController.register_as("awaiting_graphics_initialization", entity)
	};
	
	
	//registers a new instance
	//so that renderers and updaters know to update it on tick
	var reg_for_logic_update = function(new_entity){
		var type = new_entity.type;

		if(type == null){
			console.log(new_entity);
			throw "Type is undefined for this entity";
		}

		if(!EntityModel.for_logic_update[type]){
			EntityModel.for_logic_update[type] = {};
		}
		var logic_upd_table = EntityModel.for_logic_update[type];
		logic_upd_table[new_entity.id] =  new_entity;
		
	};
	
	//wrapper for universal spawn
	//maintains the old interface
	//var spawn = function(type,x,y){
		//MultiplayerSyncController.handle_spawn({type:type,x:x,y:y});
	//};
	
	var delete_entity = function(entity_instance){
		/**
		* This function is supposed to be called by the individual logic modules, when the are finished
		* animating deat/destruction of something and want to get rid of it, or in other circumstances,
		* when entity should be immediately deleted from the world
		* ! notice that it doesn't delete entity directly, but instead sends the request
		* ! for the entity deletion, so undeterminate amount of time may pass from the
		* ! moment this function returned, until the entity is actually deleted
		* this time will usually be relatively small, probably 2-20 ticks or so for multiplayer
		*/

		MultiplayerSyncController.route_outcoming_packet({
			op: "delete_entity",
			id: entity_instance.id,
			type: entity_instance.type,
		});

	};
	
	var handle_delete = function(packet){
		/**
		* This function will remove this entity along with some other info about this entity
		* from the world, it'll also free the id of this entity. The physical body will be deleted
		* too; 
		*/

		var entity_instance = EntityModel.for_logic_update[packet.type][packet.id];

		if(entity_instance == null){
			// if no such entity,
			// probably it was already deleted through other means,
			// thus abort
			return;
		}
	
		var type = entity_instance.type;
		if(type == null){
			console.log(entity_instance);
			throw "type is undefined for this entity";
		}

		var id = entity_instance.id;
		if(id == null){
			console.log(entity_instance);
			throw "id is undefined for this entity";
		}
		

		// TODO: finish this function and then update it regularly;
		// This one is very sensitive, as even one reference left may prevent 
		// object from being deleted and cause memory leaks. Testing is required
		if(entity_instance.body != null){
			var body = entity_instance.body;
		}else{
			// body is required. if place where body is stored changed, you should update this function
			throw "Body of the instance is undefined"
		}
		// remove graphics
			RegisterAsController.register_as("removed_entity", entity_instance);
		// remove physics
			PhysicsController.remove_body(body);
		// remove stored references within EntityController/Model
			delete EntityModel.for_logic_update[type][id];
			if(type == "hero"){
				delete EntityModel.heroes[entity_instance.player_id];
				EntityModel.hero_spawned = false;
			}
		// free the id
			IdentificationController.remove_id(id);
	};


    var despawn = function (entity) {
        /**
         * this function will despawn given entity
         * in one of two ways:
         * if entity has despawn function, it will be called
         * if not, entity will be deleted directly
        */

        var type = entity.type;
        var id = entity.id;


        if (entity.die) {
            // if custom despawn function is provided, call it
			entity.die();
            console.log("die called for the type", type);
        } else {
            // or delete directly
            delete_entity(entity);
			console.warn("die function not defined for the entity of type", type);
        }

    };


    var beyond_world_boundary = function (entity) {
        /**
        * checks if the entity is beyond one of the world boundaries,
        */
        var body = entity.body;
        return (body.GetWorldCenter().x < WorldController.get_movement_edge() ||
            body.GetWorldCenter().y > Config.World.maxy);

    };
		
		
	var create_abstract_entity = function(){
		return new AbstractEntity();
	};
		
		
	/**
	class AbstractEntity
	member functions:
		//numbers are given in meters rather than pixels except where noted (1 meter = 30 pixels)
		VOID jump(double x, double y)
					applies an impulse with x_component x and y_component y
		VOID jump_direction(double angle, double force)
					where angle is in degrees. calls jump internally
		VOID move(double speed)
					causes the entity to move horizontally at speed/tick. 
		BOOL enemy_in_range
					returns true if any hero is within range (x axis only)
		BOOL direction_nearest_enemy()
					returns true (right) if the nearest enemy is to the right, else returns false (left)
		VOID take_damage()
					checks if damage has been dealt this tick and resolves it 
		VOID die()
					should be called each tick that hp <= 0. handles death and decay
		b2dFixture get_fixture(string name)
					given a name, returns the first fixture in entity.body with matching name. default names are "top", "bottom", "left", "right", and "main".
		BOOL movement_voluntary()
					returns true if the object is moving in the same direction it is facing, else false
		BOOL in_air()
					returns true if there are no objects immediately below the entity, else false
		BOOL path_free()
					returns true if their is an object immediately adjacent to the entity in the currently faced direction
		VOID change_animation(string animation_id)
					sets the animation for the entity, and ensures that the animation will not be continuously reset.
	*/
	this.AbstractEntity = function(){
		this.hp = 2;
		this.speed = 7;
		this.jump_force = 125;
		this.damage = 5;
		this.point_value = 200;
		this.sight_range = 16; //distance at which entity detects heroes
		this.attack_range = 8; //distance at which entity leaps at the hero
		
		this.hit_taken = false; //whether a hit has been taken since the last tick
		this.damage_taken = 0; //the amount of damage inflicted by hits since the last tick
		
		this.direction = false;	//false=left, true=right;
		this.direction_previous = false;//store direction from end of previous tick
		this.x_previous = 0;		//store x value from end of previous tick
		this.y_previous = 0;		//store x value from end of previous tick
		this.velocity_previous = new B2D.b2Vec2(0,0);
		
		this.is_idle = true; //determines whether entity is aggressive or idle
		this.idle_duration = 40; // time buffer between changing idle states
		this.idle_timer = this.idle_duration;
		this.idle_counter = 0; //used to manage the number of times the entity has changed state while idle
		this.is_alive = true; //disables attacking and plays death animation while false
		this.death_duration = 30;//time between death and deletion
		this.decay_duration = 20;//time between decay animation and deletion
		this.death_timer = -1;
		this.running_away = false; //whether the entity is running away
		this.run_away_duration = 30; //set cowardice level
		this.run_away_timer = -1;
		this.can_attack = true;	//whether attacking is enabled
		this.attack_cooldown = 10; //attack cooldown
		this.attack_cooldown_timer = -1;
		this.can_leap = true;		//leaping enabled
		this.leap_cooldown = 40;//minimum time between leaps
		this.leap_cooldown_timer = -1; 
		this.charge_duration = 80;//maximum length of a charge
		this.charge_timer = this.charge_duration;
		this.charge_cooldown = 20;//minimum time between charges
		this.charge_cooldown_timer = -1;
		this.blinking = false;	//whether entity is blinking
		this.blink_duration = 20;//how long the entity blinks after taking damage
		this.blink_timer = -1;
		this.maintenance_frequency = 20;//ticks between routine maintenance checks
		this.maintenance_timer = this.maintenance_frequency;
		
		this.path_blocked = false;//is this deprecated? set during collision
		this.obstruction_tolerance = 4;//how many times the entity can be blocked before he takes action
		this.blocked_count = 0;//tracks number of times blocked between maintenance checks
		
		this.needs_graphics_update = false; //accessed by renderer for animation purposes
		this.animation = "stand"; //accessed by renderer for animation purposes
		
		//boost entity
		this.jump = function(x,y){
			var body = this.body;
			var direction = new B2d.b2Vec2(x, y);
			body.ApplyImpulse(direction, body.GetWorldCenter());
		};
		
		//converts angle and force into x and y, then calls jump
		this.jump_direction = function(angle,force){
			var x,y;
			angle = ((angle%360)*Math.PI)/180;
			x = force*Math.cos(angle);
			y = force*Math.sin(angle);
			this.jump(x,y);
		};
		
		
		//move speed in current direction
		this.move = function(speed){
			var dir = (this.direction*2-1);
			var velocity = this.body.GetLinearVelocity();
			velocity.x = speed*dir; 
			this.body.SetLinearVelocity(velocity);
			this.body.SetAwake(true);
		};
			
		//check for enemies in range (vision or jump)
		this.enemy_in_range = function(range){
			var hero_x;
			var output = false;
			//Multiplayer
			var hero_list = EntityController.get_all_heroes();
			if(hero_list.length != null){
				for (i=0; i<hero_list.length; i++){
					if(hero_list[i] != null){
						hero_x = hero_list[i].body.GetWorldCenter().x
						if(Math.abs(hero_x - this.body.GetWorldCenter().x) < range){
							output = true;
							break;
						}
					}
				}
			}else if(EntityController.get_my_hero() != null){
				var hero = EntityController.get_my_hero();
				if(hero != null){
					hero_x = hero.body.GetWorldCenter().x;
					output = (Math.abs(hero_x - this.body.GetWorldCenter().x) < range);
				}
			}
			return output;
		};
		
		//returns the direction of nearest enemy
		this.direction_nearest_enemy = function(){
			//in multiplayer, first find nearest enemy
			var nearest, hero_x; 
			var distance = 0;
			var x = this.body.GetWorldCenter().x;
			var hero_list = EntityController.get_all_heroes();
			if(hero_list.length != null){
				for(i=0;i<8;i++){
					if(hero_list.i != null){
						if(Math.abs(hero_list.i.body.GetWorldCenter().x - x) < Math.abs(nearest.body.GetWorldCenter().x - x) || nearest == null){
							nearest = hero_list.i;
						}
					}
				}
				hero_x = nearest.body.GetWorldCenter().x;
				distance = (hero_x - x);
			}else if(EntityController.get_my_hero() != null){
				distance = EntityController.get_my_hero().body.GetWorldCenter().x - x;
			}
			return (distance > 0);//return true/right of distance is positive, return false/left if distance is negative
			/*
			//single player implementation
			var nearest;
			var hero_x = EntityController.get_my_hero().body.GetWorldCenter().x;
			var distance = (hero_x - this.body.GetWorldCenter().x);
			return (distance > 0);//return true/right of distance is positive, return false/left if distance is negative
			*/
		};
		
		//decrease health
		this.take_damage = function(){
			this.hp -= this.damage_taken;
			this.damage_taken = 0;
			this.hit_taken = false;
			this.blinking = true;
			this.blink_timer = this.blink_duration;
			//knockback here
		};
		
		//die
		this.die = function(){
			if (this.is_alive){//if alive, kill it
				this.death_timer = this.death_duration;
				this.is_alive = false;
				WorldController.increase_score(this.point_value);
				this.hit_taken = false;
				this.can_attack = false;
				this.change_animation(this,"death");
				return ;
			}else{//else decay
				this.death_timer--;
				if (this.death_timer <= this.death_duration && this.death_timer > this.decay_duration && this.death_timer > 0){
					this.change_animation("death");
				} else if (this.death_timer <= this.decay_duration && this.death_timer > 0){
					this.change_animation("decay");
				} else {
					var dif = Math.floor(WorldController.get_movement_edge()/200)+1;
					var rand = Math.random()*100;
					if(rand < 50/dif && this.point_value != 0){
						spawn((this.body.GetWorldCenter().x), (this.body.GetWorldCenter().y), "pizza");
					}
					EntityController.delete_entity(this);//remove instance from memory
				}
				return;
			}
		}
		
		//takes a string as parameters. returns the fixture with fixture_name == name, or null if it does not exist
		this.get_fixture = function(entity,name){
			var current_fixture = entity.body.GetFixtureList();
			while (current_fixture != null){
				if (current_fixture.GetUserData() != null){
					if (current_fixture.GetUserData().name == name){
						break;
					}
				}
				current_fixture = current_fixture.GetNext();
			}
			if (current_fixture.GetUserData() == null){
				current_fixture = null;
			}else if (current_fixture.GetUserData().name != name){
				current_fixture = null;
			}
			return current_fixture;
		};
		
		//checks if movement is voluntary or forced
		this.movement_voluntary = function(){
			//if direction being faced is different from the direction moving, return false
			var output = true;
			var velocity = this.body.GetLinearVelocity().x;
			if(velocity != 0){
				output = (velocity/Math.abs(velocity) == (this.direction)*2-1);
			}
			return output;
		};

		//checks if in the air
		this.in_air = function(){
			var body = this.body;
			var objects_beneath;
			if (body.GetFixtureList() != null){//prevent bugs on destruction
				var AABB = body.GetFixtureList().GetNext().GetNext().GetAABB();
				objects_beneath = PhysicsController.query_aabb(AABB);
			}else{
				objects_beneath = 0;
			}
			return (objects_beneath < 5);//for some mysterious reason, it counts 4 collisions even in mid air
		};

		//checks if there is a collision in current direction
		this.path_free = function(){
			var body = this.body;
			var objects_before;
			var AABB;
			if (body.GetFixtureList() != null){//prevent bugs on destruction
				if (this.direction){
					AABB = body.GetFixtureList().GetAABB();
					objects_before = PhysicsController.query_aabb(AABB);
				}else{
					AABB = body.GetFixtureList().GetNext().GetAABB();
					objects_before = PhysicsController.query_aabb(AABB);
				}
			}else{
				objects_before = 0;
			}
			return (objects_before < 4);//assumes contact with bottom sensor, top sensor, and main shape 
		};

		//setter for animation variable, ensures the animation is only reset on actual change
		this.change_animation = function(new_animation){
			if(this.animation != new_animation){
				this.animation = new_animation;
				this.needs_graphics_update = true;
			}else{ 
				this.needs_graphics_update = false;
			}
			this.jump_tick = 1; //for hero jump tick
		};
	}; // end AbstractEntity
	
	var sync_hero = function(){
		/**
		* send synchronization information for the hero,
		* if needed (if something important changed)
		*/

		var my_hero = EntityModel.heroes[NetworkController.get_network_id()];

		if(my_hero){
			var velocity = my_hero.body.GetLinearVelocity();
			var old_velocity = EntityModel.hero_last_velocity;

			var difference = Math.sqrt(Math.pow(velocity.x - old_velocity.x, 2) + Math.pow(velocity.y - old_velocity.y, 2))

			if(difference != 0){
				// if different
				var position = my_hero.body.GetWorldCenter();
		
				MultiplayerSyncController.route_outcoming_packet({
					op: "hero_sync",
					velocity: {x: velocity.x, y: velocity.y},
					position: {x: position.x, y: position.y}
				});
			}

			EntityModel.hero_last_velocity = {x: velocity.x, y: velocity.y};
		}


		// check velocity change
		
		// send if needed
		
	};
	
	var sync_enemy = function(id){
		/**
		* send synchronization information for enemies,
		* if needed (if something important changed)
		*/

		var entity = IdentificationController.get_by_id(id);

		if(entity){
			var position = entity.body.GetWorldCenter();
			var velocity = entity.body.GetLinearVelocity();
			var old_velocity = entity.velocity_previous;
			var old_position = new B2D.b2vec2(entity.x_previous, entity.y_previous);

			var vel_difference = Math.sqrt(Math.pow(velocity.x - old_velocity.x, 2) + Math.pow(velocity.y - old_velocity.y, 2));
			var pos_difference = Math.sqrt(Math.pow())

			if(vel_difference != 0){
				// if different, send update packet
				MultiplayerSyncController.route_outcoming_packet({
					op: "enemy_sync",
					velocity: {x: velocity.x, y: velocity.y},
					position: {x: position.x, y: position.y}
				});
			}
			EntityModel.hero_last_velocity = {x: velocity.x, y: velocity.y};
		}
		// check velocity change
		// send if needed
	};
	
	var handle_hero_sync = function(packet){
		/**
		* handle the sync request for the hero
		* synchronize velocity and the position
		*/
		
		if(packet.player_id == NetworkController.get_network_id()){
			return;
		}
		
		var player_id = packet.player_id;

		var hero = EntityModel.heroes[player_id];

		if(hero == null){
			console.warn("hero is not defined for the player_id", String(player_id));
		}else{

			var vel = new B2d.b2Vec2(packet.velocity.x, packet.velocity.y);
			var pos = new B2d.b2Vec2(packet.position.x, packet.position.y);
			
			hero.body.SetLinearVelocity(vel);
			hero.body.SetPosition(pos);
		}
		
	};
	
	var handle_enemy_sync = function(packet){
		/**
		* handle the sync request for the hero
		* synchronize velocity and the position
		*/
		
		if(packet.player_id == NetworkController.get_network_id()){
			return;
		}
		
		var player_id = packet.player_id;

		var entity = EntityModel.heroes[player_id];

		if(entity == null){
			console.warn("entity is not defined for the player_id", String(player_id));
		}else{

			var vel = new B2d.b2Vec2(packet.velocity.x, packet.velocity.y);
			var pos = new B2d.b2Vec2(packet.position.x, packet.position.y);
			
			entity.body.SetLinearVelocity(vel);
			entity.body.SetPosition(pos);
		}
		
	};

	var get_all_heroes = function(){
		/**
		* return table with network ids associated with corresponging hero instances
		*/
		
		return EntityModel.heroes;
	};

	var get_my_hero = function(){
		/**
		* get the hero for this player
		*/

		return get_all_heroes()[NetworkController.get_network_id()];
		
	};
	

	
	return {
		// declare public
		init: init, 
		update: update,
		//get_operation: get_operation,
		reg_for_logic_update: reg_for_logic_update,
		spawn: spawn,
		delete_entity: delete_entity,
		despawn: despawn,
		//fulfill_delete_request: fulfill_delete_request,
		handle_spawn: handle_spawn,
		handle_delete: handle_delete,
		handle_hero_sync: handle_hero_sync,

		get_all_heroes: get_all_heroes,
		get_my_hero: get_my_hero,
		create_abstract_entity: create_abstract_entity,
    };
})();

module.exports = EntityController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
    current_module: "EntityController",
    include_options: Includes.choices.DEFAULT | Includes.choices.LOGIC
}); eval(include_data.name_statements); var include = function () { eval(include_data.module_statements); }

},{"../Includes.js":19}],5:[function(require,module,exports){


var GameController = (function(){

	var init = function(){
		include();
	};
		

	var update_all = function(event){
		/*
		 * main function pretty much
		 * everyghing else is called from here every tick
		 */
		KeyboardController.update(delta);

	    var cmds = KeyboardController.pause_commands();
	    if (cmds("pause") && GameModel.pauseCounter > 10 && GraphicsController.get_health() > 0) {
	        createjs.Ticker.paused = !createjs.Ticker.paused;
	        GameModel.pauseCounter = 0;
	        console.log("pause");
	    }
	    GameModel.pauseCounter += 1;
		
		if (!createjs.Ticker.paused){
			var delta = event.delta;

			// !!!! world simulation step goes somewhere right here
			// as per current design, will take delta as an argument
		
			//TerrainController.generate_terrain(); 
			//PlayerController.update();
		
			IdentificationController.update(delta);
			WorldController.update(delta);

			TerrainController.update(delta);
			EntityController.update(delta);

			// Should be called after all movement of objects is done:
			//HUDController.update();
			//BackgroundController.update();
			GraphicsController.update();
			GraphicsController.update(delta);

			MultiplayerSyncController.update(delta);
			NetworkController.update(delta);
		}
	};

	var stop_game = function(){
		/**
		* stop the game. 
		* this one prevents any controller updates except Game and Keyboard
		* different from the PAUSE for multiplayer purposes
		*/

		createjs.Ticker.paused = true;
		
	};

	var continue_game = function(){
		/**
		* continue game
		*/
		
		createjs.Ticker.paused = false;

	};

	return {
		init: init,
		update_all: update_all,
		stop_game: stop_game,
		continue_game: continue_game,
	};

})();

module.exports = GameController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "GameController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],6:[function(require,module,exports){
/*
GraphicsController
	Public Functions:
	-init()
		sets up the GraphicsController for the rest of the game, called once during initialization
	-update(int delta)
		common function, called each tick. performs routine graphics maintenance
		registers all instances that were marked for registration since the last tick
		renders all registered instances
	-get_stage()
		returns the stage object, an easeljs object that stores information about the game
	-get_camera()
		returns the camera object, which controls the view offset
	-get_asset(string id)
		retrieves the asset with id; an alias for the same function in AssetController
	-reg_for_render(Easeljs_obj sprite, Object entity_instance)
		links an entity with a sprite and registers it to be rendered each tick
	-set_reg_position(easeljs_obj,int offset_x,int offset_y)
		adjusts a sprites x and y offsets to conform to the box2d system
	-request_bitmap(string? id)
		retrieves a previously loaded asset as a sprite
	-request_animated(string id, string||int start_animation/start_frame)
		returns a new sprite object generated from the image id and the start frame
	-destroy_graphics_for(int id)
		destroys the graphics objects associated with the instance of the passed id
	-follow(int id)
		sets the camera to follow the object of the passed id
	-get_movement_edge()
		returns left camera bound, a.k.a, the movement edge. used for lots of things
		
*/
var GraphicsController = (function(){
	/* 
	Controls all graphics and provides an interface for common easel.js functions
	*/
	
	var get_asset; 
	var type_renderer_table;
	var PrivateGraphics; 
	var reRender = false;

	var init = function(){
		/* is ran from the InitController once when the game is loaded */
		include(); // satisfy requirements

		//All renderers must be registered here
		//Links each renderer with its object id
		type_renderer_table = {
		// type:	renderer:
			"ant": AntRenderer,
			"hero": HeroRenderer,
			"Griffin": GriffinRenderer,
			"Medusa": MedusaRenderer,
            "Centaur": CentaurRenderer,
			"Hyena": HyenaRenderer,
			"terrain_cell": TerrainCellRenderer,
			"terrain_slice": TerrainSliceRenderer,
			"companion": EsteemedCompanionRenderer,
            "pizza": PizzaRenderer,
		};

		get_asset = AssetController.get_asset; // for quicker access

		GraphicsModel.stage = new createjs.Stage(Config.MAIN_CANVAS_NAME);
		GraphicsModel.stage.canvas.width = Config.SCREEN_W;
		GraphicsModel.stage.canvas.height = Config.SCREEN_H;
		
		GraphicsModel.camera.offset_from_followed.x -= (1614 - GraphicsModel.stage.canvas.width) / 3;

		// init all renderers
		for(type in type_renderer_table){
			type_renderer_table[type].init();
		}

		// this object is passed to all renderers to give them access to functions
		// that no one else is supposed to be able to access
		PrivateGraphics = {
			stage: GraphicsModel.stage,
			request_bitmap: request_bitmap,
			request_animated: request_animated,
			get_asset: get_asset,
			trans_xy: trans_xy,
			reg_for_render: reg_for_render,
		};

		BackgroundRenderer.init();
		HUDRenderer.init();

	};

    
	var update = function(delta){
		/* is ran each tick from the GameController.update_all */
		
		update_camera(); // needs to be updated first

		destroy_unneeded(); // goes second, do not update any stuff before unneeded stuff is removed

		register_new_stuff();

		render_things();
		
		synchronize_to_physical_bodies();

		BackgroundRenderer.render();
		
		HUDRenderer.render();
		
		GraphicsModel.stage.update();
	};

	var destroy_unneeded = function(){
		/**
		* destroy graphics for everything that was marked
		* for destruction
		*/

		var slices = RegisterAsController.retrieve_registered_as("removed_slice");

		var entities = RegisterAsController.retrieve_registered_as("removed_entity");

		while(slices.length > 0){
			var slice = slices.pop();
			var grid = slice.grid;

			for(var i = 0; i < grid.length; i++){
				var row = grid[i]; // or is it a column?

				for(var j = 0; j < row.length; j++){
					var cell = row[j];
					if(cell.kind != 0){
						destroy_graphics_for(cell.id);
					}
				}
			}
			
		}
		
		while(entities.length > 0){
			var entity = entities.pop();
			destroy_graphics_for(entity.id);
		}
	};
	
	

	var follow = function(id){
		//order camera to follow the graphical representation
		//of an object with the given id, if it exists
		GraphicsModel.camera.following = GraphicsModel.all_physical[id];
	};
	
	
	var register_new_stuff = function(){
		//search through all instances in the queue 
		//and register them for graphics updates.

		// retrieve instances of physical things that do not have graphics yet
		var new_stuff = RegisterAsController.retrieve_registered_as("awaiting_graphics_initialization");

		var length = new_stuff.length
		for(var i = 0; i < length; i++){
			var new_obj = new_stuff.pop();
			if(type_renderer_table[new_obj.type]){
				// if renderer exists for this type, register through it
				type_renderer_table[new_obj.type].register(new_obj, PrivateGraphics);	
			}else{
				throw "No renderer found for the type " + String(new_obj.type) +
					" confirm that renderer exists and is added to the GraphicsController.type_renderer_table"
			}
		}
	};
	
	var render_things = function(){
		/**
		* call renderers for everything
		*/
		
		var to_render = GraphicsModel.special_render;

		for(var type in to_render){
			var table = to_render[type];
			var renderer = type_renderer_table[type];

			for(var id in table){
				sprite_animate(table[id], PrivateGraphics);
			}
		}
		
	};
	
	var sprite_animate = function(sprite){
		//set graphical representation based on the animation variable determined by the AI
		//set animation
		if(sprite.physical_instance.needs_graphics_update){
			var animation = sprite.physical_instance.animation;
			sprite.gotoAndPlay(animation)
			sprite.needs_graphics_update = false;
		}
		
		//set direction
		if (sprite.physical_instance.direction){ //if direction == right, flip right
			sprite.scaleX = -1;
		}else{ //else flip left
			sprite.scaleX = 1;
		}

		//set alpha if blinking
		if(sprite.physical_instance.blinking && sprite.physical_instance.blink_timer%2 == 1){
			sprite.alpha = 0;
		}else{
			sprite.alpha = 1;
		}
	};

	//called from update(), maintains camera position
	var update_camera = function(){
		var camera = GraphicsModel.camera;
		var center = camera.center;
		
		center.x = Config.SCREEN_W/2 - camera.offset_from_followed.x;
		//CAMERA SHOULD NOT MOVE VERTICALLY
		//center.y = Config.SCREEN_H/2 - camera.offset_from_followed.y;
		
		if(camera.following != null){
		    camera.offset.x = center.x - camera.following.physical_instance.body.GetWorldCenter().x * Config.B2D.SCALE;
			camera.offset.y = center.y - camera.following.physical_instance.body.GetWorldCenter().y * Config.B2D.SCALE;
			// now, we do not want the camera to display what is behind the movement edge. but the camera is a relative thing
			// so we can't just limit some sort of x position or such.
			// I'll use the following technique: 
			//   1. calculate were the physical movement edge would be if drawn right now to the canvas
			//   2. if it would be displayed on-screen, offset camera so that it wouldn't be anymore

			var mov_edge_graphics_x = (WorldController.get_movement_edge() * Config.B2D.SCALE) + camera.offset.x;

			// recall that left display edge is 0 for graphics, as (0, 0) is the top-left corner
			if(mov_edge_graphics_x > 0){
				// if movement edge would be displayed
				camera.offset.x -= mov_edge_graphics_x;
			}
		}
		if (camera.offset.y < 0) {
		    camera.offset.y = 0;
		}

		adjust_debug_draw(); // goes last
	};

	


	//*************************************
	var adjust_debug_draw = function(){
		var camera = GraphicsModel.camera;
		TestController.set_debug_offset(camera.offset.x, camera.offset.y);
	};

	var request_bitmap = function(id){
		// if id is invalid, throw meaningful exception?
		var bitmap = new createjs.Bitmap(get_asset(id));
		// more complicated setting for registration position may be needed, depending on the body attached
		if (!(bitmap.image)){
			throw "Error: image wasn't correctly loaded for this bitmap";
		}
		
		bitmap.regX = bitmap.image.width/2;
		bitmap.regY = bitmap.image.height/2;

		return bitmap;
		// TODO research DisplayObject's caching. and maybe incorporate
	};
	
	
	var request_animated = function(id, start_frame){
		// this implementation is temporary
		// until I setup efficient facility for defining spritesheets
		// within GraphicsController

		if(!id || !start_frame){
			if(!id){
				throw "wrong id";
			}else{
				throw "wrong start_frame";
			}
		};

		var sprite = new createjs.Sprite(id, start_frame);

		return sprite;
	};

	
	//converts easeljs origins to box2d origins
	var synchronize_to_physical_bodies = function(){

		var tiles = GraphicsModel.all_physical;

		for(var id in tiles){
			var tile = tiles[id];
			var body = tile.physical_instance.body;
			var tile_pos = trans_xy(body.GetWorldCenter());

			tile.x = tile_pos.x;
			tile.y = tile_pos.y;
		}
	};
	

	var trans_xy = function(position_vector_unscaled){
		// takes position vector with values in meters, translates
		// it to pixel position taking the camera position into account
		var camera = GraphicsModel.camera;

		var x = (position_vector_unscaled.x * Config.B2D.SCALE) + camera.offset.x;
		var y = (position_vector_unscaled.y * Config.B2D.SCALE) + camera.offset.y;

		return {x: x, y: y};	
	};

	var set_reg_position = function(easeljs_obj, offset_x, offset_y){
		// sets registration position of the easeljs object
		// regisration position is the relative point of the object
		// that you move when you set object's x and y coordinats
		// i.e. if reg. position of the player is head, and you set their
		// position to (0, 0), their head will be at (0, 0)
		// currently the registration position is set to the middle of the body
		// to match what box2d does
		// last two arguments are optional and set PIXEL offset from the normal registration
		// position
		
		// this if statement should be temporary
		if(easeljs_obj.image){
			var w = easeljs_obj.image.width;	
			var h = easeljs_obj.image.height;	
		}else{
			var w = easeljs_obj.spriteSheet._frameWidth;
			var h = easeljs_obj.spriteSheet._frameHeight;
		};

		var offset_x = offset_x || 0;
		var offset_y = offset_y || 0;

		easeljs_obj.regX = w/2 + offset_x;
		easeljs_obj.regY = h/2 + offset_y;

	};

	var reg_for_render = function(easeljs_obj, physical_instance){
		// registeres object for rendering within graphics controller
		// if (OPTIONAL!) physical_instance is given, graphics controller will automatically
		// set the easeljs_obj's position to position of that body, each tick.
		// if the type of the physical instance is associated with some renderer
			
		
		if(physical_instance){

			if(physical_instance.body == null){
				// are you trying to do something terrible? such as registering
				// some object that doesn't need graphical representation?
				throw "Physical instance is provided, but it has no body";
			}
			var id = physical_instance.id;
			var type = physical_instance.type;

			if(id == null || type == null){
				throw "Id or type is undefined for this physical instance";
			}

			easeljs_obj.physical_instance = physical_instance;
			GraphicsModel.all_physical[id] = easeljs_obj;

			if(!GraphicsModel.special_render[type]){
				GraphicsModel.special_render[type] = {};
			}

			GraphicsModel.special_render[type][id] = easeljs_obj;
		}


		AddToStage(easeljs_obj);
	};

	var AddToStage = function(element){
		// can be updated later to manage z-index or whatever
		GraphicsModel.stage.addChild(element);
	};
	

	var get_stage = function(){
		return GraphicsModel.stage;
	};
	
	var get_camera = function(){
		return GraphicsModel.camera;
	};
	
	var destroy_graphics_for = function(id){
		/**
		* remove from the stage and destroy graphics instances for the object with the given id
		* this includes removing all references to it.
		* TODO: IMPORTANT!!! if GraphicsController was updated to store more
		* references to some graphics instances, UPDATE this function to reflect changes
		* even a single reference to the object may cause it to stay in memory
		*/
		

		if(GraphicsModel.all_physical[id] != null){
			var graphics_instance = GraphicsModel.all_physical[id];
		}else{
			// if you encounter this exception, maybe implementation changed. 
			// If that's the case, some things need rewriting. This function in
			// prticular. Or maybe there is a bug.
			throw "The graphics object with id " + String(id) + " isn't registered as having physical body";
		}

		if(graphics_instance.physical_instance.type != null){
			var type = graphics_instance.physical_instance.type;

		}else{
			// if you encounter this exception it may mean a bug, or alternatively
			// it may mean that implementation changed and this function needs an update
			throw "Physical instance with id " + String(id) + " doesn't seem to have a type";
		}
		
		// remove from the stage 
		
			/* graphics_instance.removeAllEventListeners(); 
			   could be necessary to remove attached event listeners, but it seems, at least
			   so far, that this stuff is done automatically be easeljs */

			GraphicsModel.stage.removeChild(graphics_instance);

		// remove from all_physical (responsible tracking for body position)
			delete GraphicsModel.all_physical[id];
		// remove from special_render
			delete GraphicsModel.special_render[type][id];
		// TODO: remove camera reference if following this object
			
	};

	return {
		// declare public
		init: init, 
		update: update,
		get_stage: get_stage,
		get_camera: get_camera,
		get_asset: get_asset,
		reg_for_render: reg_for_render,
		set_reg_position: set_reg_position,
		request_bitmap: request_bitmap,
		request_animated: request_animated,
		destroy_graphics_for: destroy_graphics_for,
		follow: follow,
	};
})();

module.exports = GraphicsController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "GraphicsController", 
	include_options: Includes.choices.DEFAULT | Includes.choices.RENDERERS
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],7:[function(require,module,exports){

var IdentificationController = (function(){
	/* Is in charge of giving unique ID's to everything
	 * that wants them
	*/

	var init = function(){
		/* is ran from the InitController once when the game is loaded */

		include(); // satisfy requirements

		// create 100 id's
		for(var i = 0; i < 100; i++){
			var id = IdentificationModel.next_id ++;
			IdentificationModel.free_ids.push(id);
			IdentificationModel.id_matching[id] = null;
		}

	};

	var update = function(delta){
		/* is ran each tick from the GameController.update_all */
		// cleanup ids, if too many free ids (like if non-free id's < free id's/10
		
		//TODO: make function to actually be called from the GameController.update_all
		// TODO: loop through all non-free id's, and if any of them reference null,
		// remove (unregister) them;
		var cmds = KeyboardController.debug_commands();
		
		if(cmds("show_ids")){
			console.log(IdentificationModel.free_ids, IdentificationModel.next_id);
		}

	};

	var assign_id = function(obj, set_id){
		/**
		* assigns id to the object
		* sets property id on the object given. you can give OPTIONAL parameter
		* set_id which should be a function that takes object and id and assigns
		* id to the object. this can be useful if you want to store id in some unusual
		* place, or perform some extra operations before id is assigned
		*
		* return id assigned
		* IdentificationController will remember that this id has been assigned
		* this object
		*/
		var free = IdentificationModel.free_ids;
		var id;

		// get free id
		if(free.length > 0){
			id = free.pop();
		}else{
			id = IdentificationModel.next_id++;
		}

		// set id on the object. through function if provided
		if(set_id){
			set_id(obj, id);
		}else{
			obj.id = id;
		}

		// associate id with the object obj
		IdentificationModel.id_matching[id] = obj;

		return id
	};

	var reserve_id = function(){
		/**
		* returns free id and promises not to overite it
		* also allows someone to force this id
		*/
		var free = IdentificationModel.free_ids;
		// get free id
		if(free.length > 0){
			id = free.pop();
		}else{
			id = IdentificationModel.next_id++;
		}

		IdentificationModel.reserved.push(id);

		return id;

	};
	

	var force_id = function(obj, id, set_id){
		/**
		* Force object >obj< to have the given id >id<
		* If id isn't free, exception is thrown
		* This function is most likely used directly only for the multiplayer
		* purposes 
		* If OPTIONAL function >set_id< is given, it'll be called instead
		* of assigning ids directly (use this if special manipulations should be done)
		*
		*/

		var free = IdentificationModel.free_ids;
		var reserved = IdentificationModel.reserved;

		var idx = free.indexOf(id); 
		var idy = reserved.indexOf(id);

		if(idx >= 0){
			var id = free.splice(idx, 1); // extract the desired index 
		}else if (idy >= 0){
			var id = reserved.splice(idx, 1); // extract the desired index 
		}else{
			// if not found, then non-free id, then exception
			throw "The id " + String(id) + " is non-free";
		}
	
		// set id on the object. through function if provided
		if(set_id){
			set_id(obj, id);
		}else{
			obj.id = id;
		}

		// associate id with the object obj
		IdentificationModel.id_matching[id] = obj;

		return id;

	};

	var get_by_id = function(id){
		/**
		* get object associated with the given id
		*/
		return IdentificationModel.id_matching[id];
	};

	var remove_id = function(id){
		/**
		* mark id as free and no longer assiciate it with any object
		* notice that you yourself is responsible for making sure
		* that object that was associated with this id doesn't think
		* that he is still assigned this is
		*/

		// TODO: make sure that all known places that use ids (PhysicsControllers'
		// contact listener for example) are notified that id had been unregistered
		delete IdentificationModel.id_matching[id];
		IdentificationModel.free_ids.push(id);
	};
	
	var assign_type = function(obj, type){
		/**
		* assigns wanted type (string) to the given
		* model definition
		* if you try to assign same type twice, throws exception;
		* Id...Controller allows you to retrieve model
		*/

		var types = IdentificationModel.types;
		if(types[type]){
			throw "Error: type " + type + " is already registered. " +
				"You can't register the same type twice";
		}else{
			types[type] = obj;
			obj.prototype.type = type;
		}
		
	};
	
	var get_by_type = function(type){
		/**
		* gets object by it's type
		*/
		var types = IdentificationModel.types;
		if(types[type]){
			return types[type];
		}else{
			throw "Error: type " + type + " wasn't defined yet";
		}
	};
	
	
	
	
	return {
		// declare public
		init: init, 
		update: update,
		assign_id: assign_id,
		reserve_id: reserve_id,
		force_id: force_id,
		get_by_id: get_by_id,
		remove_id: remove_id,
		assign_type: assign_type,
		get_by_type: get_by_type,
	};
})();

module.exports = IdentificationController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "IdentificationController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],8:[function(require,module,exports){
var InitController = (function(){
	// why do you want to put initialization of everything into the InitController?
	// Because if initialization of smth depends on initialization of smth else,
	// it's easier to control here
	//
	// e.g. if you try to do var foo = $('#foo'); somewhere in other module,
	// you can get foo = null; as code of that module can execute before the html document
	// was fully loaded, but >InitController.init< is called after document was loaded, so
	// -1 potential problem. Btw, at this moment in time the the stuff is set to work that way
	// using html (<body onload=...); maybe using JS would be better? Idk;
		

	var init = function(mode, session_id, player_id, player_id_array){
		include();

		Config.Init.mode = mode;
		Config.Init.session_id = session_id;
		Config.Init.player_id = player_id;
		Config.Init.player_id_array = player_id_array;

		enable_arrowkey_scroll(false);
		setup_screen();
		setup_events();

		init_all_modules(mode); // call .init function of everyone. e.g. PlayerController.init(); etc.

		
		// Notice that asset dependent stuff doesn't (and mustn't) start until
		// all assets are completely loaded. That includes ticker, i.e. no ticks are processed
		// until everything is loaded. If you want something different, e.g. display some sort of loading
		// animation - let me know.
		// Look into the setup_asset_dependent function
			AssetModel.loader = new createjs.LoadQueue(false); // loading resourses using preload.js
			AssetModel.loader.addEventListener("complete", setup_asset_dependent);

		// if more stuff needs to be done for the test mode, 
		// or more types of it needs to be added
		// you can safely make the following a separate function
			var asset_path = (mode == "test") ? "./assets/art/" : "../GameCode/assets/art/";

		AssetController.init(asset_path);


	};

	var init_all_modules = function(mode){
		// TODO: better way to do stuff like that (call certain function
		// of every module in the order. 
		// Also, init and update functions of each module should probably
		// accept some argument. I think to make this argument an object,
		// this way we can add more things to be passed w/o any problem and
		// we won't need to change anything
		
		B2d.init(); // goes first
		IdentificationController.init();
		RegisterAsController.init();

		//AssetController.init(); // called from the InitController.init// stuff has to change
		GameController.init();
		KeyboardController.init();
		PhysicsController.init();

		TestController.init(mode);
		

		//PlayerController.init();
		TerrainController.init();
		TerrainSliceController.init();
		WorldController.init();
		



		// WARNING!!! GraphicsController.init is called from the
		// setup_asset_dependent function as it, well, depends on assets being loaded

	};


	var enable_arrowkey_scroll = function(enable_scroll){
		if(enable_scroll == false){                                                          
			document.addEventListener('keydown', function(e){ // .getElementById("display_canvas")
				arrows = [37, 38, 39, 40];                                          
				if(arrows.indexOf(e.keyCode) > -1){                                 
					e.preventDefault();                                             
					return false;                                                   
				}else{                                                              
					return true                                                     
				}                                                                   
			})                                                                      
		}		
	};
	
	var setup_screen = function(){

		// Setting up other stuff:
		// e.g setup canvas size
		
		// TODO: allow resizes?

		Config.SCREEN_W = $('#canvas_container').width(); // is dynamically set to pixel width of the containing element

		// possible resizing technique: 
		// http://www.fabiobiondi.com/blog/2012/08/createjs-and-html5-canvas-resize-fullscreen-and-liquid-layouts/

		
		//$('#debug_canvas').width(String(SCREEN_W) + "px");
		//$('#display_canvas').width(String(SCREEN_W) + "px");

		//$('#debug_canvas').height(String(SCREEN_H) + "px");
		//$('#display_canvas').height(String(SCREEN_H) + "px");
		
	};

	var setup_ticker = function(){

		createjs.Ticker.setFPS(Config.FPS);

		// ticker: on each tick call GameController.update_all();
		createjs.Ticker.addEventListener("tick", GameController.update_all);

	
	};

	var setup_events = function(){


		// keyboard input event: on each keyboard event call appropriate KeyboardController function
		document.onkeydown = KeyboardController.keydown;
		document.onkeyup = KeyboardController.keyup;

			// on interrupt event: stop/pause ticker ?

	};

	var setup_asset_dependent = function(){
		// this may need to move to either load_game or some sort of resizing function
		MultiplayerSyncController.init();
		
		
		NetworkController.init();
		EntityController.init();
		GraphicsController.init();
		//HUDController.init();
		//BackgroundController.init();

		
		setup_ticker();

		if(Config.Init.mode == "multiplayer" && Config.Init.player_id_array != null){
			// if multiplayer mode
			NetworkController.start_multiplayer_session(Config.Init.player_id_array);
		}else if(Config.Init.mode == "test" && GameUtility.read_query_string().player_id_array != null){
			var query_object = GameUtility.read_query_string();

			var player_id_array = JSON.parse(decodeURI(query_object.player_id_array));


			Config.Init.session_id = query_object.session_id;
			Config.Init.player_id = query_object.player_id;
			Config.Init.player_id_array = player_id_array;

			console.log("Detected id array passed in test mode. Switching to the multiplayer mode",
					"player_id_array is", player_id_array, "my id is", query_object.player_id);
			Config.Init.mode = "multiplayer";

			NetworkController.start_multiplayer_session(Config.Init.player_id_array);
		}

		//TerrainController.generate_terrain(); // Initial terrain generation // deprecated, generation will be called from update each tick
	};


	return {
		init: init,
	};
})();

module.exports = InitController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "InitController", 
	include_options: Includes.choices.ALL
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],9:[function(require,module,exports){
var KeyboardController = (function()
{

	var init = function(){
		
		include();
	};

	var update = function(delta){
		/**
		* update called from GameController.update_all
		*/
		
		if(KeyboardModel.state_changed){
			// if keyboard state changed since the last time,
			// send the keyboard state over.
			// TODO: optimize?
			// You could send only those specific keys that changed, not whole table
			// You could send only relevant keys that might be needed there
			// Is it worth the time spent? Keep in minds, those tables are usually small,
			// unless players decide to smash their faces into the keybord repeatedly
			// (our game isn't that bad, right?)
			MultiplayerSyncController.route_outcoming_packet({
				op: "keyboard_state",
				key_table: KeyboardModel.keys,
			});

			KeyboardModel.state_changed = false;
		}
		
	};

	var handle_keyboard_change = function(packet){
		/**
		* accepts the network packet. changes the respective
		* keybord state for the given packet.player_id
		* is called from the MultiplayerSyncController
		*/
		var player_id = packet.player_id;
		
		if(player_id == null){
			throw "Error: (network) player_id is not defined";
		}

		KeyboardModel.all_keyboard_states[player_id] = packet.key_table;
	};
	
	
	var copy_object = function(obj){
		/**
		* returns (shallow) copy of the object
		*
		* @Stack Overflow:
		* With jQuery, you can shallow copy with:
		* var copiedObject = jQuery.extend({}, originalObject)
		* subsequent changes to the copiedObject will not affect the originalObject, and vice versa.
		* Or to make a deep copy:
		* var copiedObject = jQuery.extend(true, {}, originalObject)
		*/
		
		return jQuery.extend({}, obj);
	};
	
	
	
	var get_active_commands_function = function(table, player_id){
		// >player_id< is optional, and part of a dirty-ish quick implementation
		// Things should be rewritten at some point
		//
		// get all commands associated with keys that are defined in the >table<,
		// and are currently pressed
		//
		// returns: array of commands
		//
		// TODO: REFACTOR this function to work better and so people do not
		// need to call it each tick. instead they should get reference to function one time
		// and stay updated on the active commands
		
		var commands = [];
		if(player_id != null){
			var key_table = KeyboardModel.all_keyboard_states[player_id];
		}else{
			var key_table = KeyboardModel.keys;
		}
		
		$.each(KeyboardModel.translation_tables.code_to_name, function(key, cmd){
			if(key_table[key] && table[cmd]){
				commands.push(table[cmd]);
			}
		});

		var get_key = function(key){
			if(commands.indexOf(key) > -1){
				return true;
			}else{
				return false
			};
		};

		return get_key;
	};

	// public:
	
	var keydown = function(event){
		KeyboardModel.keys[event.keyCode] = true;
		KeyboardModel.state_changed = true;
	};

	var keyup = function(event){
		delete KeyboardModel.keys[event.keyCode];
		KeyboardModel.state_changed = true;
	};


	var movement_commands = function(){
		return get_active_commands_function(KeyboardModel.translation_tables.movement);
	};

	var pause_commands = function () {
	    return get_active_commands_function(KeyboardModel.translation_tables.pause);
	};

	var debug_commands = function(){
		/**
		* commands active in debug mode
		*/
		return get_active_commands_function(KeyboardModel.translation_tables.debug);
	};
	
	var get_remote_movement = function(player_id){
		/**
		* this it TEMPORARY function 
		* I throw it together so I do not have to change how keyboard controller works for now
		* if we find that we should send more keyboard stuff over the network, we should rewrite
		* the KeyboardController appropriately
		*/

		if(player_id == null){
			throw "Error: player_id undefined";
		}

		var key_fun = get_active_commands_function(KeyboardModel.translation_tables.movement, player_id);
		return key_fun;
	};
	
	

	return {
		keydown: keydown,
		keyup: keyup,
        pause_commands: pause_commands,
		movement_commands: movement_commands,
		debug_commands: debug_commands,
		init: init,
		update: update,
		handle_keyboard_change: handle_keyboard_change,
		get_remote_movement: get_remote_movement,
	};

})();

module.exports = KeyboardController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "KeyboardController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],10:[function(require,module,exports){

var MultiplayerSyncController = (function(){
	/* Ensures that current player is synchronized with the server
	 * or with other players
	*/

	var op_table;

	var init = function(){
		/* is ran from the InitController once when the game is loaded */
		include(); // satisfy requirements

		// table that associates >op< (operation) with the specific handler
		// at some (likely external) module
		op_table = {
			spawn: EntityController.handle_spawn,
			delete_entity: EntityController.handle_delete,
			keyboard_state: KeyboardController.handle_keyboard_change,
			hero_sync: EntityController.handle_hero_sync,
			terrain_seed: sync_seed,
		}
	};


	var update = function(delta){
		/* is ran each tick from the GameController.update_all */

		var data = NetworkController.get_data(); // array of all packets

		var op_packet = MultiplayerSyncModel.op_packets_table; //op_packet is a list of objects

		if(data != null){
			for(var i = 0; i < data.length; i++){
				// for each packet in incoming packets,
				// rout it
				var packet = data[i];
				route_incoming_packet(packet);
			}
		}

		NetworkController.clean_data();	// remove data that was processed
	};

	var route_outcoming_packet = function(packet){
		/**
		* route packet appropriately
		*/
		if(packet.player_id == null){
				// if packet wasn't identified before
				// identify the packet as mine
				packet.player_id = NetworkController.get_network_id();
		}

		var op = packet.op;
		var handler = op_table[op];

		if(handler == null){
			// if no handler assigned
			console.warn("No handler for op", op);
			return -1;
		}

		if(Config.Remote.connected){
			// if multiplayer
			
			
			if(Config.Remote.master){
				// if master of the network
				// route back to specific handler
				// echo to all clients

				handler(packet);

				var response = packet; // do we want to allow overriding the response?

				NetworkController.add_to_next_update(response);
			}else{
				// if one of the clients
				// route to the master
				NetworkController.add_to_next_update(packet);
			}
		}else{
			// if singlplayer
			// route back to the specific handler
			handler(packet);
			//console.log(op,handler);
			
			
		}
	};

	var route_incoming_packet = function(packet){
		/**
		* handle packet that arrived over the network
		* ! this function is called only when packets arrive remotely
		* ! so you may safely assume that you are connected to the network
		* ! and the packet didn't originate on your side (this last one is
		* ! especially important)
		*/

		apply_transforms(packet); // apply any necessary transformations before beginning

		var op = packet.op;
		var handler = op_table[op];

		if(handler == null){
			// if no handler assigned
			console.warn("No handler for op", op);
			return -1;
		}

		if(packet.personal_communication != null){
			console.warn(packet.personal_communication);
		}

		if(Config.Remote.master && packet.personal_communication != true){
			// if master and packet isn't meant personally for me
			// route to specific handler
			// echo to the clients
			handler(packet);
			NetworkController.add_to_next_update(packet);
		}else{
			// if one of the clients
			// route to the handler
			handler(packet);
		}
		
	};

	var apply_transforms = function(packet){
		/**
		* if some specific transformation is supposed to be applied to the packet
		* (op should change somehow, new properties added etc.)
		* apply this transformation
		* ! notice that transforms are applied to incoming packets only
		* ! if you are confident you need something else, contact me (AK)
		*/

		switch(packet.op){
			case null:
				console.log(packet);
				throw "op for this packet is undefined";
				break;
			case "spawn":
				break;
			//default:
		}

		return packet;
	};
	

	var patch = function(object, func){
		/**
		* patch object with the function given
		* >object< - object whose prototype to patch 
		* >func< - NAMED function. it has to have the same name
		* as the function on the >object<'s prototype that it's meant to replace
		* this is function named bar: var hey = function bar(){};
		* this is unnamed function: var hey = function(){};
		*
		* the function that you pass will be called before the normal function body
		* when called, your function will be called on the same object (instance) that
		* old_function is called and will be passed the same arguments
		*/

		if(func.name === ""){
			throw "Function passed should be named function";
		}

		var old_func = object.prototype[func.name];
		var custom_function = func;

		var new_function = function overriden_by_multiplayer_controller(){

			custom_function.apply(this, arguments);
			return old_func.apply(this, arguments); // call old function and return what it returns
		}

		object.prototype[func.name] = new_function;
		
	};

	var get_initialization_data_master = function(){
		/**
		* get array packets that should be sent from master to all other people after the connection
		* with them is established
		*/

		var data = [];
		data.push({op: "terrain_seed", seed: TerrainController.get_seed(),});


		return data;
	};

	var get_initialization_data_common = function(){
		/**
		* get the array of packets that should be sent when to newly connected player
		* regardless whether this player is a master or not
		*/

		var data = [];

		var my_hero = EntityController.get_my_hero();

		if(my_hero != null){
			var pos = my_hero.body.GetWorldCenter();
			data.push({
				op: "spawn",
				personal_communication: true,
				type: "hero",
				x: pos.x,
				y: pos.y,
				// TODO: synchronize the state ??? or will it be handled automatically w/ herosync?
			});
		}
		
		return data;
	};

	var purge_all_data_for = function(network_id){
		/**
		* despawn hero and remove all traces of presence for the player
		* with this network id
		* called when player disconnects from the game
		*/
		
		var heroes = EntityController.get_all_heroes(); 
		var hero = heroes[network_id];
		

		if(hero != null){
			EntityController.delete_entity(hero);
		}
	};
	
	
	var sync_seed = function(packet){
		/**
		* description
		*/
		
		console.log("syncing my seed with master; the seed is", packet.seed);
		
		var seed = packet.seed;
		if(seed != null){
			TerrainController.set_seed(seed);
		}else{
			throw "seed is not defined";
		}
	};

	return {
		// declare public
		init: init, 
		update: update,
		route_outcoming_packet: route_outcoming_packet,
		route_incoming_packet: route_incoming_packet,
		get_initialization_data_master: get_initialization_data_master,
		get_initialization_data_common: get_initialization_data_common,
		purge_all_data_for: purge_all_data_for,
	};
})();

module.exports = MultiplayerSyncController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "MultiplayerSyncController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],11:[function(require,module,exports){

var NetworkController = (function(){
	/* manages p2p communication
	*/

	var peer, conn; // TEMPORARY. there will be multiple of those things
	var MEDIATOR_SERVER_KEY = 'lvgioxuj3ylm1jor'; //'l2f8f8vtbhcfecdi'; //'a7vojcpf70ysyvi';

	var init = function(){
		/* is ran from the InitController once when the game is loaded */
		include(); // satisfy requirements

		// TODO: make sure that sensitive host info (like spawn request that have not been
		// satisfied yet) are processed correctly before unloading
		// also it may make sense to handle even situations when the page was forced to unload
		// even before the function was called (power problem?)
		document.onbeforeunload = on_unload; // will be executed before user leaves page
		NetworkModel.hey = false;
	};


	var update = function(delta){
		/* is ran each tick from the GameController.update_all */

		var cmds = KeyboardController.debug_commands();

		if(!NetworkModel.block_connections && cmds("connect") && Config.Init.mode == "test"){ 
			NetworkModel.block_connections = true;
			start_multiplayer_session(["player1", "player2", "player3", "player4", "player5", "player6", "player7", "player8"]);
		}

		if(Config.Remote.connected){
			if(Config.Remote.master){
				// if I am the master, distribute data
				send_out_data();
			}else{
				// if not the master, just send data to the master
				send_data_to_master();
			}
		}

	};

	var start_multiplayer_session = function(ids){
		/**
		* perform procedures to start playing with all
		* other connected people
		*/
		NetworkModel.peers_to_connect = ids;

		// to not interrupt connection process
		GameController.stop_game();

		if(Config.Init.mode != "test"){	
			// create peer, assign id
			var peer = NetworkModel.my_peer = new_peer(Config.Init.player_id); 
			peer.on('error', handle_standart_peer_error);
			peer.on('open', on_obtaining_id_successfully);
			NetworkModel.my_peer = peer;
			NetworkModel.my_id = Config.Init.player_id;

		}else{

			setup_network_variables_for_testing_mode();
			setup_my_peer_test(); // setup peer // also picks free idr// calls >on_obtaining_id_successfully
		}
				
	};

	var setup_network_variables_for_testing_mode = function(){
		/**
		* setup various parameters for the testing mode game
		*/
		var ids = NetworkModel.peers_to_connect;

		NetworkModel.connections = {};
		NetworkModel.free_ids = [];

		for(var i = 0; i < ids.length; i++){
			var id = ids[i];
			NetworkModel.connections[id] = null;
			NetworkModel.free_ids.push(id);
		}

		NetworkModel.non_free_ids = [];

	};
	
	
	var handle_standart_peer_error = function(error){
		/**
		* this function is for connection errors
		* in non-test mode
		*/

		//console.log(error);
		//throw "Peer error";
		
	};
	

	var on_obtaining_id_successfully = function(id){
		/**
		* when the player id for this client was successfully
		* found through the process in the setup_my_peer_test(); function,
		* this function is called, which should setup all necessary things for 
		* the multiplayer to work, and connect to the other player
		*/

		NetworkModel.my_id = id;
		Config.Remote.connected = true;

		var peer = NetworkModel.my_peer;

		peer.on('error', on_peer_error);

		if(NetworkModel.my_id != NetworkModel.my_peer.id){
			// not a meaningful check, terrible practices are terrible
			throw "Id's do not match. Smth went wrong" 
		}

		console.log("Obtained id sucessfully, my id is", id);

		if(Config.Init.mode == "test"){
			console.log("Playing in testing multiplayer mode");
		}else{
			console.log("Playing in normal multiplayer mode");
		}

		/* note that if other peers connect in the future, 
		 * connection with them will be handled at that time
		 * through accept_connection function
		 */
		connect_to_others();

		// allow time for connections to be established, then pick the master
		NetworkModel.timeout_id = setTimeout(pick_the_master, Config.Remote.notification_wait);
	};


	var connect_to_others = function(){
		/**
		* connect to all other peers that are available at this time
		*/
		var ids = NetworkModel.peers_to_connect;
		for(var i = 0; i < ids.length; i++){

			var id = ids[i];

			if(id != NetworkModel.my_id){
				var connection = NetworkModel.my_peer.connect(id);

				setup_connection_listeners(connection);
			}
		}

	};

	
	var on_peer_error = function(error){
		/**
		* called on peer error;
		* notice that this function doesn't handle
		* peer errors that arise from inability to create peer because of id conflicts,
		* as this function is attached as listener only after the peer is sucessfully
		* created
		*/
		//console.warn("Peer error", error);
	};

	
	var setup_my_peer_test = function(error){
		/**
		* setups your personal peer picking free id, and returning it
		* looking up for the free id's is a huge pain now, once we run our
		* own peer matching server, it'll be a lot easier
		*
		* >error< parameter is null on the first call, but if first id that was
		* tried was already taken, and function is called again, it'll not be null 
		*/

		if(error == null || error.type == "unavailable-id"){
			if(NetworkModel.free_ids.length > 0){
				var id = NetworkModel.free_ids.pop();
				NetworkModel.non_free_ids.push(id);
				var peer = NetworkModel.my_peer = new_peer(id); 
				peer.on('error', setup_my_peer_test);
				peer.on('open', on_obtaining_id_successfully);
			}else{
				console.warn("Couldn't establish multiplayer session, all " + String(NetworkModel.peers_to_connect.length) + " available slots taken");
				Config.Remote.connected = false;
				NetworkModel.block_connections = false;

				setup_network_variables_for_testing_mode();
			}
		}else{
			//console.warn("Peer error", error);
		}
		
	};

	var on_connection_open = function(){
		/**
		* on opening the connection
		*/

		var id = this.peer;	
		
		console.log("Successfully initiated new connection with the peer", id);

		NetworkModel.connections[id] = this;
		
	};

	var on_connection_closed = function(){
		/**
		* called when some connection closes
		*/
		var id = this.peer;
		var nfree = NetworkModel.non_free_ids;

		nfree.splice(nfree.indexOf(id), 1);

		NetworkModel.free_ids.push(id);

		delete NetworkModel.connections[id];


		if(NetworkModel.master_id === id){
			GameController.stop_game();
			console.log("Closing connection with the master");
			NetworkModel.master_id = null;
			pick_the_master();
		}

		MultiplayerSyncController.purge_all_data_for(id);

		console.log("Connection with peer", id, "was successfully closed");
	};

	var on_connection_error = function(error){
		/**
		* when error on trying to establish connection occurs;
		* most often it will be error for peer not existing. that's part of the normal process
		*/
		
		console.log("connection error (likely not a bug)");
	};
	
	var pick_the_master = function(){
		/**
		* pick the master (one with whome everyone synchronizes)
		* for the current group of peers.
		*/

		if(NetworkModel.master_id != null){
			// if master was chosen already
			console.log("master is already chosen");
		}else{

			var ids = NetworkModel.peers_to_connect;

			var conns = NetworkModel.connections;

			for(var i = 0; i < ids.length; i++){
				var id = ids[i];

				if(conns[id] != null && id != NetworkModel.my_id){
					set_master(id);
					console.log("The master is", id);
					break;
				}else if(id == NetworkModel.my_id){
					// i am the best candidate for master
					console.log("I am the law (was chosen as master)");
					set_master(id);
					break;
				}
			}
		}

		GameController.continue_game();

	}; // end pick_the_master
	
	var set_master = function(id){
		/**
		* set the master to the peer with given id
		* and perform all associated procedures
		*/

		NetworkModel.master_id = id;
		
		if(NetworkModel.master_id == NetworkModel.my_id){
			// if master

			// set the master flag
			Config.Remote.master = true;
			
			
		}// fi

		// send out initial sync data
		send_initialization_data();
	};

	var send_initialization_data = function(){
		/**
		* send the initialization data to the peer with the given id
		*
		*/

		var conns = NetworkModel.connections;
		for(var id in conns){
			if(id != NetworkModel.my_id && conns[id]){
				send_initialization_data_to(id);
			}
		}

	};


	var send_initialization_data_to = function(id){
		/**
		* description
		*/

		console.log("sending initialization data to", id);
		
		
		if(NetworkModel.master_id == NetworkModel.my_id){
			data = [];

			var arr = MultiplayerSyncController.get_initialization_data_master();

			for(var i = 0; i < arr.length; i++){
				data.push(arr[i]);
			}

			send_to(id, {op: "special_communication", special_communication: true, message: "I am the law!", master_id: NetworkModel.my_id});
			send_to(id, data);
		}

	};
	
	
	var new_peer = function(id){
		/**
		* pass the id you want the peer to have
		* returns created peer
		*/
		
		var peer = new Peer(id, {key: MEDIATOR_SERVER_KEY});

		peer.on('connection', accept_connection);


		return peer;
	};

	var accept_connection = function(conn){
		/**
		* takes connection
		* is called when someone attempts to establish connection
		* with this client
		*/

		var free_ids = NetworkModel.free_ids;
		var nfree_ids = NetworkModel.non_free_ids;

		var id = conn.peer;
		NetworkModel.connections[id] = conn;

		// remove the id from list of free ids. notice that 
		// array is relatively small, and operation happends seldomly
		free_ids.splice(free_ids.indexOf(id), 1); 

		console.log("accepting connection from peer", id);
		
		nfree_ids.push(id);

		setup_connection_listeners(conn);

		setTimeout(function(){
				send_initialization_data_to(id)
			}
			, Config.Remote.connection_timeout);

	};

	var setup_connection_listeners = function(connection){
		/**
		* description
		*/
		connection.on('data', on_data_arrival);
		connection.on('close', on_connection_closed);
		connection.on('open', on_connection_open);
		connection.on('error', on_connection_error);
	};
	
	

	var connection_unsuccessful = function(error){
		/**
		* for now, just add the peer to which was trying to connect to the
		* free peers list. Later some investigation or reconnection attempts
		* may be implemented
		*/

		console.log(error);
		
	};

	var send_to = function(peer_id, data){
		/**
		* send data to the peer with the peer_id
		* you can make decision to delay data sending, or change
		* procedure somehow right here
		* but do not try to compress the data in this function.
		* send_to will be fired multiple times per each piece of data
		* (it'll be sent to all other players) so any compression should
		* take place in the "distribute_data" function
		*/

		var conn = NetworkModel.connections[peer_id];

		if(conn != null){
			conn.send(data);
		}else{
			throw "No connection exists for the peer with id " + String(id);
		}
		
	};


	var distribute_data = function(data){
		/**
		* First, manipulate the data to properly compress it, or decide what should
		* and what shouldn't be sent (make sure to document stuff here, because people
		* will pull their hair out trying to understand why their stuff doesn't get sent)
		* Second, send the data to all the connected players in this game
		*/

		var conns = NetworkModel.connections;
		for(var id in conns){
			if(id != NetworkModel.my_id && conns[id]){
				conns[id].send(data);
			}
		}
		
	};


	var on_unload = function(arguments){
		/**
		* will be called when the user is about to leave the web page
		* will make sure connections are gracefully closed and peers are destroyed
		*/

		console.log("document is unloaded now. Destroying peer, disconnecting from others");
		NetworkModel.my_peer.destroy();	
	};
	
	
	var on_event = function(smth){
		/**
		* dummy function, delete when isn't called from anywhere
		*/
		
	};


	var on_data_arrival = function(data){
		/**
		* is called whenever new data arrives
		*/

		if(data.special_communication != null){
			// if this is network handling data,
			// not the regular multiplayer data transfer

			if(data.message == "I am the law!"){
				var m_id = data.master_id;

				set_master(m_id);
				console.log("The master is", m_id);
				//clearTimeout(NetworkModel.timeout_id); // will give an error if timeout passed?
			}

			// stop processing
			return;
		}

		if(NetworkModel.recieve_array == null){
			NetworkModel.recieve_array = data;
		}else{
			for(var i = 0; i < data.length; i++){
				NetworkModel.recieve_array.push(data[i]);
			}
		}
	};


	var on_error = function(error){
		/**
		* called when error occurs with the peer
		*/
	};


	var connect_to = function(id, peer){
		/**
		* connect peer >peer< to the peer with the given >id<
		* returns connection object
		*/
		
		var conn = peer.connect(id);

		return conn;
	};
	

	var retrieve_from_backlog = function(){
		/**
		* gets packet from the linked list
		* and removes it from the list
		*/
		
		var list = NetworkModel.package_backlog;

		if(list.HEAD == null){
			return null;
		}

		var packet = list.HEAD.packet;

		list.HEAD = list.HEAD.next;
		list.HEAD.previous = null;

		return packet;

	};


	var place_to_backlog = function(packet){
		/**
		* puts packet into the linked list
		*/
		var list = NetworkModel.package_backlog;
		var packet_container = {packet: packet}; 
		if(list.HEAD == null){
			list.HEAD = packet_container;
			list.TAIL = packet_container;
		}else{
			packet_container.previous = list.TAIL;
			list.TAIL.next = packet_container;
			list.TAIL = packet_container;
		}
	};
	

	var add_to_next_update = function(data){
		/**
		* call this function to schedule the data to be passed to the master/clients.
		* note that this module will decide itself when and how to send the data,
		* so you are not guaranteed that it'll be send immediately, or with the next update
		* You should account for that. This function is meant to be intelligent and prioritize more important
		* stuff
		*/

		NetworkModel.send_array = NetworkModel.send_array || [];

		NetworkModel.send_array.push(data);
	};

	var send_out_data = function(){
		/**
		* temp
		*/
		
		if(NetworkModel.send_array != null){
			
			distribute_data(NetworkModel.send_array);
			NetworkModel.send_array = null;
		}

	};

	var send_data_to_master = function(){
		/**
		* send the prepared data to the master
		*/
		var master_conn = NetworkModel.connections[NetworkModel.master_id];
		if(NetworkModel.send_array != null && master_conn != null){
			master_conn.send(NetworkModel.send_array);
			NetworkModel.send_array = null;
		}

	};
	

	var get_data = function(){
		/**
		* get the data array
		*/
		
		var data = NetworkModel.recieve_array;
		
		return data;
	};

	var clean_data = function(){
		/**
		* description
		*/
		delete NetworkModel.recieve_array;
	};
	
	var get_network_id = function(){
		// returns my network id if I am connected,
		// or "local" if not
		if(Config.Remote.connected){
			return NetworkModel.my_id;
		}else{
			return "local";
		}
	};
	
	return {
		// declare public
		init: init, 
		update: update,
		add_to_next_update: add_to_next_update,
		get_data: get_data,
		clean_data: clean_data,
		get_network_id: get_network_id,
		send_to: send_to,
		start_multiplayer_session: start_multiplayer_session,
	};
})();

module.exports = NetworkController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "NetworkController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],12:[function(require,module,exports){
// Notes:
// notice that you can reuse body definitions multiple times, it makes sense to have
// collection of body definitions that are commonly use and maybe allow some sort of 
// inheritance (i.e. you can make some definition on top of the another definition)
// // bodies are allowed to have userData on them that is just reference to some object.
// may be useful in some situations
//
// Question:
// does it make sense to allow users to pass any properties as part of object definition
// and just apply those properties automatically to the userData property of body?

var B2dConfig;

var PhysicsController = (function(){

	var init = function(){
		include();

		B2dConfig = Config.B2D;

		PhysicsModel.scale = B2dConfig.SCALE;
		PhysicsModel.step_amount = 1/(B2dConfig.SPS);

		PhysicsModel.gravity = new B2d.b2Vec2(0,30); // earth gravity
		PhysicsModel.world = new B2d.b2World(PhysicsModel.gravity, true);

		init_collision_listener();

	};
	
	var step = function (delta_ms) {
		// !? should I set upper limit on delta to prevent world from
		// fast forwarding if the ticker was paused? or that is not a problem in our case?
		// investigation is needed

		var delta = delta_ms/1000;

		PhysicsModel.timeToCover += delta;

		while (PhysicsModel.timeToCover > PhysicsModel.step_amount) {
			PhysicsModel.timeToCover -= PhysicsModel.step_amount;
			PhysicsModel.world.Step(
				PhysicsModel.step_amount,
				B2dConfig.POSITION_ITR, // velocity iterations
				B2dConfig.VELOCITY_ITR // position iterations
			);
		}
	};  // end step 

	var draw_debug = function(){
		if (B2dConfig.debug_draw) {
			PhysicsModel.world.DrawDebugData();
		}
	};

	var get_parent_chain = function(template, default_def){
		var next = template;
		var ancestors = [];

		while(next != null){
			ancestors.push(next);
			next = next["parent"];
		}

		if(default_def){
			ancestors.push(default_def);
		}

		return ancestors;
		
	};

	var apply_parents = function(template_name, template_collection){
		// TODO: refactor the code so this thing is done only once
		// at the load tim
		// that could probably be done even for other things.
		// idea: store compiled body/fixture etc. together with the
		// template. this way you'll have easy access to the all defined
		// options for debugging;
		
		var default_tmplate = template_collection["default"];

		var chain = get_parent_chain(template_collection[template_name], default_tmplate);

		var final_definition = {};

		for(var i = chain.length - 1; i >= 0 ; i--){
			// may be needed to be made more efficient by moving the other way
			// and not considering options that were already encountered in children
			var current = chain[i];


			for(var prop in current){
				final_definition[prop] = current[prop];
			}
		}

		return final_definition;
	}; // end apply_parents
		
	var target_props = {
		body_def: [
			"active",
			"allowSleep",
			"angle",
			"angularDamping",
			"angularVelocity",
			"awake",
			"bullet",
			"fixedRotation",
			"inertiaScale",
			"linearDamping",
			"linearVelocity",
			"position",
			"type",
			//"userData" // doesn't seem to properly work, doing it differently
		],
		fixture_def: [
			"density",
			//"filter", implement later if needed
			"friction",
			"isSensor",
			"restitution",
			"shape",
			"userData"
		]
	};

	var apply_property_list = function(source, destination, list){
		/**
		 * takes two objects and the list of strings
		 * copies all properties with names found in the list
		 * from source to destination
		 * scips properties which are null/undefined
		 */

		for(var i = 0; i < list.length; i++){
			var prop = list[i];
			if(source[prop] != null){
				destination[prop] = source[prop];
			}
		}

		return destination;
	};

	var PropertyUndefined = function PropertyUndefined(property_name){
		this.name = "PropertyUndefined";
		this.message = "Error: " + property_name + " is not defined";
	};
	PropertyUndefined.prototype = Object.create(Error.prototype);
	PropertyUndefined.prototype.constructor = PropertyUndefined;

	var get_formal_body_def = function(non_formal_def){
		/**
		 * turn non formal definition into the formal one
		 * non-formal definition is an object that contains
		 * properties SOME of which are box2d properties or are 
		 * intended to be transformed into such. E.g. the non-formal
		 * definition may contain properties vx and vy which will be transformed
		 * into the linearVelocity vector in the formal definition
		 */

		var nfdef = non_formal_def;

		var definition = new B2d.b2BodyDef();

		if(nfdef.vx != null && nfdef.vy != null){
			// check for informal parameter specification first
			nfdef.linearVelocity = new B2d.b2Vec2(nfdef.vx, nfdef.vy);
		}else{
			// maybe the linearVelocity was specified directly as vector,
			// and not through informal parameters; checking that, and if not,
			// exception
			if(!(nfdef.linearVelocity)){
				throw new PropertyUndefined("linearVelocity");
			}
		}

		if(nfdef.x != null && nfdef.y != null){
			// same procedure as for the linear velocity
			// checking for informal specification here
			// and if present, turning into the formal
			nfdef.position = new B2d.b2Vec2(nfdef.x, nfdef.y);
		}else{
			// checking if formal was specified directly
			if(!(nfdef.position)){
				// if not, throw custom exception
				throw new PropertyUndefined("position");
			}
		}

		if(nfdef.type){
			nfdef.type = {
				"static": B2d.b2Body.b2_staticBody, 
				"dynamic": B2d.b2Body.b2_dynamicBody,
				"kinematic": B2d.b2Body.b2_kinematicBody
			}[nfdef.type]; // turn string-type into b2d type
		}else{
			throw new PropertyUndefined("type");
		}

		apply_property_list(nfdef, definition, target_props.body_def);

		return definition;

	};

	var get_formal_fixture_def = function(non_formal_def){
		/**
		 * turns non-formal definition into the formal one
		 * see get_fromal_body_def for explanation
		 */

		var nfdef = non_formal_def;
		var shape = nfdef.shape;
		var fixture_def = new B2d.b2FixtureDef();

		apply_property_list(non_formal_def, fixture_def, target_props.fixture_def);

		switch (shape) {
			case "rectangle":

				if(nfdef.width != null && nfdef.height != null){
					fixture_def.shape = new B2d.b2PolygonShape();
					if (nfdef.offset != null){
						var offset = new B2d.b2Vec2(nfdef.offset.x ,nfdef.offset.y);
						fixture_def.shape.SetAsOrientedBox(nfdef.width/2, nfdef.height/2, offset, 0);
					}else{
						fixture_def.shape.SetAsBox(nfdef.width/2, nfdef.height/2);
					}
				}else{
					throw new PropertyUndefined("width or height");
				}
				break;
			case "polygon":

				if(nfdef.points != null){
					fixture_def.shape = new B2d.b2PolygonShape();
					fixture_def.shape.SetAsArray(nfdef.points, nfdef.points.length);
				}else{
					throw new PropertyUndefined("points");
				}
				break;
			case "circle":

				if(nfdef.radius != null){
					fixture_def.shape = new B2d.b2CircleShape(nfdef.radius);
				}else{
					throw new PropertyUndefined("radius");
				}
				break;
			default:
				throw "Error: shape must be one of the following: " + 
					'"polygon", "rectangle", "circle". You specified: ' +
					String(shape);
		}

		return fixture_def;

	};
	

	var get_body = function(non_formal_def, entity_instance){
		/**
		 * takes non-formal definition
		 * returns body based on this definition
		 *
		 */
		if (entity_instance == null){
		throw new PropertyUndefined("entity_instance");
		}
		var definition = get_formal_body_def(non_formal_def);

		var body = PhysicsModel.world.CreateBody(definition);

		//if(body.userData == null){
			//body.userData = {};
		//}

		// append passed definition to the user data of the body
		// for debugging purposes, and also to allow easy specification of 
		// custom parameters during definition. If this will cause confusion,
		// I'll remove that
		//body.userData.def = non_formal_def;
		body.SetUserData({def: non_formal_def, entity_instance: entity_instance});
		
		return body;
	
	};

	var attach_fixture = function(body, non_formal_def, fixture_name){
		/**
		 * given b2d body, (non-formal) fixture definition and (OPTIONAL) fixture_name
		 * this function attaches fixture to the body
		 */

		var fixture_def = get_formal_fixture_def(non_formal_def);

		if(fixture_def.userData == null){
			fixture_def.userData = {};
		}

		fixture_def.userData.def = non_formal_def;
		fixture_def.userData.name = fixture_name;
		
		body.CreateFixture(fixture_def);
		
	};

	var attach_sensors = function(body){
		var SENSOR_THICKNESS = 0.1;
		
		// get the width and height of the body's main fixture
		// and create 4 sensor fixtures based on those parameters
		// calculate offset of sensors so that they match the main fixture
		var x = body.GetPosition().x;
		var y = body.GetPosition().y;

		// TODO: change to getting dimentions of main fixture
		var h = body.GetFixtureList().GetAABB().GetExtents().y;
		var w = body.GetFixtureList().GetAABB().GetExtents().x;
		
		//attach top fixture
		var top_sensor = {};
		top_sensor.shape = "rectangle";
		top_sensor.density = 0;
		top_sensor.isSensor = true;
		top_sensor.height = SENSOR_THICKNESS;
		top_sensor.width = (w*2 - SENSOR_THICKNESS*2) - 0.3;
		top_sensor.offset = {x:0, y: (-1*h) + SENSOR_THICKNESS/2};
		attach_fixture(body,top_sensor,"top");
		
		//attach bottom fixture
		var bottom_sensor = top_sensor;
		//bottom_sensor.width += 0.4;
		bottom_sensor.offset = {x:0, y: h - SENSOR_THICKNESS/2};
		attach_fixture(body,bottom_sensor,"bottom");
		
		//attach left fixture
		var left_sensor = top_sensor;
		left_sensor.height = (h*2 - SENSOR_THICKNESS*2) - 0.3;
		left_sensor.width = SENSOR_THICKNESS;
		left_sensor.offset = {x:(-1*w) + SENSOR_THICKNESS/2,y:0};
		attach_fixture(body,left_sensor,"left");
		
		//attach right fixture
		var right_sensor = left_sensor;
		right_sensor.offset = {x:w - SENSOR_THICKNESS/2, y:0};
		attach_fixture(body,right_sensor,"right");
	};
	
	
	

	var get_rectangular = function(def, entity_instance){
		// get appropriate template collection to draw from
		var template_name = entity_instance.type;
		var template_collection = PhysicsModel.r_templates;
		var compiled_template = apply_parents(template_name, template_collection);

		// apply custom override
		var final_def = compiled_template;
		for(var prop in def){
			final_def[prop] = def[prop];
		}

		final_def.shape = "rectangle";

		// final_def contains all final data, about body we are about to create
		// it takes into account template given and all it's parents
		// and also manually specified parameters. However, this definition is raw,
		// i.e. some data in it may not be in its final form, e.g. linear velocity is specified
		// as two parameters, vx and vy, while it whould be converted into the vector
		// for box2d. so final_def is a final description, but not in final form


		var body = get_body(final_def, entity_instance);
		 
		attach_fixture(body, final_def, "main");
		
		//If the object has directional sensors, attach sensors here
		if(final_def.border_sensors){
			attach_sensors(body);
		}

		return body;
	};

	var get_circular = function(def, template){
		var type = "circular";
		// dont' forget about refactoring some stuff into the
		// set_common function
		
		var definition = new B2d.b2BodyDef();
		
	};
		
	var get_polygonal = function(def, template){
		var type = "polygonal";
		
		var definition = new B2d.b2BodyDef();
		
	};

	var set_debug_draw = function(debug_draw){
		PhysicsModel.world.SetDebugDraw(debug_draw);
	};


	
	var listen_for_contact_with = function(what, collision_event_name, custom_function){
		/**
		 * setups custom_function to be called each time the collision event 
		 * occurs and involves >what<
		 * TAKES:
		 * 	>what<
		 * 		string 
		 * 		id of an object ("383") or it's type ("player")
		 * 	>collision_event_name<
		 * 		string. one of:
		 * 		BeginContact, EndContact, PreSolve, PostSolve
		 * 	>custom_function< 
		 * 		function
		 * 		function to be called on one of those events
		 * 		notice that function will be wrapped, so it should
		 * 		accept extra parameter >info< that will contain
		 * 		unpacked information about the collision
		 */


		if(what == null){
			throw new PropertyUndefined("what");
		}

		if(
			collision_event_name != "BeginContact" && collision_event_name != "EndContact" &&
			collision_event_name != "PreSolve" && collision_event_name != "PostSolve" 
		){
			throw "collision_event_name should be one of: PreSolve, PostSolve, EndContact, BeginContact";
		}

		if(custom_function == null || typeof(custom_function) != "function"){
			throw "Property custom_function is not defined or isn't a function"
		}

		var target_function_table = PhysicsModel.awaiting_contact[collision_event_name]; 

		if(target_function_table[what] == null){
			target_function_table[what] = [custom_function];
		}else{
			target_function_table[what].push(custom_function);
		}
		
		
	};
	
	
		
	var init_collision_listener = function(){
		
		/**
		 */
		
		var call_all = function(list, args){
			/**
			 * call all functions in list providing arguments
			 * from the array args
			 * if list give is null/undefined, do nothing
			 */

			if(list != null){
				for(var i = 0; i < list.length; i++){
					list[i].apply(this, args);
				}
			}
		};

		var get_id = function(obj){
			userData = obj.GetUserData();
			if(userData != null && userData.id != null){
				return userData.id;
			}else{
				return "[NO_ID]"
			}
			
		};

		var get_type = function(obj){
			var userData = obj.GetUserData();
			if(userData != null && userData.entity_instance.type != null){
				return userData.entity_instance.type;
			}else{
				return null;
			}
			
		};

		var unpack_contact_info = function(contact, my_type){
			/**
			 * unpacks info about the collision and 
			 * returns it
			 * >my_type< is an type of an object that will
			 * go under the >Me< parameeter inside of info
			 * (As opposed to Them, which is the other object)
			 */
			if(my_type == null){
				// >my_type< isn't supposed to be null/undefined
				throw new PropertyUndefined("my_type");
			}

			var A = {};
			var B = {};

			A.fixture = contact.m_fixtureA;
			B.fixture = contact.m_fixtureB;
			A.body = A.fixture.GetBody();
			B.body = B.fixture.GetBody();

			A.id = get_id(A.body);
			B.id = get_id(B.body);

			//A.entity = IdentificationController.get_by_id(A.id);
			//B.entity = IdentificationController.get_by_id(B.id);
			A.entity = A.body.GetUserData().entity_instance;
			B.entity = B.body.GetUserData().entity_instance;

			A.type = get_type(A.body);
			B.type = get_type(B.body);

			A.fixture_name = get_custom_property(A.fixture, "name");
			B.fixture_name = get_custom_property(B.fixture, "name");

			// TODO: unpack more info if necessary

			var info = {};

			if(A.type == my_type){
				info.Me = A;
				info.Them = B;
			}else{
				info.Me = B;
				info.Them = A;
			}

			return info;
			
		};
		
		var common_contact = function(contact, args, lists){
			// create info, call respective functions for each id. use provided arguments >args<
			// lookup ids in the provided table of lists >lists<
			
			/* next available index in the args array 
			 * it's used to determine at what index the info object should be inserted as*/
			var next_arg_index = args.length; 

			var type1 = get_type(contact.m_fixtureA.GetBody());
			var type2 = get_type(contact.m_fixtureB.GetBody());

			if(type1 != null){
				
				args[next_arg_index] = unpack_contact_info(contact, type1);
				call_all(lists[type1], args);
			}

			if(type2 != null){
				args[next_arg_index] = unpack_contact_info(contact, type2);
				call_all(lists[type2], args);
			}

		};
		
		var PreSolve = function(contact, impulse){
			
			var lists = PhysicsModel.awaiting_contact.PreSolve;

			var args = [contact, impulse];

			common_contact(contact, args, lists);
	
		};
		
		var PostSolve = function(contact, oldManifold){
			var lists = PhysicsModel.awaiting_contact.PostSolve;

			var args = [contact, oldManifold];

			common_contact(contact, args, lists);
		};

		var BeginContact = function(contact){
			var lists = PhysicsModel.awaiting_contact.BeginContact;

			var args = [contact];

			common_contact(contact, args, lists);
		};

		var EndContact = function(contact){
			var lists = PhysicsModel.awaiting_contact.EndContact;

			var args = [contact];

			common_contact(contact, args, lists);
		};
		
		
		
		var listener = new B2d.b2ContactListener;
		listener.PreSolve = PreSolve;
		listener.PostSolve = PostSolve;
		listener.BeginContact = BeginContact;
		listener.EndContact = EndContact;
		
		PhysicsModel.world.SetContactListener(listener);
	
	};

	var get_custom_property = function(b2d_obj, property_name){
		
		/**
		 * given any box2d object that has GetUserData method
		 * this function will return custom property with given
		 * property_name if this property is set on userData of the object
		 * if not, the function returns null
		 */
		var user_data = b2d_obj.GetUserData();
		if(user_data && user_data[property_name]){
			return user_data[property_name];
		}else{
			return null;
		}
	};
	
	var remove_body = function(body){
		/**
		* destroy given body (remove it from world and remove all references Physics has to it)
		*/
		
		// TODO: IMPORTANT!!! update this function if you store extra references
		// to the body within PhysicsModel/Controller.
		// Even a single reference to the body may keep it from being deleted
		// from the memory 
		PhysicsModel.world.DestroyBody(body);
	};
	
	//a very important function that I need for the hyena
	//returns the number of shapes in contact with a given bounding box
	var query_aabb = function(aabb){
		var count = 0;
		PhysicsModel.world.QueryAABB(
		function(max){
			count++;
			return true;
		},
		aabb);
		return count;
	};
	
	
	return {
		get_body: get_body,
		get_rectangular: get_rectangular,
		step: step,
		init: init,
		set_debug_draw: set_debug_draw,
		draw_debug: draw_debug,
		listen_for_contact_with: listen_for_contact_with,
		remove_body: remove_body,
		query_aabb: query_aabb,
	};
})();


module.exports = PhysicsController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "PhysicsController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],13:[function(require,module,exports){

var RegisterAsController = (function(){
	/* Allows you to register object as something,
	 * for other modules to access
	 * One use could be registering newly generated terrain slice from the slice controller,
	 * for the GraphicsController to notice and generate graphics for it
	*/

	var init = function(){
		/* is ran from the InitController once when the game is loaded */

		include(); // satisfy requirements

	};

	var update = function(delta){
		/* is ran each tick from the GameController.update_all */

		// TODO: automatically delete stuff depending on timeout stuff
		// calculate timeout of 
	};

	var register_as = function(what, obj){
		/**
		* simple one time lookup registering of object
		* >what< - string. e.g. "new_terrain_slice"
		* >obj< - object to register
		*/
		
		var table = RegisterAsModel.simple_one_time_lookup;

		if(table[what]){
			table[what].push(obj);
		}else{
			table[what] = [obj];
		}
	};

	var retrieve_registered_as = function(what){
		/**
		* returns reference to the object contatining
		* things currently registered as >what<
		* you are responsible for popping (or not popping) them
		* from the array to no longer consieder (or continue to consider)
		* them as registered as >what<
		*/
		var list = RegisterAsModel.simple_one_time_lookup[what];
		if(list){
			return list;
		}else{
			return [];
		}
		
	};
	
	
	return {
		// declare public
		init: init, 
		update: update,
		register_as: register_as,
		retrieve_registered_as: retrieve_registered_as
	};
})();

module.exports = RegisterAsController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "RegisterAsController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],14:[function(require,module,exports){
config = require ("../Config.js");

var TerrainController = (function(){
	/* this will be the physical representation of the terrain
	 * currently it contains graphical bits, but that will change
	 */
	

	var init = function(){
	    include();
	    TerrainModel.seed = Math.floor(Math.random()*2000) + 1000;//placeholder for seed

	};
	
	
	var update = function(){
		// check for any chunks to be unloaded/deleted will go here, for now
		// maybe it'll check for all players to be sufficiently far to the right
		// of it, maybe one chunk in advance, or smth like that
		//if (config.movement_edge.x > x)
		while(TerrainModel.terrain_slices_queue.length < 4){
			var slice = NewTerrainSlice();
			TerrainModel.terrain_slices_queue.push(slice);
		}

		var cmds = KeyboardController.debug_commands();

		if(cmds("new_slice")){
			console.log(TerrainModel.seed);
			var slice = NewTerrainSlice();
			TerrainModel.terrain_slices_queue.push(slice);
		}
		

		if(WorldController.get_movement_edge() > (TerrainModel.terrain_slices_queue.length-3)*(20)){
			var slice = NewTerrainSlice(TerrainModel.seed);
			TerrainModel.terrain_slices_queue.push(slice);
			TerrainModel.seed = (((TerrainModel.seed) * (TerrainModel.seed) - TerrainModel.seed / 2)) % 2000 + 1001;
			WorldController.set_spawn();
		};

		check_for_old_slices();
	};

	var get_seed = function(){
		return TerrainModel.seed;
	};
	
	var set_seed = function(new_seed){
		TerrainModel.seed = new_seed;
	};

	var NewTerrainSlice = function(seed){
		/* this takes care of appending new terrain slice to the generated terrain
		 * it calculates it's origin x and y positions and whatever other stuff,
		 * generates slice; sets up everything
		 */
		var x_offset = TerrainModel.slice_counter * Config.TerrainSlice.grid_columns;

		TerrainModel.slice_counter++; // TODO: change how it works when truly infinite

		if(TerrainModel.initial_generated < 3){
			TerrainModel.initial_generated++;
			var slice = new TerrainSliceController.generate_initial(x_offset);
		}else{
			var slice = new TerrainSliceController.generate_random(x_offset, seed);
		}

		IdentificationController.assign_id(slice);

		MarkAsNewTerrainSlice(slice); 

		return slice;

	};

	var check_for_old_slices = function(){
		/**
		* check for slices that are too far behind and should be removed
		*/

		var tqueue = TerrainModel.terrain_slices_queue;
		var cut_off_index = 0; // what amnt of slices should go off the queue

		// find the old slices and handle their deletion
		for(var i = 0; i < tqueue.length; i++){
			var slice = tqueue[i];
			var slice_end_x = slice.origin.x + slice.grid_columns * slice.cell_w;

			if(slice_end_x < WorldController.get_movement_edge){
				// if slice is unreachable, delete it 
				cut_off_index++;
				delete_slice(slice);
			}
		}

		// now remove all found old slices from the queue
		if(cut_off_index > 0){
			TerrainModel.terrain_slices_queue = tqueue.slice(cut_off_index);
		}
	};
	
	

	var delete_slice = function(slice){
		/**
		* assumes that slice will be popped from the terrain slice queue elsewhere
		* (or was already)
		* otherwise the slice won't be properly deleted
		*/
			
		console.log("deleting slice with origin", slice.origin);
		
		var grid = slice.grid;
		
		for(var i = 0; i < grid.length; i++){
			var row = grid[i];
			for(var j = 0; j < row.length; j++){
				var cell = row[j];
				if(cell.kind != 0){
					PhysicsController.remove_body(cell.body);
					IdentificationController.remove_id(cell.id);
				}
			}
		}

		
		// For graphics to pick up and delete unneeded graphics
		RegisterAsController.register_as("removed_slice", slice);

		// free the id (yes, terrain slice has id id
		IdentificationController.remove_id(slice.id);
	};
	
	

	
	var for_each_tile = function(f){
		// takes function >f< that takes three parameters: tile (easeljs object),
		// terrain_lvl (int), and tile_index (int)
		// calls this function for every tile of the terrain
		
		var queues = TerrainModel.terrain_queues;

		$.each(queues, function(terrain_lvl){
			$.each(queues[terrain_lvl], function(tile_index){
				f(queues[terrain_lvl][tile_index], terrain_lvl, tile_index);
			});
		});

	};

	
	var MarkAsNewTerrainSlice = function(slice){
		//TerrainModel.new_slices.push(slice);
		RegisterAsController.register_as("awaiting_graphics_initialization", slice);
	};

	//var NewSlicesAvailable = function(){
		//return (TerrainModel.new_slices.length > 0);
	//};

	//var GetNewTerrainSlices = function(){
		//return TerrainModel.new_slices;
	//};

	return {
		update: update,
		init: init,
		NewTerrainSlice: NewTerrainSlice,
		MarkAsNewTerrainSlice: MarkAsNewTerrainSlice,
		get_seed: get_seed,
		set_seed: set_seed,
		//NewSlicesAvailable: NewSlicesAvailable,
		//GetNewTerrainSlices: GetNewTerrainSlices,
	}
})();

module.exports = TerrainController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "TerrainController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Config.js":2,"../Includes.js":19}],15:[function(require,module,exports){

var TerrainSliceController = (function () {

	var init = function(){
		/* is ran from the InitController once when the game is loaded */
		include(); // satisfy requirements
		IdentificationController.assign_type(TerrainSliceModel.Cell, "terrain_cell");
		IdentificationController.assign_type(TerrainSliceModel.Slice, "terrain_slice");

	};

	var update = function(slice){
		

	};

	var get_next_origin = function(){
	};
	

	
	var spawnBlock = function(x, y, kind){
		//spawn instance of this entity at the given coordinates
		var block = new TerrainSliceModel.Cell(kind%3); //kind is an int, 1 = block, 2 = platform
		IdentificationController.assign_id(block); //eventually we may want to remove this for the sake of efficiency
		block.body = PhysicsController.get_rectangular({x: x, y: y}, block);
		return block;
	};
	
	var spawnSpike = function(x, y){
		//spawn instance of this entity at the given coordinates
		var spike = new TerrainSliceModel.Cell(3); //kind = 3 means spikes
		spike.can_attack = true;
		spike.damage = 4;
		IdentificationController.assign_id(spike); //eventually we may want to remove this for the sake of efficiency
		spike.body = PhysicsController.get_rectangular({x: x, y: y}, spike);
		return spike;
	};
	
	var spawnGap = function(x,y){
		// 0 will be the id for the "air" i.e. nothing
		var gap;
		gap = new TerrainSliceModel.Cell(0);
		//IdentificationController.assign_id(gap); // DO NOT ASSIGN IDS TO EMPTY SPACES
		return gap;
	};
	
	var getRandomNumber = function (seed) {
		return (seed*seed)%2000 + 1000;
	};
	
	var buildTerrainSlice_00 = function(slice,seed){
	
	    //set variables
	    //console.log(seed);
	    var seed = seed;
		var rows = slice.grid_rows;
		var columns = slice.grid_columns;
		var i,j;
		var ground_lvl = rows - 3; //the row that is considered ground level.
		var vgap_min = 7;
		var vgap_len = 0;
		var hgap_min = 10;				//minimum size of gaps between platforms
		var hgap_len = 0; 		//current number of consecutive horizontal gaps
		var pit_max = 8;				//maximum len of pits in blocks
		var pit_len = 0; 		//current number of consecutive pits
		var has_pit = [];
		var pit_frequency = 6; 		//base percentage chance of a pit being dug
		var platform_len_max = 7;	//maximum len of a platform
		var platform_len_min = 3; //minimum len of a platform
		var platform_len = 0; 		//len of currently generated platform
		var platform_count_max = 2; //maximum number of platforms per column
		var platform_count = []; 		//keeps track of platforms per column
		var platform_frequency = 15;//base percentage chance of a platform to be generated
		var spike_frequency = 50;//base percentage chance of a platform to have spikes
		/*
		var spike frequency
		var column frequency
		etc.
		*/
		for(i=0; i<=columns;i++){
			platform_count[i] = 0;
			has_pit[i] = false;
		}

		//build the stage from the bottom up
		/*
		Build Stage from bottom up, left to right
		load blocks and gaps into slice.grid[i][j]
		
		*/
		for(i=rows-1;i>=0;i--){
			slice.grid[i] = [];
		}
		
		for(i=rows - 1;i>=0;i--){ //outer loop: generate rows bottom to top
			if (vgap_len < vgap_min){
				vgap_len++;
			}
			if (seed % 10 == 0) {
			    seed += i;
			}
			for(j=0;j<columns;j++){ //inner loop: generate from left to right within current row
				var x = slice.origin.x + j * slice.cell_w + slice.cell_w/2;
				var y = slice.origin.y + i * slice.cell_w + slice.cell_w/2;
				
				if (i >= ground_lvl){	//If on or below ground level, Generate Ground
				    if (pit_len < pit_max && (getRandomNumber(seed) % i < pit_frequency || pit_len != 0) || has_pit[j]) {
						slice.grid[i][j] = spawnGap(x,y); //create gap
						has_pit[j] = true;
						pit_len++; //the pit gets wider
						seed = getRandomNumber(seed) + 71;
					}
					else{
						slice.grid[i][j] = spawnBlock(x,y,1);//create a ground block (1 means ground)
						pit_len = 0; //any pits being spawned have been interrupted
						if (i == ground_lvl){
							slice.grid[i][j].position = "surface";
							if(getRandomNumber(seed)%100 < spike_frequency && j > 0){//check for random spike
								if(slice.grid[i-1][j-1] == null && slice.grid[i][j-1].kind != 0){
									slice.grid[i - 1][j] = spawnSpike(x, y - slice.cell_w); //create a spike above the current block
									seed = getRandomNumber(seed) + 21;
								}
							}
						}else{
						slice.grid[i][j].position = "underground";
						}
					}
				}else{ //ElSE Generate Platforms
					if((hgap_len >= hgap_min || platform_len > 0) //if there is a large gap or a platform being built
					&& (platform_len < platform_len_max) // and any platform being built is less than max len
					&& (platform_count[j] < platform_count_max) // and the current column's platform limit has not been met
					&& (vgap_len >= vgap_min) //if the vertical gap minimum has been met
					&& (platform_len > 0 || (j<columns-1 && platform_count[j+1] < platform_count_max))){ //and the platform is not going to be a singleton
						if (getRandomNumber(seed)%100 < platform_frequency || (platform_len > 0 && platform_len <= platform_len_min)){
						
							slice.grid[i][j] = spawnBlock(x,y,2);//create platform (2 means platform)
							
							//check aesthetic stuff, like platform edges
							if (platform_len == 0){
								slice.grid[i][j].position = "left";
							}
							else{
								slice.grid[i][j].position = "right";
							}
							if (j>0){if (slice.grid[i][j-1].kind != 0){
								if (slice.grid[i][j-1].position != "left"){
									slice.grid[i][j-1].position = "middle";
								}
							}}
							
							seed = getRandomNumber(seed);
							platform_len++;	//platform gets longer, and 
							platform_count[j]++;//the number of platforms in the current column increases
							hgap_len = 0; 		//reset the gap counter to 0
						}else{
							if (slice.grid[i][j] == null){
								slice.grid[i][j] = spawnGap(x,y); //create a gap
								platform_len = 0; //if there was a platform, it has been interrupted
								hgap_len++; //the gap gets wider
							}
						}
					}else{
						if (slice.grid[i][j] == null){
							slice.grid[i][j] = spawnGap(x,y); //create a gap
							platform_len = 0; //if there was a platform, it has been interrupted
							hgap_len++; //the gap gets wider
						}
					}
					seed = getRandomNumber(seed);
				}
			}
			vgap_len = vgap_len%vgap_min;
		}
		return slice;
	};
	
	//pregenerated slice
	var buildTerrainSlice_01 = function(slice,seed){
		//set variables
		var rows = slice.grid_rows;
		var columns = slice.grid_columns;
		var i,j;
		var ground_lvl = rows - 3; //the row that is considered ground level.
		var vgap_min = 7;
		var vgap_len = 0;
		var hgap_min = 10;				//minimum size of gaps between platforms
		var hgap_len = 0; 		//current number of consecutive horizontal gaps
		var pit_max = 20;				//maximum len of pits in blocks
		var pit_len = 0; 		//current number of consecutive pits
		var has_pit = [];
		var pit_frequency = 0; 		//base percentage chance of a pit being dug
		var platform_len_max = 7;	//maximum len of a platform
		var platform_len_min = 3; //minimum len of a platform
		var platform_len = 0; 		//len of currently generated platform
		var platform_count_max = 2; //maximum number of platforms per column
		var platform_count = []; 		//keeps track of platforms per column
		var platform_frequency = 5;//base percentage chance of a platform to be generated
		for(i=0; i<=columns;i++){
			platform_count[i] = 0;
			has_pit[i] = false;
		}
		for(i=rows - 1;i>=0;i--){ //outer loop: generate rows bottom to top
			slice.grid[i] = [];
			for(j=0;j<columns;j++){ //inner loop: generate from left to right within current row
				var x = slice.origin.x + j * slice.cell_w + slice.cell_w/2;
				var y = slice.origin.y + i * slice.cell_w + slice.cell_w/2;
				if (i >= ground_lvl){	//If on or below ground level, Generate Ground
					slice.grid[i][j] = spawnBlock(x,y,1);//create a ground block (1 means ground)
					if (i == ground_lvl)
						slice.grid[i][j].position = "surface";
					else{
					slice.grid[i][j].position = "underground";
					}
				}else{
					slice.grid[i][j] = spawnGap(x,y);
				}
			}
		}
		return slice;
	};
	
	var generate_initial = function(x_offset){
		var slice = new TerrainSliceModel.Slice();
		slice.origin.x = x_offset;
		slice.origin.y = 0;
		slice = buildTerrainSlice_01(slice);
		
		return slice;
	}
	
	var generate_random = function(x_offset, seed){
		var slice = new TerrainSliceModel.Slice();
		slice.origin.x = x_offset;
		slice.origin.y = 0;
		//get a random kind of slice
		if (getRandomNumber(seed)%100 < 95){
			slice = buildTerrainSlice_00(slice,seed);
		}else{
			slice = buildTerrainSlice_01(slice,seed);
		}
		
		return slice;
	};
	




	return {
		// declare public
		init: init, 
		update: update,
		generate_initial: generate_initial,
		generate_random: generate_random,
	};
})();

module.exports = TerrainSliceController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "TerrainSliceController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],16:[function(require,module,exports){
var TestController = (function(){
	// placeholder for implementing testing
	// may be changed/removed/upgraded depending on how we will handle our tests
	
	
	var preinit_tests = function(){
	//For tests requiring run before init is called
	
	
	};
	
	
	var test = function(){
		// if you need some sort of tests launched, this is one of the places to do it
		QUnit.test( "hello test", function( assert ) {
			assert.ok( 1 == "1", "Passed!" );
		});
		Includes.automated_tests();
	};

	var post_loading_tests = function(){
		// TODO: call when loading assets is completed if there are some tests that need
		// to be done at that moment. (Refer to InitController.init and 
		// InitController.setup_asset_dependent methods
	};

	var testMode;

	var init = function(mode){
		include();
		// Sets up the debug canvas during testing
		TestModel.d_canvas = document.getElementById(Config.DEBUG_CANVAS_NAME);
		testMode = mode;

		if(mode == "test"){
			TestModel.context = TestModel.d_canvas.getContext("2d");
			
			TestModel.debugDraw = new B2d.b2DebugDraw();
			TestModel.debugDraw.SetSprite(TestModel.context);
			TestModel.debugDraw.SetDrawScale(Config.B2D.SCALE);
			TestModel.debugDraw.SetFillAlpha(0.3);
			TestModel.debugDraw.SetLineThickness(1.0);
			TestModel.debugDraw.SetFlags(B2d.b2DebugDraw.e_shapeBit | B2d.b2DebugDraw.e_jointBit);

			PhysicsController.set_debug_draw(TestModel.debugDraw);

			Config.B2D.debug_draw = true;
			// Screen_W was setup only after this was called

			TestModel.d_canvas.width = Config.SCREEN_W;
			TestModel.d_canvas.height = Config.SCREEN_H;

			//$('#'+Config.DEBUG_CANVAS_NAME).show();

		}else{
			//d_canvas.hide();
		}
	};
	
	//this function sets the x and y offsets of the debug canvas
	var set_debug_offset = function(x_offset, y_offset){
	    if (testMode == "test"){
	        context = TestModel.context;
	        context.save();
	        context.clearRect(0, 0, Config.SCREEN_W, Config.SCREEN_H);
	        context.translate(x_offset, y_offset);
	        PhysicsController.draw_debug();
	        context.restore();
	    }
	};

	return {
		init: init, 
		test: test,
		post_loading_tests: post_loading_tests,
		preinit_tests: preinit_tests,
		set_debug_offset: set_debug_offset
	}
})();

module.exports = TestController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "TestController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],17:[function(require,module,exports){
	
var WorldController = (function(){
	/* all the physics control of the whole world
	*/
    var movement_edge;
    var spawn_enemy;
    var difficulty;
		var season;
		var movement_edge_buffer;
		var body_test;
		var score;
		var progress;
	//var temp = 0;

	var init = function(){
		/* is ran from the InitController once when the game is loaded */

		include(); // satisfy requirements
		movement_edge_buffer = 20;
		movement_edge = 0;
		season = 0;
		score = 0;
		progress = 20;
		//body_test = new platform();
		//var id = IdentificationController.assign_id(body_test);
		//var body_test = PhysicsController.get_rectangular({}, body_test);

	};

	var update = function(delta){
		/* is ran each tick from the GameController.update_all */
		PhysicsController.step(delta);

		update_movement_edge();
		update_progress();

		get_spawn();
		//if(temp++ == 0){
			//TerrainController.NewTerrainSlice();
		//}

	};

	var update_progress = function(arguments){
		/**
		* 
		*/

		progress = get_movement_edge();
		
	};
	
	
	
	var update_movement_edge = function(){
		var heroes = EntityController.get_all_heroes();
		var min_x = Infinity;

		for(var net_id in heroes){
			// iterate through all connected heroes
			// and choose minimum of their x positions
			var hero_x = heroes[net_id].body.GetWorldCenter().x;
			if(hero_x < min_x){
				min_x = hero_x;
			}
		}

		if((movement_edge < min_x - movement_edge_buffer) && min_x != Infinity){
			movement_edge = min_x - movement_edge_buffer;
		}
	};
	
	var get_movement_edge = function(){
		return movement_edge;
	}

	var get_spawn = function () {
	    difficulty = Math.floor(progress / 100);

	    var spawn_num;
	    if (spawn_enemy) {
	        for (i = 0; i < Math.floor(Math.random() * 4) ; i++) {
	            spawn_num = Math.floor(Math.random() * 1000);
	            // demonstration purposes for hyena
                if (spawn_num <= 3 * difficulty) {
	                var new_medusa = EntityController.spawn(40 + get_movement_edge() + 20 * Math.random(), 10, "Medusa");
	            }
                else if (spawn_num <= 7 * difficulty) {
	                var new_hyena = EntityController.spawn(40 + get_movement_edge() + 20 * Math.random(), 10, "Hyena");
	            }
	            /*    // demonstration purposes for griffin
	            else if (spawn_num <= 15 * EntityModel.difficulty && Count > 5) {
	                var new_griffin = spawn(60 + WorldController.get_movement_edge() + i, -20, "Griffin");
	                Count = 0;
	            }*/
	            else if (spawn_num <= 14 * difficulty) {
	                var new_centaur = EntityController.spawn(40 + get_movement_edge() + 20 * Math.random(), 10, "Centaur");
	            }
	            else if (spawn_num <= 25 * difficulty) {
	                var new_griffin = EntityController.spawn(40 + get_movement_edge() + 20 * Math.random(), 10, "Griffin");
	            }
	                // demonstration purposes for ant
	            else {
	                var new_ant = EntityController.spawn(get_movement_edge() + 40 + 20 * Math.random(), 10, "ant");
	            }
	        }
	        spawn_enemy = false;
	    }
	    return spawn_num;
	}

	var set_spawn = function () {
	    spawn_enemy = true;
	}
	
	var get_season = function(){
		return season;
	}
	
	var set_season = function(index){
		season = index;
	}
	
	var MarkAsNewTerrainSlice = function(slice){
		
	};
	
	var get_progress = function(){
		return progress;
	};
	
	var increase_progress = function(amount){
		progress += amount;
	};
	
	var get_score = function(){
		return score;
	};
	
	var increase_score = function(amount){
		if(amount != null){
			score += amount;
		}else{
			throw "Error: >amount< is not defined";
		}
	};

	return {
		// declare public
		init: init, 
		update: update,
		get_movement_edge: get_movement_edge,
		get_season: get_season,
		set_season: set_season,
		get_spawn: get_spawn,
		set_spawn: set_spawn,
		increase_score: increase_score,
		increase_progress: increase_progress,
		get_score: get_score,
		get_progress: get_progress,
	};
})();

module.exports = WorldController;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "WorldController", 
	include_options: Includes.choices.DEFAULT
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],18:[function(require,module,exports){
var GameUtility = (function()
{
  function arrow_key_scrolling(flag) {
    // Configures arrow key scrolling for canvas
    if (flag == false) {
      document.addEventListener('keydown', function (e) { // .getElementById("display_canvas")
        arrows = [37, 38, 39, 40];
        if (arrows.indexOf(e.keyCode) > -1) {
          e.preventDefault();
          return false;
        } else {
          return true
        }
      })
    }
  }

	var lg = function()
	{
		/*
		 * shortcut to console.log()
		 * prints all arguments to console
		 * first argument is used as a label for the rest
		 *
		 * each labeled group is enclosed into the colored delimiters
		 * >>> and <<< so it's easily distinguished. I found it helpful,
		 * if you don't let me know, or use something else
		 */
		console.log("%s %c %s", arguments[0], "background: #DAF2B1", ">>>");
		
		for(var i = 1; i < arguments.length; i++)
		{
			console.log("\t", arguments[i]);
		}
		console.log("%c<<<", "background: #DAF2B1");

	};

	var random_choice = function(probabilities, choices){
		/*
		   takes 2 arrays with elements at corresponding indexes
		   being choice and it's probability. picks random one.
		   choices are anything, probability is integer a, such that
		   probability of a choice is a/10. with a < 10, of course
		   and probabilities adding up to 10. 
		   Yes, it's not very good implementation (read: terrible), 
		   and since you noticed, now it's your job to improve it.

		*/

		// array with choices duplicated a proper amount of times based on
		// their probability
		var blah = []; 

		for(var i = 0; i < choices.length; i++){
			for(var j = 0; j < probabilities[i]; j++){
				blah.push(choices[i]);
			}
		}

		var rand_index = Math.floor(Math.random() * blah.length);

		return blah[rand_index];
	};

	
	var read_query_string = function(){
		/**
		* read the query string and put it into the object
		*/
	  var queries = {};
	  $.each(document.location.search.substr(1).split('&'),function(c,q){
		if(!(c == 0 && q == "")){
			var i = q.split('=');
			queries[i[0].toString()] = i[1].toString();
		}
	  });	

	  return queries;
	};
	
	

	return {
		lg: lg,
		random_choice: random_choice,
		read_query_string: read_query_string,
		
	};

})();

module.exports = GameUtility;

},{}],19:[function(require,module,exports){
var Include = function(){

	var modules;

	// simple enumerator // option codes MUST be power of 2 or sum of other options (with 0 being the only exception), and unique
	var choices = (function(){
		// simple options: numberic value must be 0 or some power of 2, name should be all caps and unique
		var result = {NONE: 0, ALL_CONTROLLERS: 1, ALL_MODELS: 2, OWN_MODEL: 4, OTHER_STUFF: 8, RENDERERS: 16, LOGIC: 32};

		// complex options: should consist of simple options, bitwise(!) OR'ed or AND'ed together in any fashion
		result.DEFAULT = (result.ALL_CONTROLLERS | result.OWN_MODEL | result.OTHER_STUFF);
		result.ALL =  (result.ALL_CONTROLLERS | result.ALL_MODELS | result.OTHER_STUFF); 
		result.RENDERER_SPECIFIC = (result.ALL_CONTROLLERS | result.OTHER_STUFF);
		result.LOGIC_SPECIFIC = (result.ALL_CONTROLLERS | result.OTHER_STUFF);

		// object is immutable
		return Object.freeze(result);
	})();

	var module_names = {
		Controllers: [
			"AssetController",
			"EntityController",
			"GameController",
			"GraphicsController",
			"InitController",
			"KeyboardController",
			"PhysicsController",
			"TerrainController",
			"TerrainSliceController",
			"TestController",
			"WorldController",
			"IdentificationController",
			"RegisterAsController",
			"NetworkController",
			"MultiplayerSyncController",
		],

		Models: [
		
			"AssetModel",
			"GameModel",
			"GraphicsModel",
			"KeyboardModel",
			"PhysicsModel",
			"TerrainModel",
			"TerrainSliceModel",
			"TestModel",
			"WorldModel",
			"EntityModel",
			"RegisterAsModel",
			"NetworkModel",
			"MultiplayerSyncModel",
		],

		Other: [
		
			"B2d",
			"Box2D",
			"Config",
			"GameUtility",
		],

		Renderers: [
			"AntRenderer",
			"HeroRenderer",
            "MedusaRenderer",
			"TerrainCellRenderer",
			"GriffinRenderer",
            "CentaurRenderer",
			"HyenaRenderer",
			"TerrainSliceRenderer",
			"BackgroundRenderer",
			"HUDRenderer",
            "PizzaRenderer",
			"EsteemedCompanionRenderer",
		],

		Logic: [
			"AntLogic",
			"HeroLogic",
			"GriffinLogic",
            "CentaurLogic",
            "MedusaLogic",
			"HyenaLogic",
			"EsteemedCompanionLogic",
            "PizzaLogic",
		],

	};//end module_names


	var init = function(){

		modules = {
			AssetController: require("./Controllers/AssetController.js"),
			GraphicsController: require("./Controllers/GraphicsController.js"),
			KeyboardController: require("./Controllers/KeyboardController.js"),
			PhysicsController: require("./Controllers/PhysicsController.js"),
			TerrainController: require("./Controllers/TerrainController.js"),
			TerrainSliceController: require("./Controllers/TerrainSliceController.js"),
			WorldController: require("./Controllers/WorldController.js"),
			InitController: require("./Controllers/InitController.js"),
			TestController: require("./Controllers/TestController.js"),
			GameController: require("./Controllers/GameController.js"),
			EntityController: require("./Controllers/EntityController.js"),
			IdentificationController: require("./Controllers/IdentificationController.js"),
			RegisterAsController: require("./Controllers/RegisterAsController.js"),
			
			NetworkController: require("./Controllers/NetworkController.js"),
			MultiplayerSyncController: require("./Controllers/MultiplayerSyncController.js"),
			
			// Models

			GameModel: require("./Models/GameModel.js"),
			TerrainSliceModel: require("./Models/TerrainSliceModel.js"),
			AssetModel: require("./Models/AssetModel.js"),
			PhysicsModel: require("./Models/PhysicsModel.js"),
			GraphicsModel: require("./Models/GraphicsModel.js"),
			TerrainModel: require("./Models/TerrainModel.js"),
			WorldModel: require("./Models/WorldModel.js"),
			KeyboardModel: require("./Models/KeyboardModel.js"),
			TestModel: require("./Models/TestModel.js"),
			IdentificationModel: require("./Models/IdentificationModel.js"),
			EntityModel: require("./Models/EntityModel.js"),
			RegisterAsModel: require("./Models/RegisterAsModel.js"),
			NetworkModel: require("./Models/NetworkModel.js"),
			MultiplayerSyncModel: require("./Models/MultiplayerSyncModel.js"),
						
			// Other stuff
			
			Config: require("./Config.js"),
			GameUtility: require("./GameUtility.js"),
			B2d: require("./B2d.js"),
			Box2D: require("box2dweb"),
			
			// Renderers
			
			AntRenderer: require("./Renderers/AntRenderer.js"),
			GriffinRenderer: require("./Renderers/GriffinRenderer.js"),
            MedusaRenderer: require("./Renderers/MedusaRenderer.js"),
            CentaurRenderer: require("./Renderers/CentaurRenderer.js"),
            HyenaRenderer: require("./Renderers/HyenaRenderer.js"),
			HeroRenderer: require("./Renderers/HeroRenderer.js"),
			TerrainCellRenderer: require("./Renderers/TerrainCellRenderer.js"),
			TerrainSliceRenderer: require("./Renderers/TerrainSliceRenderer.js"),
			BackgroundRenderer: require("./Renderers/BackgroundRenderer.js"),
			HUDRenderer: require("./Renderers/HUDRenderer.js"),
			PizzaRenderer: require("./Renderers/PizzaRenderer.js"),
			
			
			
			EsteemedCompanionRenderer: require("./Renderers/EsteemedCompanionRenderer.js"),
			
			// Logic
			AntLogic: require("./Logic/AntLogic.js"),
			GriffinLogic: require("./Logic/GriffinLogic.js"),
			MedusaLogic: require("./Logic/MedusaLogic.js"),
            CentaurLogic: require("./Logic/CentaurLogic.js"),
			HyenaLogic: require("./Logic/HyenaLogic.js"),
			HeroLogic: require("./Logic/HeroLogic.js"),
			EsteemedCompanionLogic: require("./Logic/EsteemedCompanionLogic.js"),
			PizzaLogic: require("./Logic/PizzaLogic.js"),

		};

	}; // end init

	var option_is_set = function(what_mods_selected, options){
		if(what_mods_selected == 0 && options == 0){
			return true;
		}
		// be mindful of bitwise operator ahead
		return (what_mods_selected & options);
	};//end option_is_set

	var get_module = function(name){
		// can be modified to throw object error instead of simple one
		// in that case it may contain list of defined modules
		// may also be modified to check whether module is missing from 
		// module_names, modules, or both, and give more accurate description
		var message = "Module " + name + 
			" is undefined. Note that you must hardcode all new modules" + 
			" into the Includes.module_names AND Includes.modules."
		
		if(modules){
			if(modules[name]){
				return modules[name];
			}else if(console.warn){ // check if console.warn is available
				console.warn(message);
			}else{
				throw message;
			}
		}else{
			throw "Error: You must run the Includes.init() before you can use any modules";
		}
	};//end get_module
	

	var get_names = function(current_module_name, options_code){
		var result = {Models: [], Controllers: [], Other: [], Renderers: [], Logic: [],};

		if(option_is_set(choices.NONE, options_code)){
			return result;
		}

		if (option_is_set(choices.ALL_CONTROLLERS, options_code)){

			var controller_names = module_names.Controllers;

			for(var i = 0; i < controller_names.length; i++){

				var ctl_name = controller_names[i];

				if(ctl_name != current_module_name){
					result.Controllers.push(ctl_name);
				}
			}
			
		}

		if (option_is_set(choices.ALL_MODELS, options_code)){
			result.Models = module_names.Models;
		}else if(option_is_set(choices.OWN_MODEL, options_code)){
			var own_model = current_module_name.replace("Controller", "Model");
			result.Models.push(own_model);
		}

		if(option_is_set(choices.OTHER_STUFF, options_code)){
			result.Other = module_names.Other;
		}

		if(option_is_set(choices.RENDERERS, options_code)){
			result.Renderers = module_names.Renderers;
		}

		if(option_is_set(choices.LOGIC, options_code)){
			result.Logic = module_names.Logic;
		}

		return result;
	};//end get_names

	var sections = ["Models", "Controllers", "Other", "Renderers", "Logic"];
	var get_name_statements = function(names){
		var result = "";
		for(var section_index = 0; section_index < sections.length; section_index++){
			var section = sections[section_index];
			for(var i = 0; i < names[section].length; i++){
				result += ("var " + names[section][i] + "; ");
			}
		}

		return result;
		
	};//end get_name_statements

	var get_module_statements = function(names){
		var result = "";
		for(var section_index = 0; section_index < sections.length; section_index++){
			var section = sections[section_index];
			for(var i = 0; i < names[section].length; i++){
				result += (names[section][i] + " = Includes.get_module(\"" + names[section][i] + "\"); ");
			}
		}

		return result;
	};//end get_module_statements

	var get_include_data = function(params){
		var current_module = params.current_module;
		var include_options = params.include_options;
		var names = get_names(current_module, include_options);

		var name_statements = get_name_statements(names);
		var module_statements = get_module_statements(names);

		return {
			imported_modules: names,
			name_statements: name_statements,
			module_statements: module_statements,
		};

	};//end get_include_data

	var automated_tests = function(){
		
		QUnit.test("option matching function", function( assert) {

			//If both are none
			assert.equal(option_is_set(choices.NONE, choices.NONE), true);

			assert.throws(option_is_set(choices.NONE, -1));

			//If both match, it returns the value of choices
			//If they don't match, it returns 0
			
			//MATCH
			assert.equal(option_is_set(choices.ALL_CONTROLLERS, choices.ALL_CONTROLLERS), 1);
			assert.equal(option_is_set(choices.ALL_MODELS, choices.ALL_MODELS), 2);
			assert.equal(option_is_set(choices.OTHER_STUFF, choices.OTHER_STUFF), 8);

			//Mismatch
			assert.equal(option_is_set(choices.NONE, choices.ALL_CONTROLLERS), 0);
			assert.equal(option_is_set(choices.OTHER_STUFF, choices.NONE), 0);
			assert.equal(option_is_set(choices.ALL_MODELS, choices.ALL_CONTROLLERS), 0);
			assert.equal(option_is_set(choices.OWN_MODEL, choices.ALL_MODELS), 0);
		});//end option matching test
		
	};//end automated_tests


	return {
		init: init,
		module_names: module_names,
		get_module: get_module,
		get_include_data: get_include_data,
		choices: choices,
		automated_tests: automated_tests
	};

};

module.exports = new Include;


},{"./B2d.js":1,"./Config.js":2,"./Controllers/AssetController.js":3,"./Controllers/EntityController.js":4,"./Controllers/GameController.js":5,"./Controllers/GraphicsController.js":6,"./Controllers/IdentificationController.js":7,"./Controllers/InitController.js":8,"./Controllers/KeyboardController.js":9,"./Controllers/MultiplayerSyncController.js":10,"./Controllers/NetworkController.js":11,"./Controllers/PhysicsController.js":12,"./Controllers/RegisterAsController.js":13,"./Controllers/TerrainController.js":14,"./Controllers/TerrainSliceController.js":15,"./Controllers/TestController.js":16,"./Controllers/WorldController.js":17,"./GameUtility.js":18,"./Logic/AntLogic.js":20,"./Logic/CentaurLogic.js":21,"./Logic/EsteemedCompanionLogic.js":22,"./Logic/GriffinLogic.js":23,"./Logic/HeroLogic.js":24,"./Logic/HyenaLogic.js":25,"./Logic/MedusaLogic.js":26,"./Logic/PizzaLogic.js":27,"./Models/AssetModel.js":28,"./Models/EntityModel.js":29,"./Models/GameModel.js":30,"./Models/GraphicsModel.js":31,"./Models/IdentificationModel.js":32,"./Models/KeyboardModel.js":33,"./Models/MultiplayerSyncModel.js":34,"./Models/NetworkModel.js":35,"./Models/PhysicsModel.js":36,"./Models/RegisterAsModel.js":37,"./Models/TerrainModel.js":38,"./Models/TerrainSliceModel.js":39,"./Models/TestModel.js":40,"./Models/WorldModel.js":41,"./Renderers/AntRenderer.js":42,"./Renderers/BackgroundRenderer.js":43,"./Renderers/CentaurRenderer.js":44,"./Renderers/EsteemedCompanionRenderer.js":45,"./Renderers/GriffinRenderer.js":46,"./Renderers/HUDRenderer.js":47,"./Renderers/HeroRenderer.js":48,"./Renderers/HyenaRenderer.js":49,"./Renderers/MedusaRenderer.js":50,"./Renderers/PizzaRenderer.js":51,"./Renderers/TerrainCellRenderer.js":52,"./Renderers/TerrainSliceRenderer.js":53,"box2dweb":55}],20:[function(require,module,exports){
var AntLogic = (function(){

	var Ant = function(){
		/* Will be instantiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like this:
			this.some_state_variable_initial_value = 0;
			instantiate (most likely in the spawn function) like that:
			var new_entity_instance = new Ant();
		*/
		var entity = EntityController.create_abstract_entity();
		
		entity.hero_hurt_me = false;
		entity.me_hurt_hero = false;
		entity.death_tick = 0;

		entity.hp = 3;
		entity.speed = 3;
		entity.damage = 1;
		entity.point_value = 50;

		entity.AI_state = "walk";//use entity to keep track of the enemy's AI state
		
		entity.can_attack = true;
		entity.aliveflag = true;
		entity.unhurtflag = true;
		entity.needs_graphics_update = false;

		entity.direction = false;
		entity.pop = 40;
		entity.popup = 0;
		
		entity.can_leap = true;		//leaping enabled

		entity.maintenance_frequency = 20;//ticks between routine maintenance checks
		entity.maintenance_timer = entity.maintenance_frequency;
		entity.blinking = false;
		entity.barely_obstructed = false;
		entity.collision_buffer = 0.2	//the region of overlap accounted for during collision checking
		entity.path_blocked = false;	//is entity deprecated? set during collision
		entity.obstruction_tolerance = 2;//how many times the hyena can be blocked before he takes action
		entity.blocked_count = 0;			//tracks number of times blocked between maintenance checks


		return entity;
	};

	var init = function(){
		/* Is run from the EntityController.init once during game loading 
		 	you should assign type to your model here using the identification controller
		 */
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Ant, "ant");
	};

	var spawn = function(x, y){
		/* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you want to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/

		var new_ant = new Ant();
		new_ant.type = "ant";
		var id = IdentificationController.assign_id(new_ant);

		new_ant.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, new_ant);	

		return new_ant;

	};

    //Begin Ant AI --------------------------------------------------------------------------------
	var tick_AI = function(ant){
	    /* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/

	    //if enemy is dead, die
	    //if (ant.body.GetWorldCenter().y > 22 || ant.body.GetWorldCenter().x < Config.Player.movement_edge - 1) {
	    //EntityController.delete_entity();
	    //console.log("drop of death");
	    //}
	    //
	    if (ant.hp <= 0) { //If Ant is Dead, Die
	        ant.die();
				if (ant.blinking) {
				    ant.blink_timer--;
				    if (ant.blink_timer == 0) {
				        ant.blinking = false;
				    }
				}
	    } else { // hp > 1

	        ant.change_animation("walk");

	        //Maintenance....
	        ant.direction_previous = ant.direction;				//remember direction at start of tick
	        ant.x_previous = ant.body.GetWorldCenter().x; //remember x at start of tick
			
	        //do maintenance
	        //ant.direction_previous = ant.direction;
	        //ant.x_previous = ant.body.GetWorldCenter().x
	        //if blocked, turn around
	        //if ((!ant.path_free() || ant.xprevious == ant.body.GetWorldCenter().x) && !ant.in_air()) {
	        //    ant.direction = !ant.direction;
	        //}
			
	        if (ant.animation == "walk") { //Move forward
	            ant.move(ant.speed);
	        }

	        //Run Main AI Script.....
	        if (!ant.in_air() || ant.body.GetLinearVelocity().y == 0) { //if on ground OR if we suspect he's stuck on a corner
	            if (ant.enemy_in_range(ant.sight_range)) { //if enemy nearby

	                if (ant.hit_taken) {
	                    ant.change_animation("upside_down");
	                    ant.take_damage();
						ant.blinking = true;
						
	                }
	                else if ((ant.path_blocked) && ant.can_leap && ant.leap_cooldown_timer <= 0) { //if  path is blocked, and leaping is enabled, leap
	                    ant.direction = ant.direction_nearest_enemy();
	                    leap(ant);
	                    ant.can_leap = false;
	                    ant.leap_cooldown_timer = ant.leap_cooldown;
	                } else {
	                    if (!ant.in_air()) { //if hyena isn't cowering or in the air, face the enemy
	                        ant.direction = ant.direction_nearest_enemy();
	                    }

	                }

	            }



	            //check periodically to ensure the ant is not stuck and other routine maintenance
                
	            ant.maintenance_timer--;
	            if (ant.maintenance_timer == 0) {
	                ant.jump(0, -2);
	                if (ant.path_free()) {
	                    ant.path_blocked = false;
	                }
	                if (ant.blocked_count > ant.obstruction_tolerance) {	//you know he's stuck now
	                    if (ant.can_leap) {
	                        ant.path_blocked = true;
	                        leap(ant);	//attempt to get out of jam or stuck
	                        ant.path_blocked = false;
	                    }
	                }
	                ant.blocked_count = 0;
	                ant.maintenance_timer = ant.maintenance_frequency; //reset check timer
	            }

	            //if (ant.hp == 1) {
	            //    ant.popup++;
	            //    if (ant.popup == ant.pop) {
	            //        ant.jump(10, -20);
	            //        ant.hp++;
	            //        ant.popup = 0;
	            //        ant.can_attack = true;
	            //        ant.unhurtflag = true;
	            //        ant.change_animation("walk");
	            //    }
	            //}
	        }
	    }
	};

    //End Ant AI ---------------------------------------------------------


    //Helper Functions -------------------------------------------------
	var leap = function (ant) {
	    if (ant.path_blocked) {//jump out of a hole or over a wall
	        ant.jump(-10 + (20 * ant.direction), -1 * ant.jump_force);
	    } else { //leap viciously at hero
	        ant.jump((2 * ant.jump_force * ant.direction) - ant.jump_force, -1 * ant.jump_force / 2);
	    }
	    ant.can_leap = false;
	};



	//Collision Handlers ----------------------------------------------
	var begin_contact = function (contact, info) {
	    //handle collisions here
	    if ((info.Me.fixture_name == "right" || info.Me.fixture_name == "left") && info.Them.type != "pizza") {
	        info.Me.entity.direction = !info.Me.entity.direction;
	        console.log('hit');
	        if (info.Them.entity.point_value > 0) {
	            info.Me.entity.direction = Math.round(Math.random());
	            info.Them.entity.direction = Math.round(Math.random());
	        }
	    }

	    if (info.Them.type == "hero") {
	        if (info.Them.fixture_name != "bottom" && info.Me.entity.can_attack) {
	            info.Me.entity.me_hurt_hero = true;
	        } else {
	            info.Me.entity.hit_taken = true;//take damage if enemy collides from above and distance < vulnerability radius
	            info.Me.entity.damage_taken = info.Them.entity.damage;
	        }
	    }
	};

	var end_contact = function(contact, info) {
	
	};

	
	return {
		// declare public
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = AntLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "AntLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],21:[function(require,module,exports){
var CentaurLogic = (function(){
   
	var Centaur = function(){
		/* Will be instantiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like entity:
			entity.some_state_variable_initial_value = 0;
			instantiate (most likely in the spawn function) like that:
			var new_entity_instance = new Centaur();
		*/
		var entity = EntityController.create_abstract_entity();
		
		entity.hero_hurt_me = false;
		entity.me_hurt_hero = false;
		entity.death_tick = 0;

		//set your game logic parameters here
		//entity.object_id = 1; //hardcode a unique identifier for each new enemy class
		entity.hp = 4;
		entity.speed = 4;
		entity.damage = 12;
		entity.point_value = 100;
		//entity.attack_cooldown = 4; //use entity for enemies who need
		entity.can_attack = true;//use entity for enemies who alternate between 
		//entity.cooldown_timer=-1;
		entity.AI_state = "walk";//use entity to keep track of the enemy's AI state

		entity.can_attack = true;
		entity.aliveflag = true;
		entity.unhurtflag = true;
		entity.needs_graphics_update = false;

		entity.maintenance_frequency = 20;//ticks between routine maintenance checks
		entity.maintenance_timer = entity.maintenance_frequency;

		entity.direction = false;
		entity.jolt_force = 100;

		entity.blinking = false;
		entity.blink_timer = -1;
		entity.blink_duration = 20;//how long the entity blinks after taking damage
		
		return entity;
	};

	var init = function(){
		/* Is ran from the EntityController.init once during game loading 
		 	you should assign type to your model here using the identification controller
		 */
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Centaur, "Centaur");
	};

	var spawn = function(x, y){
		/* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you want to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/

		var new_Centaur = new Centaur();
		new_Centaur.type = "Centaur";
		var id = IdentificationController.assign_id(new_Centaur);

		new_Centaur.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, new_Centaur);	

		return new_Centaur;

	};

	var tick_AI = function(Centaur){
		/* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/

		//if dead, die
		if (Centaur.hp <= 0) {
			Centaur.die();
		}else{ // Centaur.hp >= 1
				Centaur.change_animation("walk");
			
				if (Centaur.blinking) {
				    Centaur.blink_timer--;
				    if (Centaur.blink_timer == 0) {
				        Centaur.blinking = false;
				    }
				}

			if (Centaur.animation == "walk"){
				Centaur.move(Centaur.speed);
			}
			if (Centaur.animation == "jolt"){
			    Centaur.jump((2 * Centaur.jolt_force * Centaur.direction) - Centaur.jolt_force, Centaur.jolt_force/2);
			}
			if (Centaur.hit_taken){
				Centaur.take_damage();
			}

			Centaur.maintenance_timer--;
			if (Centaur.maintenance_timer == 0) {
			    Centaur.jump(0, -2);
			    Centaur.maintenance_timer = Centaur.maintenance_frequency; //reset check timer
			}
		}
	};

	// // //Set up Collision handler
	
	
	var begin_contact = function(contact, info){
	    //handle collisions here

	    if ((info.Me.fixture_name == "right" || info.Me.fixture_name == "left") && info.Them.type != "pizza") {
	        info.Me.entity.direction = !info.Me.entity.direction;
	        console.log('hit');
	        if (info.Them.entity.point_value > 0) {
	            info.Me.entity.direction = Math.round(Math.random());
	            info.Them.entity.direction = Math.round(Math.random());
	        }
	    }
		
		if(info.Them.type == "hero"){
			if(info.Them.fixture_name != "bottom" && info.Me.entity.can_attack){
				info.Me.entity.me_hurt_hero = true;
			}else{
				info.Me.entity.hit_taken = true;//take damage if enemy collides from above and distance < vulnerability radius
				info.Me.entity.damage_taken = info.Them.entity.damage;
			}
		}
	};

	var end_contact = function(contact, info){
	
	};

	
	return {
		// declare public
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = CentaurLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "CentaurLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}
},{"../Includes.js":19}],22:[function(require,module,exports){
var EsteemedCompanionLogic = (function(){

		
	var Companion = function(){
		/* Will be instantiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like this:
			this.some_state_variable_initial_value = 0;
			instantiate (most likely in the spawn function) like that:
			var new_entity_instance = new EsteemedCompanion();
		*/
		this.hp = 100;
		this.wound = false;
		this.jumps = 0;
		this.score = 0;
	};

	var init = function(){
		/* Is ran from the EntityController.init once during game loading 
			you should assign type to your model here using the identification controller
		*/
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Companion, "companion");
	};

	var spawn = function(x, y){
		/* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you want to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/

		var companion = new Companion();

		companion.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, companion);

		//var id = IdentificationController.assign_id(companion);

		companion.hp = 100;
		companion.wound = false;
		companion.jumps = 0;
		companion.score = 0;


		return companion;
	
	};

	var tick_AI = function(companion){
		/* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/

		
		console.warn("ticking companion");

		

		var cmds = KeyboardController.movement_commands();

		var MOVEMENT_EDGE = 500; // where terrain start scrolling


		// TEMPORARYYYYYYYYYYYYYYYY

		if(companion.wound)
		{
			companion.hp--;
			console.log("Taking damage");
			GraphicsController.update_health(companion.hp);
		}
		
		if(companion.hp <= 0)
		{
			createjs.Ticker.paused = true;
			console.log("Player Is Dead");
		}
		GraphicsController.update_score(companion.score);
	};

	var begin_contact = function(contact, info){
		//console.log(info.Me.id, ":", "My fixture", "'" + info.Me.fixture_name + "'", "came into contact with fixture", 
			//"'" + info.Them.fixture_name + "'", "of", info.Them.id);
		if (info.Me.fixture_name == "bottom"){
			info.Me.entity.jumps = 0;
		}
		if (info.Me.fixture_name == "top"){
			take_hit(info.Me.entity, 1);
		}
		
		if(info.Me.fixture_name != "bottom" && info.Them.entity.can_attack)
		{
		    info.Me.entity.wound = true;
		    add_score(info.Me.entity, 100);
		}
				
	};
	
	var add_score = function (companion, amount) {
	    companion.score += amount;
	}
	

	var take_hit = function(companion, amount){
	    companion.hp -= amount;
		//GraphicsController.update_health(companion.hp);
	}

	var end_contact = function(contact, info){
			
		info.Me.entity.wound = false;
	};

	var move_right = function(companion){
		var body = companion.body;
		var velocity = body.GetLinearVelocity();
		velocity.x = 5;
		body.SetLinearVelocity(velocity); // body.SetLinearVelocity(new b2Vec2(5, 0)); would work too
		body.SetAwake(true);
		//companion.x += 10; // old
		//companion.x = (body.GetPosition().x + 1.5/2) * 30 ; 
	};

	var jump = function(companion){
	    var body = companion.body;
		if (companion.jumps == 0){
		    body.ApplyImpulse(new B2d.b2Vec2(0, -100), body.GetWorldCenter());
		    companion.jumps += 1;
		}
		else if (companion.jumps == 1 && body.GetLinearVelocity().y > -1) {
		    body.ApplyImpulse(new B2d.b2Vec2(0, -100), body.GetWorldCenter());
		    companion.jumps += 1;
		}

		//companion.y = body.GetPosition().y * 30;
	
	};

	var set_coordinates = function(position_vector, companion){
		// TODO: remove;
		// temporary/testing
		companion.x = (position_vector.x - 1.5/2) * 30 ;
		companion.y = (position_vector.y + 2.5/2) * 30 ;

	};

	var b2b_get_coordinates = function(companion){
		return companion.body.GetWorldCenter();
	};

	var move_left = function(companion){
		var velocity = companion.body.GetLinearVelocity();
		velocity.x = -5;
		companion.body.SetLinearVelocity(velocity); // companion.SetLinearVelocity(new b2Vec2(5, 0)); would work too
		companion.body.SetAwake(true);
	};

	var move_right = function(companion){
		var velocity = companion.body.GetLinearVelocity();
		velocity.x = +5;
		companion.body.SetLinearVelocity(velocity); // companion.SetLinearVelocity(new b2Vec2(5, 0)); would work too
		companion.body.SetAwake(true);
	};

	var move = function(offset_x, offset_y, companion){
		// unimplemented
		// should it hard-set position (not safe!)
		// or just allow to set any velocity/impulse vector?
	};

	return {
		// declare public
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = EsteemedCompanionLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "EsteemedCompanionLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],23:[function(require,module,exports){
var GriffinLogic = (function(){
   
	var Griffin = function(){
		/* Will be instantiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like entity:
			entity.some_state_variable_initial_value = 0;
			instantiate (most likely in the spawn function) like that:
			var new_entity_instance = new Griffin();
		*/
		var entity = EntityController.create_abstract_entity();
		
		entity.hero_hurt_me = false;
		entity.me_hurt_hero = false;
		entity.death_tick = 0;

		//set your game logic parameters here
		//entity.object_id = 1; //hardcode a unique identifier for each new enemy class
		entity.hp = 3;
		entity.speed = 6;
		entity.damage = 10;
		entity.point_value = 100;
		//entity.attack_cooldown = 4; //use entity for enemies who need
		entity.can_attack = true;//use entity for enemies who alternate between 
		//entity.cooldown_timer=-1;
		entity.AI_state = "fly";//use entity to keep track of the enemy's AI state
		entity.aliveflag = true;
		entity.unhurtflag = true;
		entity.needs_graphics_update = false;

		entity.maintenance_frequency = 20;//ticks between routine maintenance checks
		entity.maintenance_timer = entity.maintenance_frequency;

		entity.direction = false;
		entity.fly_force = 100;
		entity.blinking = false;
		entity.blink_timer = -1;
		entity.blink_duration = 20;//how long the entity blinks after taking damage
		return entity;
	};

	var init = function(){
		/* Is ran from the EntityController.init once during game loading 
		 	you should assign type to your model here using the identification controller
		 */
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Griffin, "Griffin");
	};

	var spawn = function(x, y){
		/* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you want to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/

		var new_Griffin = new Griffin();
		new_Griffin.type = "Griffin";
		var id = IdentificationController.assign_id(new_Griffin);

		new_Griffin.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, new_Griffin);	

		return new_Griffin;

	};

	var tick_AI = function(Griffin){
		/* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/

		//if dead, die
		if (Griffin.hp <= 0) {
			Griffin.die();
		}else{ // Griffin.hp >= 1

		    if (Griffin.blinking) {
		        Griffin.blink_timer--;
		        if (Griffin.blink_timer == 0) {
		            Griffin.blinking = false;
		        }
		    }

		    if (Griffin.in_air()) {
				Griffin.change_animation("fly");
			}else{
				Griffin.change_animation("walk");
			}
			if (Griffin.animation == "walk"){
				Griffin.move(Griffin.speed);
			}
			if (Griffin.animation == "fly"){
			    Griffin.jump((2 * Griffin.fly_force * Griffin.direction) - Griffin.fly_force, Griffin.fly_force/2);
			}
			if (Griffin.hit_taken){
			        Griffin.take_damage(); //if hit, take damage
			}

			Griffin.maintenance_timer--;
			if (Griffin.maintenance_timer == 0) {
			    Griffin.jump(0, -2);
			    Griffin.maintenance_timer = Griffin.maintenance_frequency; //reset check timer
			}
		}
	};

	// // //Set up Collision handler
	
	
	var begin_contact = function(contact, info){
		//handle collisions here
		
	    if ((info.Me.fixture_name == "right" || info.Me.fixture_name == "left") && info.Them.type != "pizza") {
	        info.Me.entity.direction = !info.Me.entity.direction;
	        console.log('hit');
	        if (info.Them.entity.point_value > 0) {
	            info.Me.entity.direction = Math.round(Math.random());
	            info.Them.entity.direction = Math.round(Math.random());
	        }
	    }

		if(info.Them.type == "hero"){
			if(info.Them.fixture_name != "bottom" && info.Me.entity.can_attack){
				info.Me.entity.me_hurt_hero = true;
			}else{
				info.Me.entity.hit_taken = true;//take damage if enemy collides from above and distance < vulnerability radius
				info.Me.entity.damage_taken = info.Them.entity.damage;
			}
		}
	};

	var end_contact = function(contact, info){
	
	};

	
	return {
		// declare public
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = GriffinLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "GriffinLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],24:[function(require,module,exports){
var HeroLogic = (function(){

	var Hero = function(){
		/* Will be instantiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like this:
			this.some_state_variable_initial_value = 0;
			instantiate (most likely in the spawn function) like that:
			var new_entity_instance = new Hero();
		*/
		entity = new EntityController.create_abstract_entity();
		
		entity.hp = 100;
		entity.speed = 8;
		entity.hit_taken = false;
		entity.damage_taken = 0;
		entity.damage = 1;
		entity.is_walking = false;
		entity.point_value = 0;
		
		entity.jumps = 0;
		entity.decay_duration = 35;//time between decay animation and deletion
		entity.death_duration = 60;//time between death and deletion
		entity.jump_tick=0;

		entity.direction = 1; //default direction = left
		
		entity.needs_graphics_update = false; //accessed by renderer for animation purposes
		entity.animation = "stand"; //accessed by renderer for animation purposes
		
		return entity;
	};

	var init = function(){
		/* Is ran from the EntityController.init once during game loading 
			you should assign type to your model here using the identification controller
		*/
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Hero, "hero");
	};

	var spawn = function(x, y){
		/* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you want to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/


		var hero = new Hero();
		hero.type = "hero";
		hero.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, hero);

		hero.hp = 100;
		hero.wound = false;
		hero.jumps = 0;
		hero.score = 0;

		return hero;
	
	};

	var tick_AI = function(hero){
		/* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/
		if(hero.player_id == NetworkController.get_network_id()){
			var cmds = KeyboardController.movement_commands();
		}else{
			var cmds = KeyboardController.get_remote_movement(hero.player_id);
		}

		hero.direction_previous = hero.direction;
		hero.x_previous = hero.body.GetWorldCenter().x;
		hero.y_previous = hero.body.GetWorldCenter().y;
       
		if(hero.hp <= 0){
			hero.die();
		}else{
			hero.is_walking = false;	
			
			if(cmds("right")){
				 if(hero.jumps==0){
					hero.change_animation("walk");
					hero.is_walking = true;
				}
				hero.direction = true;//direction = right
				hero.move(hero.speed);
			}
			
			if(cmds("left")){
				if(hero.jumps==0){
					hero.change_animation("walk");
					hero.is_walking = true;
				}
				hero.direction = false;//direction = left
				hero.move(hero.speed);
			}
			
			if(cmds("down")){
				slam(hero);
				stop_hero(hero);
			}
			
			if(cmds("up")){
				jump(hero);
			}
			
			if(!hero.is_walking && hero.animation != "jump" && hero.body.GetLinearVelocity().y == 0){
				hero.change_animation("stand");
				hero.jump_tick = 0;
			}
			
			if(hero.animation=="jump"){
				if(hero.jump_tick == 1){
					hero.change_animation("jump");
				}
				hero.jump_tick++;
				if(hero.jump_tick >= 20){
					hero.change_animation("finish");
					if(hero.jumps == 0){
						hero.animation = "finish";
					}
				}
			}
		
			if(hero.hit_taken){
			    hero.take_damage();
			    //console.log("hold on");
			}
		
			if (hero.body.GetWorldCenter().x < WorldController.get_movement_edge() + hero.body.GetUserData().def.width/2){
				stop_hero(hero);
			}
		}
	};


	var begin_contact = function(contact, info){
		var hero = info.Me.entity;
		var other = info.Them.entity;
		if (other.type == "pizza") {
		    if (hero.hp <= 100+other.regen) {
		        hero.damage_taken = other.regen;
		        hero.hit_taken = true;
		    }
		    else if (hero.hp != 100) {
		        hero.damage_taken = hero.hp - 100;
		        hero.hit_taken = true;
		    }
		}
		if (info.Me.fixture_name == "bottom"){
			if(info.Them.fixture_name == "top" || other.kind == 1 || other.kind == 2){
				hero.jumps = 0;//if colliding with surface, reset jumps
			}
			if(other.kind == 3){
				if (hero.hp > 0){
					hero.hit_taken = true;
					hero.damage_taken = other.damage;
				}
			}
		}
		if(info.Me.fixture_name != "bottom" && other.can_attack){
			if(other.kind == null){
				var my_extents = hero.get_fixture(hero,"main").GetAABB().GetExtents();
				var my_coordinates = hero.body.GetWorldCenter();
				var other_extents = hero.get_fixture(other,"main").GetAABB().GetExtents();
				var other_coordinates = other.body.GetWorldCenter();
				//prevents taking damage while on top of enemies
				if (!(my_coordinates.y <= other_coordinates.y - (my_extents.y + other_extents.y - 0.5))) {
					if (hero.hp > 0) {
						hero.hit_taken = true;
						hero.damage_taken = other.damage;
					}
				}
			}else{//if they're spikes, take damage no matter what
				hero.hit_taken = true;
				hero.damage_taken = other.damage;
			}
		}
	};

	var end_contact = function(contact, info){
			
		//info.Me.entity.hit_taken = false;
	};

	var stop_hero = function (hero) {
		//var body = hero.body;
		//var velocity = body.GetLinearVelocity();
		//velocity.x = 0;
		//body.SetLinearVelocity(velocity); // body.SetLinearVelocity(new b2Vec2(5, 0)); would work too
		//body.SetAwake(true);

		var body = hero.body;
		var w = hero.body.GetUserData().def.width/2;
		var pos = new B2d.b2Vec2(WorldController.get_movement_edge() + w, body.GetWorldCenter().y)
		var vel = body.GetLinearVelocity();
		if(vel.x < 0 || body.GetWorldCenter().x > pos.x){
			var vel = new B2d.b2Vec2(0, vel.y);
			body.SetLinearVelocity(vel);
		}

	    body.SetAwake(true);
	}

	var slam = function(hero){
	    var body = hero.body;
	    body.ApplyImpulse(new B2d.b2Vec2(0, 20), body.GetWorldCenter());
	};
	var move_left = function(hero){
		var body = hero.body;
		var velocity = body.GetLinearVelocity();
		velocity.x = -5;
		body.SetLinearVelocity(velocity); // body.SetLinearVelocity(new b2Vec2(5, 0)); would work too
		body.SetAwake(true);
		//hero.x += 10; // old
		//hero.x = (body.GetPosition().x + 1.5/2) * 30 ; 
	};

	var jump = function(hero){
	    var body = hero.body;
	    var w = hero.body.GetUserData().def.width / 2;
	    var pos = new B2d.b2Vec2(WorldController.get_movement_edge() + w, body.GetWorldCenter().y)
	    var vel = body.GetLinearVelocity();
		//console.log(hero.jumps);
		if (hero.jumps == 0){
			hero.change_animation("jump");
			var vel = new B2d.b2Vec2(vel.x, -18);
			body.SetLinearVelocity(vel);
			hero.body.SetAwake(true);
		    hero.jumps += 1;
		}
		else if (hero.jumps == 1 && body.GetLinearVelocity().y > -1){
			hero.change_animation("jump");
			var min_check = vel.y - 18;
			if (min_check > -9){
				min_check = -9;
			}
			var vel = new B2d.b2Vec2(vel.x, min_check);
			body.SetLinearVelocity(vel);
			hero.body.SetAwake(true);
			hero.jumps += 1;
		}
	};

	
	var b2b_get_coordinates = function(hero){
		return hero.body.GetWorldCenter();
	};

	//var move_left = function(hero){
		//var velocity = hero.body.GetLinearVelocity();
		//move(hero, velocity.x - 5, velocity.y)

	//};

	//var move_right = function(hero){
		//var velocity = hero.body.GetLinearVelocity();
		//move(hero, velocity.x + 5, velocity.y)
	//};

	//var move = function(hero, x, y){
		//var velocity = new B2d.b2Vec2(x, y);
		//hero.body.SetLinearVelocity(velocity); // hero.SetLinearVelocity(new b2Vec2(5, 0)); would work too
		//hero.body.SetAwake(true);
	//};

	return {
		// declare public
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = HeroLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "HeroLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],25:[function(require,module,exports){
/* 
	Enemy: Hyena 
	class and functions for the Hyena type enemy
	public functions:
		-init()
			initializes default class data for all instances of class Hyena
		-spawn(int x, int y)
			returns a new instance of class Hyena with unique instance ID at global coordinates(x,y)
		-tick_AI()
			runs hyena AI script, to be called for each instance on game tick
		-begin_contact()
			handles collisions, called on collision with any object
		-end_contact()
			callback function for box2d
*/

var HyenaLogic = (function(){
	//Instantiated for each instance of hyena at creation
	//call constructor through wrapper function spawn()
	var Hyena = function(){

		var entity = EntityController.create_abstract_entity();

		//Declare initial variables for the Hyena
	
		entity.hp = 2;
		entity.speed = 7;
		entity.jump_force = 125;
		entity.damage = 5;
		entity.point_value = 200;
		entity.sight_range = 16; //distance at which hyena detects heroes
		entity.attack_range = 8; //distance at which hyena leaps at the hero
		
		entity.hit_taken = false; //whether a hit has been taken since the last tick
		entity.damage_taken = 0; //the amount of damage inflicted by hits since the last tick
		
		entity.direction = false;	//false=left, true=right;
		entity.direction_previous = false;//store direction from end of previous tick
		entity.x_previous = 0;		//store x value from end of previous tick
		
		entity.is_idle = true; //determines whether hyena is aggressive or idle
		entity.idle_duration = 40; // time buffer between changing idle states
		entity.idle_timer = entity.idle_duration;
		entity.idle_counter = 0; //used to manage the number of times the hyena has changed state while idle
		entity.is_alive = true; //disables attacking and plays death animation while false
		entity.death_duration = 30;//time between death and deletion
		entity.decay_duration = 20;//time between decay animation and deletion
		entity.death_timer = -1;
		entity.running_away = false; //whether the hyena is running away
		entity.run_away_duration = 30; //set cowardice level
		entity.run_away_timer = -1;
		entity.can_attack = true;	//whether attacking is enabled
		entity.attack_cooldown = 10; //attack cooldown
		entity.attack_cooldown_timer = -1;
		entity.can_leap = true;		//leaping enabled
		entity.leap_cooldown = 40;//minimum time between leaps
		entity.leap_cooldown_timer = -1; 
		entity.charge_duration = 80;//maximum length of a charge
		entity.charge_timer = entity.charge_duration;
		entity.charge_cooldown = 20;//minimum time between charges
		entity.charge_cooldown_timer = -1;
		entity.blinking = false;	//whether hyena is blinking
		entity.blink_duration = 20;//how long the hyena blinks after taking damage
		entity.blink_timer = -1;
		entity.maintenance_frequency = 20;//ticks between routine maintenance checks
		entity.maintenance_timer = entity.maintenance_frequency;
		
		entity.barely_obstructed = false;
		entity.collision_buffer = 0.2	//the region of overlap accounted for during collision checking
		entity.path_blocked = false;	//is entity deprecated? set during collision
		entity.obstruction_tolerance = 4;//how many times the hyena can be blocked before he takes action
		entity.blocked_count = 0;			//tracks number of times blocked between maintenance checks
		
		entity.needs_graphics_update = false; //accessed by renderer for animation purposes
		entity.animation = "stand"; //accessed by renderer for animation purposes
		
		return entity;
	};

	//Initialize class variables, called once in EntityController.init() during game load
	var init = function(){
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Hyena, "Hyena"); //assign class id
	};

	//Instantiates class Hyena
	//Wrapper for constructor, assigns unique ID
	var spawn = function(x, y){
		var new_hyena = new Hyena();
		new_hyena.type = "Hyena";
		var id = IdentificationController.assign_id(new_hyena);

		new_hyena.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, new_hyena);	
		new_hyena.PhysicsController = PhysicsController;
		
		return new_hyena;
	};
	
//........................COMMENCE.........................\\
//.......................ARTIFICIAL........................\\
//.........................HYENA...........................\\
//......................INTELLIGENCE.......................\\
	
	// Is run each tick from the EntityController.update for every registered instance
	var tick_AI = function(Hyena){
		//Check if Dead........
		//If Hyena is close to the movement edge, leap away
		if (Hyena.body.GetWorldCenter().x <= WorldController.get_movement_edge() + 1.125){
			Hyena.jump(Hyena.jump_force, 0);
		}
		if (Hyena.hp <= 0){//if mortally wounded
			Hyena.die(); //die
		}else{ // Do Live Hyena Stuff
			//Maintenance....
			Hyena.direction_previous = Hyena.direction;				//remember what hyena's direction was at start of tick
			Hyena.x_previous = Hyena.body.GetWorldCenter().x; //remember what hyena's x was at start of tick
			Hyena.leap_cooldown_timer--;			//ensure the hyena is not eternally jumping
			//maintain blinking
			if(Hyena.blinking){
				Hyena.blink_timer--;
				if(Hyena.blink_timer == 0){
					Hyena.blinking = false;
				}
			}
			//maintain attack cooldown
			if(Hyena.attack_cooldown_timer > 0){ 
				Hyena.attack_cooldown_timer--;
				Hyena.can_attack = (Hyena.attack_cooldown_timer == 0);
			}
			//maintain the hyena's alternating phases of running and stopping
			if(Hyena.charge_timer <= 0){
				Hyena.charge_cooldown_timer--;
				if (Hyena.charge_cooldown_timer <= 0){
					Hyena.charge_timer = Hyena.charge_duration;
				}
			}
			//maintain the hyena's cowardly tactics
			if (Hyena.running_away){	//if hyena is deliberately running away
				Hyena.run_away_timer--;	//tickdown run_away timer
				if (Hyena.run_away_timer == 0){ //maybe stop running away
					Hyena.run_away_timer = -1;
					Hyena.direction = Hyena.direction_nearest_enemy();
					Hyena.running_away = false;
				}
			}
			//check periodically to ensure the hyena is not stuck in a corner and other routine maintenance
			Hyena.maintenance_timer--;
			if (Hyena.maintenance_timer == 0){
				if (Hyena.path_free()){
					Hyena.path_blocked = false;
				}
				if (Hyena.blocked_count > Hyena.obstruction_tolerance){	//you know he's stuck now
					if (Hyena.can_leap){
						Hyena.path_blocked = true;
						leap(Hyena);	//time to jump for it
						Hyena.path_blocked = false;
					}
				}
				Hyena.blocked_count = 0;
				Hyena.maintenance_timer = Hyena.maintenance_frequency; //reset check timer
			}
			//Run Main AI Script.....
			if(!Hyena.in_air() || Hyena.body.GetLinearVelocity().y == 0){ //if on ground OR if we suspect he's stuck on a corner
				if (Hyena.enemy_in_range(Hyena.sight_range)){ //if enemy nearby
					Hyena.idle = false;
					if (Hyena.hit_taken){	//if hyena was attacked,
						Hyena.running_away = true;	//back off
						Hyena.run_away_timer = Hyena.run_away_duration;
						Hyena.direction = !(Hyena.direction);
					}else if ((Hyena.enemy_in_range(Hyena.attack_range) || Hyena.path_blocked) && Hyena.can_leap && Hyena.leap_cooldown_timer <= 0){ //if enemy in range or path is blocked, and leaping is enabled, leap
						Hyena.direction = Hyena.direction_nearest_enemy();
						leap(Hyena);
						Hyena.can_leap = false;
						Hyena.leap_cooldown_timer = Hyena.leap_cooldown;
						Hyena.change_animation("leap");
					}else{
						if(!Hyena.running_away && !Hyena.in_air()){ //if hyena isn't cowering or in the air, face the enemy
							Hyena.direction = Hyena.direction_nearest_enemy();
						}
						if (Hyena.charge_timer > 0){ //if charge duration > 0
							run(Hyena);
							Hyena.change_animation("run"); //charge the enemy
							Hyena.charge_timer--;
							if(Hyena.charge_timer == 0){
								Hyena.charge_cooldown_timer = Hyena.charge_cooldown;
							}
							if(Hyena.x_previous == Hyena.body.GetWorldCenter().x){ //check if hyena has moved successfully
								Hyena.blocked_count++;
							}
						}else{//else stand aggressively
							Hyena.change_animation("stand");
						}
					}
				}else{
					Hyena.idle = true; //idle mode
					Hyena.idle_timer--;
					if (Hyena.idle_timer == 0){
						Hyena.idle_timer = Hyena.idle_duration;
						Hyena.idle_counter = (Hyena.idle_counter+1)%27;
						if (Hyena.idle_counter%4 == 0 && Hyena.idle_counter%5 != 0){
							Hyena.direction = !(Hyena.direction);//use weird modulos to get random looking idle behavior
						}
					}
					if (Hyena.idle_counter%2 == 0 || Hyena.idle_counter%3 == 0){ //use weird modulos to get random looking idle behavior
						walk(Hyena);
						Hyena.change_animation("walk");//pace
						if(Hyena.x_previous == Hyena.body.GetWorldCenter().x){ //check if hyena has wandered successfully
							Hyena.blocked_count++; //else check for being stuck
						}
					}else{
						Hyena.change_animation("stand");//loiter
					}
				}
			}else{//if in the air
				if(Hyena.movement_voluntary()){
					Hyena.change_animation("leap");//if voluntary, leap
				}else{
					Hyena.change_animation("fall");//else, fall
				}
			}
			if (Hyena.hit_taken){
				Hyena.take_damage(); //if hit, take damage
			}
		}
	};
//...........................END............................\\
//........................ARTIFICIAL........................\\
//.......................INTELLIGENCE.......................\\


//.....................HELPER FUNCTIONS......................
	
	
	//run
	var run = function(hyena){
		hyena.move(hyena.speed);
	};
	
	//walk
	var walk = function(hyena){
		hyena.move(hyena.speed/3);
	};
	
	//leap
	var leap = function(hyena){
		if (hyena.path_blocked){//jump out of a hole or over a wall
			hyena.jump(-10+(20*hyena.direction), -1*hyena.jump_force);
		}else{ //leap viciously at hero
			hyena.jump((2*hyena.jump_force*hyena.direction) - hyena.jump_force, -1*hyena.jump_force/2);
		}
		hyena.can_leap = false;
	};
	

//......................COLLISION HANDLERS...........................
	//called at the beginning of the collision
	var begin_contact = function(contact, info){
		var type = info.Me.type;
		var hyena = info.Me.entity;
		var hyena_x = hyena.body.GetWorldCenter().x;
		var hyena_y = hyena.body.GetWorldCenter().x;
		var hyena_w = 1.125; //half width of hyena
		var hyena_h = 0.875; //half the height of hyena
		var other_x = info.Them.entity.body.GetWorldCenter().x;
		var other_y = info.Them.entity.body.GetWorldCenter().y;
		var other_w = hyena.get_fixture(info.Them.entity,"main").GetAABB().GetExtents().x;
		var other_h = hyena.get_fixture(info.Them.entity,"main").GetAABB().GetExtents().y;
		
		/**
		(hyena_w + other_w + buffer) = minimum horizontal distance for non-vertically stacked entities
		abs(them.x - me.x) = absolute horizontal distance
		(abs_hdistance < min_hdistance) implies vertical stacking
		
		(hyena_h + other_h + buffer) = minimum vertical distance for non-adjacent entities
		(abs_vdistance < min_vdistance) implies adjacency
		
		(hyena.x - other.x) < 0 if (hyena.x < other.x)
		(hyena.x - other.x) = 0 if (hyena.x = other.x)
		(hyena.x - other.x) > 0 if (hyena.x > other.x)
		smaller x is to the left of bigger x
		smaller y is above bigger y
		0 = left;
		1 = right;
		((hyena.x - other.x) > 0) returns true if hyena is to the right of the enemy, else false
		((hyena.x - other.x) < 0) returns true if other is to the right of hyena, else false
		
		((hyena.y - other.y) > 0) returns true if hyena is below the enemy (hyena_y > other_y), else false
		((hyena.y - other.y) < 0) returns true if other is above hyena(hyena_y < other_y), else false
		*/
		
		//ultimate collision detector
		if (info.Me.fixture_name == "main"){
			//if adjacent
			if (Math.abs(hyena_y - other_y) < (hyena_h + other_h - hyena.collision_buffer)){ //if adjacent
				if ((hyena_h+other_h) - (other_y-hyena_y) < hyena.collision_buffer){//if the hyena is close enough to the top that he could almost walk over it...
					hyena.barely_obstructed = true;//call for a tiny bump
				}else{
					hyena.blocked_count++; //else call for a real jump
					hyena.path_blocked = true;
				}
				if (info.Them.type == "hero"){//if other = hero, deal damage
					if(hyena.can_attack){
						hyena.attack_cooldown_timer = hyena.attack_cooldown;//set cooldown timer
					}
				}
			}else{
				//if other is below
				if(true){}
					//reset jump
					//if hero, deal damage
				
				//if other is above:
					//if hero, take damage
			}
		}
		
		var vulnerability_radius = (1.125 + 0.45 - 0.3);// hyena_width/2 + hero_width/2 - buffer, in meters
		//if bottom colliding with the ground or top of another object, enable leap
		if (info.Me.fixture_name == "bottom" && (info.Them.fixture_name == "top" || info.Them.entity.kind == 1 || info.Them.entity.kind == 2)){
			hyena.can_leap = true;
		}
		
		//if colliding with a wall, detect blocked path
		if ((info.Me.fixture_name == "left" && !hyena.direction)||(info.Me.fixture_name == "right" && hyena.direction)){
			hyena.path_blocked = true;
			hyena.blocked_count++;
		}
		
		//if colliding with a player, check for damage
		if(info.Them.type == "hero"){
			if(info.Them.fixture_name != "bottom"){ //if can_attack and colliding with a fixture other than "bottom"
				if(hyena.can_attack){
					hyena.attack_cooldown_timer = hyena.attack_cooldown;//set cooldown timer
				}
			}else if(Math.abs(info.Them.entity.body.GetWorldCenter().x - hyena.body.GetWorldCenter().x) < vulnerability_radius && !hyena.blinking){
				hyena.hit_taken = true;//take damage if enemy collides from above and distance < vulnerability radius
				hyena.damage_taken = info.Them.entity.damage;
			}
		}
	};

	//called upon end of collision
	var end_contact = function(contact, info){
		
	};


//.................DECLARE PUBLIC FUNCTIONS.....................
	return {
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = HyenaLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "HyenaLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],26:[function(require,module,exports){
var MedusaLogic = (function(){
   
	var Medusa = function(){
		/* Will be instantiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like entity:
			entity.some_state_variable_initial_value = 0;
			instantiate (most likely in the spawn function) like that:
			var new_entity_instance = new Medusa();
		*/
		var entity = EntityController.create_abstract_entity();
		
		entity.hero_hurt_me = false;
		entity.me_hurt_hero = false;
		entity.death_tick = 0;

		//set your game logic parameters here
		//entity.object_id = 1; //hardcode a unique identifier for each new enemy class
		entity.hp = 4;
		entity.speed = 4;
		entity.damage = 12;
		entity.point_value = 100;
		//entity.attack_cooldown = 4; //use entity for enemies who need
		entity.can_attack = true;//use entity for enemies who alternate between 
		//entity.cooldown_timer=-1;
		entity.AI_state = "walk";//use entity to keep track of the enemy's AI state
		entity.aliveflag = true;
		entity.unhurtflag = true;
		entity.needs_graphics_update = false;

		entity.maintenance_frequency = 20;//ticks between routine maintenance checks
		entity.maintenance_timer = entity.maintenance_frequency;

		entity.direction = false;
		entity.jolt_force = 100;

		entity.blinking = false;
		entity.blink_timer = -1;
		entity.blink_duration = 20;//how long the entity blinks after taking damage
		
		return entity;
	};

	var init = function(){
		/* Is ran from the EntityController.init once during game loading 
		 	you should assign type to your model here using the identification controller
		 */
		include(); // satisfy requirements, GOES FIRST
		IdentificationController.assign_type(Medusa, "Medusa");
	};

	var spawn = function(x, y){
		/* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you want to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/

		var new_Medusa = new Medusa();
		new_Medusa.type = "Medusa";
		var id = IdentificationController.assign_id(new_Medusa);

		new_Medusa.body = PhysicsController.get_rectangular({x: x, y: y, border_sensors: true}, new_Medusa);	

		return new_Medusa;

	};

	var tick_AI = function(Medusa){
		/* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/

		//if dead, die
		if (Medusa.hp <= 0) {
			Medusa.die();
		}else{ // Medusa.hp >= 1
				Medusa.change_animation("walk");
			
				if (Medusa.blinking) {
				    Medusa.blink_timer--;
				    if (Medusa.blink_timer == 0) {
				        Medusa.blinking = false;
				    }
				}

			if (Medusa.animation == "walk"){
				Medusa.move(Medusa.speed);
			}
			if (Medusa.animation == "jolt"){
			    Medusa.jump((2 * Medusa.jolt_force * Medusa.direction) - Medusa.jolt_force, Medusa.jolt_force/2);
			}
			if (Medusa.hit_taken){
				Medusa.take_damage();
			}

			Medusa.maintenance_timer--;
			if (Medusa.maintenance_timer == 0) {
			    Medusa.jump(0, -2);
			    Medusa.maintenance_timer = Medusa.maintenance_frequency; //reset check timer
			}
		}
	};

	// // //Set up Collision handler
	
	
	var begin_contact = function(contact, info){
	    //handle collisions here

	    if ((info.Me.fixture_name == "right" || info.Me.fixture_name == "left") && info.Them.type != "pizza") {
	        info.Me.entity.direction = !info.Me.entity.direction;
	        console.log('hit');
	        if (info.Them.entity.point_value > 0) {
	            info.Me.entity.direction = Math.round(Math.random());
	            info.Them.entity.direction = Math.round(Math.random());
	        }
	    }
		
		if(info.Them.type == "hero"){
			if(info.Them.fixture_name != "bottom" && info.Me.entity.can_attack){
				info.Me.entity.me_hurt_hero = true;
			}else{
				info.Me.entity.hit_taken = true;//take damage if enemy collides from above and distance < vulnerability radius
				info.Me.entity.damage_taken = info.Them.entity.damage;
			}
		}
	};

	var end_contact = function(contact, info){
	
	};

	
	return {
		// declare public
		init: init, 
		spawn: spawn,
		tick_AI: tick_AI,
		begin_contact: begin_contact,
		end_contact: end_contact,
	};
})();

module.exports = MedusaLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "MedusaLogic", 
	include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],27:[function(require,module,exports){
var PizzaLogic = (function () {

    var Pizza = function () {
        /* Will be instPizzaiated for every created entity to hold all the information 
			about the physical (not graphical) state of the entity in question. 
			declare the properties like this:
			this.some_state_variable_initial_value = 0;
			instPizzaiate (most likely in the spawn function) like that:
			var new_entity_instance = new Pizza();
		*/
        var entity = EntityController.create_abstract_entity();

        entity.animation = "normal";
        entity.can_attack = false;
        entity.used = false;
        entity.point_value = 0;
        entity.is_alive = false;
        entity.regen = -25;

        return entity;
    };

    var init = function () {
        /* Is run from the EntityController.init once during game loading 
		 	you should assign type to your model here using the identification controller
		 */
        include(); // satisfy requirements, GOES FIRST
        IdentificationController.assign_type(Pizza, "pizza");
    };

    var spawn = function (x, y) {
        /* spawn instance of this entity at the given coordinates
			you will have to create new entity instance, assign it id
			using the IdentificationController.assign_id(entity_instance),
			assign it a body which you can get through PhysicsController
			do any other stuff you wPizza to do during spawning,
			and finally you HAVE TO(!!!) return the instance you just created from this function
		*/

        var new_Pizza = new Pizza();
        new_Pizza.type = "pizza";
        var id = IdentificationController.assign_id(new_Pizza);

        new_Pizza.body = PhysicsController.get_rectangular({ x: x, y: y, border_sensors: false }, new_Pizza);

        return new_Pizza;

    };

    var tick_AI = function (Pizza) {
        /* Is ran each tick from the EntityController.update for every registered
			entity of this type. I given entity_instance
		*/

        //if enemy is dead, die
        //if (Pizza.body.GetWorldCenter().y > 22 || Pizza.body.GetWorldCenter().x < Config.Player.movement_edge - 1) {
        //EntityController.delete_entity();
        //console.log("drop of death");
        //}
        //
        if (Pizza.used) {
            Pizza.die();
        }
    };

    // // //Set up Collision handler


    var begin_contact = function (contact, info) {
        //handle collisions here
        if (info.Them.entity.type == "hero" && info.Them.entity.hp < 100) {
            info.Me.entity.used = true;
        }

    };

    var end_contact = function (contact, info) {

    };


    return {
        // declare public
        init: init,
        spawn: spawn,
        tick_AI: tick_AI,
        begin_contact: begin_contact,
        end_contact: end_contact,
    };
})();

module.exports = PizzaLogic;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
    current_module: "PizzaLogic",
    include_options: Includes.choices.LOGIC_SPECIFIC
}); eval(include_data.name_statements); var include = function () { eval(include_data.module_statements); }

},{"../Includes.js":19}],28:[function(require,module,exports){
var AssetModel = new function(){
	// As always, almost anything is initialized in the InitController
	
	this.loader;
//mackerel
	this.manifest = [ // defining resources to be loaded in bulk with preload.js
			{src: "greek_warrior.png", id: "greek_warrior"},
			//{src:, id:},
			{src: "middle_terrain.png", id:"middle_terrain"},
			{src: "bottom_terrain.png", id: "bottom_terrain"},
			{src: "grass_summer.png", id: "grass_summer" },
			{src: "grass_winter.png", id: "grass_winter" },
			{src: "grass_fall.png", id: "grass_fall" },
			{src: "grass_spring.png", id: "grass_spring" },
			{src: "AntChompers.png", id: "Ant1"},
			{src: "AntChompers2.png", id: "Ant2"},
			{src: "AntChompersDeath.png", id: "Ant3"},
			{src: "Greek Landscape fall.png", id: "Fall"},
			{src: "Greek Landscape spring.png", id: "Spring"},
			{src: "Greek Landscape winter.png", id: "Winter"},
			{src: "Greek Landscape summer.png", id: "Summer"},
			{src: "griffinPhase1Small.png", id: "Griffin1" },
			{src: "griffinPhase2Small.png", id: "Griffin2" },
			{src: "griffinPhase3Small.png", id: "Griffin3" },
			{ src: "griffinDeathSmall.png", id: "GriffinDeath" },
            { src: "griffinDeathSmall2.png", id: "GriffinDeath2" },
            { src: "griffinDeathSmall3.png", id: "GriffinDeath3" },
			{ src: "MedusaSheet.png", id: "Medusa1" },
            { src: "CentaurSheet.png", id: "Centaur1" },
			{src: "platform_left.png", id: "left_platform" },
			{src: "platform_middle.png", id: "middle_platform" },
			{src: "platform_right.png", id: "right_platform" },
			{src: "HyenaPhase3.png", id: "HyenaSprite" },
			{src: "platform_spikes.png", id: "platform_spikes" },
			{src: "Hero.png", id: "Hero"},
			{src: "HeroHitRed.png", id: "HeroR"},
			{src: "HeroHitWhite.png", id: "HeroW"},
			{src: "HeroRed.png", id: "HeroRed"},
			{src: "HeroPink.png", id: "HeroPink"},
			{src: "HeroBlue.png", id: "HeroBlue"},
			{src: "HeroLPurple.png", id: "HeroLPurple"},
			{src: "HeroOrange.png", id: "HeroOrange"},
			{src: "HeroLB.png", id: "HeroLightBlue"},
			{src: "HeroLG.png", id: "HeroLightGreen"},
			{src: "HeroGreen.png", id: "HeroGreen"},
            {src: "pizza.png", id: "pizza"},
			{src: "HeadGreen.png", id: "HeadGreen"},
			{src: "HeadBlue.png", id: "HeadBlue"},
			{src: "HeadLightBlue.png", id: "HeadLightBlue"},
			{src: "HeadOrange.png", id: "HeadOrange"},
			{src: "HeadLightGreen.png", id: "HeadLightGreen"},
			{src: "HeadPurple.png", id: "HeadPurple"},
			{src: "HeadPink.png", id: "HeadPink"},
			{src: "HeadRed.png", id: "HeadRed"},

			
		]; 
		// TODO make adding resources easier? Automatic loading 
		// of everything from assets, automatic names etc.?

	this.shapes = {}; // maybe this aren't needed

	this.bitmaps = {};

	this.animations = {};

};

module.exports = AssetModel;

},{}],29:[function(require,module,exports){
var EntityModel = function(){	
	// associates type with the AI
	this.type_to_AI = {};

	this.for_logic_update = {}; // key: type, value: table of objects with id for key, object for value
	
	
	this.hero_spawned = false;

	// assiciates player network id with the hero entity instance
	this.heroes = {};

	// last velocity for my hero
	// used to check how much velocity changed since the last tick
	this.hero_last_velocity = {x: 0, y: 0};
};

module.exports = new EntityModel;


},{}],30:[function(require,module,exports){
var GameModel = new function(){ // main model
    this.pauseCounter = 0;
};

module.exports = GameModel;

},{}],31:[function(require,module,exports){
var GraphicsModel = function(){
	this.stage; // main stage to where everything will be drawn
	// note that every graphics object must be augmented with
	// the reference to the corresponding physics object, if any
	this.other_players = []; // array of players other then hero for multiplayer

	// all object registered for continious update to match their physical body
	// position 
	this.all_physical = {}; 
	this.special_render = {}; // matches type with array of all objects of that type to be rendered

	// all spritesheet definitions (added at the initialization stage
	// because they need assets to be loaded)
	this.spritesheets = {}; 

	this.camera = {
		// should be easeljs object or null
		following: null,

		// internal camera implementation thing to know how far to offset from the
		// initial position
		offset: {x: 0, y: 0},

		// the offset of the camera from the followed object
		// e.g. offset of {x: 100, y: 100} will center camera
		// 100 pixels to the right and 100 pixels below the followed object
		offset_from_followed: { x: 400, y: -100 },
		//offset_from_followed: {x: 330, y: -205}, //FOR GAME PAGE
		// this is center of the screen in pixels. gets dynamically recalculated 
		// during the camera update so if it's ever changed, camera still works as expected
		center: {x: 0, y: 0}

	};

};

module.exports = new GraphicsModel;


},{}],32:[function(require,module,exports){

var IdentificationModel = function(){
	
	// next unique id to be given if not free id's remain
	this.next_id = 0;

	// array of free id's. push when freed, pop when free id is needed
	// if array is empty, get next id using >next_id<
	this.free_ids = [];

	// array matches ids to their corresponding objects
	this.id_matching = [];

	// registry of types to make sure that no type is registerd twice
	// and enable people to get the model by type name
	this.types = {}

	//list of heroes and companions spawned
	this.hero;
	this.companions = [];

	this.reserved = [];
};

module.exports = new IdentificationModel;



},{}],33:[function(require,module,exports){
var KeyboardModel = function(){

	// own keys that are currently active
	this.keys = {
	};

	this.state_changed = false;

	// table of all keys that have
	// changed since the last tick
	// key is keycode, value is boolean
	// indicating whether key was pressed or released
	// TODO: implement;
	// idea is that only commands for relevant tables will be sent
	// overseas
	this.changed_keys = {};

	// own keys that were active previous tick
	//this.old_keys = {
	//};

	// table of network player ids associated
	// with the last registered state of their keyborads
	this.all_keyboard_states = {
	}

	this.translation_tables = {
		code_to_name: {
			8:   "backspace", //  backspace
			9:   "tab", //  tab
			13:  "enter", //  enter
			16:  "shift", //  shift
			17:  "ctrl", //  ctrl
			18:  "alt", //  alt
			19:  "pause/break", //  pause/break
			20:  "caps lock", //  caps lock
			27:  "escape", //  escape
			33:  "page up", // page up, to avoid displaying alternate character and confusing people
			34:  "page down", // page down
			35:  "end", // end
			36:  "home", // home
			37:  "left arrow", // left arrow
			38:  "up arrow", // up arrow
			39:  "right arrow", // right arrow
			40:  "down arrow", // down arrow
			45:  "insert", // insert
			46:  "delete", // delete
			48:  "0",
			49:  "1",
			50:  "2",
			51:  "3",
			52:  "4",
			53:  "5",
			54:  "6",
			55:  "7",
			56:  "8",
			57:  "9",
			65:  "a",
			66:  "b",
			67:  "c",
			68:  "d",
			69:  "e",
			70:  "f",
			71:  "g",
			72:  "h",
			73:  "i",
			74:  "j",
			75:  "k",
			76:  "l",
			77:  "m",
			78:  "n",
			79:  "o",
			80:  "p",
			81:  "q",
			82:  "r",
			83:  "s",
			84:  "t",
			85:  "u",
			86:  "v",
			87:  "w",
			88:  "x",
			89:  "y",
			90:  "z",
			91:  "left window", // left window
			92:  "right window", // right window
			93:  "select key", // select key
			96:  "numpad 0", // numpad 0
			97:  "numpad 1", // numpad 1
			98:  "numpad 2", // numpad 2
			99:  "numpad 3", // numpad 3
			100: "numpad 4", // numpad 4
			101: "numpad 5", // numpad 5
			102: "numpad 6", // numpad 6
			103: "numpad 7", // numpad 7
			104: "numpad 8", // numpad 8
			105: "numpad 9", // numpad 9
			106: "multiply", // multiply
			107: "add", // add
			109: "subtract", // subtract
			110: "decimal point", // decimal point
			111: "divide", // divide
			112: "F1", // F1
			113: "F2", // F2
			114: "F3", // F3
			115: "F4", // F4
			116: "F5", // F5
			117: "F6", // F6
			118: "F7", // F7
			119: "F8", // F8
			120: "F9", // F9
			121: "F10", // F10
			122: "F11", // F11
			123: "F12", // F12
			144: "num lock", // num lock
			145: "scroll lock", // scroll lock
			186: ";", // semi-colon
			187: "=", // equal-sign
			188: ",", // comma
			189: "-", // dash
			190: ".", // period
			191: "/", // forward slash
			192: "`", // grave accent
			219: "[", // open bracket
			220: "\\", // back slash
			221: "]", // close bracket
			222: "'", // single quote
		},

		movement: {
			"left arrow": "left",
			"up arrow": "up",
			"down arrow": "down",
			"right arrow": "right",
		},

		pause: {
		    "p": "pause",
		},
		
		debug: {
			"a": "spawn_ant",
			"m": "spawn_medusa",
            "t": "spawn_centaur",
			"z": "season",
			"g": "spawn_griffin",
			"s": "new_slice",
			"h": "spawn_hyena",
			"c": "connect",
			"v": "request_hero",
			"i": "show_ids",
            "k": "spawn_pizza",
		},

	}


};

module.exports = new KeyboardModel;


},{}],34:[function(require,module,exports){
var MultiplayerSyncModel = function(){
	this.hero = null;

	this.op_packets_table = {};
	
};

module.exports = new MultiplayerSyncModel;



},{}],35:[function(require,module,exports){
var NetworkModel = function(){
	this.connected = false; // flag to indicate if already connected to the network

	// flag to indicate whether to disallow connections, useful to prevent
	// more attempts to connect when connection is already being established
	this.block_connections; 

	this.my_peer = null;
	this.my_id = null;

	this.master_id = null; // id of the master with whome everyone synces

	// this is for standart (non-test) mode
	// I plan to make test mode use this too, eventually
	this.peers_to_connect = null;
	

	// player_id associated with the connection object
	this.connections = {};

	this.send_array = null;
	this.recieve_array = null;

	this.one_packet = null; // used to store one packet, for one packet communication

	this.input_cell = null;
	this.output_cell = null;
	this.counter = 0; // temp

	// linked list to store the backlog of packets for the communication that needs that
	this.package_backlog = {HEAD: null, TAIL: null} 

	this.waiting_for_initial_sync = []; // list of players waiting to sync with master

	// TIME 
		this.begin_time = null; // seconds
		this.timeout_id = null;
	// END TIME
	
	// TESTING MODE STUFF. SHOULD BE MERGED WITH GENERAL STUFF IF POSSIBLE
	
	this.non_free_ids = [
	];

	this.free_ids = [
	];

	// END TESTING MODE STUFF

};

module.exports = new NetworkModel;



},{}],36:[function(require,module,exports){

var PhysicsModel = function() {
	
	this.gravity;
	this.world;
 
	// getting context of the debug canvas, for box2d to draw debuggin boxes

	// timeToCover is the time that simulation must cover to catch up to the real world time;
	// since createjs ticker is what we use for timing, and box2d ticks
	// must be of constant length and independent from the graphics framerate,
	// we keep track of time that passed since last box2d step by adding time deltas
	// to the timeToCover. Then, when timeToCover exceeds desired box2d step length,
	// we perform the step and subtract the corresponding time from the timeToCover;
	// If anything is still unclear, ask me (AK);
		this.timeToCover = 0; 

	this.step_amount;

	this.awaiting_contact = {
		PreSolve: {},
		PostSolve: {},
		BeginContact: {},
		EndContact: {},
	};

}; 

/*
 * Parameters for b2d body definition
	active: true
	allowSleep: true
	angle: 0
	angularDamping: 0
	angularVelocity: 0
	awake: true
	bullet: false
	fixedRotation: false
	inertiaScale: 1
	linearDamping: 0
	linearVelocity: b2Vec2
	position: b2Vec2
	type: 0
	userData: null
*/

/*
 * Fixture definition parameters:
	density: 0
	filter: b2FilterData
	friction: 0.2
	isSensor: false
	restitution: 0
	shape: null
	userData: null
 */

// rectangular
PhysicsModel.prototype.r_templates = r_templates = {};
// circular
PhysicsModel.prototype.c_templates = c_templates = {};
// polygonal
PhysicsModel.prototype.p_templates = p_templates = {};



r_templates["default"] = {

	//shape: "rectangle", // implied from the template type
	x: 3,
	y: 3,
	vx: 0,
	vy: 0,

	width: 5,
	height: 5,
	density: 2,
	friction: 1,
	restitution: 0.2,
	isSensor: false,


	active: true,
	allowSleep: true,
	angle: 0,
	angularVelocity: 0,
	awake: true,
	bullet: false,
	fixedRotation: false,
	type: "dynamic",

};

r_templates.living = {
	fixedRotation: true,
	awake: true,
	isSensor: false,
	//mobexp++
};

r_templates.terrain_cell = {
	type: "static",
	width: 1,
	height: 1,
	friction: 2,
	//mobexp++
};

r_templates.hero = {
	parent: r_templates.living,
	width: 0.9,
	height: 1.7,
	density: 4.5,
	type: "dynamic",
	//mobexp++
};

r_templates.companion = {
	parent: r_templates.living,
	width: 1.5,
	height: 2.5,
	type: "dynamic",
	//mobexp++
};

r_templates.ant = {
	parent: r_templates.living,
	width: 1,
	height: 0.5,
	type: "dynamic",
	x: 40,
	y: 10,
	//mobexp++
};

r_templates.Griffin = {
	parent: r_templates.living,
	width: 2.8,
	height: 2.5,
	type: "dynamic",
	x: 95,
	y: 50,
	//mobexp++
};

r_templates.Hyena = {
	parent: r_templates.living,
	width: 2.25,
	height: 1.75,
	type: "dynamic",
	x: 65,
	y: 10,
	//mobexp++
};

r_templates.Medusa = {
    parent: r_templates.living,
    width: 1.4,
    height: 2.8,
    type: "dynamic",
    x: 65,
    y: 10,
};

r_templates.Centaur = {
    parent: r_templates.living,
    width: 2.2,
    height: 3.4,
    type: "dynamic",
    x: 65,
    y: 10,
};

r_templates.test = {
	width: 1,
	height: 2,
	fixedRotation: false,
	//mobexp++
}

r_templates.platform = {
    x: 10,
    y: 11,
    width: 10,
    height: .5,
    type: "static",
}

r_templates.pizza = {
    isSensor: true,
    type: "static",
    height: .5,
    width: .5,
    x: 10,
    y: 11,
}

module.exports = new PhysicsModel;

},{}],37:[function(require,module,exports){
var RegisterAsModel = function(){
	
	// register stuff for one time lookup
	// the one requesting stuff is supposed to pop the each examined element
	// there is no timeouts or automatic cleanup
	this.simple_one_time_lookup = {};
};

module.exports = new RegisterAsModel;


},{}],38:[function(require,module,exports){
var TerrainModel = function(){
	//This is physics, for graphics look into the GraphicsController/Model
	this.terrain_slices_queue = [];
	//this.new_slices = [];
	this.seed;

	// how many initial (non-random) terrain slices
	// were generated already?
	this.initial_generated = 0;


	// used to determine x offset of the next slice
	// TODO: update this when truly infinite terrain will be implemented
	this.slice_counter = 0;

};

module.exports = new TerrainModel;

},{}],39:[function(require,module,exports){
TerrainSliceConfig = require ("../Config.js").TerrainSlice;

var TerrainSliceModel = function(){

	this.Slice = function(){
		/**
		* slice "model" to be instantiated
		*/
		
		
		this.num = TerrainSliceConfig.next_slice_id++; // automaticall assign id and increment 

		this.grid_columns = TerrainSliceConfig.grid_columns;
		this.grid_rows = TerrainSliceConfig.grid_rows;
		this.cell_w = TerrainSliceConfig.cell_w;
		this.cell_h = this.cell_w;;
		
		// grid[i][j] is the element in the i's column and j's row
		// the grid is maid to match the screen coordinates and the current box2d coordinates
		// i.e. grid[0][0] is the one in the top left corner of the terrain slice
		// do we want to change it? would it be easier to generate terrain if we start at the bottom?
		// if yes, then what makes more sense, changing coordinate systems or just switching generation
		// loops around? discuss
		//
		// notice that the grid is a terrain generation device only. once terrain slice is loaded,
		// box2d physics simulation may (and will) go nuts on it, changing whatever it wants,
		// and changes won't anyhow be reflected in the grid. to keep track of all the bodies
		// in the terrain slice, if that will be needed, other mechanisms should be used.
		// idea: have a collections of bodies by type, and setup sensor collision beams
		// at the terrain slices' boundaries to keep track of bodies flying over from one
		// terrain slice to another. Btw, Ali, I hate you for making me to type "terrain slice"
		// instead of the "chunk" 
		this.grid = [];
		
		this.origin = {x: null, y: null};

	};

	this.Cell = function(kind){
		this.kind = kind;
		this.body;
	}

	
};

TerrainSliceModel.prototype.lvl_prob = [
	[7, 2, 1],
	[0, 7, 3],
	[0, 1, 9]
]

module.exports = new TerrainSliceModel;

},{"../Config.js":2}],40:[function(require,module,exports){
var TestModel = function(){

};

module.exports = new TestModel;


},{}],41:[function(require,module,exports){
var WorldModel = function(){
	
};

module.exports = new WorldModel;


},{}],42:[function(require,module,exports){
var AntRenderer = (function(){

	var spritesheets = {};
	var ant_animation;

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
		 	use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/

		include(); // satisfy requirements, GOES FIRST
		var get_asset = AssetController.get_asset;

		spritesheets["ant"] = new createjs.SpriteSheet({
			"framerate": 1,
			"images": [get_asset("Ant1"), get_asset("Ant2"), get_asset("Ant3")],
			"frames": { "regX": 3, "regY": 6, "height": 25, "width": 50, "count": 6},
			"animations": {
				"walk": [0, 1, "walk", 0.25],
				"upside_down": [2, 3, "upside_down"],
				"death": [4, 5, "death"],
			}
		})

	};

	var register = function(entity_ant){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		ant_animation = GraphicsController.request_animated(spritesheets["ant"], "walk");
		GraphicsController.set_reg_position(ant_animation, 0, 0); // change that to adjust sprite position relative to the body
		GraphicsController.reg_for_render(ant_animation, entity_ant); // sets ant_animation's position to track the ant's position (updates each tick)

		
	};

	var render = function(ant){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/

		ant_animate(ant); 
	};
	var ant_animate = function(ant){
		//set graphical representation based on the animation variable determined by the AI
		//set animation
		if(ant.physical_instance.needs_graphics_update){
			var animation = ant.physical_instance.animation;
			ant.gotoAndPlay(animation)
		}
		
		//set direction
		if (ant.physical_instance.direction){ //if direction == right, flip right
			ant.scaleX = -1;
		}else{ //else flip left
			ant.scaleX = 1;
		}

		//set alpha if blinking
		if(ant.physical_instance.blinking && ant.physical_instance.blink_timer%2 == 1){
			ant.alpha = 0;
		}else{
			ant.alpha = 1;
		}
	};
	/*
	var ant_special_render_temp = function(ant){
		

		
		if(ant.physical_instance.AI_state == "death"&& ant.physical_instance.aliveflag){
			ant.gotoAndPlay("death");
			ant.physical_instance.aliveflag = false;
			
			
		}

		if(ant.physical_instance.AI_state == "upside_down" && ant.physical_instance.unhurtflag)
		{
			ant.gotoAndPlay("upside_down");
			ant.physical_instance.unhurtflag = false;
			
			
		}
		if(ant.physical_instance.AI_state == "walk" && ant.physical_instance.start_walking)
		{
			ant.gotoAndPlay("walk");
			//ant.physical_instance.hp += 1;
			ant.physical_instance.start_walking = false;
			
			
		}

	};
	*/

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = AntRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "AntRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],43:[function(require,module,exports){
var BackgroundRenderer = (function(){

	var season_array;
	var season_image;
	var season_threshold;
	
	var season_progress;
	var season_progress_to_level;
	var hero_current_level;
		
	var init = function(){
		include(); //sets up dependencies MUST GO FIRST
		
		season_array = [];//stores season sprites
		season_image = ["Winter", "Spring", "Summer", "Fall"];
		season_threshold = 2; //So seasons only update once
		
		season_progress = 0;
		season_progress_to_level = 199;//season_image[cycle].width*2 + Config.SCREEN_W/2;
		hero_current_level = season_progress_to_level;
		
		generate_season("Winter", GraphicsController.get_stage().canvas.width, 0);
	};
	
	var render = function(){

		if(Math.round(WorldController.get_progress()) > hero_current_level){
			season_progress++;
			hero_current_level += season_progress_to_level;
			WorldController.increase_score(season_progress*500);
		}
		
		//Potentially change seasons based on hero progress
		change_seasons(season_progress);
		
		//perform parallax effect with background
		background_loop(WorldController.get_progress(),season_progress);
	};
	
	//Generates tiled background for season
	var generate_season = function(season_image, canvas_width, start){
		for(i=0; i<3; i++){//create tiles 3 at a time
			var season = GraphicsController.request_bitmap(season_image);
			season.regY -= season.image.height/2;
			//create a new tile with offset
			season.x = start + i*season.image.width;
			GraphicsController.get_stage().addChildAt(season, 0);
			season_array.push(season);
		}
	};
	
	//checks for and handles potential season change
	var change_seasons = function(progress){
		var flag = false;
		if(progress == season_threshold){ //seasons will change every even progress number
			season_threshold += 2;
			flag = true;
		}
		if(flag){
			console.log("generating season");
			delete_all_season();
			WorldController.set_season((WorldController.get_season()+1)%4);
			generate_season(season_image[WorldController.get_season()], GraphicsController.get_stage().canvas.width, WorldController.get_movement_edge() / 30);
		}
	};
	
	//scrolls the background along with the player
	var background_loop = function(hero_x, progress){
		for(i=0; i<season_array.length; i++){
			//season_array[i].x = (i * 799) + GraphicsModel.camera.offset.x;
			//season_array[i].y = GraphicsModel.camera.offset.y;
			season_array[i].x = ((i + progress) * 799) - (hero_x * 4);
			season_array[i].y = GraphicsController.get_camera().offset.y;
		}
	};

	//deletes all background objects
	var delete_all_season = function(){
		for(var i = 0; i < season_array.length; i++){
			GraphicsController.get_stage().removeChild(season_array[i]);
		}
		season_array = [];
	};
	
	var register = function(background){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		
	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = BackgroundRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "BackgroundRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}



},{"../Includes.js":19}],44:[function(require,module,exports){
var CentaurRenderer = (function(){

	var spritesheets = {};
	var Centaur_animation;

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
		 	use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/

		include(); // satisfy requirements, GOES FIRST
		var get_asset = AssetController.get_asset;

		spritesheets["Centaur"] = new createjs.SpriteSheet({
			"framerate": 1,
			"images": [get_asset("Centaur1"),], //CentaurSpriteSheet
			"frames": { "regX": 0, "regY": 0, "height": 105, "width": 70.7, "count": 4},
				"animations": {
				"walk": [0, 3, "walk", 0.1],
				"injury": {
				    frames: [3, 4, .25]
				},
				"death": [3, 4, "death", 0.6],
                
			}
		})

	};

	var register = function(entity_Centaur){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		Centaur_animation = GraphicsController.request_animated(spritesheets["Centaur"], "walk");
		GraphicsController.set_reg_position(Centaur_animation, 0, 0); // change that to adjust sprite position relative to the body
		GraphicsController.reg_for_render(Centaur_animation, entity_Centaur); // sets Centaur_animation's position to track the Centaur's position (updates each tick)

		
	};

	var render = function(Centaur){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/

		Centaur_special_render_temp(Centaur); 
	};

	var Centaur_special_render_temp = function(Centaur){
		/* how to handle special render? TEMPORARY */

		//set graphical representation based on the animation variable determined by the AI
		//set animation
		if(Centaur.physical_instance.needs_graphics_update){
			var animation = Centaur.physical_instance.animation;
			Centaur.gotoAndPlay(animation)
		}
		
		//set direction
		if (Centaur.physical_instance.direction){ //if direction == right, flip right
			Centaur.scaleX = -1;
		}else{ //else flip left
			Centaur.scaleX = 1;
		}

		//set alpha if blinking
		if(Centaur.physical_instance.blinking && Centaur.physical_instance.blink_timer%2 == 1){
			Centaur.alpha = 0;
		}else{
			Centaur.alpha = 1;
		}
	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = CentaurRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "CentaurRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}
},{"../Includes.js":19}],45:[function(require,module,exports){
var EsteemedCompanionRenderer = (function(){

	var spritesheets = {}; // to store spritesheets used by this entity

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
			use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/
		include(); // satisfy requirements, GOES FIRST
	};

	var register = function(entity_companion){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		var companion = GraphicsController.request_bitmap("greek_warrior");

		GraphicsController.set_reg_position(companion, -20, +10);
		GraphicsController.reg_for_render(companion, entity_companion);

	};

	var render = function(companion){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/
		GraphicsController.update_health(companion.physical_instance.hp);
	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = EsteemedCompanionRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "EsteemedCompanion", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],46:[function(require,module,exports){
var GriffinRenderer = (function(){

	var spritesheets = {};
	var Griffin_animation;

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
		 	use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/

		include(); // satisfy requirements, GOES FIRST
		var get_asset = AssetController.get_asset;

		spritesheets["Griffin"] = new createjs.SpriteSheet({
			"framerate": 1,
			"images": [get_asset("Griffin1"), get_asset("Griffin2"), get_asset("Griffin3"), get_asset("GriffinDeath")], //, get_asset("GriffinDeath2"), get_asset("GriffinDeath3")
				"frames": { "regX": 5, "regY": 14, "height": 207, "width": 210, "count": 6},
				"animations": {
				"walk": [0, 2, "walk", 0.1],
				"injury": {
				    frames: [2, 4, .25]
				},
				"death": [3, 4, "death", 0.6],
                "fly": [1, 2, "fly", .4],
			}
		})

	};

	var register = function(entity_Griffin){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		Griffin_animation = GraphicsController.request_animated(spritesheets["Griffin"], "walk");
		GraphicsController.set_reg_position(Griffin_animation, 0, 0); // change that to adjust sprite position relative to the body
		GraphicsController.reg_for_render(Griffin_animation, entity_Griffin); // sets griffin_animation's position to track the griffin's position (updates each tick)

		
	};

	var render = function(Griffin){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/

		Griffin_special_render_temp(Griffin); 
	};

	var Griffin_special_render_temp = function(Griffin){
		/* how to handle special render? TEMPORARY */

		//set graphical representation based on the animation variable determined by the AI
		//set animation
		if(Griffin.physical_instance.needs_graphics_update){
			var animation = Griffin.physical_instance.animation;
			Griffin.gotoAndPlay(animation)
		}
		
		//set direction
		if (Griffin.physical_instance.direction){ //if direction == right, flip right
			Griffin.scaleX = -1;
		}else{ //else flip left
			Griffin.scaleX = 1;
		}

		//set alpha if blinking
		if(Griffin.physical_instance.blinking && Griffin.physical_instance.blink_timer%2 == 1){
			Griffin.alpha = 0;
		}else{
			Griffin.alpha = 1;
		}
	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = GriffinRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "GriffinRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],47:[function(require,module,exports){
var HUDRenderer = (function(){
	
	var score;
	var health_bar;
	var score_title;
	var health_outline;
	var healthX;

	var init = function(){
		
		include();
		healthX = 100;
		get_asset = AssetController.get_asset; // for quicker access
		score = new createjs.Text();
		GraphicsController.reg_for_render(score);
		health_bar = new createjs.Shape();
		GraphicsController.reg_for_render(health_bar);
		score_title = new createjs.Text();
		GraphicsController.reg_for_render(score_title);
		health_outline = new createjs.Shape();
		GraphicsController.reg_for_render(health_outline);
		player_head = new createjs.Bitmap(get_asset("HeadRed"));
		GraphicsController.reg_for_render(player_head);
		
		health_outline.x = 30;
		health_outline.y = 25;
		health_outline.graphics.beginStroke("red").setStrokeStyle(1).drawRect(30,25,100,20);
		health_bar.x = 30;
		health_bar.y = 25;
		health_bar.graphics.beginFill("red");
		health_bar.graphics.drawRect(30,25,healthX, 20);
		
		player_head.x = 10;
		player_head.y = 35;
		score_title.text = "Score: ";
		score_title.x = 10;
		score_title.y = 10;
		score.text = "0";
		score.x = 80;
		score.y = 10;
		score.font = "20px Arial";
		score_title.font = "20px Arial";
	};
	
	var render = function(){
		var camera = GraphicsController.get_camera();
		var hero = EntityController.get_my_hero();
		
		update_score(WorldController.get_score());
		if(hero){
			update_health(hero.hp);
		}
		
	};
	
	var update_score = function(new_score){
		score.text = parseInt(new_score);
	};
	
	var update_health = function(new_health){
		healthX = parseInt(new_health);
		health_bar.graphics.clear();
		health_bar.graphics.beginFill("red");
		if(healthX >= 0){
			health_bar.graphics.drawRect(30,25,healthX, 20);
		}
		else{
			health_bar.graphics.drawRect(30,25,1, 20);
		} 
	};
	
	return {
		// declare public
		init: init, 
		render: render,
	};
})();

module.exports = HUDRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "HUDRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],48:[function(require,module,exports){
var HeroRenderer = (function(){

	var spritesheets = {}; // to store spritesheets used by this entity

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
			use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/
		include(); // satisfy requirements, GOES FIRST
		
		//SpriteSheetUtils.addFlippedFrames(spriteSheets["Hero"], true, false, false);
	};

	var register = function(entity_hero){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/
		var get_asset = AssetController.get_asset;
		spritesheets["hero"] = new createjs.SpriteSheet({
			"framerate": 1,
			"images": [get_asset("Hero")], //get_asset("HeroR"), get_asset("HeroW")
			"frames": { "regX": 25, "regY": 25, "height": 50, "width": 50, "count": 16},
			"animations": {
				"stand": {
				frames: [0]
				},
				"finish": {
					frames: [8]
				},				
				"walk": {
					 frames: [0,1, 2],
					 speed: 0.2
				 },
				"jump": {
					frames: [3, 4, 5, 6, 7, 8],
					speed: 0.2
				},
				"death": {
					frames: [9, 10, 11, 12, 13, 14, 15],
					speed: 0.1,
					next: "death"
				},
				"decay": {
					frames: [15]
				},
			}
		})
		hero_animation = GraphicsController.request_animated(spritesheets["hero"], "stand");
		hero_animation.graphics_id = "hero";
		GraphicsController.set_reg_position(hero_animation, -25, -25);
		GraphicsController.reg_for_render(hero_animation, entity_hero);
		if(entity_hero.player_id == NetworkController.get_network_id()){
			GraphicsController.follow(entity_hero.id);
		}

	};
	/*
	var render = function(hero){

		if(hero.physical_instance.state=="walk"&&hero.physical_instance.is_walk == true){
			if(hero.physical_instance.walk_tick ==1){
				hero.gotoAndPlay("walk");
			}
			hero.physical_instance.walk_tick++;
			if(hero.physical_instance.walk_tick ==10){
				hero.physical_instance.state= "stand";
				hero.physical_instance.is_walk = false;
			}
		}
		
		if(hero.physical_instance.state=="jump"){
			if(hero.physical_instance.jump_tick ==1){
				hero.gotoAndPlay("jump");
			}
			hero.physical_instance.jump_tick++;
			if(hero.physical_instance.jump_tick >= 20){
				hero.gotoAndPlay("finish");
				if(hero.physical_instance.jumps==0){
					hero.physical_instance.state="finish";
				}
				
			}
		}
		
		if(hero.physical_instance.state=="finish"){
			hero.gotoAndPlay("finish");
		}
		if(hero.physical_instance.state=="deathFinal"){
			hero.gotoAndPlay("deathFinal");
		}
		if(hero.physical_instance.state=="stand"){
			hero.gotoAndPlay("stand");
		}
		//console.log(hero.physical_instance.state);
		if (hero.physical_instance.state == "death") {
			//console.log(hero.physical_instance.death_tick);
			if(hero.physical_instance.death_tick ==1){
			    hero.gotoAndPlay("death");
			}
			else if(hero.physical_instance.death_tick >=20){
				hero.physical_instance.state="deathFinal";
			}
		}
		
		//set direction
		if (hero.physical_instance.left){ //if direction == right, flip right
			hero.scaleX = -1;
		}else{ //else flip left
			hero.scaleX = 1;
		}
	};
	*/

	return {
		// declare public
		init: init, 
		register: register,
		//render: render,
	};
})();

module.exports = HeroRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "HeroRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],49:[function(require,module,exports){
var HyenaRenderer = (function(){

	var spritesheets = {};
	var Hyena_animation;

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
		 	use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/

		include(); // satisfy requirements, GOES FIRST
		var get_asset = AssetController.get_asset;

		spritesheets["Hyena"] = new createjs.SpriteSheet({
			"framerate": 1,
			"images": [get_asset("HyenaSprite")],
			"frames": { "regX": 0, "regY": 8, "height": 64, "width": 64, "count": 17},
			"animations": {
				"run": [0,3, "run", 0.5],
				"stand": [4,5, "stand", 0.25],
				"walk": [8,11, "walk", 0.2],
				"leap": [6],
				"fall": [7],
				"death": [12,14, "decay", 0.25],
				"decay": [15,16, "decay", 0.25],
			}
		})

	};

	var register = function(entity_hyena){
		/* is run for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to create graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		hyena_animation = GraphicsController.request_animated(spritesheets["Hyena"], "walk");
		GraphicsController.set_reg_position(hyena_animation, 0, 0); // change that to adjust sprite position relative to the body
		GraphicsController.reg_for_render(hyena_animation, entity_hyena); // sets hyena_animation's position to track the hyena's position (updates each tick)
		/*
		hyena_animation is the easeljs_obj passed through graphicsController
		entity_hyena is the physical object spawned in HyenaLogic
		request_animated returns an easeljs object of type Sprite
		this Sprite is the object passed to render
		*/
		
	};

	var render = function(hyena){
		/* 	is run each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attached correctly
		*/

		hyena_animate(hyena); 
	};

	var hyena_animate = function(hyena){
		//set graphical representation based on the animation variable determined by the AI
		//set animation
		if(hyena.physical_instance.needs_graphics_update){
			var animation = hyena.physical_instance.animation;
			hyena.gotoAndPlay(animation)
		}
		
		//set direction
		if (hyena.physical_instance.direction){ //if direction == right, flip right
			hyena.scaleX = -1;
		}else{ //else flip left
			hyena.scaleX = 1;
		}

		//set alpha if blinking
		if(hyena.physical_instance.blinking && hyena.physical_instance.blink_timer%2 == 1){
			hyena.alpha = 0;
		}else{
			hyena.alpha = 1;
		}
	};
	
	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = HyenaRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "HyenaRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],50:[function(require,module,exports){
var MedusaRenderer = (function(){

	var spritesheets = {};
	var Medusa_animation;

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
		 	use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/

		include(); // satisfy requirements, GOES FIRST
		var get_asset = AssetController.get_asset;

		spritesheets["Medusa"] = new createjs.SpriteSheet({
			"framerate": 1,
			"images": [get_asset("Medusa1"),], //MedusaSpriteSheet
			"frames": { "regX": 0, "regY": 0, "height": 85, "width": 47.5, "count": 3},
				"animations": {
				"walk": [0, 2, "walk", 0.2],
				"injury": {
				    frames: [2, 3, .25]
				},
				"death": [2, 3, "death", 0.6],
                
			}
		})

	};

	var register = function(entity_Medusa){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		Medusa_animation = GraphicsController.request_animated(spritesheets["Medusa"], "walk");
		GraphicsController.set_reg_position(Medusa_animation, 0, 0); // change that to adjust sprite position relative to the body
		GraphicsController.reg_for_render(Medusa_animation, entity_Medusa); // sets medusa_animation's position to track the medusa's position (updates each tick)

		
	};

	var render = function(Medusa){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/

		Medusa_special_render_temp(Medusa); 
	};

	var Medusa_special_render_temp = function(Medusa){
		/* how to handle special render? TEMPORARY */

		//set graphical representation based on the animation variable determined by the AI
		//set animation
		if(Medusa.physical_instance.needs_graphics_update){
			var animation = Medusa.physical_instance.animation;
			Medusa.gotoAndPlay(animation)
		}
		
		//set direction
		if (Medusa.physical_instance.direction){ //if direction == right, flip right
			Medusa.scaleX = -1;
		}else{ //else flip left
			Medusa.scaleX = 1;
		}

		//set alpha if blinking
		if(Medusa.physical_instance.blinking && Medusa.physical_instance.blink_timer%2 == 1){
			Medusa.alpha = 0;
		}else{
			Medusa.alpha = 1;
		}
	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = MedusaRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "MedusaRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

},{"../Includes.js":19}],51:[function(require,module,exports){
var PizzaRenderer = (function () {

    var spritesheets = {}; // to store spritesheets used by this entity

    var init = function () {
        include(); // satisfy requirements, GOES FIRST
        var get_asset = AssetController.get_asset;
        spritesheets["pizza"] = new createjs.SpriteSheet({
            "framerate": 1,
            "images": [get_asset("pizza")],
            "frames": { "regX": 0, "regY": 0, "height": 15, "width": 15, "count": 1 },
            "animations": {
                "normal": [1, "walk"]
            }
        })
    };

    var register = function (entity_pizza) {
        pizza_animation = GraphicsController.request_animated(spritesheets["pizza"], "normal");
        GraphicsController.set_reg_position(pizza_animation, 0, 0); // change that to adjust sprite position relative to the body
        GraphicsController.reg_for_render(pizza_animation, entity_pizza); // sets ant_animation's position to track the ant's position (updates each tick)
    };

    var render = function (cell) {

    };

    return {
        // declare public
        init: init,
        register: register,
        render: render,
    };
})();

module.exports = PizzaRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
    current_module: "TerrainCellRenderer",
    include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function () { eval(include_data.module_statements); }


},{"../Includes.js":19}],52:[function(require,module,exports){
var TerrainCellRenderer = (function(){

	var spritesheets = {}; // to store spritesheets used by this entity

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
			use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/
		include(); // satisfy requirements, GOES FIRST

	};

	var register = function(entity_cell){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		
	};

	var render = function(cell){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/

	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = TerrainCellRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "TerrainCellRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],53:[function(require,module,exports){
var TerrainSliceRenderer = (function(){

	var spritesheets = {}; // to store spritesheets used by this entity

	var init = function(){
		/* is ran from GraphicsController.init once during game loading
			use this function to create spritesheets and such
			like spritesheets.first = new createjs.Spritesheet(...);
		*/
		include(); // satisfy requirements, GOES FIRST

	};

	var register = function(slice, PrivateGraphics){
		/* is ran for every entity of this type that was just created and should
		get graphics representation. You are given the entity instance and is supposed
		to crete graphics instance, and GraphicsController.reg_for_render(graphics_instance, entity_instance); it 
		*/

		// TODO: change that private crap to smth more useful
		// like make graphics controller special case in includes,
		// so that only interested people can get it
		var request_animated = PrivateGraphics.request_animated;
		var request_bitmap = PrivateGraphics.request_bitmap;
		var trans_xy = PrivateGraphics.trans_xy;
		var reg_for_render = PrivateGraphics.reg_for_render;

		for(var i = 0; i < slice.grid_rows; i++){
				for(var j = 0; j < slice.grid_columns; j++){
					var kind = slice.grid[i][j].kind;
					if(kind != 0){
						// TODO: should make proper terrain collection thing to pull from
						/*
						var tile_texture = ["grass", "middle_terrain", "bottom_terrain"][kind-1];
						var tile = request_bitmap(tile_texture);
						*/
						var surface_textures = ["grass_winter","grass_spring","grass_summer","grass_fall"];
						var position = slice.grid[i][j].position;
						if (kind == 1){ //if tile is part of the ground
							switch (position){
									case "surface":
										//console.log(WorldController.get_season());
										var tile_texture = surface_textures[WorldController.get_season()];
									break;
								case "underground":
									var tile_texture = "bottom_terrain";
									break;
							}
						}
						if (kind == 2){ //if tile is part of a platform
							switch (position){
								case "left":
									var tile_texture = "left_platform";;
									break;
								case "middle":
									var tile_texture = "middle_platform";
									break;
								case "right":
									var tile_texture = "right_platform";
									break;
							}
						}
						if (kind == 3){//if tile is actually just spikes
							var tile_texture = "platform_spikes";
						}
						var tile = request_bitmap(tile_texture);
						var physical_instance = slice.grid[i][j];
						var body_position = physical_instance.body.GetWorldCenter();
						var trans_pos = trans_xy(body_position);
						tile.x = trans_pos.x;
						tile.y = trans_pos.y;
						reg_for_render(tile, physical_instance);
					} // end tile_texture assignment
				} // end for
			}//end for
		
	};

	var render = function(slice){
		/* 	is ran each tick from GraphicsController, for every registered object of this type
			is given >graphics_instance< parameter, which is also supposed to contain
			physical_instance property containing entity_instance, if it was attched correctly
		*/

	};

	return {
		// declare public
		init: init, 
		register: register,
		render: render,
	};
})();

module.exports = TerrainSliceRenderer;

var Includes = require("../Includes.js"); var include_data = Includes.get_include_data({
	current_module: "TerrainSliceRenderer", 
	include_options: Includes.choices.RENDERER_SPECIFIC
}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}


},{"../Includes.js":19}],54:[function(require,module,exports){

/*
 * Rules for working on the (client-side) game code:
 *
 * 1. If you think that one of these rules is stupid or useless, tell me, along with some better suggestions.
 *
 * 2. Model [name]Model can only be accessed through [name]Controller. If you need to do something to 
 * 		change [name]Model from [other_name]Controller, write function in the [name]Controller that does
 * 		what you need, and call it from the [other_name]Controller
 *
 * 3. Controllers are allowed to have private methods/fields. Models aren't. 
 *
 * 4. Controllers aren't allowed to have public data fields. 
 * 		Those data fields that are present must not reflect state of the game, they must be related to
 * 		some internal functionality of the controller
 *
 * 5. If you write some function that doesn't logically belong to one of the controllers,
 * 		put it in the Utility
 *
 * 6. Variables are named like that: variable_name
 * 		Except (singleton)class names, that are written like that: ClassName
 *
 * 7. And all the obvious stuff that everyone knows:
 * 		function must do one thing; don't make function public unless it needs to be that; 
 * 		comment ambigious code, for larger functions indicate their purpose (through commenting);
 */


// main namespace that is exposed to global scope (window object)
window.sidescroller_game = (function namespace(){

		var Includes = require("./Includes.js"); var include_data = Includes.get_include_data({
		current_module: "None", 
		include_options: Includes.choices.ALL_CONTROLLERS
	}); eval(include_data.name_statements); var include = function(){eval(include_data.module_statements);}

	// Game initiation section: >>>
		
	var load_game = function(mode, session_id, player_id, player_id_array)
	{
	
		Includes.init(); // first
		include(); // second

		InitController.init(mode, session_id, player_id, player_id_array); // init all the stuff

		if(mode == "test"){
			TestController.test();
		}
	};


	var run = function(mode, session_id, player_id, player_id_array)
	{
		// done this way to ensure that load_game's internals aren't accessible to the world:
		load_game(mode, session_id, player_id, player_id_array);
	}; 
	
	return {
		run: run
	}; // expose function run to the world

})(); 


},{"./Includes.js":19}],55:[function(require,module,exports){
/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
"use strict"

var Box2D = {};

(function (a2j, undefined) {
   
   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };
   
   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };
   
   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };
   
   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };
   
   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }
   
})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < Number.MIN_VALUE) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < Number.MIN_VALUE) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < Number.MIN_VALUE) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
       function QueryCallback(proxy) {
          if (proxy == queryProxy) return true;
          if (__this.m_pairCount == __this.m_pairBuffer.length) {
             __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
          }
          var pair = __this.m_pairBuffer[__this.m_pairCount];
          pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
          pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
          return true;
       };
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < Number.MIN_VALUE) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + Number.MIN_VALUE) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - Number.MIN_VALUE) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-Number.MIN_VALUE);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * Number.MIN_VALUE;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < Number.MIN_VALUE) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
         var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
         if (overlap == false) {
            cNuke = c;
            c = cNuke.GetNext();
            this.Destroy(cNuke);
            continue;
         }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
         b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
         b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b.m_xf;
            for (f = b.GetFixtureList();
            f; f = f.m_next) {
               s = f.GetShape();
               if (b.IsActive() == false) {
                  color.Set(0.5, 0.5, 0.3);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_staticBody) {
                  color.Set(0.5, 0.9, 0.5);
                  this.DrawShape(s, xf, color);
               }
               else if (b.GetType() == b2Body.b2_kinematicBody) {
                  color.Set(0.5, 0.5, 0.9);
                  this.DrawShape(s, xf, color);
               }
               else if (b.IsAwake() == false) {
                  color.Set(0.6, 0.6, 0.6);
                  this.DrawShape(s, xf, color);
               }
               else {
                  color.Set(0.9, 0.7, 0.7);
                  this.DrawShape(s, xf, color);
               }
            }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (Number.MIN_VALUE < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < Number.MIN_VALUE) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= Number.MIN_VALUE) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            }
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();

module.exports = Box2D
},{}]},{},[54])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIkIyZC5qcyIsIkNvbmZpZy5qcyIsIkNvbnRyb2xsZXJzL0Fzc2V0Q29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL0VudGl0eUNvbnRyb2xsZXIuanMiLCJDb250cm9sbGVycy9HYW1lQ29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL0dyYXBoaWNzQ29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL0lkZW50aWZpY2F0aW9uQ29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL0luaXRDb250cm9sbGVyLmpzIiwiQ29udHJvbGxlcnMvS2V5Ym9hcmRDb250cm9sbGVyLmpzIiwiQ29udHJvbGxlcnMvTXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL05ldHdvcmtDb250cm9sbGVyLmpzIiwiQ29udHJvbGxlcnMvUGh5c2ljc0NvbnRyb2xsZXIuanMiLCJDb250cm9sbGVycy9SZWdpc3RlckFzQ29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL1RlcnJhaW5Db250cm9sbGVyLmpzIiwiQ29udHJvbGxlcnMvVGVycmFpblNsaWNlQ29udHJvbGxlci5qcyIsIkNvbnRyb2xsZXJzL1Rlc3RDb250cm9sbGVyLmpzIiwiQ29udHJvbGxlcnMvV29ybGRDb250cm9sbGVyLmpzIiwiR2FtZVV0aWxpdHkuanMiLCJJbmNsdWRlcy5qcyIsIkxvZ2ljL0FudExvZ2ljLmpzIiwiTG9naWMvQ2VudGF1ckxvZ2ljLmpzIiwiTG9naWMvRXN0ZWVtZWRDb21wYW5pb25Mb2dpYy5qcyIsIkxvZ2ljL0dyaWZmaW5Mb2dpYy5qcyIsIkxvZ2ljL0hlcm9Mb2dpYy5qcyIsIkxvZ2ljL0h5ZW5hTG9naWMuanMiLCJMb2dpYy9NZWR1c2FMb2dpYy5qcyIsIkxvZ2ljL1BpenphTG9naWMuanMiLCJNb2RlbHMvQXNzZXRNb2RlbC5qcyIsIk1vZGVscy9FbnRpdHlNb2RlbC5qcyIsIk1vZGVscy9HYW1lTW9kZWwuanMiLCJNb2RlbHMvR3JhcGhpY3NNb2RlbC5qcyIsIk1vZGVscy9JZGVudGlmaWNhdGlvbk1vZGVsLmpzIiwiTW9kZWxzL0tleWJvYXJkTW9kZWwuanMiLCJNb2RlbHMvTXVsdGlwbGF5ZXJTeW5jTW9kZWwuanMiLCJNb2RlbHMvTmV0d29ya01vZGVsLmpzIiwiTW9kZWxzL1BoeXNpY3NNb2RlbC5qcyIsIk1vZGVscy9SZWdpc3RlckFzTW9kZWwuanMiLCJNb2RlbHMvVGVycmFpbk1vZGVsLmpzIiwiTW9kZWxzL1RlcnJhaW5TbGljZU1vZGVsLmpzIiwiTW9kZWxzL1Rlc3RNb2RlbC5qcyIsIk1vZGVscy9Xb3JsZE1vZGVsLmpzIiwiUmVuZGVyZXJzL0FudFJlbmRlcmVyLmpzIiwiUmVuZGVyZXJzL0JhY2tncm91bmRSZW5kZXJlci5qcyIsIlJlbmRlcmVycy9DZW50YXVyUmVuZGVyZXIuanMiLCJSZW5kZXJlcnMvRXN0ZWVtZWRDb21wYW5pb25SZW5kZXJlci5qcyIsIlJlbmRlcmVycy9HcmlmZmluUmVuZGVyZXIuanMiLCJSZW5kZXJlcnMvSFVEUmVuZGVyZXIuanMiLCJSZW5kZXJlcnMvSGVyb1JlbmRlcmVyLmpzIiwiUmVuZGVyZXJzL0h5ZW5hUmVuZGVyZXIuanMiLCJSZW5kZXJlcnMvTWVkdXNhUmVuZGVyZXIuanMiLCJSZW5kZXJlcnMvUGl6emFSZW5kZXJlci5qcyIsIlJlbmRlcmVycy9UZXJyYWluQ2VsbFJlbmRlcmVyLmpzIiwiUmVuZGVyZXJzL1RlcnJhaW5TbGljZVJlbmRlcmVyLmpzIiwibWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9ib3gyZHdlYi9ib3gyZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ253QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9jQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gVGhpcyBmaWxlIGNvbnRhaW5zIHNob3J0Y3V0cyBmb3IgdGhlIG1ldGhvZHMgb2YgdGhlIEJveDJEIGxpYnJhcnkgdGhhdCBhcmUgdXNlZFxyXG4vLyB0b28gb2Z0ZW4gdG8gdHlwZSB0aGVpciBsb25nIG5hbWVzXHJcblxyXG52YXIgQjJkID0gZnVuY3Rpb24oKXtcclxuXHJcbn07XHJcblxyXG5CMmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpe1xyXG5cdGluY2x1ZGUoKTtcclxuXHJcblx0dGhpcy5iMlZlYzIgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzI7XHJcblx0dGhpcy5iMkJvZHlEZWYgPSBCb3gyRC5EeW5hbWljcy5iMkJvZHlEZWY7XHJcblx0dGhpcy5iMkJvZHkgPSBCb3gyRC5EeW5hbWljcy5iMkJvZHk7XHJcblx0dGhpcy5iMkZpeHR1cmVEZWYgPSBCb3gyRC5EeW5hbWljcy5iMkZpeHR1cmVEZWY7XHJcblx0dGhpcy5iMkZpeHR1cmUgPSBCb3gyRC5EeW5hbWljcy5iMkZpeHR1cmU7XHJcblx0dGhpcy5iMldvcmxkID0gQm94MkQuRHluYW1pY3MuYjJXb3JsZDtcclxuXHR0aGlzLmIyTWFzc0RhdGEgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyTWFzc0RhdGE7XHJcblx0dGhpcy5iMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGU7XHJcblx0dGhpcy5iMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlO1xyXG5cdHRoaXMuYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdzsgXHJcblx0dGhpcy5iMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyO1xyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IEIyZDtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiQjJkXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5PVEhFUl9TVFVGRlxyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJ2YXIgQ29uZmlnID0gZnVuY3Rpb24oKXtcclxuXHR0aGlzLlNDUkVFTl9XID0gMDsgLy8gc2V0IHVwIHdoZW4gdGhlIHBhZ2UgaXMgbG9hZGVkICh0byA5NSUgb2Ygd2lkdGggb2YgY29udGFpbmluZyBlbGVtZW50KSBcclxuXHR0aGlzLlNDUkVFTl9IID0gNjAwO1xyXG5cclxuXHR0aGlzLk1BSU5fQ0FOVkFTX05BTUUgPSBcImRpc3BsYXlfY2FudmFzXCI7XHJcblx0dGhpcy5ERUJVR19DQU5WQVNfTkFNRSA9IFwiZGVidWdfY2FudmFzXCI7XHJcblxyXG5cdC8vIEZyYW1lcyBQZXIgU2Vjb25kLiBFc3NlbnRpYWxseSwgZnJlcXVlbmN5IG9mIGNyZWF0ZWpzLlRpY2tlciBcclxuXHQvLyBXYXJuaW5nISBGcmVxdWVuY3kgb2YgdGhlIEJveDJEIHBoeXNpY3MgdXBkYXRlcyBtYXkgYmUgZGlmZmVyZW50XHJcblx0Ly8gKEN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQpXHJcblx0dGhpcy5GUFMgPSAzMDsgXHJcblx0XHJcblx0Ly90aGUgbW92ZW1lbnQgZWRnZSwgY29udHJvbHMgdGVycmFpbiBnZW5lcmF0aW9uXHJcblx0dGhpcy5tb3ZlbWVudF9lZGdlID0gMDtcclxuXHJcblx0Ly8gQm94MkQgc3R1ZmYgPj4+XHJcblx0dGhpcy5CMkQgPSB7XHJcblx0XHRTQ0FMRTogMzAsXHJcblx0XHRTUFM6IDYwLCBcdFx0XHQvLyBTdGVwcyBQZXIgU2Vjb25kXHJcblx0XHRWRUxPQ0lUWV9JVFI6IDgsXHQvLyB2ZWxvY2l0eSBpdGVyYXRpb25zXHJcblx0XHRQT1NJVElPTl9JVFI6IDMsXHQvLyBwb3NpdGlvbiBpdGVyYXRpb25zXHJcblx0XHRkZWJ1Z19kcmF3OiBmYWxzZVxyXG5cdH07XHJcblxyXG5cdHRoaXMuVGVycmFpblNsaWNlID0ge1xyXG5cdFx0Z3JpZF9yb3dzOiAyMCxcclxuXHRcdGdyaWRfY29sdW1uczogMjAsXHJcblx0XHRjZWxsX3c6IDEsIC8vIGluIG1ldGVyc1xyXG5cclxuXHRcdC8vIGlzIGF1dG9tYXRpY2FsbHkgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIG5ldyBUZXJyYWluU2xpY2VNb2RlbCBpcyBpbnN0YW50aWF0ZWQ6XHJcblx0XHRuZXh0X3NsaWNlX2lkOiAwIFxyXG5cdH07XHJcblxyXG5cdHRoaXMuV29ybGQgPSB7XHJcblx0XHRtYXh5OiAyMixcclxuXHJcblx0fTtcclxuXHR0aGlzLlJlbW90ZSA9IHtcclxuXHRcdG1hc3RlcjogZmFsc2UsIC8vIGFtIEkgdGhlIG9uZSB3aXRoIHdob21lIG90aGVyIHBsYXllcnMgc3luYz8gXHJcblx0XHRjb25uZWN0ZWQ6IGZhbHNlLCAvLyBhbSBJIGluIG11bHRpcGxheWVyIG1vZGVcclxuXHRcdGNvbm5lY3Rpb25fdGltZW91dDogMTAwMCwgLy8gbXNcclxuXHRcdG5vdGlmaWNhdGlvbl93YWl0OiAzMDAwLCAvLyBtcyAhISEgU0hPVUxEIEJFIEFUIExFQVNUIDEwMDAgYmlnZ2VyIFRIQU4gVEhFIFBSRVZJT1VTIE9ORVxyXG5cdH07XHJcblx0XHJcblx0dGhpcy5Jbml0ID0ge1xyXG5cdFx0c2Vzc2lvbl9pZDogbnVsbCxcclxuXHRcdHBsYXllcl9pZDogbnVsbCxcclxuXHRcdG1vZGU6IG51bGwsXHJcblxyXG5cdFx0Ly8gZm9yIG11bHRpcGxheWVyIGdhbWUgeW91IGhhdmUgY2VydGFpbiB0aW1lIGxpbWl0XHJcblx0XHQvLyB0byBqb2luIHRoZSBnYW1lLiBJbiB0aGlzIHRpbWUgbGltaXQgcGxheWVycyBzaG91bGRuJ3QgYmUgYWJsZSB0byBnbyBwYXN0XHJcblx0XHQvLyBjZXJ0YWluIHBvaW50IG9mIHRoZSBtYXAuXHJcblx0XHRtb3ZlbWVudF9ibG9ja2VkOiB0cnVlLFxyXG5cdFx0dGltZV9saW1pdDogMTUsIC8vIHNlY29uZHNcclxuXHRcdC8vIHdlIHNob3VsZCBiZWdpbiBhdXRvbWF0aWNhbGx5IGFmdGVyIGV2ZXJ5b25lIGlzIGpvaW5lZFxyXG5cclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb25maWc7XHJcbiIsIlxyXG52YXIgQXNzZXRDb250cm9sbGVyID0gKGZ1bmN0aW9uKCl7XHJcblx0LypcclxuXHQgICBBc3NldENvbnRyb2xsZXIgaXMgaW4gY2hhcmdlIG9mIHNldHRpbmcgdXAgYWxsIGJpdG1hcHMvYW5pbWF0aW9ucy9vdGhlciByZXNvdXJjZXNcclxuXHQgICBmb3IgZXZlcnlvbmUgZWxzZS5cclxuICAgKi9cclxuXHJcblx0Ly8gdXNlIEFzc2V0TW9kZWwubG9hZGVyLmdldFJlc3VsdChcImlkX29mX3RoZV9hc3NldFwiKTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbihhc3NldF9wYXRoKXtcclxuXHRcdGluY2x1ZGUoKTtcdFxyXG5cclxuXHRcdC8qIFRPRE8gbWFrZSBtb2RlbCB3aXRoIHRoZSBlYXNpbHkgbWFuYWdlZCB0YWJsZXMgb2YgcmVzb3VyY2VzIHdoaWNoIHdpbGwgYmVcclxuXHRcdCAgIGFkZGVkIHRvIHRoZSBsb2FkZXIgYXV0b21hdGljYWxseVxyXG5cdFx0Ki9cclxuXHJcblx0XHQvL2xvYWRlciA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoZmFsc2UpOyAvLyBsb2FkaW5nIHJlc291cnNlcyB1c2luZyBwcmVsb2FkLmpzXHJcblx0XHQvL2xvYWRlci5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgaGFuZGxlQ29tcGxldGUpO1xyXG5cdFx0dmFyIG1hbmlmZXN0ID0gQXNzZXRNb2RlbC5tYW5pZmVzdDtcdFxyXG5cdFx0QXNzZXRNb2RlbC5sb2FkZXIubG9hZE1hbmlmZXN0KG1hbmlmZXN0LCB0cnVlLCBhc3NldF9wYXRoKTtcclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciBwb3N0X2luaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGRvbmUgZGlmZmVyZW50bHkgYXQgc29tZSBwb2ludFxyXG5cdFx0ICogaXQnbGwgaGF2ZSBzb21ldGhpbmcgdG8gZG8gd2l0aCByZWZhY3RvcmluZyBJbml0Q29udHJvbGxlclxyXG5cdFx0ICovXHJcblxyXG5cdFx0Ly9Bc3NldE1vZGVsLmFuaW1hdGlvbnNbXCJhbnRcIl0gPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoe1xyXG5cdFx0XHQvL1wiZnJhbWVyYXRlXCI6IDAuMixcclxuXHRcdFx0Ly9cImltYWdlc1wiOiBbZ2V0X2Fzc2V0KFwiQW50MVwiKSwgZ2V0X2Fzc2V0KFwiQW50MlwiKSwgZ2V0X2Fzc2V0KFwiQW50M1wiKV0sXHJcblx0XHRcdC8vXCJmcmFtZXNcIjogeyBcInJlZ1hcIjogMywgXCJyZWdZXCI6IDYsIFwiaGVpZ2h0XCI6IDI1LCBcIndpZHRoXCI6IDUwLCBcImNvdW50XCI6IDZ9LFxyXG5cdFx0XHQvL1wiYW5pbWF0aW9uc1wiOiB7XHJcblx0XHRcdFx0Ly9cIndhbGtcIjogWzAsIDEsIFwid2Fsa1wiXSxcclxuXHRcdFx0XHQvL1widXBzaWRlX2Rvd25cIjogWzIsIDMsIFwidXBzaWRlX2Rvd25cIl0sXHJcblx0XHRcdFx0Ly9cImRlYXRoXCI6IFs0LCA1LCBcImRlYXRoXCJdXHJcblx0XHRcdC8vfVxyXG5cdFx0Ly99KVxyXG5cclxuXHR9O1xyXG5cdFxyXG5cclxuXHR2YXIgZ2V0X2Fzc2V0ID0gZnVuY3Rpb24oaWQpe1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBBc3NldE1vZGVsLmxvYWRlci5nZXRSZXN1bHQoaWQpO1xyXG5cclxuXHRcdGlmKCFyZXN1bHQpe1xyXG5cdFx0XHR0aHJvdyBcIkVycm9yOiBhc3NldCB3aXRoIGlkIFwiICsgaWQgKyBcIiBjb3VsZCBub3QgYmUgbG9hZGVkLlwiICtcclxuXHRcdFx0XHRcIiBDaGVjayB0aGF0IGlkIGlzIHZhbGlkIGFuZCB0aGF0IGFzc2V0cyB3ZXJlIHByb3Blcmx5IGxvYWRlZFwiO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblx0XHRcclxuXHJcblxyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHRpbml0OiBpbml0LFxyXG5cdFx0Z2V0X2Fzc2V0OiBnZXRfYXNzZXQsXHJcblx0fTtcclxuXHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2V0Q29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkFzc2V0Q29udHJvbGxlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuREVGQVVMVFxyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJ2YXIgRW50aXR5Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiBEZXNjcmlwdGlvblxyXG4gICAgKi9cclxuXHJcbiAgICB2YXIgdHlwZV9sb2dpY190YWJsZTtcclxuXHJcbiAgICB2YXIgQ291bnQgPSAwO1xyXG5cclxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qIGlzIHJhbiBmcm9tIHRoZSBJbml0Q29udHJvbGxlciBvbmNlIHdoZW4gdGhlIGdhbWUgaXMgbG9hZGVkICovXHJcblxyXG4gICAgICAgIGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHRcdC8vdHlwZV9sb2dpY190YWJsZSA9IHtcclxuXHRcdC8vXHRcImFudFwiOiBBbnRMb2dpYyxcclxuXHRcdC8vXHRcImhlcm9cIjogSGVyb0xvZ2ljLFxyXG5cdFx0Ly9cdFwiY29tcGFuaW9uXCI6IEVzdGVlbWVkQ29tcGFuaW9uTG9naWMsXHJcblx0XHQvL307XHJcblxyXG4gICAgICAgIHR5cGVfbG9naWNfdGFibGUgPSB7XHJcbiAgICAgICAgICAgIFwiYW50XCI6IEFudExvZ2ljLFxyXG4gICAgICAgICAgICBcImhlcm9cIjogSGVyb0xvZ2ljLFxyXG4gICAgICAgICAgICBcIkdyaWZmaW5cIjogR3JpZmZpbkxvZ2ljLFxyXG4gICAgICAgICAgICBcIkh5ZW5hXCI6IEh5ZW5hTG9naWMsXHJcblx0XHRcdFwiTWVkdXNhXCI6IE1lZHVzYUxvZ2ljLFxyXG5cdFx0XHRcInBpenphXCI6IFBpenphTG9naWMsXHJcbiAgICAgICAgICAgIFwiQ2VudGF1clwiOiBDZW50YXVyTG9naWMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgZm9yICh0eXBlIGluIHR5cGVfbG9naWNfdGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIGxvZ2ljID0gdHlwZV9sb2dpY190YWJsZVt0eXBlXTtcclxuICAgICAgICAgICAgbG9naWMuaW5pdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxvZ2ljLmJlZ2luX2NvbnRhY3QpIHtcclxuICAgICAgICAgICAgICAgIFBoeXNpY3NDb250cm9sbGVyLmxpc3Rlbl9mb3JfY29udGFjdF93aXRoKHR5cGUsIFwiQmVnaW5Db250YWN0XCIsIGxvZ2ljLmJlZ2luX2NvbnRhY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobG9naWMuZW5kX2NvbnRhY3QpIHtcclxuICAgICAgICAgICAgICAgIFBoeXNpY3NDb250cm9sbGVyLmxpc3Rlbl9mb3JfY29udGFjdF93aXRoKHR5cGUsIFwiRW5kQ29udGFjdFwiLCBsb2dpYy5lbmRfY29udGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsb2dpYy5wcmVfc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIFBoeXNpY3NDb250cm9sbGVyLmxpc3Rlbl9mb3JfY29udGFjdF93aXRoKHR5cGUsIFwiUHJlU29sdmVcIiwgbG9naWMucHJlX3NvbHZlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxvZ2ljLnBvc3Rfc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIFBoeXNpY3NDb250cm9sbGVyLmxpc3Rlbl9mb3JfY29udGFjdF93aXRoKHR5cGUsIFwiUG9zdFNvbHZlXCIsIGxvZ2ljLnBvc3Rfc29sdmUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuXHJcblx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKXtcclxuXHRcdC8qIGlzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgR2FtZUNvbnRyb2xsZXIudXBkYXRlX2FsbCAqL1xyXG5cdFx0dmFyIGRlYnVnX2NvbW1hbmRzID0gS2V5Ym9hcmRDb250cm9sbGVyLmRlYnVnX2NvbW1hbmRzKCk7XHJcblxyXG5cdFx0Ly8gZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xyXG5cdFx0aWYoZGVidWdfY29tbWFuZHMoXCJzcGF3bl9hbnRcIikpe1xyXG5cdFx0ICAgIHNwYXduKChNYXRoLnJhbmRvbSgpICogNTAgKyAxMCArIFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpKSwgMTAsIFwiYW50XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkZWJ1Z19jb21tYW5kcyhcInNwYXduX3BpenphXCIpKSB7XHJcblx0XHQgICAgc3Bhd24oKE1hdGgucmFuZG9tKCkgKiA1MCArIDEwICsgV29ybGRDb250cm9sbGVyLmdldF9tb3ZlbWVudF9lZGdlKCkpLCAxNiwgXCJwaXp6YVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihkZWJ1Z19jb21tYW5kcyhcInJlcXVlc3RfaGVyb1wiKSAmJiAhRW50aXR5TW9kZWwuaGVyb19zcGF3bmVkKXtcclxuXHRcdFx0Ly8gaWYgaGVybyBpcyByZXF1ZXN0ZWQsIGFuZCBub3Qgc3Bhd25lZCB5ZXQsXHJcblx0XHRcdC8vIHNwYXduIGhlcm9cclxuXHRcdFx0XHJcblx0XHRcdEVudGl0eU1vZGVsLmhlcm9fc3Bhd25lZCA9IHRydWU7XHJcblx0XHRcdHNwYXduKFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpICsgMTAsMTAsIFwiaGVyb1wiKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZGVidWdfY29tbWFuZHMoXCJzcGF3bl9ncmlmZmluXCIpICYmIENvdW50ID4gNSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3X2dyaWZmaW4gPSBzcGF3bihNYXRoLnJhbmRvbSgpICogNTAgKyBXb3JsZENvbnRyb2xsZXIuZ2V0X21vdmVtZW50X2VkZ2UoKSwgLTIwLCBcIkdyaWZmaW5cIik7XHJcbiAgICAgICAgICAgIENvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQ291bnQrKztcclxuXHJcbiAgICAgICAgaWYgKGRlYnVnX2NvbW1hbmRzKFwic3Bhd25fZ3JpZmZpblwiKSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3X2dyaWZmaW4gPSBzcGF3bihNYXRoLnJhbmRvbSgpICogNTAgKyBXb3JsZENvbnRyb2xsZXIuZ2V0X21vdmVtZW50X2VkZ2UoKSwgMTAsIFwiR3JpZmZpblwiKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIGZvciBoeWVuYVxyXG4gICAgICAgIGlmIChkZWJ1Z19jb21tYW5kcyhcInNwYXduX2h5ZW5hXCIpKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdfaHllbmEgPSBzcGF3bihNYXRoLnJhbmRvbSgpICogNTAgKyBXb3JsZENvbnRyb2xsZXIuZ2V0X21vdmVtZW50X2VkZ2UoKSwgMTAsIFwiSHllbmFcIik7XHJcbiAgICAgICAgfVxyXG5cdFx0XHJcblx0XHQvLyBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIGZvciBNZWR1c2FcclxuICAgICAgICBpZiAoZGVidWdfY29tbWFuZHMoXCJzcGF3bl9tZWR1c2FcIikpIHtcclxuICAgICAgICAgICAgdmFyIG5ld19NZWR1c2EgPSBzcGF3bihNYXRoLnJhbmRvbSgpICogNTAgKyBXb3JsZENvbnRyb2xsZXIuZ2V0X21vdmVtZW50X2VkZ2UoKSwgMTAsIFwiTWVkdXNhXCIpO1xyXG4gICAgICAgIH1cclxuXHJcblx0ICAgIC8vIGRlbW9uc3RyYXRpb24gcHVycG9zZXMgZm9yIENlbnRhdXJcclxuICAgICAgICBpZiAoZGVidWdfY29tbWFuZHMoXCJzcGF3bl9jZW50YXVyXCIpKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdfQ2VudGF1ciA9IHNwYXduKE1hdGgucmFuZG9tKCkgKiA1MCArIFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpLCAxMCwgXCJDZW50YXVyXCIpO1xyXG4gICAgICAgIH1cclxuXHRcdFxyXG5cclxuXHRcdC8qXHJcblx0XHQvL1RoaXMgc2hvdWxkIGJlIGhhbmRsZWQgaW4gdGhlIHVwZGF0ZSBvZiBNdWx0aXBsYXllclN5bmNcclxuXHRcdGlmKENvbmZpZy5SZW1vdGUubWFzdGVyKXsvL2lmIG1hc3RlciwgcGFyc2UgcmVxdWVzdHNcclxuXHRcdFx0TXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlci5yZWNlaXZlX3NwYXduX3JlcXVlc3QoKTtcclxuXHRcdH1lbHNlIGlmKENvbmZpZy5SZW1vdGUuY29ubmVjdGVkKXsvL2lmIHNsYXZlLCBwYXJzZSBub3RpZmljYXRpb25zXHJcblx0XHRcdE11bHRpcGxheWVyU3luY0NvbnRyb2xsZXIucmVjZWl2ZV9zcGF3bl9ub3RpZmljYXRpb24oKTtcclxuXHRcdH1cclxuXHRcdCovXHJcblx0XHRmb3IgKHZhciB0eXBlIGluIEVudGl0eU1vZGVsLmZvcl9sb2dpY191cGRhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHRhYmxlID0gRW50aXR5TW9kZWwuZm9yX2xvZ2ljX3VwZGF0ZVt0eXBlXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBsb2dpYyA9IHR5cGVfbG9naWNfdGFibGVbdHlwZV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gdGFibGVbaWRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiZXlvbmRfd29ybGRfYm91bmRhcnkoZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG91dHNpZGUgYm91bmRhcmllcyBvZiB0aGUgd29ybGQsIGRlc3Bhd25cclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkucG9pbnRfdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3Bhd24oZW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50aXR5LnR5cGUgPT0gXCJoZXJvXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LmhwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbnRpdHkgb2YgdHlwZVwiLCB0eXBlLCBcImRlbGV0ZWQgZHVlIHRvIHRoZSB3b3JsZCBib3VuZGFyeVwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB0aWNrIGl0cyBBSVxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2ljLnRpY2tfQUkoZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IC8vIGVuZCBmb3IgaW4gXHJcblxyXG5cdFx0c3luY19oZXJvKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBzcGF3biA9IGZ1bmN0aW9uKHgsIHksIHR5cGUpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHNwYXduIGVudGl0eSBvZiB0eXBlID50eXBlPFxyXG5cdFx0KiBhdCBwb3NpdGlvbiAoeCwgeSlcclxuXHRcdCogISBub3RpY2UgdGhhdCBpdCBkb2Vzbid0IHNwYXduIGVudGl0eSBkaXJlY3RseSwgYnV0IGluc3RlYWQgc2VuZHMgdGhlIHJlcXVlc3RcclxuXHRcdCogISBmb3IgdGhlIGVudGl0eSBkZWxldGlvbiwgc28gdW5kZXRlcm1pbmF0ZSBhbW91bnQgb2YgdGltZSBtYXkgcGFzcyBmcm9tIHRoZVxyXG5cdFx0KiAhIG1vbWVudCB0aGlzIGZ1bmN0aW9uIHJldHVybmVkLCB1bnRpbCB0aGUgZW50aXR5IGlzIGFjdHVhbGx5IHNwYXduZWRcclxuXHRcdCogdGhpcyB0aW1lIHdpbGwgdXN1YWxseSBiZSByZWxhdGl2ZWx5IHNtYWxsLCBwcm9iYWJseSAyLTIwIHRpY2tzIG9yIHNvIGZvciBtdWx0aXBsYXllclxyXG5cdFx0Ki9cclxuXHJcblx0XHRNdWx0aXBsYXllclN5bmNDb250cm9sbGVyLnJvdXRlX291dGNvbWluZ19wYWNrZXQoe1xyXG5cdFx0XHRvcDogXCJzcGF3blwiLFxyXG5cdFx0XHR0eXBlOiB0eXBlLFxyXG5cdFx0XHR4OiB4LFxyXG5cdFx0XHR5OiB5XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgaGFuZGxlX3NwYXduID0gZnVuY3Rpb24ocGFja2V0KXtcclxuXHRcdC8qKlxyXG5cdFx0KiB0YWtlcyB0aGUgcGFja2V0IHdpdGggPm9wPCBcInNwYXduXCJcclxuXHRcdCogY29udGFpbmluZyBwcm9wZXJ0aWVzID54PCwgPnk8LCA+dHlwZTwsIGFuZCBwb3NzaWJseSBtb3JlXHJcblx0XHQqIGhhbmRsZXMgY3JlYXRpb24gb2YgdGhlIGVudGl0eSwgaWQgYXNzaWdubWVudCwgZXRjLlxyXG5cdFx0Ki9cclxuXHJcblx0XHRcclxuXHRcdHZhciB4ID0gcGFja2V0LngsXHJcblx0XHRcdHkgPSBwYWNrZXQueSxcclxuXHRcdFx0dHlwZSA9IHBhY2tldC50eXBlO1xyXG5cclxuXHRcdGlmKHR5cGVfbG9naWNfdGFibGVbdHlwZV0gPT0gbnVsbCl7XHJcblx0XHRcdHRocm93IFwiTm8gbG9naWMgZm91bmQgZm9yIHRoZSB0eXBlXCIgKyBTdHJpbmcodHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxvZ2ljID0gdHlwZV9sb2dpY190YWJsZVt0eXBlXTtcclxuXHRcdHZhciBlbnRpdHkgPSBsb2dpYy5zcGF3bih4LCB5KTtcclxuXHJcblx0XHRpZih0eXBlID09IFwiaGVyb1wiKXtcclxuXHRcdFx0Ly8gVE9ETzogbW92ZSB0aGlzIHdob2xlIHRoaW5nIGludG8gdGhlIEhlcm9Mb2dpYy5zcGF3bj9cclxuXHRcdFx0dmFyIHBsYXllcl9pZCA9IHBhY2tldC5wbGF5ZXJfaWQ7XHJcblx0XHRcdGlmKHBsYXllcl9pZCA9PSBudWxsKXtcclxuXHRcdFx0XHR0aHJvdyBcInBsYXllcl9pZCBpcyB1bmRlZmluZWRcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBpZGVudGlmeSB0aGUgaGVyb1xyXG5cdFx0XHRlbnRpdHkucGxheWVyX2lkID0gcGxheWVyX2lkO1xyXG5cdFx0XHQvLyBzdG9yZSBpdCBmb3IgRW50aXR5Q29udHJvbGxlciBwdXJwb3Nlc1xyXG5cdFx0XHRFbnRpdHlNb2RlbC5oZXJvZXNbcGxheWVyX2lkXSA9IGVudGl0eTtcclxuXHRcdH1cclxuXHJcblx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKGVudGl0eSk7XHJcblxyXG5cdFx0cmVnX2Zvcl9sb2dpY191cGRhdGUoZW50aXR5KTtcclxuXHJcblx0XHRSZWdpc3RlckFzQ29udHJvbGxlci5yZWdpc3Rlcl9hcyhcImF3YWl0aW5nX2dyYXBoaWNzX2luaXRpYWxpemF0aW9uXCIsIGVudGl0eSlcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdC8vcmVnaXN0ZXJzIGEgbmV3IGluc3RhbmNlXHJcblx0Ly9zbyB0aGF0IHJlbmRlcmVycyBhbmQgdXBkYXRlcnMga25vdyB0byB1cGRhdGUgaXQgb24gdGlja1xyXG5cdHZhciByZWdfZm9yX2xvZ2ljX3VwZGF0ZSA9IGZ1bmN0aW9uKG5ld19lbnRpdHkpe1xyXG5cdFx0dmFyIHR5cGUgPSBuZXdfZW50aXR5LnR5cGU7XHJcblxyXG5cdFx0aWYodHlwZSA9PSBudWxsKXtcclxuXHRcdFx0Y29uc29sZS5sb2cobmV3X2VudGl0eSk7XHJcblx0XHRcdHRocm93IFwiVHlwZSBpcyB1bmRlZmluZWQgZm9yIHRoaXMgZW50aXR5XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIUVudGl0eU1vZGVsLmZvcl9sb2dpY191cGRhdGVbdHlwZV0pe1xyXG5cdFx0XHRFbnRpdHlNb2RlbC5mb3JfbG9naWNfdXBkYXRlW3R5cGVdID0ge307XHJcblx0XHR9XHJcblx0XHR2YXIgbG9naWNfdXBkX3RhYmxlID0gRW50aXR5TW9kZWwuZm9yX2xvZ2ljX3VwZGF0ZVt0eXBlXTtcclxuXHRcdGxvZ2ljX3VwZF90YWJsZVtuZXdfZW50aXR5LmlkXSA9ICBuZXdfZW50aXR5O1xyXG5cdFx0XHJcblx0fTtcclxuXHRcclxuXHQvL3dyYXBwZXIgZm9yIHVuaXZlcnNhbCBzcGF3blxyXG5cdC8vbWFpbnRhaW5zIHRoZSBvbGQgaW50ZXJmYWNlXHJcblx0Ly92YXIgc3Bhd24gPSBmdW5jdGlvbih0eXBlLHgseSl7XHJcblx0XHQvL011bHRpcGxheWVyU3luY0NvbnRyb2xsZXIuaGFuZGxlX3NwYXduKHt0eXBlOnR5cGUseDp4LHk6eX0pO1xyXG5cdC8vfTtcclxuXHRcclxuXHR2YXIgZGVsZXRlX2VudGl0eSA9IGZ1bmN0aW9uKGVudGl0eV9pbnN0YW5jZSl7XHJcblx0XHQvKipcclxuXHRcdCogVGhpcyBmdW5jdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBjYWxsZWQgYnkgdGhlIGluZGl2aWR1YWwgbG9naWMgbW9kdWxlcywgd2hlbiB0aGUgYXJlIGZpbmlzaGVkXHJcblx0XHQqIGFuaW1hdGluZyBkZWF0L2Rlc3RydWN0aW9uIG9mIHNvbWV0aGluZyBhbmQgd2FudCB0byBnZXQgcmlkIG9mIGl0LCBvciBpbiBvdGhlciBjaXJjdW1zdGFuY2VzLFxyXG5cdFx0KiB3aGVuIGVudGl0eSBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGVsZXRlZCBmcm9tIHRoZSB3b3JsZFxyXG5cdFx0KiAhIG5vdGljZSB0aGF0IGl0IGRvZXNuJ3QgZGVsZXRlIGVudGl0eSBkaXJlY3RseSwgYnV0IGluc3RlYWQgc2VuZHMgdGhlIHJlcXVlc3RcclxuXHRcdCogISBmb3IgdGhlIGVudGl0eSBkZWxldGlvbiwgc28gdW5kZXRlcm1pbmF0ZSBhbW91bnQgb2YgdGltZSBtYXkgcGFzcyBmcm9tIHRoZVxyXG5cdFx0KiAhIG1vbWVudCB0aGlzIGZ1bmN0aW9uIHJldHVybmVkLCB1bnRpbCB0aGUgZW50aXR5IGlzIGFjdHVhbGx5IGRlbGV0ZWRcclxuXHRcdCogdGhpcyB0aW1lIHdpbGwgdXN1YWxseSBiZSByZWxhdGl2ZWx5IHNtYWxsLCBwcm9iYWJseSAyLTIwIHRpY2tzIG9yIHNvIGZvciBtdWx0aXBsYXllclxyXG5cdFx0Ki9cclxuXHJcblx0XHRNdWx0aXBsYXllclN5bmNDb250cm9sbGVyLnJvdXRlX291dGNvbWluZ19wYWNrZXQoe1xyXG5cdFx0XHRvcDogXCJkZWxldGVfZW50aXR5XCIsXHJcblx0XHRcdGlkOiBlbnRpdHlfaW5zdGFuY2UuaWQsXHJcblx0XHRcdHR5cGU6IGVudGl0eV9pbnN0YW5jZS50eXBlLFxyXG5cdFx0fSk7XHJcblxyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZV9kZWxldGUgPSBmdW5jdGlvbihwYWNrZXQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIFRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgdGhpcyBlbnRpdHkgYWxvbmcgd2l0aCBzb21lIG90aGVyIGluZm8gYWJvdXQgdGhpcyBlbnRpdHlcclxuXHRcdCogZnJvbSB0aGUgd29ybGQsIGl0J2xsIGFsc28gZnJlZSB0aGUgaWQgb2YgdGhpcyBlbnRpdHkuIFRoZSBwaHlzaWNhbCBib2R5IHdpbGwgYmUgZGVsZXRlZFxyXG5cdFx0KiB0b287IFxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgZW50aXR5X2luc3RhbmNlID0gRW50aXR5TW9kZWwuZm9yX2xvZ2ljX3VwZGF0ZVtwYWNrZXQudHlwZV1bcGFja2V0LmlkXTtcclxuXHJcblx0XHRpZihlbnRpdHlfaW5zdGFuY2UgPT0gbnVsbCl7XHJcblx0XHRcdC8vIGlmIG5vIHN1Y2ggZW50aXR5LFxyXG5cdFx0XHQvLyBwcm9iYWJseSBpdCB3YXMgYWxyZWFkeSBkZWxldGVkIHRocm91Z2ggb3RoZXIgbWVhbnMsXHJcblx0XHRcdC8vIHRodXMgYWJvcnRcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFxyXG5cdFx0dmFyIHR5cGUgPSBlbnRpdHlfaW5zdGFuY2UudHlwZTtcclxuXHRcdGlmKHR5cGUgPT0gbnVsbCl7XHJcblx0XHRcdGNvbnNvbGUubG9nKGVudGl0eV9pbnN0YW5jZSk7XHJcblx0XHRcdHRocm93IFwidHlwZSBpcyB1bmRlZmluZWQgZm9yIHRoaXMgZW50aXR5XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlkID0gZW50aXR5X2luc3RhbmNlLmlkO1xyXG5cdFx0aWYoaWQgPT0gbnVsbCl7XHJcblx0XHRcdGNvbnNvbGUubG9nKGVudGl0eV9pbnN0YW5jZSk7XHJcblx0XHRcdHRocm93IFwiaWQgaXMgdW5kZWZpbmVkIGZvciB0aGlzIGVudGl0eVwiO1xyXG5cdFx0fVxyXG5cdFx0XHJcblxyXG5cdFx0Ly8gVE9ETzogZmluaXNoIHRoaXMgZnVuY3Rpb24gYW5kIHRoZW4gdXBkYXRlIGl0IHJlZ3VsYXJseTtcclxuXHRcdC8vIFRoaXMgb25lIGlzIHZlcnkgc2Vuc2l0aXZlLCBhcyBldmVuIG9uZSByZWZlcmVuY2UgbGVmdCBtYXkgcHJldmVudCBcclxuXHRcdC8vIG9iamVjdCBmcm9tIGJlaW5nIGRlbGV0ZWQgYW5kIGNhdXNlIG1lbW9yeSBsZWFrcy4gVGVzdGluZyBpcyByZXF1aXJlZFxyXG5cdFx0aWYoZW50aXR5X2luc3RhbmNlLmJvZHkgIT0gbnVsbCl7XHJcblx0XHRcdHZhciBib2R5ID0gZW50aXR5X2luc3RhbmNlLmJvZHk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly8gYm9keSBpcyByZXF1aXJlZC4gaWYgcGxhY2Ugd2hlcmUgYm9keSBpcyBzdG9yZWQgY2hhbmdlZCwgeW91IHNob3VsZCB1cGRhdGUgdGhpcyBmdW5jdGlvblxyXG5cdFx0XHR0aHJvdyBcIkJvZHkgb2YgdGhlIGluc3RhbmNlIGlzIHVuZGVmaW5lZFwiXHJcblx0XHR9XHJcblx0XHQvLyByZW1vdmUgZ3JhcGhpY3NcclxuXHRcdFx0UmVnaXN0ZXJBc0NvbnRyb2xsZXIucmVnaXN0ZXJfYXMoXCJyZW1vdmVkX2VudGl0eVwiLCBlbnRpdHlfaW5zdGFuY2UpO1xyXG5cdFx0Ly8gcmVtb3ZlIHBoeXNpY3NcclxuXHRcdFx0UGh5c2ljc0NvbnRyb2xsZXIucmVtb3ZlX2JvZHkoYm9keSk7XHJcblx0XHQvLyByZW1vdmUgc3RvcmVkIHJlZmVyZW5jZXMgd2l0aGluIEVudGl0eUNvbnRyb2xsZXIvTW9kZWxcclxuXHRcdFx0ZGVsZXRlIEVudGl0eU1vZGVsLmZvcl9sb2dpY191cGRhdGVbdHlwZV1baWRdO1xyXG5cdFx0XHRpZih0eXBlID09IFwiaGVyb1wiKXtcclxuXHRcdFx0XHRkZWxldGUgRW50aXR5TW9kZWwuaGVyb2VzW2VudGl0eV9pbnN0YW5jZS5wbGF5ZXJfaWRdO1xyXG5cdFx0XHRcdEVudGl0eU1vZGVsLmhlcm9fc3Bhd25lZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHQvLyBmcmVlIHRoZSBpZFxyXG5cdFx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIucmVtb3ZlX2lkKGlkKTtcclxuXHR9O1xyXG5cclxuXHJcbiAgICB2YXIgZGVzcGF3biA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgZGVzcGF3biBnaXZlbiBlbnRpdHlcclxuICAgICAgICAgKiBpbiBvbmUgb2YgdHdvIHdheXM6XHJcbiAgICAgICAgICogaWYgZW50aXR5IGhhcyBkZXNwYXduIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZFxyXG4gICAgICAgICAqIGlmIG5vdCwgZW50aXR5IHdpbGwgYmUgZGVsZXRlZCBkaXJlY3RseVxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIHZhciB0eXBlID0gZW50aXR5LnR5cGU7XHJcbiAgICAgICAgdmFyIGlkID0gZW50aXR5LmlkO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKGVudGl0eS5kaWUpIHtcclxuICAgICAgICAgICAgLy8gaWYgY3VzdG9tIGRlc3Bhd24gZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGNhbGwgaXRcclxuXHRcdFx0ZW50aXR5LmRpZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImRpZSBjYWxsZWQgZm9yIHRoZSB0eXBlXCIsIHR5cGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG9yIGRlbGV0ZSBkaXJlY3RseVxyXG4gICAgICAgICAgICBkZWxldGVfZW50aXR5KGVudGl0eSk7XHJcblx0XHRcdGNvbnNvbGUud2FybihcImRpZSBmdW5jdGlvbiBub3QgZGVmaW5lZCBmb3IgdGhlIGVudGl0eSBvZiB0eXBlXCIsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXIgYmV5b25kX3dvcmxkX2JvdW5kYXJ5ID0gZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogY2hlY2tzIGlmIHRoZSBlbnRpdHkgaXMgYmV5b25kIG9uZSBvZiB0aGUgd29ybGQgYm91bmRhcmllcyxcclxuICAgICAgICAqL1xyXG4gICAgICAgIHZhciBib2R5ID0gZW50aXR5LmJvZHk7XHJcbiAgICAgICAgcmV0dXJuIChib2R5LkdldFdvcmxkQ2VudGVyKCkueCA8IFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpIHx8XHJcbiAgICAgICAgICAgIGJvZHkuR2V0V29ybGRDZW50ZXIoKS55ID4gQ29uZmlnLldvcmxkLm1heHkpO1xyXG5cclxuICAgIH07XHJcblx0XHRcclxuXHRcdFxyXG5cdHZhciBjcmVhdGVfYWJzdHJhY3RfZW50aXR5ID0gZnVuY3Rpb24oKXtcclxuXHRcdHJldHVybiBuZXcgQWJzdHJhY3RFbnRpdHkoKTtcclxuXHR9O1xyXG5cdFx0XHJcblx0XHRcclxuXHQvKipcclxuXHRjbGFzcyBBYnN0cmFjdEVudGl0eVxyXG5cdG1lbWJlciBmdW5jdGlvbnM6XHJcblx0XHQvL251bWJlcnMgYXJlIGdpdmVuIGluIG1ldGVycyByYXRoZXIgdGhhbiBwaXhlbHMgZXhjZXB0IHdoZXJlIG5vdGVkICgxIG1ldGVyID0gMzAgcGl4ZWxzKVxyXG5cdFx0Vk9JRCBqdW1wKGRvdWJsZSB4LCBkb3VibGUgeSlcclxuXHRcdFx0XHRcdGFwcGxpZXMgYW4gaW1wdWxzZSB3aXRoIHhfY29tcG9uZW50IHggYW5kIHlfY29tcG9uZW50IHlcclxuXHRcdFZPSUQganVtcF9kaXJlY3Rpb24oZG91YmxlIGFuZ2xlLCBkb3VibGUgZm9yY2UpXHJcblx0XHRcdFx0XHR3aGVyZSBhbmdsZSBpcyBpbiBkZWdyZWVzLiBjYWxscyBqdW1wIGludGVybmFsbHlcclxuXHRcdFZPSUQgbW92ZShkb3VibGUgc3BlZWQpXHJcblx0XHRcdFx0XHRjYXVzZXMgdGhlIGVudGl0eSB0byBtb3ZlIGhvcml6b250YWxseSBhdCBzcGVlZC90aWNrLiBcclxuXHRcdEJPT0wgZW5lbXlfaW5fcmFuZ2VcclxuXHRcdFx0XHRcdHJldHVybnMgdHJ1ZSBpZiBhbnkgaGVybyBpcyB3aXRoaW4gcmFuZ2UgKHggYXhpcyBvbmx5KVxyXG5cdFx0Qk9PTCBkaXJlY3Rpb25fbmVhcmVzdF9lbmVteSgpXHJcblx0XHRcdFx0XHRyZXR1cm5zIHRydWUgKHJpZ2h0KSBpZiB0aGUgbmVhcmVzdCBlbmVteSBpcyB0byB0aGUgcmlnaHQsIGVsc2UgcmV0dXJucyBmYWxzZSAobGVmdClcclxuXHRcdFZPSUQgdGFrZV9kYW1hZ2UoKVxyXG5cdFx0XHRcdFx0Y2hlY2tzIGlmIGRhbWFnZSBoYXMgYmVlbiBkZWFsdCB0aGlzIHRpY2sgYW5kIHJlc29sdmVzIGl0IFxyXG5cdFx0Vk9JRCBkaWUoKVxyXG5cdFx0XHRcdFx0c2hvdWxkIGJlIGNhbGxlZCBlYWNoIHRpY2sgdGhhdCBocCA8PSAwLiBoYW5kbGVzIGRlYXRoIGFuZCBkZWNheVxyXG5cdFx0YjJkRml4dHVyZSBnZXRfZml4dHVyZShzdHJpbmcgbmFtZSlcclxuXHRcdFx0XHRcdGdpdmVuIGEgbmFtZSwgcmV0dXJucyB0aGUgZmlyc3QgZml4dHVyZSBpbiBlbnRpdHkuYm9keSB3aXRoIG1hdGNoaW5nIG5hbWUuIGRlZmF1bHQgbmFtZXMgYXJlIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIGFuZCBcIm1haW5cIi5cclxuXHRcdEJPT0wgbW92ZW1lbnRfdm9sdW50YXJ5KClcclxuXHRcdFx0XHRcdHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIG1vdmluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gaXQgaXMgZmFjaW5nLCBlbHNlIGZhbHNlXHJcblx0XHRCT09MIGluX2FpcigpXHJcblx0XHRcdFx0XHRyZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIG9iamVjdHMgaW1tZWRpYXRlbHkgYmVsb3cgdGhlIGVudGl0eSwgZWxzZSBmYWxzZVxyXG5cdFx0Qk9PTCBwYXRoX2ZyZWUoKVxyXG5cdFx0XHRcdFx0cmV0dXJucyB0cnVlIGlmIHRoZWlyIGlzIGFuIG9iamVjdCBpbW1lZGlhdGVseSBhZGphY2VudCB0byB0aGUgZW50aXR5IGluIHRoZSBjdXJyZW50bHkgZmFjZWQgZGlyZWN0aW9uXHJcblx0XHRWT0lEIGNoYW5nZV9hbmltYXRpb24oc3RyaW5nIGFuaW1hdGlvbl9pZClcclxuXHRcdFx0XHRcdHNldHMgdGhlIGFuaW1hdGlvbiBmb3IgdGhlIGVudGl0eSwgYW5kIGVuc3VyZXMgdGhhdCB0aGUgYW5pbWF0aW9uIHdpbGwgbm90IGJlIGNvbnRpbnVvdXNseSByZXNldC5cclxuXHQqL1xyXG5cdHRoaXMuQWJzdHJhY3RFbnRpdHkgPSBmdW5jdGlvbigpe1xyXG5cdFx0dGhpcy5ocCA9IDI7XHJcblx0XHR0aGlzLnNwZWVkID0gNztcclxuXHRcdHRoaXMuanVtcF9mb3JjZSA9IDEyNTtcclxuXHRcdHRoaXMuZGFtYWdlID0gNTtcclxuXHRcdHRoaXMucG9pbnRfdmFsdWUgPSAyMDA7XHJcblx0XHR0aGlzLnNpZ2h0X3JhbmdlID0gMTY7IC8vZGlzdGFuY2UgYXQgd2hpY2ggZW50aXR5IGRldGVjdHMgaGVyb2VzXHJcblx0XHR0aGlzLmF0dGFja19yYW5nZSA9IDg7IC8vZGlzdGFuY2UgYXQgd2hpY2ggZW50aXR5IGxlYXBzIGF0IHRoZSBoZXJvXHJcblx0XHRcclxuXHRcdHRoaXMuaGl0X3Rha2VuID0gZmFsc2U7IC8vd2hldGhlciBhIGhpdCBoYXMgYmVlbiB0YWtlbiBzaW5jZSB0aGUgbGFzdCB0aWNrXHJcblx0XHR0aGlzLmRhbWFnZV90YWtlbiA9IDA7IC8vdGhlIGFtb3VudCBvZiBkYW1hZ2UgaW5mbGljdGVkIGJ5IGhpdHMgc2luY2UgdGhlIGxhc3QgdGlja1xyXG5cdFx0XHJcblx0XHR0aGlzLmRpcmVjdGlvbiA9IGZhbHNlO1x0Ly9mYWxzZT1sZWZ0LCB0cnVlPXJpZ2h0O1xyXG5cdFx0dGhpcy5kaXJlY3Rpb25fcHJldmlvdXMgPSBmYWxzZTsvL3N0b3JlIGRpcmVjdGlvbiBmcm9tIGVuZCBvZiBwcmV2aW91cyB0aWNrXHJcblx0XHR0aGlzLnhfcHJldmlvdXMgPSAwO1x0XHQvL3N0b3JlIHggdmFsdWUgZnJvbSBlbmQgb2YgcHJldmlvdXMgdGlja1xyXG5cdFx0dGhpcy55X3ByZXZpb3VzID0gMDtcdFx0Ly9zdG9yZSB4IHZhbHVlIGZyb20gZW5kIG9mIHByZXZpb3VzIHRpY2tcclxuXHRcdHRoaXMudmVsb2NpdHlfcHJldmlvdXMgPSBuZXcgQjJELmIyVmVjMigwLDApO1xyXG5cdFx0XHJcblx0XHR0aGlzLmlzX2lkbGUgPSB0cnVlOyAvL2RldGVybWluZXMgd2hldGhlciBlbnRpdHkgaXMgYWdncmVzc2l2ZSBvciBpZGxlXHJcblx0XHR0aGlzLmlkbGVfZHVyYXRpb24gPSA0MDsgLy8gdGltZSBidWZmZXIgYmV0d2VlbiBjaGFuZ2luZyBpZGxlIHN0YXRlc1xyXG5cdFx0dGhpcy5pZGxlX3RpbWVyID0gdGhpcy5pZGxlX2R1cmF0aW9uO1xyXG5cdFx0dGhpcy5pZGxlX2NvdW50ZXIgPSAwOyAvL3VzZWQgdG8gbWFuYWdlIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGVudGl0eSBoYXMgY2hhbmdlZCBzdGF0ZSB3aGlsZSBpZGxlXHJcblx0XHR0aGlzLmlzX2FsaXZlID0gdHJ1ZTsgLy9kaXNhYmxlcyBhdHRhY2tpbmcgYW5kIHBsYXlzIGRlYXRoIGFuaW1hdGlvbiB3aGlsZSBmYWxzZVxyXG5cdFx0dGhpcy5kZWF0aF9kdXJhdGlvbiA9IDMwOy8vdGltZSBiZXR3ZWVuIGRlYXRoIGFuZCBkZWxldGlvblxyXG5cdFx0dGhpcy5kZWNheV9kdXJhdGlvbiA9IDIwOy8vdGltZSBiZXR3ZWVuIGRlY2F5IGFuaW1hdGlvbiBhbmQgZGVsZXRpb25cclxuXHRcdHRoaXMuZGVhdGhfdGltZXIgPSAtMTtcclxuXHRcdHRoaXMucnVubmluZ19hd2F5ID0gZmFsc2U7IC8vd2hldGhlciB0aGUgZW50aXR5IGlzIHJ1bm5pbmcgYXdheVxyXG5cdFx0dGhpcy5ydW5fYXdheV9kdXJhdGlvbiA9IDMwOyAvL3NldCBjb3dhcmRpY2UgbGV2ZWxcclxuXHRcdHRoaXMucnVuX2F3YXlfdGltZXIgPSAtMTtcclxuXHRcdHRoaXMuY2FuX2F0dGFjayA9IHRydWU7XHQvL3doZXRoZXIgYXR0YWNraW5nIGlzIGVuYWJsZWRcclxuXHRcdHRoaXMuYXR0YWNrX2Nvb2xkb3duID0gMTA7IC8vYXR0YWNrIGNvb2xkb3duXHJcblx0XHR0aGlzLmF0dGFja19jb29sZG93bl90aW1lciA9IC0xO1xyXG5cdFx0dGhpcy5jYW5fbGVhcCA9IHRydWU7XHRcdC8vbGVhcGluZyBlbmFibGVkXHJcblx0XHR0aGlzLmxlYXBfY29vbGRvd24gPSA0MDsvL21pbmltdW0gdGltZSBiZXR3ZWVuIGxlYXBzXHJcblx0XHR0aGlzLmxlYXBfY29vbGRvd25fdGltZXIgPSAtMTsgXHJcblx0XHR0aGlzLmNoYXJnZV9kdXJhdGlvbiA9IDgwOy8vbWF4aW11bSBsZW5ndGggb2YgYSBjaGFyZ2VcclxuXHRcdHRoaXMuY2hhcmdlX3RpbWVyID0gdGhpcy5jaGFyZ2VfZHVyYXRpb247XHJcblx0XHR0aGlzLmNoYXJnZV9jb29sZG93biA9IDIwOy8vbWluaW11bSB0aW1lIGJldHdlZW4gY2hhcmdlc1xyXG5cdFx0dGhpcy5jaGFyZ2VfY29vbGRvd25fdGltZXIgPSAtMTtcclxuXHRcdHRoaXMuYmxpbmtpbmcgPSBmYWxzZTtcdC8vd2hldGhlciBlbnRpdHkgaXMgYmxpbmtpbmdcclxuXHRcdHRoaXMuYmxpbmtfZHVyYXRpb24gPSAyMDsvL2hvdyBsb25nIHRoZSBlbnRpdHkgYmxpbmtzIGFmdGVyIHRha2luZyBkYW1hZ2VcclxuXHRcdHRoaXMuYmxpbmtfdGltZXIgPSAtMTtcclxuXHRcdHRoaXMubWFpbnRlbmFuY2VfZnJlcXVlbmN5ID0gMjA7Ly90aWNrcyBiZXR3ZWVuIHJvdXRpbmUgbWFpbnRlbmFuY2UgY2hlY2tzXHJcblx0XHR0aGlzLm1haW50ZW5hbmNlX3RpbWVyID0gdGhpcy5tYWludGVuYW5jZV9mcmVxdWVuY3k7XHJcblx0XHRcclxuXHRcdHRoaXMucGF0aF9ibG9ja2VkID0gZmFsc2U7Ly9pcyB0aGlzIGRlcHJlY2F0ZWQ/IHNldCBkdXJpbmcgY29sbGlzaW9uXHJcblx0XHR0aGlzLm9ic3RydWN0aW9uX3RvbGVyYW5jZSA9IDQ7Ly9ob3cgbWFueSB0aW1lcyB0aGUgZW50aXR5IGNhbiBiZSBibG9ja2VkIGJlZm9yZSBoZSB0YWtlcyBhY3Rpb25cclxuXHRcdHRoaXMuYmxvY2tlZF9jb3VudCA9IDA7Ly90cmFja3MgbnVtYmVyIG9mIHRpbWVzIGJsb2NrZWQgYmV0d2VlbiBtYWludGVuYW5jZSBjaGVja3NcclxuXHRcdFxyXG5cdFx0dGhpcy5uZWVkc19ncmFwaGljc191cGRhdGUgPSBmYWxzZTsgLy9hY2Nlc3NlZCBieSByZW5kZXJlciBmb3IgYW5pbWF0aW9uIHB1cnBvc2VzXHJcblx0XHR0aGlzLmFuaW1hdGlvbiA9IFwic3RhbmRcIjsgLy9hY2Nlc3NlZCBieSByZW5kZXJlciBmb3IgYW5pbWF0aW9uIHB1cnBvc2VzXHJcblx0XHRcclxuXHRcdC8vYm9vc3QgZW50aXR5XHJcblx0XHR0aGlzLmp1bXAgPSBmdW5jdGlvbih4LHkpe1xyXG5cdFx0XHR2YXIgYm9keSA9IHRoaXMuYm9keTtcclxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IG5ldyBCMmQuYjJWZWMyKHgsIHkpO1xyXG5cdFx0XHRib2R5LkFwcGx5SW1wdWxzZShkaXJlY3Rpb24sIGJvZHkuR2V0V29ybGRDZW50ZXIoKSk7XHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHQvL2NvbnZlcnRzIGFuZ2xlIGFuZCBmb3JjZSBpbnRvIHggYW5kIHksIHRoZW4gY2FsbHMganVtcFxyXG5cdFx0dGhpcy5qdW1wX2RpcmVjdGlvbiA9IGZ1bmN0aW9uKGFuZ2xlLGZvcmNlKXtcclxuXHRcdFx0dmFyIHgseTtcclxuXHRcdFx0YW5nbGUgPSAoKGFuZ2xlJTM2MCkqTWF0aC5QSSkvMTgwO1xyXG5cdFx0XHR4ID0gZm9yY2UqTWF0aC5jb3MoYW5nbGUpO1xyXG5cdFx0XHR5ID0gZm9yY2UqTWF0aC5zaW4oYW5nbGUpO1xyXG5cdFx0XHR0aGlzLmp1bXAoeCx5KTtcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdFxyXG5cdFx0Ly9tb3ZlIHNwZWVkIGluIGN1cnJlbnQgZGlyZWN0aW9uXHJcblx0XHR0aGlzLm1vdmUgPSBmdW5jdGlvbihzcGVlZCl7XHJcblx0XHRcdHZhciBkaXIgPSAodGhpcy5kaXJlY3Rpb24qMi0xKTtcclxuXHRcdFx0dmFyIHZlbG9jaXR5ID0gdGhpcy5ib2R5LkdldExpbmVhclZlbG9jaXR5KCk7XHJcblx0XHRcdHZlbG9jaXR5LnggPSBzcGVlZCpkaXI7IFxyXG5cdFx0XHR0aGlzLmJvZHkuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkpO1xyXG5cdFx0XHR0aGlzLmJvZHkuU2V0QXdha2UodHJ1ZSk7XHJcblx0XHR9O1xyXG5cdFx0XHRcclxuXHRcdC8vY2hlY2sgZm9yIGVuZW1pZXMgaW4gcmFuZ2UgKHZpc2lvbiBvciBqdW1wKVxyXG5cdFx0dGhpcy5lbmVteV9pbl9yYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKXtcclxuXHRcdFx0dmFyIGhlcm9feDtcclxuXHRcdFx0dmFyIG91dHB1dCA9IGZhbHNlO1xyXG5cdFx0XHQvL011bHRpcGxheWVyXHJcblx0XHRcdHZhciBoZXJvX2xpc3QgPSBFbnRpdHlDb250cm9sbGVyLmdldF9hbGxfaGVyb2VzKCk7XHJcblx0XHRcdGlmKGhlcm9fbGlzdC5sZW5ndGggIT0gbnVsbCl7XHJcblx0XHRcdFx0Zm9yIChpPTA7IGk8aGVyb19saXN0Lmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHRcdGlmKGhlcm9fbGlzdFtpXSAhPSBudWxsKXtcclxuXHRcdFx0XHRcdFx0aGVyb194ID0gaGVyb19saXN0W2ldLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54XHJcblx0XHRcdFx0XHRcdGlmKE1hdGguYWJzKGhlcm9feCAtIHRoaXMuYm9keS5HZXRXb3JsZENlbnRlcigpLngpIDwgcmFuZ2Upe1xyXG5cdFx0XHRcdFx0XHRcdG91dHB1dCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKEVudGl0eUNvbnRyb2xsZXIuZ2V0X215X2hlcm8oKSAhPSBudWxsKXtcclxuXHRcdFx0XHR2YXIgaGVybyA9IEVudGl0eUNvbnRyb2xsZXIuZ2V0X215X2hlcm8oKTtcclxuXHRcdFx0XHRpZihoZXJvICE9IG51bGwpe1xyXG5cdFx0XHRcdFx0aGVyb194ID0gaGVyby5ib2R5LkdldFdvcmxkQ2VudGVyKCkueDtcclxuXHRcdFx0XHRcdG91dHB1dCA9IChNYXRoLmFicyhoZXJvX3ggLSB0aGlzLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54KSA8IHJhbmdlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG91dHB1dDtcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdC8vcmV0dXJucyB0aGUgZGlyZWN0aW9uIG9mIG5lYXJlc3QgZW5lbXlcclxuXHRcdHRoaXMuZGlyZWN0aW9uX25lYXJlc3RfZW5lbXkgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHQvL2luIG11bHRpcGxheWVyLCBmaXJzdCBmaW5kIG5lYXJlc3QgZW5lbXlcclxuXHRcdFx0dmFyIG5lYXJlc3QsIGhlcm9feDsgXHJcblx0XHRcdHZhciBkaXN0YW5jZSA9IDA7XHJcblx0XHRcdHZhciB4ID0gdGhpcy5ib2R5LkdldFdvcmxkQ2VudGVyKCkueDtcclxuXHRcdFx0dmFyIGhlcm9fbGlzdCA9IEVudGl0eUNvbnRyb2xsZXIuZ2V0X2FsbF9oZXJvZXMoKTtcclxuXHRcdFx0aWYoaGVyb19saXN0Lmxlbmd0aCAhPSBudWxsKXtcclxuXHRcdFx0XHRmb3IoaT0wO2k8ODtpKyspe1xyXG5cdFx0XHRcdFx0aWYoaGVyb19saXN0LmkgIT0gbnVsbCl7XHJcblx0XHRcdFx0XHRcdGlmKE1hdGguYWJzKGhlcm9fbGlzdC5pLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54IC0geCkgPCBNYXRoLmFicyhuZWFyZXN0LmJvZHkuR2V0V29ybGRDZW50ZXIoKS54IC0geCkgfHwgbmVhcmVzdCA9PSBudWxsKXtcclxuXHRcdFx0XHRcdFx0XHRuZWFyZXN0ID0gaGVyb19saXN0Lmk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aGVyb194ID0gbmVhcmVzdC5ib2R5LkdldFdvcmxkQ2VudGVyKCkueDtcclxuXHRcdFx0XHRkaXN0YW5jZSA9IChoZXJvX3ggLSB4KTtcclxuXHRcdFx0fWVsc2UgaWYoRW50aXR5Q29udHJvbGxlci5nZXRfbXlfaGVybygpICE9IG51bGwpe1xyXG5cdFx0XHRcdGRpc3RhbmNlID0gRW50aXR5Q29udHJvbGxlci5nZXRfbXlfaGVybygpLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54IC0geDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gKGRpc3RhbmNlID4gMCk7Ly9yZXR1cm4gdHJ1ZS9yaWdodCBvZiBkaXN0YW5jZSBpcyBwb3NpdGl2ZSwgcmV0dXJuIGZhbHNlL2xlZnQgaWYgZGlzdGFuY2UgaXMgbmVnYXRpdmVcclxuXHRcdFx0LypcclxuXHRcdFx0Ly9zaW5nbGUgcGxheWVyIGltcGxlbWVudGF0aW9uXHJcblx0XHRcdHZhciBuZWFyZXN0O1xyXG5cdFx0XHR2YXIgaGVyb194ID0gRW50aXR5Q29udHJvbGxlci5nZXRfbXlfaGVybygpLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54O1xyXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSAoaGVyb194IC0gdGhpcy5ib2R5LkdldFdvcmxkQ2VudGVyKCkueCk7XHJcblx0XHRcdHJldHVybiAoZGlzdGFuY2UgPiAwKTsvL3JldHVybiB0cnVlL3JpZ2h0IG9mIGRpc3RhbmNlIGlzIHBvc2l0aXZlLCByZXR1cm4gZmFsc2UvbGVmdCBpZiBkaXN0YW5jZSBpcyBuZWdhdGl2ZVxyXG5cdFx0XHQqL1xyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0Ly9kZWNyZWFzZSBoZWFsdGhcclxuXHRcdHRoaXMudGFrZV9kYW1hZ2UgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGlzLmhwIC09IHRoaXMuZGFtYWdlX3Rha2VuO1xyXG5cdFx0XHR0aGlzLmRhbWFnZV90YWtlbiA9IDA7XHJcblx0XHRcdHRoaXMuaGl0X3Rha2VuID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuYmxpbmtpbmcgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmJsaW5rX3RpbWVyID0gdGhpcy5ibGlua19kdXJhdGlvbjtcclxuXHRcdFx0Ly9rbm9ja2JhY2sgaGVyZVxyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0Ly9kaWVcclxuXHRcdHRoaXMuZGllID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYgKHRoaXMuaXNfYWxpdmUpey8vaWYgYWxpdmUsIGtpbGwgaXRcclxuXHRcdFx0XHR0aGlzLmRlYXRoX3RpbWVyID0gdGhpcy5kZWF0aF9kdXJhdGlvbjtcclxuXHRcdFx0XHR0aGlzLmlzX2FsaXZlID0gZmFsc2U7XHJcblx0XHRcdFx0V29ybGRDb250cm9sbGVyLmluY3JlYXNlX3Njb3JlKHRoaXMucG9pbnRfdmFsdWUpO1xyXG5cdFx0XHRcdHRoaXMuaGl0X3Rha2VuID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5jYW5fYXR0YWNrID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5jaGFuZ2VfYW5pbWF0aW9uKHRoaXMsXCJkZWF0aFwiKTtcclxuXHRcdFx0XHRyZXR1cm4gO1xyXG5cdFx0XHR9ZWxzZXsvL2Vsc2UgZGVjYXlcclxuXHRcdFx0XHR0aGlzLmRlYXRoX3RpbWVyLS07XHJcblx0XHRcdFx0aWYgKHRoaXMuZGVhdGhfdGltZXIgPD0gdGhpcy5kZWF0aF9kdXJhdGlvbiAmJiB0aGlzLmRlYXRoX3RpbWVyID4gdGhpcy5kZWNheV9kdXJhdGlvbiAmJiB0aGlzLmRlYXRoX3RpbWVyID4gMCl7XHJcblx0XHRcdFx0XHR0aGlzLmNoYW5nZV9hbmltYXRpb24oXCJkZWF0aFwiKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuZGVhdGhfdGltZXIgPD0gdGhpcy5kZWNheV9kdXJhdGlvbiAmJiB0aGlzLmRlYXRoX3RpbWVyID4gMCl7XHJcblx0XHRcdFx0XHR0aGlzLmNoYW5nZV9hbmltYXRpb24oXCJkZWNheVwiKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGRpZiA9IE1hdGguZmxvb3IoV29ybGRDb250cm9sbGVyLmdldF9tb3ZlbWVudF9lZGdlKCkvMjAwKSsxO1xyXG5cdFx0XHRcdFx0dmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpKjEwMDtcclxuXHRcdFx0XHRcdGlmKHJhbmQgPCA1MC9kaWYgJiYgdGhpcy5wb2ludF92YWx1ZSAhPSAwKXtcclxuXHRcdFx0XHRcdFx0c3Bhd24oKHRoaXMuYm9keS5HZXRXb3JsZENlbnRlcigpLngpLCAodGhpcy5ib2R5LkdldFdvcmxkQ2VudGVyKCkueSksIFwicGl6emFcIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRFbnRpdHlDb250cm9sbGVyLmRlbGV0ZV9lbnRpdHkodGhpcyk7Ly9yZW1vdmUgaW5zdGFuY2UgZnJvbSBtZW1vcnlcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vdGFrZXMgYSBzdHJpbmcgYXMgcGFyYW1ldGVycy4gcmV0dXJucyB0aGUgZml4dHVyZSB3aXRoIGZpeHR1cmVfbmFtZSA9PSBuYW1lLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0XHJcblx0XHR0aGlzLmdldF9maXh0dXJlID0gZnVuY3Rpb24oZW50aXR5LG5hbWUpe1xyXG5cdFx0XHR2YXIgY3VycmVudF9maXh0dXJlID0gZW50aXR5LmJvZHkuR2V0Rml4dHVyZUxpc3QoKTtcclxuXHRcdFx0d2hpbGUgKGN1cnJlbnRfZml4dHVyZSAhPSBudWxsKXtcclxuXHRcdFx0XHRpZiAoY3VycmVudF9maXh0dXJlLkdldFVzZXJEYXRhKCkgIT0gbnVsbCl7XHJcblx0XHRcdFx0XHRpZiAoY3VycmVudF9maXh0dXJlLkdldFVzZXJEYXRhKCkubmFtZSA9PSBuYW1lKXtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGN1cnJlbnRfZml4dHVyZSA9IGN1cnJlbnRfZml4dHVyZS5HZXROZXh0KCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGN1cnJlbnRfZml4dHVyZS5HZXRVc2VyRGF0YSgpID09IG51bGwpe1xyXG5cdFx0XHRcdGN1cnJlbnRfZml4dHVyZSA9IG51bGw7XHJcblx0XHRcdH1lbHNlIGlmIChjdXJyZW50X2ZpeHR1cmUuR2V0VXNlckRhdGEoKS5uYW1lICE9IG5hbWUpe1xyXG5cdFx0XHRcdGN1cnJlbnRfZml4dHVyZSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGN1cnJlbnRfZml4dHVyZTtcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdC8vY2hlY2tzIGlmIG1vdmVtZW50IGlzIHZvbHVudGFyeSBvciBmb3JjZWRcclxuXHRcdHRoaXMubW92ZW1lbnRfdm9sdW50YXJ5ID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0Ly9pZiBkaXJlY3Rpb24gYmVpbmcgZmFjZWQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGRpcmVjdGlvbiBtb3ZpbmcsIHJldHVybiBmYWxzZVxyXG5cdFx0XHR2YXIgb3V0cHV0ID0gdHJ1ZTtcclxuXHRcdFx0dmFyIHZlbG9jaXR5ID0gdGhpcy5ib2R5LkdldExpbmVhclZlbG9jaXR5KCkueDtcclxuXHRcdFx0aWYodmVsb2NpdHkgIT0gMCl7XHJcblx0XHRcdFx0b3V0cHV0ID0gKHZlbG9jaXR5L01hdGguYWJzKHZlbG9jaXR5KSA9PSAodGhpcy5kaXJlY3Rpb24pKjItMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG91dHB1dDtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly9jaGVja3MgaWYgaW4gdGhlIGFpclxyXG5cdFx0dGhpcy5pbl9haXIgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgYm9keSA9IHRoaXMuYm9keTtcclxuXHRcdFx0dmFyIG9iamVjdHNfYmVuZWF0aDtcclxuXHRcdFx0aWYgKGJvZHkuR2V0Rml4dHVyZUxpc3QoKSAhPSBudWxsKXsvL3ByZXZlbnQgYnVncyBvbiBkZXN0cnVjdGlvblxyXG5cdFx0XHRcdHZhciBBQUJCID0gYm9keS5HZXRGaXh0dXJlTGlzdCgpLkdldE5leHQoKS5HZXROZXh0KCkuR2V0QUFCQigpO1xyXG5cdFx0XHRcdG9iamVjdHNfYmVuZWF0aCA9IFBoeXNpY3NDb250cm9sbGVyLnF1ZXJ5X2FhYmIoQUFCQik7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdG9iamVjdHNfYmVuZWF0aCA9IDA7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIChvYmplY3RzX2JlbmVhdGggPCA1KTsvL2ZvciBzb21lIG15c3RlcmlvdXMgcmVhc29uLCBpdCBjb3VudHMgNCBjb2xsaXNpb25zIGV2ZW4gaW4gbWlkIGFpclxyXG5cdFx0fTtcclxuXHJcblx0XHQvL2NoZWNrcyBpZiB0aGVyZSBpcyBhIGNvbGxpc2lvbiBpbiBjdXJyZW50IGRpcmVjdGlvblxyXG5cdFx0dGhpcy5wYXRoX2ZyZWUgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgYm9keSA9IHRoaXMuYm9keTtcclxuXHRcdFx0dmFyIG9iamVjdHNfYmVmb3JlO1xyXG5cdFx0XHR2YXIgQUFCQjtcclxuXHRcdFx0aWYgKGJvZHkuR2V0Rml4dHVyZUxpc3QoKSAhPSBudWxsKXsvL3ByZXZlbnQgYnVncyBvbiBkZXN0cnVjdGlvblxyXG5cdFx0XHRcdGlmICh0aGlzLmRpcmVjdGlvbil7XHJcblx0XHRcdFx0XHRBQUJCID0gYm9keS5HZXRGaXh0dXJlTGlzdCgpLkdldEFBQkIoKTtcclxuXHRcdFx0XHRcdG9iamVjdHNfYmVmb3JlID0gUGh5c2ljc0NvbnRyb2xsZXIucXVlcnlfYWFiYihBQUJCKTtcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdEFBQkIgPSBib2R5LkdldEZpeHR1cmVMaXN0KCkuR2V0TmV4dCgpLkdldEFBQkIoKTtcclxuXHRcdFx0XHRcdG9iamVjdHNfYmVmb3JlID0gUGh5c2ljc0NvbnRyb2xsZXIucXVlcnlfYWFiYihBQUJCKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdG9iamVjdHNfYmVmb3JlID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gKG9iamVjdHNfYmVmb3JlIDwgNCk7Ly9hc3N1bWVzIGNvbnRhY3Qgd2l0aCBib3R0b20gc2Vuc29yLCB0b3Agc2Vuc29yLCBhbmQgbWFpbiBzaGFwZSBcclxuXHRcdH07XHJcblxyXG5cdFx0Ly9zZXR0ZXIgZm9yIGFuaW1hdGlvbiB2YXJpYWJsZSwgZW5zdXJlcyB0aGUgYW5pbWF0aW9uIGlzIG9ubHkgcmVzZXQgb24gYWN0dWFsIGNoYW5nZVxyXG5cdFx0dGhpcy5jaGFuZ2VfYW5pbWF0aW9uID0gZnVuY3Rpb24obmV3X2FuaW1hdGlvbil7XHJcblx0XHRcdGlmKHRoaXMuYW5pbWF0aW9uICE9IG5ld19hbmltYXRpb24pe1xyXG5cdFx0XHRcdHRoaXMuYW5pbWF0aW9uID0gbmV3X2FuaW1hdGlvbjtcclxuXHRcdFx0XHR0aGlzLm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdH1lbHNleyBcclxuXHRcdFx0XHR0aGlzLm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuanVtcF90aWNrID0gMTsgLy9mb3IgaGVybyBqdW1wIHRpY2tcclxuXHRcdH07XHJcblx0fTsgLy8gZW5kIEFic3RyYWN0RW50aXR5XHJcblx0XHJcblx0dmFyIHN5bmNfaGVybyA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKipcclxuXHRcdCogc2VuZCBzeW5jaHJvbml6YXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBoZXJvLFxyXG5cdFx0KiBpZiBuZWVkZWQgKGlmIHNvbWV0aGluZyBpbXBvcnRhbnQgY2hhbmdlZClcclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIG15X2hlcm8gPSBFbnRpdHlNb2RlbC5oZXJvZXNbTmV0d29ya0NvbnRyb2xsZXIuZ2V0X25ldHdvcmtfaWQoKV07XHJcblxyXG5cdFx0aWYobXlfaGVybyl7XHJcblx0XHRcdHZhciB2ZWxvY2l0eSA9IG15X2hlcm8uYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpO1xyXG5cdFx0XHR2YXIgb2xkX3ZlbG9jaXR5ID0gRW50aXR5TW9kZWwuaGVyb19sYXN0X3ZlbG9jaXR5O1xyXG5cclxuXHRcdFx0dmFyIGRpZmZlcmVuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHkueCAtIG9sZF92ZWxvY2l0eS54LCAyKSArIE1hdGgucG93KHZlbG9jaXR5LnkgLSBvbGRfdmVsb2NpdHkueSwgMikpXHJcblxyXG5cdFx0XHRpZihkaWZmZXJlbmNlICE9IDApe1xyXG5cdFx0XHRcdC8vIGlmIGRpZmZlcmVudFxyXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IG15X2hlcm8uYm9keS5HZXRXb3JsZENlbnRlcigpO1xyXG5cdFx0XHJcblx0XHRcdFx0TXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlci5yb3V0ZV9vdXRjb21pbmdfcGFja2V0KHtcclxuXHRcdFx0XHRcdG9wOiBcImhlcm9fc3luY1wiLFxyXG5cdFx0XHRcdFx0dmVsb2NpdHk6IHt4OiB2ZWxvY2l0eS54LCB5OiB2ZWxvY2l0eS55fSxcclxuXHRcdFx0XHRcdHBvc2l0aW9uOiB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0RW50aXR5TW9kZWwuaGVyb19sYXN0X3ZlbG9jaXR5ID0ge3g6IHZlbG9jaXR5LngsIHk6IHZlbG9jaXR5Lnl9O1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBjaGVjayB2ZWxvY2l0eSBjaGFuZ2VcclxuXHRcdFxyXG5cdFx0Ly8gc2VuZCBpZiBuZWVkZWRcclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0dmFyIHN5bmNfZW5lbXkgPSBmdW5jdGlvbihpZCl7XHJcblx0XHQvKipcclxuXHRcdCogc2VuZCBzeW5jaHJvbml6YXRpb24gaW5mb3JtYXRpb24gZm9yIGVuZW1pZXMsXHJcblx0XHQqIGlmIG5lZWRlZCAoaWYgc29tZXRoaW5nIGltcG9ydGFudCBjaGFuZ2VkKVxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgZW50aXR5ID0gSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmdldF9ieV9pZChpZCk7XHJcblxyXG5cdFx0aWYoZW50aXR5KXtcclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZW50aXR5LmJvZHkuR2V0V29ybGRDZW50ZXIoKTtcclxuXHRcdFx0dmFyIHZlbG9jaXR5ID0gZW50aXR5LmJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdFx0dmFyIG9sZF92ZWxvY2l0eSA9IGVudGl0eS52ZWxvY2l0eV9wcmV2aW91cztcclxuXHRcdFx0dmFyIG9sZF9wb3NpdGlvbiA9IG5ldyBCMkQuYjJ2ZWMyKGVudGl0eS54X3ByZXZpb3VzLCBlbnRpdHkueV9wcmV2aW91cyk7XHJcblxyXG5cdFx0XHR2YXIgdmVsX2RpZmZlcmVuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codmVsb2NpdHkueCAtIG9sZF92ZWxvY2l0eS54LCAyKSArIE1hdGgucG93KHZlbG9jaXR5LnkgLSBvbGRfdmVsb2NpdHkueSwgMikpO1xyXG5cdFx0XHR2YXIgcG9zX2RpZmZlcmVuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coKSlcclxuXHJcblx0XHRcdGlmKHZlbF9kaWZmZXJlbmNlICE9IDApe1xyXG5cdFx0XHRcdC8vIGlmIGRpZmZlcmVudCwgc2VuZCB1cGRhdGUgcGFja2V0XHJcblx0XHRcdFx0TXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlci5yb3V0ZV9vdXRjb21pbmdfcGFja2V0KHtcclxuXHRcdFx0XHRcdG9wOiBcImVuZW15X3N5bmNcIixcclxuXHRcdFx0XHRcdHZlbG9jaXR5OiB7eDogdmVsb2NpdHkueCwgeTogdmVsb2NpdHkueX0sXHJcblx0XHRcdFx0XHRwb3NpdGlvbjoge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0RW50aXR5TW9kZWwuaGVyb19sYXN0X3ZlbG9jaXR5ID0ge3g6IHZlbG9jaXR5LngsIHk6IHZlbG9jaXR5Lnl9O1xyXG5cdFx0fVxyXG5cdFx0Ly8gY2hlY2sgdmVsb2NpdHkgY2hhbmdlXHJcblx0XHQvLyBzZW5kIGlmIG5lZWRlZFxyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZV9oZXJvX3N5bmMgPSBmdW5jdGlvbihwYWNrZXQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGhhbmRsZSB0aGUgc3luYyByZXF1ZXN0IGZvciB0aGUgaGVyb1xyXG5cdFx0KiBzeW5jaHJvbml6ZSB2ZWxvY2l0eSBhbmQgdGhlIHBvc2l0aW9uXHJcblx0XHQqL1xyXG5cdFx0XHJcblx0XHRpZihwYWNrZXQucGxheWVyX2lkID09IE5ldHdvcmtDb250cm9sbGVyLmdldF9uZXR3b3JrX2lkKCkpe1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHZhciBwbGF5ZXJfaWQgPSBwYWNrZXQucGxheWVyX2lkO1xyXG5cclxuXHRcdHZhciBoZXJvID0gRW50aXR5TW9kZWwuaGVyb2VzW3BsYXllcl9pZF07XHJcblxyXG5cdFx0aWYoaGVybyA9PSBudWxsKXtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiaGVybyBpcyBub3QgZGVmaW5lZCBmb3IgdGhlIHBsYXllcl9pZFwiLCBTdHJpbmcocGxheWVyX2lkKSk7XHJcblx0XHR9ZWxzZXtcclxuXHJcblx0XHRcdHZhciB2ZWwgPSBuZXcgQjJkLmIyVmVjMihwYWNrZXQudmVsb2NpdHkueCwgcGFja2V0LnZlbG9jaXR5LnkpO1xyXG5cdFx0XHR2YXIgcG9zID0gbmV3IEIyZC5iMlZlYzIocGFja2V0LnBvc2l0aW9uLngsIHBhY2tldC5wb3NpdGlvbi55KTtcclxuXHRcdFx0XHJcblx0XHRcdGhlcm8uYm9keS5TZXRMaW5lYXJWZWxvY2l0eSh2ZWwpO1xyXG5cdFx0XHRoZXJvLmJvZHkuU2V0UG9zaXRpb24ocG9zKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0dmFyIGhhbmRsZV9lbmVteV9zeW5jID0gZnVuY3Rpb24ocGFja2V0KXtcclxuXHRcdC8qKlxyXG5cdFx0KiBoYW5kbGUgdGhlIHN5bmMgcmVxdWVzdCBmb3IgdGhlIGhlcm9cclxuXHRcdCogc3luY2hyb25pemUgdmVsb2NpdHkgYW5kIHRoZSBwb3NpdGlvblxyXG5cdFx0Ki9cclxuXHRcdFxyXG5cdFx0aWYocGFja2V0LnBsYXllcl9pZCA9PSBOZXR3b3JrQ29udHJvbGxlci5nZXRfbmV0d29ya19pZCgpKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgcGxheWVyX2lkID0gcGFja2V0LnBsYXllcl9pZDtcclxuXHJcblx0XHR2YXIgZW50aXR5ID0gRW50aXR5TW9kZWwuaGVyb2VzW3BsYXllcl9pZF07XHJcblxyXG5cdFx0aWYoZW50aXR5ID09IG51bGwpe1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJlbnRpdHkgaXMgbm90IGRlZmluZWQgZm9yIHRoZSBwbGF5ZXJfaWRcIiwgU3RyaW5nKHBsYXllcl9pZCkpO1xyXG5cdFx0fWVsc2V7XHJcblxyXG5cdFx0XHR2YXIgdmVsID0gbmV3IEIyZC5iMlZlYzIocGFja2V0LnZlbG9jaXR5LngsIHBhY2tldC52ZWxvY2l0eS55KTtcclxuXHRcdFx0dmFyIHBvcyA9IG5ldyBCMmQuYjJWZWMyKHBhY2tldC5wb3NpdGlvbi54LCBwYWNrZXQucG9zaXRpb24ueSk7XHJcblx0XHRcdFxyXG5cdFx0XHRlbnRpdHkuYm9keS5TZXRMaW5lYXJWZWxvY2l0eSh2ZWwpO1xyXG5cdFx0XHRlbnRpdHkuYm9keS5TZXRQb3NpdGlvbihwb3MpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIGdldF9hbGxfaGVyb2VzID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiByZXR1cm4gdGFibGUgd2l0aCBuZXR3b3JrIGlkcyBhc3NvY2lhdGVkIHdpdGggY29ycmVzcG9uZ2luZyBoZXJvIGluc3RhbmNlc1xyXG5cdFx0Ki9cclxuXHRcdFxyXG5cdFx0cmV0dXJuIEVudGl0eU1vZGVsLmhlcm9lcztcclxuXHR9O1xyXG5cclxuXHR2YXIgZ2V0X215X2hlcm8gPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGdldCB0aGUgaGVybyBmb3IgdGhpcyBwbGF5ZXJcclxuXHRcdCovXHJcblxyXG5cdFx0cmV0dXJuIGdldF9hbGxfaGVyb2VzKClbTmV0d29ya0NvbnRyb2xsZXIuZ2V0X25ldHdvcmtfaWQoKV07XHJcblx0XHRcclxuXHR9O1xyXG5cdFxyXG5cclxuXHRcclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblx0XHQvL2dldF9vcGVyYXRpb246IGdldF9vcGVyYXRpb24sXHJcblx0XHRyZWdfZm9yX2xvZ2ljX3VwZGF0ZTogcmVnX2Zvcl9sb2dpY191cGRhdGUsXHJcblx0XHRzcGF3bjogc3Bhd24sXHJcblx0XHRkZWxldGVfZW50aXR5OiBkZWxldGVfZW50aXR5LFxyXG5cdFx0ZGVzcGF3bjogZGVzcGF3bixcclxuXHRcdC8vZnVsZmlsbF9kZWxldGVfcmVxdWVzdDogZnVsZmlsbF9kZWxldGVfcmVxdWVzdCxcclxuXHRcdGhhbmRsZV9zcGF3bjogaGFuZGxlX3NwYXduLFxyXG5cdFx0aGFuZGxlX2RlbGV0ZTogaGFuZGxlX2RlbGV0ZSxcclxuXHRcdGhhbmRsZV9oZXJvX3N5bmM6IGhhbmRsZV9oZXJvX3N5bmMsXHJcblxyXG5cdFx0Z2V0X2FsbF9oZXJvZXM6IGdldF9hbGxfaGVyb2VzLFxyXG5cdFx0Z2V0X215X2hlcm86IGdldF9teV9oZXJvLFxyXG5cdFx0Y3JlYXRlX2Fic3RyYWN0X2VudGl0eTogY3JlYXRlX2Fic3RyYWN0X2VudGl0eSxcclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVudGl0eUNvbnRyb2xsZXI7XHJcblxyXG52YXIgSW5jbHVkZXMgPSByZXF1aXJlKFwiLi4vSW5jbHVkZXMuanNcIik7IHZhciBpbmNsdWRlX2RhdGEgPSBJbmNsdWRlcy5nZXRfaW5jbHVkZV9kYXRhKHtcclxuICAgIGN1cnJlbnRfbW9kdWxlOiBcIkVudGl0eUNvbnRyb2xsZXJcIixcclxuICAgIGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5ERUZBVUxUIHwgSW5jbHVkZXMuY2hvaWNlcy5MT0dJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbiAoKSB7IGV2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTsgfVxyXG4iLCJcclxuXHJcbnZhciBHYW1lQ29udHJvbGxlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRpbmNsdWRlKCk7XHJcblx0fTtcclxuXHRcdFxyXG5cclxuXHR2YXIgdXBkYXRlX2FsbCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuXHRcdC8qXHJcblx0XHQgKiBtYWluIGZ1bmN0aW9uIHByZXR0eSBtdWNoXHJcblx0XHQgKiBldmVyeWdoaW5nIGVsc2UgaXMgY2FsbGVkIGZyb20gaGVyZSBldmVyeSB0aWNrXHJcblx0XHQgKi9cclxuXHRcdEtleWJvYXJkQ29udHJvbGxlci51cGRhdGUoZGVsdGEpO1xyXG5cclxuXHQgICAgdmFyIGNtZHMgPSBLZXlib2FyZENvbnRyb2xsZXIucGF1c2VfY29tbWFuZHMoKTtcclxuXHQgICAgaWYgKGNtZHMoXCJwYXVzZVwiKSAmJiBHYW1lTW9kZWwucGF1c2VDb3VudGVyID4gMTAgJiYgR3JhcGhpY3NDb250cm9sbGVyLmdldF9oZWFsdGgoKSA+IDApIHtcclxuXHQgICAgICAgIGNyZWF0ZWpzLlRpY2tlci5wYXVzZWQgPSAhY3JlYXRlanMuVGlja2VyLnBhdXNlZDtcclxuXHQgICAgICAgIEdhbWVNb2RlbC5wYXVzZUNvdW50ZXIgPSAwO1xyXG5cdCAgICAgICAgY29uc29sZS5sb2coXCJwYXVzZVwiKTtcclxuXHQgICAgfVxyXG5cdCAgICBHYW1lTW9kZWwucGF1c2VDb3VudGVyICs9IDE7XHJcblx0XHRcclxuXHRcdGlmICghY3JlYXRlanMuVGlja2VyLnBhdXNlZCl7XHJcblx0XHRcdHZhciBkZWx0YSA9IGV2ZW50LmRlbHRhO1xyXG5cclxuXHRcdFx0Ly8gISEhISB3b3JsZCBzaW11bGF0aW9uIHN0ZXAgZ29lcyBzb21ld2hlcmUgcmlnaHQgaGVyZVxyXG5cdFx0XHQvLyBhcyBwZXIgY3VycmVudCBkZXNpZ24sIHdpbGwgdGFrZSBkZWx0YSBhcyBhbiBhcmd1bWVudFxyXG5cdFx0XHJcblx0XHRcdC8vVGVycmFpbkNvbnRyb2xsZXIuZ2VuZXJhdGVfdGVycmFpbigpOyBcclxuXHRcdFx0Ly9QbGF5ZXJDb250cm9sbGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHJcblx0XHRcdElkZW50aWZpY2F0aW9uQ29udHJvbGxlci51cGRhdGUoZGVsdGEpO1xyXG5cdFx0XHRXb3JsZENvbnRyb2xsZXIudXBkYXRlKGRlbHRhKTtcclxuXHJcblx0XHRcdFRlcnJhaW5Db250cm9sbGVyLnVwZGF0ZShkZWx0YSk7XHJcblx0XHRcdEVudGl0eUNvbnRyb2xsZXIudXBkYXRlKGRlbHRhKTtcclxuXHJcblx0XHRcdC8vIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG1vdmVtZW50IG9mIG9iamVjdHMgaXMgZG9uZTpcclxuXHRcdFx0Ly9IVURDb250cm9sbGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHQvL0JhY2tncm91bmRDb250cm9sbGVyLnVwZGF0ZSgpO1xyXG5cdFx0XHRHcmFwaGljc0NvbnRyb2xsZXIudXBkYXRlKCk7XHJcblx0XHRcdEdyYXBoaWNzQ29udHJvbGxlci51cGRhdGUoZGVsdGEpO1xyXG5cclxuXHRcdFx0TXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlci51cGRhdGUoZGVsdGEpO1xyXG5cdFx0XHROZXR3b3JrQ29udHJvbGxlci51cGRhdGUoZGVsdGEpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHZhciBzdG9wX2dhbWUgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHN0b3AgdGhlIGdhbWUuIFxyXG5cdFx0KiB0aGlzIG9uZSBwcmV2ZW50cyBhbnkgY29udHJvbGxlciB1cGRhdGVzIGV4Y2VwdCBHYW1lIGFuZCBLZXlib2FyZFxyXG5cdFx0KiBkaWZmZXJlbnQgZnJvbSB0aGUgUEFVU0UgZm9yIG11bHRpcGxheWVyIHB1cnBvc2VzXHJcblx0XHQqL1xyXG5cclxuXHRcdGNyZWF0ZWpzLlRpY2tlci5wYXVzZWQgPSB0cnVlO1xyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIGNvbnRpbnVlX2dhbWUgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGNvbnRpbnVlIGdhbWVcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdGNyZWF0ZWpzLlRpY2tlci5wYXVzZWQgPSBmYWxzZTtcclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGluaXQ6IGluaXQsXHJcblx0XHR1cGRhdGVfYWxsOiB1cGRhdGVfYWxsLFxyXG5cdFx0c3RvcF9nYW1lOiBzdG9wX2dhbWUsXHJcblx0XHRjb250aW51ZV9nYW1lOiBjb250aW51ZV9nYW1lLFxyXG5cdH07XHJcblxyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBHYW1lQ29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkdhbWVDb250cm9sbGVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5ERUZBVUxUXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuXHJcbiIsIi8qXHJcbkdyYXBoaWNzQ29udHJvbGxlclxyXG5cdFB1YmxpYyBGdW5jdGlvbnM6XHJcblx0LWluaXQoKVxyXG5cdFx0c2V0cyB1cCB0aGUgR3JhcGhpY3NDb250cm9sbGVyIGZvciB0aGUgcmVzdCBvZiB0aGUgZ2FtZSwgY2FsbGVkIG9uY2UgZHVyaW5nIGluaXRpYWxpemF0aW9uXHJcblx0LXVwZGF0ZShpbnQgZGVsdGEpXHJcblx0XHRjb21tb24gZnVuY3Rpb24sIGNhbGxlZCBlYWNoIHRpY2suIHBlcmZvcm1zIHJvdXRpbmUgZ3JhcGhpY3MgbWFpbnRlbmFuY2VcclxuXHRcdHJlZ2lzdGVycyBhbGwgaW5zdGFuY2VzIHRoYXQgd2VyZSBtYXJrZWQgZm9yIHJlZ2lzdHJhdGlvbiBzaW5jZSB0aGUgbGFzdCB0aWNrXHJcblx0XHRyZW5kZXJzIGFsbCByZWdpc3RlcmVkIGluc3RhbmNlc1xyXG5cdC1nZXRfc3RhZ2UoKVxyXG5cdFx0cmV0dXJucyB0aGUgc3RhZ2Ugb2JqZWN0LCBhbiBlYXNlbGpzIG9iamVjdCB0aGF0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2FtZVxyXG5cdC1nZXRfY2FtZXJhKClcclxuXHRcdHJldHVybnMgdGhlIGNhbWVyYSBvYmplY3QsIHdoaWNoIGNvbnRyb2xzIHRoZSB2aWV3IG9mZnNldFxyXG5cdC1nZXRfYXNzZXQoc3RyaW5nIGlkKVxyXG5cdFx0cmV0cmlldmVzIHRoZSBhc3NldCB3aXRoIGlkOyBhbiBhbGlhcyBmb3IgdGhlIHNhbWUgZnVuY3Rpb24gaW4gQXNzZXRDb250cm9sbGVyXHJcblx0LXJlZ19mb3JfcmVuZGVyKEVhc2VsanNfb2JqIHNwcml0ZSwgT2JqZWN0IGVudGl0eV9pbnN0YW5jZSlcclxuXHRcdGxpbmtzIGFuIGVudGl0eSB3aXRoIGEgc3ByaXRlIGFuZCByZWdpc3RlcnMgaXQgdG8gYmUgcmVuZGVyZWQgZWFjaCB0aWNrXHJcblx0LXNldF9yZWdfcG9zaXRpb24oZWFzZWxqc19vYmosaW50IG9mZnNldF94LGludCBvZmZzZXRfeSlcclxuXHRcdGFkanVzdHMgYSBzcHJpdGVzIHggYW5kIHkgb2Zmc2V0cyB0byBjb25mb3JtIHRvIHRoZSBib3gyZCBzeXN0ZW1cclxuXHQtcmVxdWVzdF9iaXRtYXAoc3RyaW5nPyBpZClcclxuXHRcdHJldHJpZXZlcyBhIHByZXZpb3VzbHkgbG9hZGVkIGFzc2V0IGFzIGEgc3ByaXRlXHJcblx0LXJlcXVlc3RfYW5pbWF0ZWQoc3RyaW5nIGlkLCBzdHJpbmd8fGludCBzdGFydF9hbmltYXRpb24vc3RhcnRfZnJhbWUpXHJcblx0XHRyZXR1cm5zIGEgbmV3IHNwcml0ZSBvYmplY3QgZ2VuZXJhdGVkIGZyb20gdGhlIGltYWdlIGlkIGFuZCB0aGUgc3RhcnQgZnJhbWVcclxuXHQtZGVzdHJveV9ncmFwaGljc19mb3IoaW50IGlkKVxyXG5cdFx0ZGVzdHJveXMgdGhlIGdyYXBoaWNzIG9iamVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkIGlkXHJcblx0LWZvbGxvdyhpbnQgaWQpXHJcblx0XHRzZXRzIHRoZSBjYW1lcmEgdG8gZm9sbG93IHRoZSBvYmplY3Qgb2YgdGhlIHBhc3NlZCBpZFxyXG5cdC1nZXRfbW92ZW1lbnRfZWRnZSgpXHJcblx0XHRyZXR1cm5zIGxlZnQgY2FtZXJhIGJvdW5kLCBhLmsuYSwgdGhlIG1vdmVtZW50IGVkZ2UuIHVzZWQgZm9yIGxvdHMgb2YgdGhpbmdzXHJcblx0XHRcclxuKi9cclxudmFyIEdyYXBoaWNzQ29udHJvbGxlciA9IChmdW5jdGlvbigpe1xyXG5cdC8qIFxyXG5cdENvbnRyb2xzIGFsbCBncmFwaGljcyBhbmQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBjb21tb24gZWFzZWwuanMgZnVuY3Rpb25zXHJcblx0Ki9cclxuXHRcclxuXHR2YXIgZ2V0X2Fzc2V0OyBcclxuXHR2YXIgdHlwZV9yZW5kZXJlcl90YWJsZTtcclxuXHR2YXIgUHJpdmF0ZUdyYXBoaWNzOyBcclxuXHR2YXIgcmVSZW5kZXIgPSBmYWxzZTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogaXMgcmFuIGZyb20gdGhlIEluaXRDb250cm9sbGVyIG9uY2Ugd2hlbiB0aGUgZ2FtZSBpcyBsb2FkZWQgKi9cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHJcblx0XHQvL0FsbCByZW5kZXJlcnMgbXVzdCBiZSByZWdpc3RlcmVkIGhlcmVcclxuXHRcdC8vTGlua3MgZWFjaCByZW5kZXJlciB3aXRoIGl0cyBvYmplY3QgaWRcclxuXHRcdHR5cGVfcmVuZGVyZXJfdGFibGUgPSB7XHJcblx0XHQvLyB0eXBlOlx0cmVuZGVyZXI6XHJcblx0XHRcdFwiYW50XCI6IEFudFJlbmRlcmVyLFxyXG5cdFx0XHRcImhlcm9cIjogSGVyb1JlbmRlcmVyLFxyXG5cdFx0XHRcIkdyaWZmaW5cIjogR3JpZmZpblJlbmRlcmVyLFxyXG5cdFx0XHRcIk1lZHVzYVwiOiBNZWR1c2FSZW5kZXJlcixcclxuICAgICAgICAgICAgXCJDZW50YXVyXCI6IENlbnRhdXJSZW5kZXJlcixcclxuXHRcdFx0XCJIeWVuYVwiOiBIeWVuYVJlbmRlcmVyLFxyXG5cdFx0XHRcInRlcnJhaW5fY2VsbFwiOiBUZXJyYWluQ2VsbFJlbmRlcmVyLFxyXG5cdFx0XHRcInRlcnJhaW5fc2xpY2VcIjogVGVycmFpblNsaWNlUmVuZGVyZXIsXHJcblx0XHRcdFwiY29tcGFuaW9uXCI6IEVzdGVlbWVkQ29tcGFuaW9uUmVuZGVyZXIsXHJcbiAgICAgICAgICAgIFwicGl6emFcIjogUGl6emFSZW5kZXJlcixcclxuXHRcdH07XHJcblxyXG5cdFx0Z2V0X2Fzc2V0ID0gQXNzZXRDb250cm9sbGVyLmdldF9hc3NldDsgLy8gZm9yIHF1aWNrZXIgYWNjZXNzXHJcblxyXG5cdFx0R3JhcGhpY3NNb2RlbC5zdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShDb25maWcuTUFJTl9DQU5WQVNfTkFNRSk7XHJcblx0XHRHcmFwaGljc01vZGVsLnN0YWdlLmNhbnZhcy53aWR0aCA9IENvbmZpZy5TQ1JFRU5fVztcclxuXHRcdEdyYXBoaWNzTW9kZWwuc3RhZ2UuY2FudmFzLmhlaWdodCA9IENvbmZpZy5TQ1JFRU5fSDtcclxuXHRcdFxyXG5cdFx0R3JhcGhpY3NNb2RlbC5jYW1lcmEub2Zmc2V0X2Zyb21fZm9sbG93ZWQueCAtPSAoMTYxNCAtIEdyYXBoaWNzTW9kZWwuc3RhZ2UuY2FudmFzLndpZHRoKSAvIDM7XHJcblxyXG5cdFx0Ly8gaW5pdCBhbGwgcmVuZGVyZXJzXHJcblx0XHRmb3IodHlwZSBpbiB0eXBlX3JlbmRlcmVyX3RhYmxlKXtcclxuXHRcdFx0dHlwZV9yZW5kZXJlcl90YWJsZVt0eXBlXS5pbml0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIGFsbCByZW5kZXJlcnMgdG8gZ2l2ZSB0aGVtIGFjY2VzcyB0byBmdW5jdGlvbnNcclxuXHRcdC8vIHRoYXQgbm8gb25lIGVsc2UgaXMgc3VwcG9zZWQgdG8gYmUgYWJsZSB0byBhY2Nlc3NcclxuXHRcdFByaXZhdGVHcmFwaGljcyA9IHtcclxuXHRcdFx0c3RhZ2U6IEdyYXBoaWNzTW9kZWwuc3RhZ2UsXHJcblx0XHRcdHJlcXVlc3RfYml0bWFwOiByZXF1ZXN0X2JpdG1hcCxcclxuXHRcdFx0cmVxdWVzdF9hbmltYXRlZDogcmVxdWVzdF9hbmltYXRlZCxcclxuXHRcdFx0Z2V0X2Fzc2V0OiBnZXRfYXNzZXQsXHJcblx0XHRcdHRyYW5zX3h5OiB0cmFuc194eSxcclxuXHRcdFx0cmVnX2Zvcl9yZW5kZXI6IHJlZ19mb3JfcmVuZGVyLFxyXG5cdFx0fTtcclxuXHJcblx0XHRCYWNrZ3JvdW5kUmVuZGVyZXIuaW5pdCgpO1xyXG5cdFx0SFVEUmVuZGVyZXIuaW5pdCgpO1xyXG5cclxuXHR9O1xyXG5cclxuICAgIFxyXG5cdHZhciB1cGRhdGUgPSBmdW5jdGlvbihkZWx0YSl7XHJcblx0XHQvKiBpcyByYW4gZWFjaCB0aWNrIGZyb20gdGhlIEdhbWVDb250cm9sbGVyLnVwZGF0ZV9hbGwgKi9cclxuXHRcdFxyXG5cdFx0dXBkYXRlX2NhbWVyYSgpOyAvLyBuZWVkcyB0byBiZSB1cGRhdGVkIGZpcnN0XHJcblxyXG5cdFx0ZGVzdHJveV91bm5lZWRlZCgpOyAvLyBnb2VzIHNlY29uZCwgZG8gbm90IHVwZGF0ZSBhbnkgc3R1ZmYgYmVmb3JlIHVubmVlZGVkIHN0dWZmIGlzIHJlbW92ZWRcclxuXHJcblx0XHRyZWdpc3Rlcl9uZXdfc3R1ZmYoKTtcclxuXHJcblx0XHRyZW5kZXJfdGhpbmdzKCk7XHJcblx0XHRcclxuXHRcdHN5bmNocm9uaXplX3RvX3BoeXNpY2FsX2JvZGllcygpO1xyXG5cclxuXHRcdEJhY2tncm91bmRSZW5kZXJlci5yZW5kZXIoKTtcclxuXHRcdFxyXG5cdFx0SFVEUmVuZGVyZXIucmVuZGVyKCk7XHJcblx0XHRcclxuXHRcdEdyYXBoaWNzTW9kZWwuc3RhZ2UudXBkYXRlKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIGRlc3Ryb3lfdW5uZWVkZWQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGRlc3Ryb3kgZ3JhcGhpY3MgZm9yIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgbWFya2VkXHJcblx0XHQqIGZvciBkZXN0cnVjdGlvblxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgc2xpY2VzID0gUmVnaXN0ZXJBc0NvbnRyb2xsZXIucmV0cmlldmVfcmVnaXN0ZXJlZF9hcyhcInJlbW92ZWRfc2xpY2VcIik7XHJcblxyXG5cdFx0dmFyIGVudGl0aWVzID0gUmVnaXN0ZXJBc0NvbnRyb2xsZXIucmV0cmlldmVfcmVnaXN0ZXJlZF9hcyhcInJlbW92ZWRfZW50aXR5XCIpO1xyXG5cclxuXHRcdHdoaWxlKHNsaWNlcy5sZW5ndGggPiAwKXtcclxuXHRcdFx0dmFyIHNsaWNlID0gc2xpY2VzLnBvcCgpO1xyXG5cdFx0XHR2YXIgZ3JpZCA9IHNsaWNlLmdyaWQ7XHJcblxyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZ3JpZC5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0dmFyIHJvdyA9IGdyaWRbaV07IC8vIG9yIGlzIGl0IGEgY29sdW1uP1xyXG5cclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKXtcclxuXHRcdFx0XHRcdHZhciBjZWxsID0gcm93W2pdO1xyXG5cdFx0XHRcdFx0aWYoY2VsbC5raW5kICE9IDApe1xyXG5cdFx0XHRcdFx0XHRkZXN0cm95X2dyYXBoaWNzX2ZvcihjZWxsLmlkKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHdoaWxlKGVudGl0aWVzLmxlbmd0aCA+IDApe1xyXG5cdFx0XHR2YXIgZW50aXR5ID0gZW50aXRpZXMucG9wKCk7XHJcblx0XHRcdGRlc3Ryb3lfZ3JhcGhpY3NfZm9yKGVudGl0eS5pZCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHJcblx0dmFyIGZvbGxvdyA9IGZ1bmN0aW9uKGlkKXtcclxuXHRcdC8vb3JkZXIgY2FtZXJhIHRvIGZvbGxvdyB0aGUgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uXHJcblx0XHQvL29mIGFuIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBpZCwgaWYgaXQgZXhpc3RzXHJcblx0XHRHcmFwaGljc01vZGVsLmNhbWVyYS5mb2xsb3dpbmcgPSBHcmFwaGljc01vZGVsLmFsbF9waHlzaWNhbFtpZF07XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHR2YXIgcmVnaXN0ZXJfbmV3X3N0dWZmID0gZnVuY3Rpb24oKXtcclxuXHRcdC8vc2VhcmNoIHRocm91Z2ggYWxsIGluc3RhbmNlcyBpbiB0aGUgcXVldWUgXHJcblx0XHQvL2FuZCByZWdpc3RlciB0aGVtIGZvciBncmFwaGljcyB1cGRhdGVzLlxyXG5cclxuXHRcdC8vIHJldHJpZXZlIGluc3RhbmNlcyBvZiBwaHlzaWNhbCB0aGluZ3MgdGhhdCBkbyBub3QgaGF2ZSBncmFwaGljcyB5ZXRcclxuXHRcdHZhciBuZXdfc3R1ZmYgPSBSZWdpc3RlckFzQ29udHJvbGxlci5yZXRyaWV2ZV9yZWdpc3RlcmVkX2FzKFwiYXdhaXRpbmdfZ3JhcGhpY3NfaW5pdGlhbGl6YXRpb25cIik7XHJcblxyXG5cdFx0dmFyIGxlbmd0aCA9IG5ld19zdHVmZi5sZW5ndGhcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XHJcblx0XHRcdHZhciBuZXdfb2JqID0gbmV3X3N0dWZmLnBvcCgpO1xyXG5cdFx0XHRpZih0eXBlX3JlbmRlcmVyX3RhYmxlW25ld19vYmoudHlwZV0pe1xyXG5cdFx0XHRcdC8vIGlmIHJlbmRlcmVyIGV4aXN0cyBmb3IgdGhpcyB0eXBlLCByZWdpc3RlciB0aHJvdWdoIGl0XHJcblx0XHRcdFx0dHlwZV9yZW5kZXJlcl90YWJsZVtuZXdfb2JqLnR5cGVdLnJlZ2lzdGVyKG5ld19vYmosIFByaXZhdGVHcmFwaGljcyk7XHRcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0dGhyb3cgXCJObyByZW5kZXJlciBmb3VuZCBmb3IgdGhlIHR5cGUgXCIgKyBTdHJpbmcobmV3X29iai50eXBlKSArXHJcblx0XHRcdFx0XHRcIiBjb25maXJtIHRoYXQgcmVuZGVyZXIgZXhpc3RzIGFuZCBpcyBhZGRlZCB0byB0aGUgR3JhcGhpY3NDb250cm9sbGVyLnR5cGVfcmVuZGVyZXJfdGFibGVcIlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHR2YXIgcmVuZGVyX3RoaW5ncyA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKipcclxuXHRcdCogY2FsbCByZW5kZXJlcnMgZm9yIGV2ZXJ5dGhpbmdcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdHZhciB0b19yZW5kZXIgPSBHcmFwaGljc01vZGVsLnNwZWNpYWxfcmVuZGVyO1xyXG5cclxuXHRcdGZvcih2YXIgdHlwZSBpbiB0b19yZW5kZXIpe1xyXG5cdFx0XHR2YXIgdGFibGUgPSB0b19yZW5kZXJbdHlwZV07XHJcblx0XHRcdHZhciByZW5kZXJlciA9IHR5cGVfcmVuZGVyZXJfdGFibGVbdHlwZV07XHJcblxyXG5cdFx0XHRmb3IodmFyIGlkIGluIHRhYmxlKXtcclxuXHRcdFx0XHRzcHJpdGVfYW5pbWF0ZSh0YWJsZVtpZF0sIFByaXZhdGVHcmFwaGljcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0dmFyIHNwcml0ZV9hbmltYXRlID0gZnVuY3Rpb24oc3ByaXRlKXtcclxuXHRcdC8vc2V0IGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBiYXNlZCBvbiB0aGUgYW5pbWF0aW9uIHZhcmlhYmxlIGRldGVybWluZWQgYnkgdGhlIEFJXHJcblx0XHQvL3NldCBhbmltYXRpb25cclxuXHRcdGlmKHNwcml0ZS5waHlzaWNhbF9pbnN0YW5jZS5uZWVkc19ncmFwaGljc191cGRhdGUpe1xyXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gc3ByaXRlLnBoeXNpY2FsX2luc3RhbmNlLmFuaW1hdGlvbjtcclxuXHRcdFx0c3ByaXRlLmdvdG9BbmRQbGF5KGFuaW1hdGlvbilcclxuXHRcdFx0c3ByaXRlLm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL3NldCBkaXJlY3Rpb25cclxuXHRcdGlmIChzcHJpdGUucGh5c2ljYWxfaW5zdGFuY2UuZGlyZWN0aW9uKXsgLy9pZiBkaXJlY3Rpb24gPT0gcmlnaHQsIGZsaXAgcmlnaHRcclxuXHRcdFx0c3ByaXRlLnNjYWxlWCA9IC0xO1xyXG5cdFx0fWVsc2V7IC8vZWxzZSBmbGlwIGxlZnRcclxuXHRcdFx0c3ByaXRlLnNjYWxlWCA9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9zZXQgYWxwaGEgaWYgYmxpbmtpbmdcclxuXHRcdGlmKHNwcml0ZS5waHlzaWNhbF9pbnN0YW5jZS5ibGlua2luZyAmJiBzcHJpdGUucGh5c2ljYWxfaW5zdGFuY2UuYmxpbmtfdGltZXIlMiA9PSAxKXtcclxuXHRcdFx0c3ByaXRlLmFscGhhID0gMDtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRzcHJpdGUuYWxwaGEgPSAxO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vY2FsbGVkIGZyb20gdXBkYXRlKCksIG1haW50YWlucyBjYW1lcmEgcG9zaXRpb25cclxuXHR2YXIgdXBkYXRlX2NhbWVyYSA9IGZ1bmN0aW9uKCl7XHJcblx0XHR2YXIgY2FtZXJhID0gR3JhcGhpY3NNb2RlbC5jYW1lcmE7XHJcblx0XHR2YXIgY2VudGVyID0gY2FtZXJhLmNlbnRlcjtcclxuXHRcdFxyXG5cdFx0Y2VudGVyLnggPSBDb25maWcuU0NSRUVOX1cvMiAtIGNhbWVyYS5vZmZzZXRfZnJvbV9mb2xsb3dlZC54O1xyXG5cdFx0Ly9DQU1FUkEgU0hPVUxEIE5PVCBNT1ZFIFZFUlRJQ0FMTFlcclxuXHRcdC8vY2VudGVyLnkgPSBDb25maWcuU0NSRUVOX0gvMiAtIGNhbWVyYS5vZmZzZXRfZnJvbV9mb2xsb3dlZC55O1xyXG5cdFx0XHJcblx0XHRpZihjYW1lcmEuZm9sbG93aW5nICE9IG51bGwpe1xyXG5cdFx0ICAgIGNhbWVyYS5vZmZzZXQueCA9IGNlbnRlci54IC0gY2FtZXJhLmZvbGxvd2luZy5waHlzaWNhbF9pbnN0YW5jZS5ib2R5LkdldFdvcmxkQ2VudGVyKCkueCAqIENvbmZpZy5CMkQuU0NBTEU7XHJcblx0XHRcdGNhbWVyYS5vZmZzZXQueSA9IGNlbnRlci55IC0gY2FtZXJhLmZvbGxvd2luZy5waHlzaWNhbF9pbnN0YW5jZS5ib2R5LkdldFdvcmxkQ2VudGVyKCkueSAqIENvbmZpZy5CMkQuU0NBTEU7XHJcblx0XHRcdC8vIG5vdywgd2UgZG8gbm90IHdhbnQgdGhlIGNhbWVyYSB0byBkaXNwbGF5IHdoYXQgaXMgYmVoaW5kIHRoZSBtb3ZlbWVudCBlZGdlLiBidXQgdGhlIGNhbWVyYSBpcyBhIHJlbGF0aXZlIHRoaW5nXHJcblx0XHRcdC8vIHNvIHdlIGNhbid0IGp1c3QgbGltaXQgc29tZSBzb3J0IG9mIHggcG9zaXRpb24gb3Igc3VjaC5cclxuXHRcdFx0Ly8gSSdsbCB1c2UgdGhlIGZvbGxvd2luZyB0ZWNobmlxdWU6IFxyXG5cdFx0XHQvLyAgIDEuIGNhbGN1bGF0ZSB3ZXJlIHRoZSBwaHlzaWNhbCBtb3ZlbWVudCBlZGdlIHdvdWxkIGJlIGlmIGRyYXduIHJpZ2h0IG5vdyB0byB0aGUgY2FudmFzXHJcblx0XHRcdC8vICAgMi4gaWYgaXQgd291bGQgYmUgZGlzcGxheWVkIG9uLXNjcmVlbiwgb2Zmc2V0IGNhbWVyYSBzbyB0aGF0IGl0IHdvdWxkbid0IGJlIGFueW1vcmVcclxuXHJcblx0XHRcdHZhciBtb3ZfZWRnZV9ncmFwaGljc194ID0gKFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpICogQ29uZmlnLkIyRC5TQ0FMRSkgKyBjYW1lcmEub2Zmc2V0Lng7XHJcblxyXG5cdFx0XHQvLyByZWNhbGwgdGhhdCBsZWZ0IGRpc3BsYXkgZWRnZSBpcyAwIGZvciBncmFwaGljcywgYXMgKDAsIDApIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXJcclxuXHRcdFx0aWYobW92X2VkZ2VfZ3JhcGhpY3NfeCA+IDApe1xyXG5cdFx0XHRcdC8vIGlmIG1vdmVtZW50IGVkZ2Ugd291bGQgYmUgZGlzcGxheWVkXHJcblx0XHRcdFx0Y2FtZXJhLm9mZnNldC54IC09IG1vdl9lZGdlX2dyYXBoaWNzX3g7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChjYW1lcmEub2Zmc2V0LnkgPCAwKSB7XHJcblx0XHQgICAgY2FtZXJhLm9mZnNldC55ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRhZGp1c3RfZGVidWdfZHJhdygpOyAvLyBnb2VzIGxhc3RcclxuXHR9O1xyXG5cclxuXHRcclxuXHJcblxyXG5cdC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdHZhciBhZGp1c3RfZGVidWdfZHJhdyA9IGZ1bmN0aW9uKCl7XHJcblx0XHR2YXIgY2FtZXJhID0gR3JhcGhpY3NNb2RlbC5jYW1lcmE7XHJcblx0XHRUZXN0Q29udHJvbGxlci5zZXRfZGVidWdfb2Zmc2V0KGNhbWVyYS5vZmZzZXQueCwgY2FtZXJhLm9mZnNldC55KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcmVxdWVzdF9iaXRtYXAgPSBmdW5jdGlvbihpZCl7XHJcblx0XHQvLyBpZiBpZCBpcyBpbnZhbGlkLCB0aHJvdyBtZWFuaW5nZnVsIGV4Y2VwdGlvbj9cclxuXHRcdHZhciBiaXRtYXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKGdldF9hc3NldChpZCkpO1xyXG5cdFx0Ly8gbW9yZSBjb21wbGljYXRlZCBzZXR0aW5nIGZvciByZWdpc3RyYXRpb24gcG9zaXRpb24gbWF5IGJlIG5lZWRlZCwgZGVwZW5kaW5nIG9uIHRoZSBib2R5IGF0dGFjaGVkXHJcblx0XHRpZiAoIShiaXRtYXAuaW1hZ2UpKXtcclxuXHRcdFx0dGhyb3cgXCJFcnJvcjogaW1hZ2Ugd2Fzbid0IGNvcnJlY3RseSBsb2FkZWQgZm9yIHRoaXMgYml0bWFwXCI7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGJpdG1hcC5yZWdYID0gYml0bWFwLmltYWdlLndpZHRoLzI7XHJcblx0XHRiaXRtYXAucmVnWSA9IGJpdG1hcC5pbWFnZS5oZWlnaHQvMjtcclxuXHJcblx0XHRyZXR1cm4gYml0bWFwO1xyXG5cdFx0Ly8gVE9ETyByZXNlYXJjaCBEaXNwbGF5T2JqZWN0J3MgY2FjaGluZy4gYW5kIG1heWJlIGluY29ycG9yYXRlXHJcblx0fTtcclxuXHRcclxuXHRcclxuXHR2YXIgcmVxdWVzdF9hbmltYXRlZCA9IGZ1bmN0aW9uKGlkLCBzdGFydF9mcmFtZSl7XHJcblx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIHRlbXBvcmFyeVxyXG5cdFx0Ly8gdW50aWwgSSBzZXR1cCBlZmZpY2llbnQgZmFjaWxpdHkgZm9yIGRlZmluaW5nIHNwcml0ZXNoZWV0c1xyXG5cdFx0Ly8gd2l0aGluIEdyYXBoaWNzQ29udHJvbGxlclxyXG5cclxuXHRcdGlmKCFpZCB8fCAhc3RhcnRfZnJhbWUpe1xyXG5cdFx0XHRpZighaWQpe1xyXG5cdFx0XHRcdHRocm93IFwid3JvbmcgaWRcIjtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0dGhyb3cgXCJ3cm9uZyBzdGFydF9mcmFtZVwiO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBzcHJpdGUgPSBuZXcgY3JlYXRlanMuU3ByaXRlKGlkLCBzdGFydF9mcmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIHNwcml0ZTtcclxuXHR9O1xyXG5cclxuXHRcclxuXHQvL2NvbnZlcnRzIGVhc2VsanMgb3JpZ2lucyB0byBib3gyZCBvcmlnaW5zXHJcblx0dmFyIHN5bmNocm9uaXplX3RvX3BoeXNpY2FsX2JvZGllcyA9IGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0dmFyIHRpbGVzID0gR3JhcGhpY3NNb2RlbC5hbGxfcGh5c2ljYWw7XHJcblxyXG5cdFx0Zm9yKHZhciBpZCBpbiB0aWxlcyl7XHJcblx0XHRcdHZhciB0aWxlID0gdGlsZXNbaWRdO1xyXG5cdFx0XHR2YXIgYm9keSA9IHRpbGUucGh5c2ljYWxfaW5zdGFuY2UuYm9keTtcclxuXHRcdFx0dmFyIHRpbGVfcG9zID0gdHJhbnNfeHkoYm9keS5HZXRXb3JsZENlbnRlcigpKTtcclxuXHJcblx0XHRcdHRpbGUueCA9IHRpbGVfcG9zLng7XHJcblx0XHRcdHRpbGUueSA9IHRpbGVfcG9zLnk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHJcblx0dmFyIHRyYW5zX3h5ID0gZnVuY3Rpb24ocG9zaXRpb25fdmVjdG9yX3Vuc2NhbGVkKXtcclxuXHRcdC8vIHRha2VzIHBvc2l0aW9uIHZlY3RvciB3aXRoIHZhbHVlcyBpbiBtZXRlcnMsIHRyYW5zbGF0ZXNcclxuXHRcdC8vIGl0IHRvIHBpeGVsIHBvc2l0aW9uIHRha2luZyB0aGUgY2FtZXJhIHBvc2l0aW9uIGludG8gYWNjb3VudFxyXG5cdFx0dmFyIGNhbWVyYSA9IEdyYXBoaWNzTW9kZWwuY2FtZXJhO1xyXG5cclxuXHRcdHZhciB4ID0gKHBvc2l0aW9uX3ZlY3Rvcl91bnNjYWxlZC54ICogQ29uZmlnLkIyRC5TQ0FMRSkgKyBjYW1lcmEub2Zmc2V0Lng7XHJcblx0XHR2YXIgeSA9IChwb3NpdGlvbl92ZWN0b3JfdW5zY2FsZWQueSAqIENvbmZpZy5CMkQuU0NBTEUpICsgY2FtZXJhLm9mZnNldC55O1xyXG5cclxuXHRcdHJldHVybiB7eDogeCwgeTogeX07XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgc2V0X3JlZ19wb3NpdGlvbiA9IGZ1bmN0aW9uKGVhc2VsanNfb2JqLCBvZmZzZXRfeCwgb2Zmc2V0X3kpe1xyXG5cdFx0Ly8gc2V0cyByZWdpc3RyYXRpb24gcG9zaXRpb24gb2YgdGhlIGVhc2VsanMgb2JqZWN0XHJcblx0XHQvLyByZWdpc3JhdGlvbiBwb3NpdGlvbiBpcyB0aGUgcmVsYXRpdmUgcG9pbnQgb2YgdGhlIG9iamVjdFxyXG5cdFx0Ly8gdGhhdCB5b3UgbW92ZSB3aGVuIHlvdSBzZXQgb2JqZWN0J3MgeCBhbmQgeSBjb29yZGluYXRzXHJcblx0XHQvLyBpLmUuIGlmIHJlZy4gcG9zaXRpb24gb2YgdGhlIHBsYXllciBpcyBoZWFkLCBhbmQgeW91IHNldCB0aGVpclxyXG5cdFx0Ly8gcG9zaXRpb24gdG8gKDAsIDApLCB0aGVpciBoZWFkIHdpbGwgYmUgYXQgKDAsIDApXHJcblx0XHQvLyBjdXJyZW50bHkgdGhlIHJlZ2lzdHJhdGlvbiBwb3NpdGlvbiBpcyBzZXQgdG8gdGhlIG1pZGRsZSBvZiB0aGUgYm9keVxyXG5cdFx0Ly8gdG8gbWF0Y2ggd2hhdCBib3gyZCBkb2VzXHJcblx0XHQvLyBsYXN0IHR3byBhcmd1bWVudHMgYXJlIG9wdGlvbmFsIGFuZCBzZXQgUElYRUwgb2Zmc2V0IGZyb20gdGhlIG5vcm1hbCByZWdpc3RyYXRpb25cclxuXHRcdC8vIHBvc2l0aW9uXHJcblx0XHRcclxuXHRcdC8vIHRoaXMgaWYgc3RhdGVtZW50IHNob3VsZCBiZSB0ZW1wb3JhcnlcclxuXHRcdGlmKGVhc2VsanNfb2JqLmltYWdlKXtcclxuXHRcdFx0dmFyIHcgPSBlYXNlbGpzX29iai5pbWFnZS53aWR0aDtcdFxyXG5cdFx0XHR2YXIgaCA9IGVhc2VsanNfb2JqLmltYWdlLmhlaWdodDtcdFxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHZhciB3ID0gZWFzZWxqc19vYmouc3ByaXRlU2hlZXQuX2ZyYW1lV2lkdGg7XHJcblx0XHRcdHZhciBoID0gZWFzZWxqc19vYmouc3ByaXRlU2hlZXQuX2ZyYW1lSGVpZ2h0O1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgb2Zmc2V0X3ggPSBvZmZzZXRfeCB8fCAwO1xyXG5cdFx0dmFyIG9mZnNldF95ID0gb2Zmc2V0X3kgfHwgMDtcclxuXHJcblx0XHRlYXNlbGpzX29iai5yZWdYID0gdy8yICsgb2Zmc2V0X3g7XHJcblx0XHRlYXNlbGpzX29iai5yZWdZID0gaC8yICsgb2Zmc2V0X3k7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciByZWdfZm9yX3JlbmRlciA9IGZ1bmN0aW9uKGVhc2VsanNfb2JqLCBwaHlzaWNhbF9pbnN0YW5jZSl7XHJcblx0XHQvLyByZWdpc3RlcmVzIG9iamVjdCBmb3IgcmVuZGVyaW5nIHdpdGhpbiBncmFwaGljcyBjb250cm9sbGVyXHJcblx0XHQvLyBpZiAoT1BUSU9OQUwhKSBwaHlzaWNhbF9pbnN0YW5jZSBpcyBnaXZlbiwgZ3JhcGhpY3MgY29udHJvbGxlciB3aWxsIGF1dG9tYXRpY2FsbHlcclxuXHRcdC8vIHNldCB0aGUgZWFzZWxqc19vYmoncyBwb3NpdGlvbiB0byBwb3NpdGlvbiBvZiB0aGF0IGJvZHksIGVhY2ggdGljay5cclxuXHRcdC8vIGlmIHRoZSB0eXBlIG9mIHRoZSBwaHlzaWNhbCBpbnN0YW5jZSBpcyBhc3NvY2lhdGVkIHdpdGggc29tZSByZW5kZXJlclxyXG5cdFx0XHRcclxuXHRcdFxyXG5cdFx0aWYocGh5c2ljYWxfaW5zdGFuY2Upe1xyXG5cclxuXHRcdFx0aWYocGh5c2ljYWxfaW5zdGFuY2UuYm9keSA9PSBudWxsKXtcclxuXHRcdFx0XHQvLyBhcmUgeW91IHRyeWluZyB0byBkbyBzb21ldGhpbmcgdGVycmlibGU/IHN1Y2ggYXMgcmVnaXN0ZXJpbmdcclxuXHRcdFx0XHQvLyBzb21lIG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBncmFwaGljYWwgcmVwcmVzZW50YXRpb24/XHJcblx0XHRcdFx0dGhyb3cgXCJQaHlzaWNhbCBpbnN0YW5jZSBpcyBwcm92aWRlZCwgYnV0IGl0IGhhcyBubyBib2R5XCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGlkID0gcGh5c2ljYWxfaW5zdGFuY2UuaWQ7XHJcblx0XHRcdHZhciB0eXBlID0gcGh5c2ljYWxfaW5zdGFuY2UudHlwZTtcclxuXHJcblx0XHRcdGlmKGlkID09IG51bGwgfHwgdHlwZSA9PSBudWxsKXtcclxuXHRcdFx0XHR0aHJvdyBcIklkIG9yIHR5cGUgaXMgdW5kZWZpbmVkIGZvciB0aGlzIHBoeXNpY2FsIGluc3RhbmNlXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVhc2VsanNfb2JqLnBoeXNpY2FsX2luc3RhbmNlID0gcGh5c2ljYWxfaW5zdGFuY2U7XHJcblx0XHRcdEdyYXBoaWNzTW9kZWwuYWxsX3BoeXNpY2FsW2lkXSA9IGVhc2VsanNfb2JqO1xyXG5cclxuXHRcdFx0aWYoIUdyYXBoaWNzTW9kZWwuc3BlY2lhbF9yZW5kZXJbdHlwZV0pe1xyXG5cdFx0XHRcdEdyYXBoaWNzTW9kZWwuc3BlY2lhbF9yZW5kZXJbdHlwZV0gPSB7fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0R3JhcGhpY3NNb2RlbC5zcGVjaWFsX3JlbmRlclt0eXBlXVtpZF0gPSBlYXNlbGpzX29iajtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0QWRkVG9TdGFnZShlYXNlbGpzX29iaik7XHJcblx0fTtcclxuXHJcblx0dmFyIEFkZFRvU3RhZ2UgPSBmdW5jdGlvbihlbGVtZW50KXtcclxuXHRcdC8vIGNhbiBiZSB1cGRhdGVkIGxhdGVyIHRvIG1hbmFnZSB6LWluZGV4IG9yIHdoYXRldmVyXHJcblx0XHRHcmFwaGljc01vZGVsLnN0YWdlLmFkZENoaWxkKGVsZW1lbnQpO1xyXG5cdH07XHJcblx0XHJcblxyXG5cdHZhciBnZXRfc3RhZ2UgPSBmdW5jdGlvbigpe1xyXG5cdFx0cmV0dXJuIEdyYXBoaWNzTW9kZWwuc3RhZ2U7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgZ2V0X2NhbWVyYSA9IGZ1bmN0aW9uKCl7XHJcblx0XHRyZXR1cm4gR3JhcGhpY3NNb2RlbC5jYW1lcmE7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgZGVzdHJveV9ncmFwaGljc19mb3IgPSBmdW5jdGlvbihpZCl7XHJcblx0XHQvKipcclxuXHRcdCogcmVtb3ZlIGZyb20gdGhlIHN0YWdlIGFuZCBkZXN0cm95IGdyYXBoaWNzIGluc3RhbmNlcyBmb3IgdGhlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBpZFxyXG5cdFx0KiB0aGlzIGluY2x1ZGVzIHJlbW92aW5nIGFsbCByZWZlcmVuY2VzIHRvIGl0LlxyXG5cdFx0KiBUT0RPOiBJTVBPUlRBTlQhISEgaWYgR3JhcGhpY3NDb250cm9sbGVyIHdhcyB1cGRhdGVkIHRvIHN0b3JlIG1vcmVcclxuXHRcdCogcmVmZXJlbmNlcyB0byBzb21lIGdyYXBoaWNzIGluc3RhbmNlcywgVVBEQVRFIHRoaXMgZnVuY3Rpb24gdG8gcmVmbGVjdCBjaGFuZ2VzXHJcblx0XHQqIGV2ZW4gYSBzaW5nbGUgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3QgbWF5IGNhdXNlIGl0IHRvIHN0YXkgaW4gbWVtb3J5XHJcblx0XHQqL1xyXG5cdFx0XHJcblxyXG5cdFx0aWYoR3JhcGhpY3NNb2RlbC5hbGxfcGh5c2ljYWxbaWRdICE9IG51bGwpe1xyXG5cdFx0XHR2YXIgZ3JhcGhpY3NfaW5zdGFuY2UgPSBHcmFwaGljc01vZGVsLmFsbF9waHlzaWNhbFtpZF07XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly8gaWYgeW91IGVuY291bnRlciB0aGlzIGV4Y2VwdGlvbiwgbWF5YmUgaW1wbGVtZW50YXRpb24gY2hhbmdlZC4gXHJcblx0XHRcdC8vIElmIHRoYXQncyB0aGUgY2FzZSwgc29tZSB0aGluZ3MgbmVlZCByZXdyaXRpbmcuIFRoaXMgZnVuY3Rpb24gaW5cclxuXHRcdFx0Ly8gcHJ0aWN1bGFyLiBPciBtYXliZSB0aGVyZSBpcyBhIGJ1Zy5cclxuXHRcdFx0dGhyb3cgXCJUaGUgZ3JhcGhpY3Mgb2JqZWN0IHdpdGggaWQgXCIgKyBTdHJpbmcoaWQpICsgXCIgaXNuJ3QgcmVnaXN0ZXJlZCBhcyBoYXZpbmcgcGh5c2ljYWwgYm9keVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKGdyYXBoaWNzX2luc3RhbmNlLnBoeXNpY2FsX2luc3RhbmNlLnR5cGUgIT0gbnVsbCl7XHJcblx0XHRcdHZhciB0eXBlID0gZ3JhcGhpY3NfaW5zdGFuY2UucGh5c2ljYWxfaW5zdGFuY2UudHlwZTtcclxuXHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly8gaWYgeW91IGVuY291bnRlciB0aGlzIGV4Y2VwdGlvbiBpdCBtYXkgbWVhbiBhIGJ1Zywgb3IgYWx0ZXJuYXRpdmVseVxyXG5cdFx0XHQvLyBpdCBtYXkgbWVhbiB0aGF0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgYW5kIHRoaXMgZnVuY3Rpb24gbmVlZHMgYW4gdXBkYXRlXHJcblx0XHRcdHRocm93IFwiUGh5c2ljYWwgaW5zdGFuY2Ugd2l0aCBpZCBcIiArIFN0cmluZyhpZCkgKyBcIiBkb2Vzbid0IHNlZW0gdG8gaGF2ZSBhIHR5cGVcIjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gcmVtb3ZlIGZyb20gdGhlIHN0YWdlIFxyXG5cdFx0XHJcblx0XHRcdC8qIGdyYXBoaWNzX2luc3RhbmNlLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7IFxyXG5cdFx0XHQgICBjb3VsZCBiZSBuZWNlc3NhcnkgdG8gcmVtb3ZlIGF0dGFjaGVkIGV2ZW50IGxpc3RlbmVycywgYnV0IGl0IHNlZW1zLCBhdCBsZWFzdFxyXG5cdFx0XHQgICBzbyBmYXIsIHRoYXQgdGhpcyBzdHVmZiBpcyBkb25lIGF1dG9tYXRpY2FsbHkgYmUgZWFzZWxqcyAqL1xyXG5cclxuXHRcdFx0R3JhcGhpY3NNb2RlbC5zdGFnZS5yZW1vdmVDaGlsZChncmFwaGljc19pbnN0YW5jZSk7XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGZyb20gYWxsX3BoeXNpY2FsIChyZXNwb25zaWJsZSB0cmFja2luZyBmb3IgYm9keSBwb3NpdGlvbilcclxuXHRcdFx0ZGVsZXRlIEdyYXBoaWNzTW9kZWwuYWxsX3BoeXNpY2FsW2lkXTtcclxuXHRcdC8vIHJlbW92ZSBmcm9tIHNwZWNpYWxfcmVuZGVyXHJcblx0XHRcdGRlbGV0ZSBHcmFwaGljc01vZGVsLnNwZWNpYWxfcmVuZGVyW3R5cGVdW2lkXTtcclxuXHRcdC8vIFRPRE86IHJlbW92ZSBjYW1lcmEgcmVmZXJlbmNlIGlmIGZvbGxvd2luZyB0aGlzIG9iamVjdFxyXG5cdFx0XHRcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblx0XHRnZXRfc3RhZ2U6IGdldF9zdGFnZSxcclxuXHRcdGdldF9jYW1lcmE6IGdldF9jYW1lcmEsXHJcblx0XHRnZXRfYXNzZXQ6IGdldF9hc3NldCxcclxuXHRcdHJlZ19mb3JfcmVuZGVyOiByZWdfZm9yX3JlbmRlcixcclxuXHRcdHNldF9yZWdfcG9zaXRpb246IHNldF9yZWdfcG9zaXRpb24sXHJcblx0XHRyZXF1ZXN0X2JpdG1hcDogcmVxdWVzdF9iaXRtYXAsXHJcblx0XHRyZXF1ZXN0X2FuaW1hdGVkOiByZXF1ZXN0X2FuaW1hdGVkLFxyXG5cdFx0ZGVzdHJveV9ncmFwaGljc19mb3I6IGRlc3Ryb3lfZ3JhcGhpY3NfZm9yLFxyXG5cdFx0Zm9sbG93OiBmb2xsb3csXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NDb250cm9sbGVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiR3JhcGhpY3NDb250cm9sbGVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5ERUZBVUxUIHwgSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUlNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG5cclxuIiwiXHJcbnZhciBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKXtcclxuXHQvKiBJcyBpbiBjaGFyZ2Ugb2YgZ2l2aW5nIHVuaXF1ZSBJRCdzIHRvIGV2ZXJ5dGhpbmdcclxuXHQgKiB0aGF0IHdhbnRzIHRoZW1cclxuXHQqL1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSB0aGUgSW5pdENvbnRyb2xsZXIgb25jZSB3aGVuIHRoZSBnYW1lIGlzIGxvYWRlZCAqL1xyXG5cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHJcblx0XHQvLyBjcmVhdGUgMTAwIGlkJ3NcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCAxMDA7IGkrKyl7XHJcblx0XHRcdHZhciBpZCA9IElkZW50aWZpY2F0aW9uTW9kZWwubmV4dF9pZCArKztcclxuXHRcdFx0SWRlbnRpZmljYXRpb25Nb2RlbC5mcmVlX2lkcy5wdXNoKGlkKTtcclxuXHRcdFx0SWRlbnRpZmljYXRpb25Nb2RlbC5pZF9tYXRjaGluZ1tpZF0gPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgdXBkYXRlID0gZnVuY3Rpb24oZGVsdGEpe1xyXG5cdFx0LyogaXMgcmFuIGVhY2ggdGljayBmcm9tIHRoZSBHYW1lQ29udHJvbGxlci51cGRhdGVfYWxsICovXHJcblx0XHQvLyBjbGVhbnVwIGlkcywgaWYgdG9vIG1hbnkgZnJlZSBpZHMgKGxpa2UgaWYgbm9uLWZyZWUgaWQncyA8IGZyZWUgaWQncy8xMFxyXG5cdFx0XHJcblx0XHQvL1RPRE86IG1ha2UgZnVuY3Rpb24gdG8gYWN0dWFsbHkgYmUgY2FsbGVkIGZyb20gdGhlIEdhbWVDb250cm9sbGVyLnVwZGF0ZV9hbGxcclxuXHRcdC8vIFRPRE86IGxvb3AgdGhyb3VnaCBhbGwgbm9uLWZyZWUgaWQncywgYW5kIGlmIGFueSBvZiB0aGVtIHJlZmVyZW5jZSBudWxsLFxyXG5cdFx0Ly8gcmVtb3ZlICh1bnJlZ2lzdGVyKSB0aGVtO1xyXG5cdFx0dmFyIGNtZHMgPSBLZXlib2FyZENvbnRyb2xsZXIuZGVidWdfY29tbWFuZHMoKTtcclxuXHRcdFxyXG5cdFx0aWYoY21kcyhcInNob3dfaWRzXCIpKXtcclxuXHRcdFx0Y29uc29sZS5sb2coSWRlbnRpZmljYXRpb25Nb2RlbC5mcmVlX2lkcywgSWRlbnRpZmljYXRpb25Nb2RlbC5uZXh0X2lkKTtcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGFzc2lnbl9pZCA9IGZ1bmN0aW9uKG9iaiwgc2V0X2lkKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBhc3NpZ25zIGlkIHRvIHRoZSBvYmplY3RcclxuXHRcdCogc2V0cyBwcm9wZXJ0eSBpZCBvbiB0aGUgb2JqZWN0IGdpdmVuLiB5b3UgY2FuIGdpdmUgT1BUSU9OQUwgcGFyYW1ldGVyXHJcblx0XHQqIHNldF9pZCB3aGljaCBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG9iamVjdCBhbmQgaWQgYW5kIGFzc2lnbnNcclxuXHRcdCogaWQgdG8gdGhlIG9iamVjdC4gdGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHN0b3JlIGlkIGluIHNvbWUgdW51c3VhbFxyXG5cdFx0KiBwbGFjZSwgb3IgcGVyZm9ybSBzb21lIGV4dHJhIG9wZXJhdGlvbnMgYmVmb3JlIGlkIGlzIGFzc2lnbmVkXHJcblx0XHQqXHJcblx0XHQqIHJldHVybiBpZCBhc3NpZ25lZFxyXG5cdFx0KiBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIgd2lsbCByZW1lbWJlciB0aGF0IHRoaXMgaWQgaGFzIGJlZW4gYXNzaWduZWRcclxuXHRcdCogdGhpcyBvYmplY3RcclxuXHRcdCovXHJcblx0XHR2YXIgZnJlZSA9IElkZW50aWZpY2F0aW9uTW9kZWwuZnJlZV9pZHM7XHJcblx0XHR2YXIgaWQ7XHJcblxyXG5cdFx0Ly8gZ2V0IGZyZWUgaWRcclxuXHRcdGlmKGZyZWUubGVuZ3RoID4gMCl7XHJcblx0XHRcdGlkID0gZnJlZS5wb3AoKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRpZCA9IElkZW50aWZpY2F0aW9uTW9kZWwubmV4dF9pZCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCBpZCBvbiB0aGUgb2JqZWN0LiB0aHJvdWdoIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXHJcblx0XHRpZihzZXRfaWQpe1xyXG5cdFx0XHRzZXRfaWQob2JqLCBpZCk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0b2JqLmlkID0gaWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXNzb2NpYXRlIGlkIHdpdGggdGhlIG9iamVjdCBvYmpcclxuXHRcdElkZW50aWZpY2F0aW9uTW9kZWwuaWRfbWF0Y2hpbmdbaWRdID0gb2JqO1xyXG5cclxuXHRcdHJldHVybiBpZFxyXG5cdH07XHJcblxyXG5cdHZhciByZXNlcnZlX2lkID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiByZXR1cm5zIGZyZWUgaWQgYW5kIHByb21pc2VzIG5vdCB0byBvdmVyaXRlIGl0XHJcblx0XHQqIGFsc28gYWxsb3dzIHNvbWVvbmUgdG8gZm9yY2UgdGhpcyBpZFxyXG5cdFx0Ki9cclxuXHRcdHZhciBmcmVlID0gSWRlbnRpZmljYXRpb25Nb2RlbC5mcmVlX2lkcztcclxuXHRcdC8vIGdldCBmcmVlIGlkXHJcblx0XHRpZihmcmVlLmxlbmd0aCA+IDApe1xyXG5cdFx0XHRpZCA9IGZyZWUucG9wKCk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0aWQgPSBJZGVudGlmaWNhdGlvbk1vZGVsLm5leHRfaWQrKztcclxuXHRcdH1cclxuXHJcblx0XHRJZGVudGlmaWNhdGlvbk1vZGVsLnJlc2VydmVkLnB1c2goaWQpO1xyXG5cclxuXHRcdHJldHVybiBpZDtcclxuXHJcblx0fTtcclxuXHRcclxuXHJcblx0dmFyIGZvcmNlX2lkID0gZnVuY3Rpb24ob2JqLCBpZCwgc2V0X2lkKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBGb3JjZSBvYmplY3QgPm9iajwgdG8gaGF2ZSB0aGUgZ2l2ZW4gaWQgPmlkPFxyXG5cdFx0KiBJZiBpZCBpc24ndCBmcmVlLCBleGNlcHRpb24gaXMgdGhyb3duXHJcblx0XHQqIFRoaXMgZnVuY3Rpb24gaXMgbW9zdCBsaWtlbHkgdXNlZCBkaXJlY3RseSBvbmx5IGZvciB0aGUgbXVsdGlwbGF5ZXJcclxuXHRcdCogcHVycG9zZXMgXHJcblx0XHQqIElmIE9QVElPTkFMIGZ1bmN0aW9uID5zZXRfaWQ8IGlzIGdpdmVuLCBpdCdsbCBiZSBjYWxsZWQgaW5zdGVhZFxyXG5cdFx0KiBvZiBhc3NpZ25pbmcgaWRzIGRpcmVjdGx5ICh1c2UgdGhpcyBpZiBzcGVjaWFsIG1hbmlwdWxhdGlvbnMgc2hvdWxkIGJlIGRvbmUpXHJcblx0XHQqXHJcblx0XHQqL1xyXG5cclxuXHRcdHZhciBmcmVlID0gSWRlbnRpZmljYXRpb25Nb2RlbC5mcmVlX2lkcztcclxuXHRcdHZhciByZXNlcnZlZCA9IElkZW50aWZpY2F0aW9uTW9kZWwucmVzZXJ2ZWQ7XHJcblxyXG5cdFx0dmFyIGlkeCA9IGZyZWUuaW5kZXhPZihpZCk7IFxyXG5cdFx0dmFyIGlkeSA9IHJlc2VydmVkLmluZGV4T2YoaWQpO1xyXG5cclxuXHRcdGlmKGlkeCA+PSAwKXtcclxuXHRcdFx0dmFyIGlkID0gZnJlZS5zcGxpY2UoaWR4LCAxKTsgLy8gZXh0cmFjdCB0aGUgZGVzaXJlZCBpbmRleCBcclxuXHRcdH1lbHNlIGlmIChpZHkgPj0gMCl7XHJcblx0XHRcdHZhciBpZCA9IHJlc2VydmVkLnNwbGljZShpZHgsIDEpOyAvLyBleHRyYWN0IHRoZSBkZXNpcmVkIGluZGV4IFxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdC8vIGlmIG5vdCBmb3VuZCwgdGhlbiBub24tZnJlZSBpZCwgdGhlbiBleGNlcHRpb25cclxuXHRcdFx0dGhyb3cgXCJUaGUgaWQgXCIgKyBTdHJpbmcoaWQpICsgXCIgaXMgbm9uLWZyZWVcIjtcclxuXHRcdH1cclxuXHRcclxuXHRcdC8vIHNldCBpZCBvbiB0aGUgb2JqZWN0LiB0aHJvdWdoIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXHJcblx0XHRpZihzZXRfaWQpe1xyXG5cdFx0XHRzZXRfaWQob2JqLCBpZCk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0b2JqLmlkID0gaWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXNzb2NpYXRlIGlkIHdpdGggdGhlIG9iamVjdCBvYmpcclxuXHRcdElkZW50aWZpY2F0aW9uTW9kZWwuaWRfbWF0Y2hpbmdbaWRdID0gb2JqO1xyXG5cclxuXHRcdHJldHVybiBpZDtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGdldF9ieV9pZCA9IGZ1bmN0aW9uKGlkKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBnZXQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gaWRcclxuXHRcdCovXHJcblx0XHRyZXR1cm4gSWRlbnRpZmljYXRpb25Nb2RlbC5pZF9tYXRjaGluZ1tpZF07XHJcblx0fTtcclxuXHJcblx0dmFyIHJlbW92ZV9pZCA9IGZ1bmN0aW9uKGlkKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBtYXJrIGlkIGFzIGZyZWUgYW5kIG5vIGxvbmdlciBhc3NpY2lhdGUgaXQgd2l0aCBhbnkgb2JqZWN0XHJcblx0XHQqIG5vdGljZSB0aGF0IHlvdSB5b3Vyc2VsZiBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIHN1cmVcclxuXHRcdCogdGhhdCBvYmplY3QgdGhhdCB3YXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaWQgZG9lc24ndCB0aGlua1xyXG5cdFx0KiB0aGF0IGhlIGlzIHN0aWxsIGFzc2lnbmVkIHRoaXMgaXNcclxuXHRcdCovXHJcblxyXG5cdFx0Ly8gVE9ETzogbWFrZSBzdXJlIHRoYXQgYWxsIGtub3duIHBsYWNlcyB0aGF0IHVzZSBpZHMgKFBoeXNpY3NDb250cm9sbGVycydcclxuXHRcdC8vIGNvbnRhY3QgbGlzdGVuZXIgZm9yIGV4YW1wbGUpIGFyZSBub3RpZmllZCB0aGF0IGlkIGhhZCBiZWVuIHVucmVnaXN0ZXJlZFxyXG5cdFx0ZGVsZXRlIElkZW50aWZpY2F0aW9uTW9kZWwuaWRfbWF0Y2hpbmdbaWRdO1xyXG5cdFx0SWRlbnRpZmljYXRpb25Nb2RlbC5mcmVlX2lkcy5wdXNoKGlkKTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBhc3NpZ25fdHlwZSA9IGZ1bmN0aW9uKG9iaiwgdHlwZSl7XHJcblx0XHQvKipcclxuXHRcdCogYXNzaWducyB3YW50ZWQgdHlwZSAoc3RyaW5nKSB0byB0aGUgZ2l2ZW5cclxuXHRcdCogbW9kZWwgZGVmaW5pdGlvblxyXG5cdFx0KiBpZiB5b3UgdHJ5IHRvIGFzc2lnbiBzYW1lIHR5cGUgdHdpY2UsIHRocm93cyBleGNlcHRpb247XHJcblx0XHQqIElkLi4uQ29udHJvbGxlciBhbGxvd3MgeW91IHRvIHJldHJpZXZlIG1vZGVsXHJcblx0XHQqL1xyXG5cclxuXHRcdHZhciB0eXBlcyA9IElkZW50aWZpY2F0aW9uTW9kZWwudHlwZXM7XHJcblx0XHRpZih0eXBlc1t0eXBlXSl7XHJcblx0XHRcdHRocm93IFwiRXJyb3I6IHR5cGUgXCIgKyB0eXBlICsgXCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLiBcIiArXHJcblx0XHRcdFx0XCJZb3UgY2FuJ3QgcmVnaXN0ZXIgdGhlIHNhbWUgdHlwZSB0d2ljZVwiO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHR5cGVzW3R5cGVdID0gb2JqO1xyXG5cdFx0XHRvYmoucHJvdG90eXBlLnR5cGUgPSB0eXBlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fTtcclxuXHRcclxuXHR2YXIgZ2V0X2J5X3R5cGUgPSBmdW5jdGlvbih0eXBlKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBnZXRzIG9iamVjdCBieSBpdCdzIHR5cGVcclxuXHRcdCovXHJcblx0XHR2YXIgdHlwZXMgPSBJZGVudGlmaWNhdGlvbk1vZGVsLnR5cGVzO1xyXG5cdFx0aWYodHlwZXNbdHlwZV0pe1xyXG5cdFx0XHRyZXR1cm4gdHlwZXNbdHlwZV07XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0dGhyb3cgXCJFcnJvcjogdHlwZSBcIiArIHR5cGUgKyBcIiB3YXNuJ3QgZGVmaW5lZCB5ZXRcIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHR1cGRhdGU6IHVwZGF0ZSxcclxuXHRcdGFzc2lnbl9pZDogYXNzaWduX2lkLFxyXG5cdFx0cmVzZXJ2ZV9pZDogcmVzZXJ2ZV9pZCxcclxuXHRcdGZvcmNlX2lkOiBmb3JjZV9pZCxcclxuXHRcdGdldF9ieV9pZDogZ2V0X2J5X2lkLFxyXG5cdFx0cmVtb3ZlX2lkOiByZW1vdmVfaWQsXHJcblx0XHRhc3NpZ25fdHlwZTogYXNzaWduX3R5cGUsXHJcblx0XHRnZXRfYnlfdHlwZTogZ2V0X2J5X3R5cGUsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpZmljYXRpb25Db250cm9sbGVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiSWRlbnRpZmljYXRpb25Db250cm9sbGVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5ERUZBVUxUXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuXHJcbiIsInZhciBJbml0Q29udHJvbGxlciA9IChmdW5jdGlvbigpe1xyXG5cdC8vIHdoeSBkbyB5b3Ugd2FudCB0byBwdXQgaW5pdGlhbGl6YXRpb24gb2YgZXZlcnl0aGluZyBpbnRvIHRoZSBJbml0Q29udHJvbGxlcj9cclxuXHQvLyBCZWNhdXNlIGlmIGluaXRpYWxpemF0aW9uIG9mIHNtdGggZGVwZW5kcyBvbiBpbml0aWFsaXphdGlvbiBvZiBzbXRoIGVsc2UsXHJcblx0Ly8gaXQncyBlYXNpZXIgdG8gY29udHJvbCBoZXJlXHJcblx0Ly9cclxuXHQvLyBlLmcuIGlmIHlvdSB0cnkgdG8gZG8gdmFyIGZvbyA9ICQoJyNmb28nKTsgc29tZXdoZXJlIGluIG90aGVyIG1vZHVsZSxcclxuXHQvLyB5b3UgY2FuIGdldCBmb28gPSBudWxsOyBhcyBjb2RlIG9mIHRoYXQgbW9kdWxlIGNhbiBleGVjdXRlIGJlZm9yZSB0aGUgaHRtbCBkb2N1bWVudFxyXG5cdC8vIHdhcyBmdWxseSBsb2FkZWQsIGJ1dCA+SW5pdENvbnRyb2xsZXIuaW5pdDwgaXMgY2FsbGVkIGFmdGVyIGRvY3VtZW50IHdhcyBsb2FkZWQsIHNvXHJcblx0Ly8gLTEgcG90ZW50aWFsIHByb2JsZW0uIEJ0dywgYXQgdGhpcyBtb21lbnQgaW4gdGltZSB0aGUgdGhlIHN0dWZmIGlzIHNldCB0byB3b3JrIHRoYXQgd2F5XHJcblx0Ly8gdXNpbmcgaHRtbCAoPGJvZHkgb25sb2FkPS4uLik7IG1heWJlIHVzaW5nIEpTIHdvdWxkIGJlIGJldHRlcj8gSWRrO1xyXG5cdFx0XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24obW9kZSwgc2Vzc2lvbl9pZCwgcGxheWVyX2lkLCBwbGF5ZXJfaWRfYXJyYXkpe1xyXG5cdFx0aW5jbHVkZSgpO1xyXG5cclxuXHRcdENvbmZpZy5Jbml0Lm1vZGUgPSBtb2RlO1xyXG5cdFx0Q29uZmlnLkluaXQuc2Vzc2lvbl9pZCA9IHNlc3Npb25faWQ7XHJcblx0XHRDb25maWcuSW5pdC5wbGF5ZXJfaWQgPSBwbGF5ZXJfaWQ7XHJcblx0XHRDb25maWcuSW5pdC5wbGF5ZXJfaWRfYXJyYXkgPSBwbGF5ZXJfaWRfYXJyYXk7XHJcblxyXG5cdFx0ZW5hYmxlX2Fycm93a2V5X3Njcm9sbChmYWxzZSk7XHJcblx0XHRzZXR1cF9zY3JlZW4oKTtcclxuXHRcdHNldHVwX2V2ZW50cygpO1xyXG5cclxuXHRcdGluaXRfYWxsX21vZHVsZXMobW9kZSk7IC8vIGNhbGwgLmluaXQgZnVuY3Rpb24gb2YgZXZlcnlvbmUuIGUuZy4gUGxheWVyQ29udHJvbGxlci5pbml0KCk7IGV0Yy5cclxuXHJcblx0XHRcclxuXHRcdC8vIE5vdGljZSB0aGF0IGFzc2V0IGRlcGVuZGVudCBzdHVmZiBkb2Vzbid0IChhbmQgbXVzdG4ndCkgc3RhcnQgdW50aWxcclxuXHRcdC8vIGFsbCBhc3NldHMgYXJlIGNvbXBsZXRlbHkgbG9hZGVkLiBUaGF0IGluY2x1ZGVzIHRpY2tlciwgaS5lLiBubyB0aWNrcyBhcmUgcHJvY2Vzc2VkXHJcblx0XHQvLyB1bnRpbCBldmVyeXRoaW5nIGlzIGxvYWRlZC4gSWYgeW91IHdhbnQgc29tZXRoaW5nIGRpZmZlcmVudCwgZS5nLiBkaXNwbGF5IHNvbWUgc29ydCBvZiBsb2FkaW5nXHJcblx0XHQvLyBhbmltYXRpb24gLSBsZXQgbWUga25vdy5cclxuXHRcdC8vIExvb2sgaW50byB0aGUgc2V0dXBfYXNzZXRfZGVwZW5kZW50IGZ1bmN0aW9uXHJcblx0XHRcdEFzc2V0TW9kZWwubG9hZGVyID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZShmYWxzZSk7IC8vIGxvYWRpbmcgcmVzb3Vyc2VzIHVzaW5nIHByZWxvYWQuanNcclxuXHRcdFx0QXNzZXRNb2RlbC5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBsZXRlXCIsIHNldHVwX2Fzc2V0X2RlcGVuZGVudCk7XHJcblxyXG5cdFx0Ly8gaWYgbW9yZSBzdHVmZiBuZWVkcyB0byBiZSBkb25lIGZvciB0aGUgdGVzdCBtb2RlLCBcclxuXHRcdC8vIG9yIG1vcmUgdHlwZXMgb2YgaXQgbmVlZHMgdG8gYmUgYWRkZWRcclxuXHRcdC8vIHlvdSBjYW4gc2FmZWx5IG1ha2UgdGhlIGZvbGxvd2luZyBhIHNlcGFyYXRlIGZ1bmN0aW9uXHJcblx0XHRcdHZhciBhc3NldF9wYXRoID0gKG1vZGUgPT0gXCJ0ZXN0XCIpID8gXCIuL2Fzc2V0cy9hcnQvXCIgOiBcIi4uL0dhbWVDb2RlL2Fzc2V0cy9hcnQvXCI7XHJcblxyXG5cdFx0QXNzZXRDb250cm9sbGVyLmluaXQoYXNzZXRfcGF0aCk7XHJcblxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgaW5pdF9hbGxfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZGUpe1xyXG5cdFx0Ly8gVE9ETzogYmV0dGVyIHdheSB0byBkbyBzdHVmZiBsaWtlIHRoYXQgKGNhbGwgY2VydGFpbiBmdW5jdGlvblxyXG5cdFx0Ly8gb2YgZXZlcnkgbW9kdWxlIGluIHRoZSBvcmRlci4gXHJcblx0XHQvLyBBbHNvLCBpbml0IGFuZCB1cGRhdGUgZnVuY3Rpb25zIG9mIGVhY2ggbW9kdWxlIHNob3VsZCBwcm9iYWJseVxyXG5cdFx0Ly8gYWNjZXB0IHNvbWUgYXJndW1lbnQuIEkgdGhpbmsgdG8gbWFrZSB0aGlzIGFyZ3VtZW50IGFuIG9iamVjdCxcclxuXHRcdC8vIHRoaXMgd2F5IHdlIGNhbiBhZGQgbW9yZSB0aGluZ3MgdG8gYmUgcGFzc2VkIHcvbyBhbnkgcHJvYmxlbSBhbmRcclxuXHRcdC8vIHdlIHdvbid0IG5lZWQgdG8gY2hhbmdlIGFueXRoaW5nXHJcblx0XHRcclxuXHRcdEIyZC5pbml0KCk7IC8vIGdvZXMgZmlyc3RcclxuXHRcdElkZW50aWZpY2F0aW9uQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHRSZWdpc3RlckFzQ29udHJvbGxlci5pbml0KCk7XHJcblxyXG5cdFx0Ly9Bc3NldENvbnRyb2xsZXIuaW5pdCgpOyAvLyBjYWxsZWQgZnJvbSB0aGUgSW5pdENvbnRyb2xsZXIuaW5pdC8vIHN0dWZmIGhhcyB0byBjaGFuZ2VcclxuXHRcdEdhbWVDb250cm9sbGVyLmluaXQoKTtcclxuXHRcdEtleWJvYXJkQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHRQaHlzaWNzQ29udHJvbGxlci5pbml0KCk7XHJcblxyXG5cdFx0VGVzdENvbnRyb2xsZXIuaW5pdChtb2RlKTtcclxuXHRcdFxyXG5cclxuXHRcdC8vUGxheWVyQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHRUZXJyYWluQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHRUZXJyYWluU2xpY2VDb250cm9sbGVyLmluaXQoKTtcclxuXHRcdFdvcmxkQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHRcclxuXHJcblxyXG5cclxuXHRcdC8vIFdBUk5JTkchISEgR3JhcGhpY3NDb250cm9sbGVyLmluaXQgaXMgY2FsbGVkIGZyb20gdGhlXHJcblx0XHQvLyBzZXR1cF9hc3NldF9kZXBlbmRlbnQgZnVuY3Rpb24gYXMgaXQsIHdlbGwsIGRlcGVuZHMgb24gYXNzZXRzIGJlaW5nIGxvYWRlZFxyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0dmFyIGVuYWJsZV9hcnJvd2tleV9zY3JvbGwgPSBmdW5jdGlvbihlbmFibGVfc2Nyb2xsKXtcclxuXHRcdGlmKGVuYWJsZV9zY3JvbGwgPT0gZmFsc2UpeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpeyAvLyAuZ2V0RWxlbWVudEJ5SWQoXCJkaXNwbGF5X2NhbnZhc1wiKVxyXG5cdFx0XHRcdGFycm93cyA9IFszNywgMzgsIDM5LCA0MF07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0XHRcdFx0aWYoYXJyb3dzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0XHR9ZWxzZXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0XHRcdH0pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0fVx0XHRcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBzZXR1cF9zY3JlZW4gPSBmdW5jdGlvbigpe1xyXG5cclxuXHRcdC8vIFNldHRpbmcgdXAgb3RoZXIgc3R1ZmY6XHJcblx0XHQvLyBlLmcgc2V0dXAgY2FudmFzIHNpemVcclxuXHRcdFxyXG5cdFx0Ly8gVE9ETzogYWxsb3cgcmVzaXplcz9cclxuXHJcblx0XHRDb25maWcuU0NSRUVOX1cgPSAkKCcjY2FudmFzX2NvbnRhaW5lcicpLndpZHRoKCk7IC8vIGlzIGR5bmFtaWNhbGx5IHNldCB0byBwaXhlbCB3aWR0aCBvZiB0aGUgY29udGFpbmluZyBlbGVtZW50XHJcblxyXG5cdFx0Ly8gcG9zc2libGUgcmVzaXppbmcgdGVjaG5pcXVlOiBcclxuXHRcdC8vIGh0dHA6Ly93d3cuZmFiaW9iaW9uZGkuY29tL2Jsb2cvMjAxMi8wOC9jcmVhdGVqcy1hbmQtaHRtbDUtY2FudmFzLXJlc2l6ZS1mdWxsc2NyZWVuLWFuZC1saXF1aWQtbGF5b3V0cy9cclxuXHJcblx0XHRcclxuXHRcdC8vJCgnI2RlYnVnX2NhbnZhcycpLndpZHRoKFN0cmluZyhTQ1JFRU5fVykgKyBcInB4XCIpO1xyXG5cdFx0Ly8kKCcjZGlzcGxheV9jYW52YXMnKS53aWR0aChTdHJpbmcoU0NSRUVOX1cpICsgXCJweFwiKTtcclxuXHJcblx0XHQvLyQoJyNkZWJ1Z19jYW52YXMnKS5oZWlnaHQoU3RyaW5nKFNDUkVFTl9IKSArIFwicHhcIik7XHJcblx0XHQvLyQoJyNkaXNwbGF5X2NhbnZhcycpLmhlaWdodChTdHJpbmcoU0NSRUVOX0gpICsgXCJweFwiKTtcclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciBzZXR1cF90aWNrZXIgPSBmdW5jdGlvbigpe1xyXG5cclxuXHRcdGNyZWF0ZWpzLlRpY2tlci5zZXRGUFMoQ29uZmlnLkZQUyk7XHJcblxyXG5cdFx0Ly8gdGlja2VyOiBvbiBlYWNoIHRpY2sgY2FsbCBHYW1lQ29udHJvbGxlci51cGRhdGVfYWxsKCk7XHJcblx0XHRjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgR2FtZUNvbnRyb2xsZXIudXBkYXRlX2FsbCk7XHJcblxyXG5cdFxyXG5cdH07XHJcblxyXG5cdHZhciBzZXR1cF9ldmVudHMgPSBmdW5jdGlvbigpe1xyXG5cclxuXHJcblx0XHQvLyBrZXlib2FyZCBpbnB1dCBldmVudDogb24gZWFjaCBrZXlib2FyZCBldmVudCBjYWxsIGFwcHJvcHJpYXRlIEtleWJvYXJkQ29udHJvbGxlciBmdW5jdGlvblxyXG5cdFx0ZG9jdW1lbnQub25rZXlkb3duID0gS2V5Ym9hcmRDb250cm9sbGVyLmtleWRvd247XHJcblx0XHRkb2N1bWVudC5vbmtleXVwID0gS2V5Ym9hcmRDb250cm9sbGVyLmtleXVwO1xyXG5cclxuXHRcdFx0Ly8gb24gaW50ZXJydXB0IGV2ZW50OiBzdG9wL3BhdXNlIHRpY2tlciA/XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBzZXR1cF9hc3NldF9kZXBlbmRlbnQgPSBmdW5jdGlvbigpe1xyXG5cdFx0Ly8gdGhpcyBtYXkgbmVlZCB0byBtb3ZlIHRvIGVpdGhlciBsb2FkX2dhbWUgb3Igc29tZSBzb3J0IG9mIHJlc2l6aW5nIGZ1bmN0aW9uXHJcblx0XHRNdWx0aXBsYXllclN5bmNDb250cm9sbGVyLmluaXQoKTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHROZXR3b3JrQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHRFbnRpdHlDb250cm9sbGVyLmluaXQoKTtcclxuXHRcdEdyYXBoaWNzQ29udHJvbGxlci5pbml0KCk7XHJcblx0XHQvL0hVRENvbnRyb2xsZXIuaW5pdCgpO1xyXG5cdFx0Ly9CYWNrZ3JvdW5kQ29udHJvbGxlci5pbml0KCk7XHJcblxyXG5cdFx0XHJcblx0XHRzZXR1cF90aWNrZXIoKTtcclxuXHJcblx0XHRpZihDb25maWcuSW5pdC5tb2RlID09IFwibXVsdGlwbGF5ZXJcIiAmJiBDb25maWcuSW5pdC5wbGF5ZXJfaWRfYXJyYXkgIT0gbnVsbCl7XHJcblx0XHRcdC8vIGlmIG11bHRpcGxheWVyIG1vZGVcclxuXHRcdFx0TmV0d29ya0NvbnRyb2xsZXIuc3RhcnRfbXVsdGlwbGF5ZXJfc2Vzc2lvbihDb25maWcuSW5pdC5wbGF5ZXJfaWRfYXJyYXkpO1xyXG5cdFx0fWVsc2UgaWYoQ29uZmlnLkluaXQubW9kZSA9PSBcInRlc3RcIiAmJiBHYW1lVXRpbGl0eS5yZWFkX3F1ZXJ5X3N0cmluZygpLnBsYXllcl9pZF9hcnJheSAhPSBudWxsKXtcclxuXHRcdFx0dmFyIHF1ZXJ5X29iamVjdCA9IEdhbWVVdGlsaXR5LnJlYWRfcXVlcnlfc3RyaW5nKCk7XHJcblxyXG5cdFx0XHR2YXIgcGxheWVyX2lkX2FycmF5ID0gSlNPTi5wYXJzZShkZWNvZGVVUkkocXVlcnlfb2JqZWN0LnBsYXllcl9pZF9hcnJheSkpO1xyXG5cclxuXHJcblx0XHRcdENvbmZpZy5Jbml0LnNlc3Npb25faWQgPSBxdWVyeV9vYmplY3Quc2Vzc2lvbl9pZDtcclxuXHRcdFx0Q29uZmlnLkluaXQucGxheWVyX2lkID0gcXVlcnlfb2JqZWN0LnBsYXllcl9pZDtcclxuXHRcdFx0Q29uZmlnLkluaXQucGxheWVyX2lkX2FycmF5ID0gcGxheWVyX2lkX2FycmF5O1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coXCJEZXRlY3RlZCBpZCBhcnJheSBwYXNzZWQgaW4gdGVzdCBtb2RlLiBTd2l0Y2hpbmcgdG8gdGhlIG11bHRpcGxheWVyIG1vZGVcIixcclxuXHRcdFx0XHRcdFwicGxheWVyX2lkX2FycmF5IGlzXCIsIHBsYXllcl9pZF9hcnJheSwgXCJteSBpZCBpc1wiLCBxdWVyeV9vYmplY3QucGxheWVyX2lkKTtcclxuXHRcdFx0Q29uZmlnLkluaXQubW9kZSA9IFwibXVsdGlwbGF5ZXJcIjtcclxuXHJcblx0XHRcdE5ldHdvcmtDb250cm9sbGVyLnN0YXJ0X211bHRpcGxheWVyX3Nlc3Npb24oQ29uZmlnLkluaXQucGxheWVyX2lkX2FycmF5KTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1RlcnJhaW5Db250cm9sbGVyLmdlbmVyYXRlX3RlcnJhaW4oKTsgLy8gSW5pdGlhbCB0ZXJyYWluIGdlbmVyYXRpb24gLy8gZGVwcmVjYXRlZCwgZ2VuZXJhdGlvbiB3aWxsIGJlIGNhbGxlZCBmcm9tIHVwZGF0ZSBlYWNoIHRpY2tcclxuXHR9O1xyXG5cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGluaXQ6IGluaXQsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW5pdENvbnRyb2xsZXI7XHJcblxyXG52YXIgSW5jbHVkZXMgPSByZXF1aXJlKFwiLi4vSW5jbHVkZXMuanNcIik7IHZhciBpbmNsdWRlX2RhdGEgPSBJbmNsdWRlcy5nZXRfaW5jbHVkZV9kYXRhKHtcclxuXHRjdXJyZW50X21vZHVsZTogXCJJbml0Q29udHJvbGxlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuQUxMXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuXHJcbiIsInZhciBLZXlib2FyZENvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKVxyXG57XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdFxyXG5cdFx0aW5jbHVkZSgpO1xyXG5cdH07XHJcblxyXG5cdHZhciB1cGRhdGUgPSBmdW5jdGlvbihkZWx0YSl7XHJcblx0XHQvKipcclxuXHRcdCogdXBkYXRlIGNhbGxlZCBmcm9tIEdhbWVDb250cm9sbGVyLnVwZGF0ZV9hbGxcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdGlmKEtleWJvYXJkTW9kZWwuc3RhdGVfY2hhbmdlZCl7XHJcblx0XHRcdC8vIGlmIGtleWJvYXJkIHN0YXRlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSxcclxuXHRcdFx0Ly8gc2VuZCB0aGUga2V5Ym9hcmQgc3RhdGUgb3Zlci5cclxuXHRcdFx0Ly8gVE9ETzogb3B0aW1pemU/XHJcblx0XHRcdC8vIFlvdSBjb3VsZCBzZW5kIG9ubHkgdGhvc2Ugc3BlY2lmaWMga2V5cyB0aGF0IGNoYW5nZWQsIG5vdCB3aG9sZSB0YWJsZVxyXG5cdFx0XHQvLyBZb3UgY291bGQgc2VuZCBvbmx5IHJlbGV2YW50IGtleXMgdGhhdCBtaWdodCBiZSBuZWVkZWQgdGhlcmVcclxuXHRcdFx0Ly8gSXMgaXQgd29ydGggdGhlIHRpbWUgc3BlbnQ/IEtlZXAgaW4gbWluZHMsIHRob3NlIHRhYmxlcyBhcmUgdXN1YWxseSBzbWFsbCxcclxuXHRcdFx0Ly8gdW5sZXNzIHBsYXllcnMgZGVjaWRlIHRvIHNtYXNoIHRoZWlyIGZhY2VzIGludG8gdGhlIGtleWJvcmQgcmVwZWF0ZWRseVxyXG5cdFx0XHQvLyAob3VyIGdhbWUgaXNuJ3QgdGhhdCBiYWQsIHJpZ2h0PylcclxuXHRcdFx0TXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlci5yb3V0ZV9vdXRjb21pbmdfcGFja2V0KHtcclxuXHRcdFx0XHRvcDogXCJrZXlib2FyZF9zdGF0ZVwiLFxyXG5cdFx0XHRcdGtleV90YWJsZTogS2V5Ym9hcmRNb2RlbC5rZXlzLFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdEtleWJvYXJkTW9kZWwuc3RhdGVfY2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIGhhbmRsZV9rZXlib2FyZF9jaGFuZ2UgPSBmdW5jdGlvbihwYWNrZXQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGFjY2VwdHMgdGhlIG5ldHdvcmsgcGFja2V0LiBjaGFuZ2VzIHRoZSByZXNwZWN0aXZlXHJcblx0XHQqIGtleWJvcmQgc3RhdGUgZm9yIHRoZSBnaXZlbiBwYWNrZXQucGxheWVyX2lkXHJcblx0XHQqIGlzIGNhbGxlZCBmcm9tIHRoZSBNdWx0aXBsYXllclN5bmNDb250cm9sbGVyXHJcblx0XHQqL1xyXG5cdFx0dmFyIHBsYXllcl9pZCA9IHBhY2tldC5wbGF5ZXJfaWQ7XHJcblx0XHRcclxuXHRcdGlmKHBsYXllcl9pZCA9PSBudWxsKXtcclxuXHRcdFx0dGhyb3cgXCJFcnJvcjogKG5ldHdvcmspIHBsYXllcl9pZCBpcyBub3QgZGVmaW5lZFwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdEtleWJvYXJkTW9kZWwuYWxsX2tleWJvYXJkX3N0YXRlc1twbGF5ZXJfaWRdID0gcGFja2V0LmtleV90YWJsZTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHZhciBjb3B5X29iamVjdCA9IGZ1bmN0aW9uKG9iail7XHJcblx0XHQvKipcclxuXHRcdCogcmV0dXJucyAoc2hhbGxvdykgY29weSBvZiB0aGUgb2JqZWN0XHJcblx0XHQqXHJcblx0XHQqIEBTdGFjayBPdmVyZmxvdzpcclxuXHRcdCogV2l0aCBqUXVlcnksIHlvdSBjYW4gc2hhbGxvdyBjb3B5IHdpdGg6XHJcblx0XHQqIHZhciBjb3BpZWRPYmplY3QgPSBqUXVlcnkuZXh0ZW5kKHt9LCBvcmlnaW5hbE9iamVjdClcclxuXHRcdCogc3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBjb3BpZWRPYmplY3Qgd2lsbCBub3QgYWZmZWN0IHRoZSBvcmlnaW5hbE9iamVjdCwgYW5kIHZpY2UgdmVyc2EuXHJcblx0XHQqIE9yIHRvIG1ha2UgYSBkZWVwIGNvcHk6XHJcblx0XHQqIHZhciBjb3BpZWRPYmplY3QgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBvcmlnaW5hbE9iamVjdClcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdHJldHVybiBqUXVlcnkuZXh0ZW5kKHt9LCBvYmopO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0dmFyIGdldF9hY3RpdmVfY29tbWFuZHNfZnVuY3Rpb24gPSBmdW5jdGlvbih0YWJsZSwgcGxheWVyX2lkKXtcclxuXHRcdC8vID5wbGF5ZXJfaWQ8IGlzIG9wdGlvbmFsLCBhbmQgcGFydCBvZiBhIGRpcnR5LWlzaCBxdWljayBpbXBsZW1lbnRhdGlvblxyXG5cdFx0Ly8gVGhpbmdzIHNob3VsZCBiZSByZXdyaXR0ZW4gYXQgc29tZSBwb2ludFxyXG5cdFx0Ly9cclxuXHRcdC8vIGdldCBhbGwgY29tbWFuZHMgYXNzb2NpYXRlZCB3aXRoIGtleXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgPnRhYmxlPCxcclxuXHRcdC8vIGFuZCBhcmUgY3VycmVudGx5IHByZXNzZWRcclxuXHRcdC8vXHJcblx0XHQvLyByZXR1cm5zOiBhcnJheSBvZiBjb21tYW5kc1xyXG5cdFx0Ly9cclxuXHRcdC8vIFRPRE86IFJFRkFDVE9SIHRoaXMgZnVuY3Rpb24gdG8gd29yayBiZXR0ZXIgYW5kIHNvIHBlb3BsZSBkbyBub3RcclxuXHRcdC8vIG5lZWQgdG8gY2FsbCBpdCBlYWNoIHRpY2suIGluc3RlYWQgdGhleSBzaG91bGQgZ2V0IHJlZmVyZW5jZSB0byBmdW5jdGlvbiBvbmUgdGltZVxyXG5cdFx0Ly8gYW5kIHN0YXkgdXBkYXRlZCBvbiB0aGUgYWN0aXZlIGNvbW1hbmRzXHJcblx0XHRcclxuXHRcdHZhciBjb21tYW5kcyA9IFtdO1xyXG5cdFx0aWYocGxheWVyX2lkICE9IG51bGwpe1xyXG5cdFx0XHR2YXIga2V5X3RhYmxlID0gS2V5Ym9hcmRNb2RlbC5hbGxfa2V5Ym9hcmRfc3RhdGVzW3BsYXllcl9pZF07XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0dmFyIGtleV90YWJsZSA9IEtleWJvYXJkTW9kZWwua2V5cztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0JC5lYWNoKEtleWJvYXJkTW9kZWwudHJhbnNsYXRpb25fdGFibGVzLmNvZGVfdG9fbmFtZSwgZnVuY3Rpb24oa2V5LCBjbWQpe1xyXG5cdFx0XHRpZihrZXlfdGFibGVba2V5XSAmJiB0YWJsZVtjbWRdKXtcclxuXHRcdFx0XHRjb21tYW5kcy5wdXNoKHRhYmxlW2NtZF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZ2V0X2tleSA9IGZ1bmN0aW9uKGtleSl7XHJcblx0XHRcdGlmKGNvbW1hbmRzLmluZGV4T2Yoa2V5KSA+IC0xKXtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBnZXRfa2V5O1xyXG5cdH07XHJcblxyXG5cdC8vIHB1YmxpYzpcclxuXHRcclxuXHR2YXIga2V5ZG93biA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuXHRcdEtleWJvYXJkTW9kZWwua2V5c1tldmVudC5rZXlDb2RlXSA9IHRydWU7XHJcblx0XHRLZXlib2FyZE1vZGVsLnN0YXRlX2NoYW5nZWQgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdHZhciBrZXl1cCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuXHRcdGRlbGV0ZSBLZXlib2FyZE1vZGVsLmtleXNbZXZlbnQua2V5Q29kZV07XHJcblx0XHRLZXlib2FyZE1vZGVsLnN0YXRlX2NoYW5nZWQgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cclxuXHR2YXIgbW92ZW1lbnRfY29tbWFuZHMgPSBmdW5jdGlvbigpe1xyXG5cdFx0cmV0dXJuIGdldF9hY3RpdmVfY29tbWFuZHNfZnVuY3Rpb24oS2V5Ym9hcmRNb2RlbC50cmFuc2xhdGlvbl90YWJsZXMubW92ZW1lbnQpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXVzZV9jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgcmV0dXJuIGdldF9hY3RpdmVfY29tbWFuZHNfZnVuY3Rpb24oS2V5Ym9hcmRNb2RlbC50cmFuc2xhdGlvbl90YWJsZXMucGF1c2UpO1xyXG5cdH07XHJcblxyXG5cdHZhciBkZWJ1Z19jb21tYW5kcyA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKipcclxuXHRcdCogY29tbWFuZHMgYWN0aXZlIGluIGRlYnVnIG1vZGVcclxuXHRcdCovXHJcblx0XHRyZXR1cm4gZ2V0X2FjdGl2ZV9jb21tYW5kc19mdW5jdGlvbihLZXlib2FyZE1vZGVsLnRyYW5zbGF0aW9uX3RhYmxlcy5kZWJ1Zyk7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgZ2V0X3JlbW90ZV9tb3ZlbWVudCA9IGZ1bmN0aW9uKHBsYXllcl9pZCl7XHJcblx0XHQvKipcclxuXHRcdCogdGhpcyBpdCBURU1QT1JBUlkgZnVuY3Rpb24gXHJcblx0XHQqIEkgdGhyb3cgaXQgdG9nZXRoZXIgc28gSSBkbyBub3QgaGF2ZSB0byBjaGFuZ2UgaG93IGtleWJvYXJkIGNvbnRyb2xsZXIgd29ya3MgZm9yIG5vd1xyXG5cdFx0KiBpZiB3ZSBmaW5kIHRoYXQgd2Ugc2hvdWxkIHNlbmQgbW9yZSBrZXlib2FyZCBzdHVmZiBvdmVyIHRoZSBuZXR3b3JrLCB3ZSBzaG91bGQgcmV3cml0ZVxyXG5cdFx0KiB0aGUgS2V5Ym9hcmRDb250cm9sbGVyIGFwcHJvcHJpYXRlbHlcclxuXHRcdCovXHJcblxyXG5cdFx0aWYocGxheWVyX2lkID09IG51bGwpe1xyXG5cdFx0XHR0aHJvdyBcIkVycm9yOiBwbGF5ZXJfaWQgdW5kZWZpbmVkXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGtleV9mdW4gPSBnZXRfYWN0aXZlX2NvbW1hbmRzX2Z1bmN0aW9uKEtleWJvYXJkTW9kZWwudHJhbnNsYXRpb25fdGFibGVzLm1vdmVtZW50LCBwbGF5ZXJfaWQpO1xyXG5cdFx0cmV0dXJuIGtleV9mdW47XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGtleWRvd246IGtleWRvd24sXHJcblx0XHRrZXl1cDoga2V5dXAsXHJcbiAgICAgICAgcGF1c2VfY29tbWFuZHM6IHBhdXNlX2NvbW1hbmRzLFxyXG5cdFx0bW92ZW1lbnRfY29tbWFuZHM6IG1vdmVtZW50X2NvbW1hbmRzLFxyXG5cdFx0ZGVidWdfY29tbWFuZHM6IGRlYnVnX2NvbW1hbmRzLFxyXG5cdFx0aW5pdDogaW5pdCxcclxuXHRcdHVwZGF0ZTogdXBkYXRlLFxyXG5cdFx0aGFuZGxlX2tleWJvYXJkX2NoYW5nZTogaGFuZGxlX2tleWJvYXJkX2NoYW5nZSxcclxuXHRcdGdldF9yZW1vdGVfbW92ZW1lbnQ6IGdldF9yZW1vdGVfbW92ZW1lbnQsXHJcblx0fTtcclxuXHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEtleWJvYXJkQ29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIktleWJvYXJkQ29udHJvbGxlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuREVGQVVMVFxyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJcclxudmFyIE11bHRpcGxheWVyU3luY0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKXtcclxuXHQvKiBFbnN1cmVzIHRoYXQgY3VycmVudCBwbGF5ZXIgaXMgc3luY2hyb25pemVkIHdpdGggdGhlIHNlcnZlclxyXG5cdCAqIG9yIHdpdGggb3RoZXIgcGxheWVyc1xyXG5cdCovXHJcblxyXG5cdHZhciBvcF90YWJsZTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogaXMgcmFuIGZyb20gdGhlIEluaXRDb250cm9sbGVyIG9uY2Ugd2hlbiB0aGUgZ2FtZSBpcyBsb2FkZWQgKi9cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHJcblx0XHQvLyB0YWJsZSB0aGF0IGFzc29jaWF0ZXMgPm9wPCAob3BlcmF0aW9uKSB3aXRoIHRoZSBzcGVjaWZpYyBoYW5kbGVyXHJcblx0XHQvLyBhdCBzb21lIChsaWtlbHkgZXh0ZXJuYWwpIG1vZHVsZVxyXG5cdFx0b3BfdGFibGUgPSB7XHJcblx0XHRcdHNwYXduOiBFbnRpdHlDb250cm9sbGVyLmhhbmRsZV9zcGF3bixcclxuXHRcdFx0ZGVsZXRlX2VudGl0eTogRW50aXR5Q29udHJvbGxlci5oYW5kbGVfZGVsZXRlLFxyXG5cdFx0XHRrZXlib2FyZF9zdGF0ZTogS2V5Ym9hcmRDb250cm9sbGVyLmhhbmRsZV9rZXlib2FyZF9jaGFuZ2UsXHJcblx0XHRcdGhlcm9fc3luYzogRW50aXR5Q29udHJvbGxlci5oYW5kbGVfaGVyb19zeW5jLFxyXG5cdFx0XHR0ZXJyYWluX3NlZWQ6IHN5bmNfc2VlZCxcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKXtcclxuXHRcdC8qIGlzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgR2FtZUNvbnRyb2xsZXIudXBkYXRlX2FsbCAqL1xyXG5cclxuXHRcdHZhciBkYXRhID0gTmV0d29ya0NvbnRyb2xsZXIuZ2V0X2RhdGEoKTsgLy8gYXJyYXkgb2YgYWxsIHBhY2tldHNcclxuXHJcblx0XHR2YXIgb3BfcGFja2V0ID0gTXVsdGlwbGF5ZXJTeW5jTW9kZWwub3BfcGFja2V0c190YWJsZTsgLy9vcF9wYWNrZXQgaXMgYSBsaXN0IG9mIG9iamVjdHNcclxuXHJcblx0XHRpZihkYXRhICE9IG51bGwpe1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0Ly8gZm9yIGVhY2ggcGFja2V0IGluIGluY29taW5nIHBhY2tldHMsXHJcblx0XHRcdFx0Ly8gcm91dCBpdFxyXG5cdFx0XHRcdHZhciBwYWNrZXQgPSBkYXRhW2ldO1xyXG5cdFx0XHRcdHJvdXRlX2luY29taW5nX3BhY2tldChwYWNrZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0TmV0d29ya0NvbnRyb2xsZXIuY2xlYW5fZGF0YSgpO1x0Ly8gcmVtb3ZlIGRhdGEgdGhhdCB3YXMgcHJvY2Vzc2VkXHJcblx0fTtcclxuXHJcblx0dmFyIHJvdXRlX291dGNvbWluZ19wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHJvdXRlIHBhY2tldCBhcHByb3ByaWF0ZWx5XHJcblx0XHQqL1xyXG5cdFx0aWYocGFja2V0LnBsYXllcl9pZCA9PSBudWxsKXtcclxuXHRcdFx0XHQvLyBpZiBwYWNrZXQgd2Fzbid0IGlkZW50aWZpZWQgYmVmb3JlXHJcblx0XHRcdFx0Ly8gaWRlbnRpZnkgdGhlIHBhY2tldCBhcyBtaW5lXHJcblx0XHRcdFx0cGFja2V0LnBsYXllcl9pZCA9IE5ldHdvcmtDb250cm9sbGVyLmdldF9uZXR3b3JrX2lkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wID0gcGFja2V0Lm9wO1xyXG5cdFx0dmFyIGhhbmRsZXIgPSBvcF90YWJsZVtvcF07XHJcblxyXG5cdFx0aWYoaGFuZGxlciA9PSBudWxsKXtcclxuXHRcdFx0Ly8gaWYgbm8gaGFuZGxlciBhc3NpZ25lZFxyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJObyBoYW5kbGVyIGZvciBvcFwiLCBvcCk7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihDb25maWcuUmVtb3RlLmNvbm5lY3RlZCl7XHJcblx0XHRcdC8vIGlmIG11bHRpcGxheWVyXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0aWYoQ29uZmlnLlJlbW90ZS5tYXN0ZXIpe1xyXG5cdFx0XHRcdC8vIGlmIG1hc3RlciBvZiB0aGUgbmV0d29ya1xyXG5cdFx0XHRcdC8vIHJvdXRlIGJhY2sgdG8gc3BlY2lmaWMgaGFuZGxlclxyXG5cdFx0XHRcdC8vIGVjaG8gdG8gYWxsIGNsaWVudHNcclxuXHJcblx0XHRcdFx0aGFuZGxlcihwYWNrZXQpO1xyXG5cclxuXHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBwYWNrZXQ7IC8vIGRvIHdlIHdhbnQgdG8gYWxsb3cgb3ZlcnJpZGluZyB0aGUgcmVzcG9uc2U/XHJcblxyXG5cdFx0XHRcdE5ldHdvcmtDb250cm9sbGVyLmFkZF90b19uZXh0X3VwZGF0ZShyZXNwb25zZSk7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdC8vIGlmIG9uZSBvZiB0aGUgY2xpZW50c1xyXG5cdFx0XHRcdC8vIHJvdXRlIHRvIHRoZSBtYXN0ZXJcclxuXHRcdFx0XHROZXR3b3JrQ29udHJvbGxlci5hZGRfdG9fbmV4dF91cGRhdGUocGFja2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdC8vIGlmIHNpbmdscGxheWVyXHJcblx0XHRcdC8vIHJvdXRlIGJhY2sgdG8gdGhlIHNwZWNpZmljIGhhbmRsZXJcclxuXHRcdFx0aGFuZGxlcihwYWNrZXQpO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKG9wLGhhbmRsZXIpO1xyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIHJvdXRlX2luY29taW5nX3BhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XHJcblx0XHQvKipcclxuXHRcdCogaGFuZGxlIHBhY2tldCB0aGF0IGFycml2ZWQgb3ZlciB0aGUgbmV0d29ya1xyXG5cdFx0KiAhIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgd2hlbiBwYWNrZXRzIGFycml2ZSByZW1vdGVseVxyXG5cdFx0KiAhIHNvIHlvdSBtYXkgc2FmZWx5IGFzc3VtZSB0aGF0IHlvdSBhcmUgY29ubmVjdGVkIHRvIHRoZSBuZXR3b3JrXHJcblx0XHQqICEgYW5kIHRoZSBwYWNrZXQgZGlkbid0IG9yaWdpbmF0ZSBvbiB5b3VyIHNpZGUgKHRoaXMgbGFzdCBvbmUgaXNcclxuXHRcdCogISBlc3BlY2lhbGx5IGltcG9ydGFudClcclxuXHRcdCovXHJcblxyXG5cdFx0YXBwbHlfdHJhbnNmb3JtcyhwYWNrZXQpOyAvLyBhcHBseSBhbnkgbmVjZXNzYXJ5IHRyYW5zZm9ybWF0aW9ucyBiZWZvcmUgYmVnaW5uaW5nXHJcblxyXG5cdFx0dmFyIG9wID0gcGFja2V0Lm9wO1xyXG5cdFx0dmFyIGhhbmRsZXIgPSBvcF90YWJsZVtvcF07XHJcblxyXG5cdFx0aWYoaGFuZGxlciA9PSBudWxsKXtcclxuXHRcdFx0Ly8gaWYgbm8gaGFuZGxlciBhc3NpZ25lZFxyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJObyBoYW5kbGVyIGZvciBvcFwiLCBvcCk7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihwYWNrZXQucGVyc29uYWxfY29tbXVuaWNhdGlvbiAhPSBudWxsKXtcclxuXHRcdFx0Y29uc29sZS53YXJuKHBhY2tldC5wZXJzb25hbF9jb21tdW5pY2F0aW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihDb25maWcuUmVtb3RlLm1hc3RlciAmJiBwYWNrZXQucGVyc29uYWxfY29tbXVuaWNhdGlvbiAhPSB0cnVlKXtcclxuXHRcdFx0Ly8gaWYgbWFzdGVyIGFuZCBwYWNrZXQgaXNuJ3QgbWVhbnQgcGVyc29uYWxseSBmb3IgbWVcclxuXHRcdFx0Ly8gcm91dGUgdG8gc3BlY2lmaWMgaGFuZGxlclxyXG5cdFx0XHQvLyBlY2hvIHRvIHRoZSBjbGllbnRzXHJcblx0XHRcdGhhbmRsZXIocGFja2V0KTtcclxuXHRcdFx0TmV0d29ya0NvbnRyb2xsZXIuYWRkX3RvX25leHRfdXBkYXRlKHBhY2tldCk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly8gaWYgb25lIG9mIHRoZSBjbGllbnRzXHJcblx0XHRcdC8vIHJvdXRlIHRvIHRoZSBoYW5kbGVyXHJcblx0XHRcdGhhbmRsZXIocGFja2V0KTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciBhcHBseV90cmFuc2Zvcm1zID0gZnVuY3Rpb24ocGFja2V0KXtcclxuXHRcdC8qKlxyXG5cdFx0KiBpZiBzb21lIHNwZWNpZmljIHRyYW5zZm9ybWF0aW9uIGlzIHN1cHBvc2VkIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHBhY2tldFxyXG5cdFx0KiAob3Agc2hvdWxkIGNoYW5nZSBzb21laG93LCBuZXcgcHJvcGVydGllcyBhZGRlZCBldGMuKVxyXG5cdFx0KiBhcHBseSB0aGlzIHRyYW5zZm9ybWF0aW9uXHJcblx0XHQqICEgbm90aWNlIHRoYXQgdHJhbnNmb3JtcyBhcmUgYXBwbGllZCB0byBpbmNvbWluZyBwYWNrZXRzIG9ubHlcclxuXHRcdCogISBpZiB5b3UgYXJlIGNvbmZpZGVudCB5b3UgbmVlZCBzb21ldGhpbmcgZWxzZSwgY29udGFjdCBtZSAoQUspXHJcblx0XHQqL1xyXG5cclxuXHRcdHN3aXRjaChwYWNrZXQub3Ape1xyXG5cdFx0XHRjYXNlIG51bGw6XHJcblx0XHRcdFx0Y29uc29sZS5sb2cocGFja2V0KTtcclxuXHRcdFx0XHR0aHJvdyBcIm9wIGZvciB0aGlzIHBhY2tldCBpcyB1bmRlZmluZWRcIjtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInNwYXduXCI6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdC8vZGVmYXVsdDpcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFja2V0O1xyXG5cdH07XHJcblx0XHJcblxyXG5cdHZhciBwYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgZnVuYyl7XHJcblx0XHQvKipcclxuXHRcdCogcGF0Y2ggb2JqZWN0IHdpdGggdGhlIGZ1bmN0aW9uIGdpdmVuXHJcblx0XHQqID5vYmplY3Q8IC0gb2JqZWN0IHdob3NlIHByb3RvdHlwZSB0byBwYXRjaCBcclxuXHRcdCogPmZ1bmM8IC0gTkFNRUQgZnVuY3Rpb24uIGl0IGhhcyB0byBoYXZlIHRoZSBzYW1lIG5hbWVcclxuXHRcdCogYXMgdGhlIGZ1bmN0aW9uIG9uIHRoZSA+b2JqZWN0PCdzIHByb3RvdHlwZSB0aGF0IGl0J3MgbWVhbnQgdG8gcmVwbGFjZVxyXG5cdFx0KiB0aGlzIGlzIGZ1bmN0aW9uIG5hbWVkIGJhcjogdmFyIGhleSA9IGZ1bmN0aW9uIGJhcigpe307XHJcblx0XHQqIHRoaXMgaXMgdW5uYW1lZCBmdW5jdGlvbjogdmFyIGhleSA9IGZ1bmN0aW9uKCl7fTtcclxuXHRcdCpcclxuXHRcdCogdGhlIGZ1bmN0aW9uIHRoYXQgeW91IHBhc3Mgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBub3JtYWwgZnVuY3Rpb24gYm9keVxyXG5cdFx0KiB3aGVuIGNhbGxlZCwgeW91ciBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgc2FtZSBvYmplY3QgKGluc3RhbmNlKSB0aGF0XHJcblx0XHQqIG9sZF9mdW5jdGlvbiBpcyBjYWxsZWQgYW5kIHdpbGwgYmUgcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50c1xyXG5cdFx0Ki9cclxuXHJcblx0XHRpZihmdW5jLm5hbWUgPT09IFwiXCIpe1xyXG5cdFx0XHR0aHJvdyBcIkZ1bmN0aW9uIHBhc3NlZCBzaG91bGQgYmUgbmFtZWQgZnVuY3Rpb25cIjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2xkX2Z1bmMgPSBvYmplY3QucHJvdG90eXBlW2Z1bmMubmFtZV07XHJcblx0XHR2YXIgY3VzdG9tX2Z1bmN0aW9uID0gZnVuYztcclxuXHJcblx0XHR2YXIgbmV3X2Z1bmN0aW9uID0gZnVuY3Rpb24gb3ZlcnJpZGVuX2J5X211bHRpcGxheWVyX2NvbnRyb2xsZXIoKXtcclxuXHJcblx0XHRcdGN1c3RvbV9mdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gb2xkX2Z1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCBvbGQgZnVuY3Rpb24gYW5kIHJldHVybiB3aGF0IGl0IHJldHVybnNcclxuXHRcdH1cclxuXHJcblx0XHRvYmplY3QucHJvdG90eXBlW2Z1bmMubmFtZV0gPSBuZXdfZnVuY3Rpb247XHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgZ2V0X2luaXRpYWxpemF0aW9uX2RhdGFfbWFzdGVyID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBnZXQgYXJyYXkgcGFja2V0cyB0aGF0IHNob3VsZCBiZSBzZW50IGZyb20gbWFzdGVyIHRvIGFsbCBvdGhlciBwZW9wbGUgYWZ0ZXIgdGhlIGNvbm5lY3Rpb25cclxuXHRcdCogd2l0aCB0aGVtIGlzIGVzdGFibGlzaGVkXHJcblx0XHQqL1xyXG5cclxuXHRcdHZhciBkYXRhID0gW107XHJcblx0XHRkYXRhLnB1c2goe29wOiBcInRlcnJhaW5fc2VlZFwiLCBzZWVkOiBUZXJyYWluQ29udHJvbGxlci5nZXRfc2VlZCgpLH0pO1xyXG5cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9O1xyXG5cclxuXHR2YXIgZ2V0X2luaXRpYWxpemF0aW9uX2RhdGFfY29tbW9uID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBnZXQgdGhlIGFycmF5IG9mIHBhY2tldHMgdGhhdCBzaG91bGQgYmUgc2VudCB3aGVuIHRvIG5ld2x5IGNvbm5lY3RlZCBwbGF5ZXJcclxuXHRcdCogcmVnYXJkbGVzcyB3aGV0aGVyIHRoaXMgcGxheWVyIGlzIGEgbWFzdGVyIG9yIG5vdFxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgZGF0YSA9IFtdO1xyXG5cclxuXHRcdHZhciBteV9oZXJvID0gRW50aXR5Q29udHJvbGxlci5nZXRfbXlfaGVybygpO1xyXG5cclxuXHRcdGlmKG15X2hlcm8gIT0gbnVsbCl7XHJcblx0XHRcdHZhciBwb3MgPSBteV9oZXJvLmJvZHkuR2V0V29ybGRDZW50ZXIoKTtcclxuXHRcdFx0ZGF0YS5wdXNoKHtcclxuXHRcdFx0XHRvcDogXCJzcGF3blwiLFxyXG5cdFx0XHRcdHBlcnNvbmFsX2NvbW11bmljYXRpb246IHRydWUsXHJcblx0XHRcdFx0dHlwZTogXCJoZXJvXCIsXHJcblx0XHRcdFx0eDogcG9zLngsXHJcblx0XHRcdFx0eTogcG9zLnksXHJcblx0XHRcdFx0Ly8gVE9ETzogc3luY2hyb25pemUgdGhlIHN0YXRlID8/PyBvciB3aWxsIGl0IGJlIGhhbmRsZWQgYXV0b21hdGljYWxseSB3LyBoZXJvc3luYz9cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH07XHJcblxyXG5cdHZhciBwdXJnZV9hbGxfZGF0YV9mb3IgPSBmdW5jdGlvbihuZXR3b3JrX2lkKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBkZXNwYXduIGhlcm8gYW5kIHJlbW92ZSBhbGwgdHJhY2VzIG9mIHByZXNlbmNlIGZvciB0aGUgcGxheWVyXHJcblx0XHQqIHdpdGggdGhpcyBuZXR3b3JrIGlkXHJcblx0XHQqIGNhbGxlZCB3aGVuIHBsYXllciBkaXNjb25uZWN0cyBmcm9tIHRoZSBnYW1lXHJcblx0XHQqL1xyXG5cdFx0XHJcblx0XHR2YXIgaGVyb2VzID0gRW50aXR5Q29udHJvbGxlci5nZXRfYWxsX2hlcm9lcygpOyBcclxuXHRcdHZhciBoZXJvID0gaGVyb2VzW25ldHdvcmtfaWRdO1xyXG5cdFx0XHJcblxyXG5cdFx0aWYoaGVybyAhPSBudWxsKXtcclxuXHRcdFx0RW50aXR5Q29udHJvbGxlci5kZWxldGVfZW50aXR5KGhlcm8pO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0dmFyIHN5bmNfc2VlZCA9IGZ1bmN0aW9uKHBhY2tldCl7XHJcblx0XHQvKipcclxuXHRcdCogZGVzY3JpcHRpb25cclxuXHRcdCovXHJcblx0XHRcclxuXHRcdGNvbnNvbGUubG9nKFwic3luY2luZyBteSBzZWVkIHdpdGggbWFzdGVyOyB0aGUgc2VlZCBpc1wiLCBwYWNrZXQuc2VlZCk7XHJcblx0XHRcclxuXHRcdHZhciBzZWVkID0gcGFja2V0LnNlZWQ7XHJcblx0XHRpZihzZWVkICE9IG51bGwpe1xyXG5cdFx0XHRUZXJyYWluQ29udHJvbGxlci5zZXRfc2VlZChzZWVkKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHR0aHJvdyBcInNlZWQgaXMgbm90IGRlZmluZWRcIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblx0XHRyb3V0ZV9vdXRjb21pbmdfcGFja2V0OiByb3V0ZV9vdXRjb21pbmdfcGFja2V0LFxyXG5cdFx0cm91dGVfaW5jb21pbmdfcGFja2V0OiByb3V0ZV9pbmNvbWluZ19wYWNrZXQsXHJcblx0XHRnZXRfaW5pdGlhbGl6YXRpb25fZGF0YV9tYXN0ZXI6IGdldF9pbml0aWFsaXphdGlvbl9kYXRhX21hc3RlcixcclxuXHRcdGdldF9pbml0aWFsaXphdGlvbl9kYXRhX2NvbW1vbjogZ2V0X2luaXRpYWxpemF0aW9uX2RhdGFfY29tbW9uLFxyXG5cdFx0cHVyZ2VfYWxsX2RhdGFfZm9yOiBwdXJnZV9hbGxfZGF0YV9mb3IsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTXVsdGlwbGF5ZXJTeW5jQ29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIk11bHRpcGxheWVyU3luY0NvbnRyb2xsZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkRFRkFVTFRcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG5cclxuIiwiXHJcbnZhciBOZXR3b3JrQ29udHJvbGxlciA9IChmdW5jdGlvbigpe1xyXG5cdC8qIG1hbmFnZXMgcDJwIGNvbW11bmljYXRpb25cclxuXHQqL1xyXG5cclxuXHR2YXIgcGVlciwgY29ubjsgLy8gVEVNUE9SQVJZLiB0aGVyZSB3aWxsIGJlIG11bHRpcGxlIG9mIHRob3NlIHRoaW5nc1xyXG5cdHZhciBNRURJQVRPUl9TRVJWRVJfS0VZID0gJ2x2Z2lveHVqM3lsbTFqb3InOyAvLydsMmY4Zjh2dGJoY2ZlY2RpJzsgLy8nYTd2b2pjcGY3MHlzeXZpJztcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogaXMgcmFuIGZyb20gdGhlIEluaXRDb250cm9sbGVyIG9uY2Ugd2hlbiB0aGUgZ2FtZSBpcyBsb2FkZWQgKi9cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHJcblx0XHQvLyBUT0RPOiBtYWtlIHN1cmUgdGhhdCBzZW5zaXRpdmUgaG9zdCBpbmZvIChsaWtlIHNwYXduIHJlcXVlc3QgdGhhdCBoYXZlIG5vdCBiZWVuXHJcblx0XHQvLyBzYXRpc2ZpZWQgeWV0KSBhcmUgcHJvY2Vzc2VkIGNvcnJlY3RseSBiZWZvcmUgdW5sb2FkaW5nXHJcblx0XHQvLyBhbHNvIGl0IG1heSBtYWtlIHNlbnNlIHRvIGhhbmRsZSBldmVuIHNpdHVhdGlvbnMgd2hlbiB0aGUgcGFnZSB3YXMgZm9yY2VkIHRvIHVubG9hZFxyXG5cdFx0Ly8gZXZlbiBiZWZvcmUgdGhlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgKHBvd2VyIHByb2JsZW0/KVxyXG5cdFx0ZG9jdW1lbnQub25iZWZvcmV1bmxvYWQgPSBvbl91bmxvYWQ7IC8vIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIHVzZXIgbGVhdmVzIHBhZ2VcclxuXHRcdE5ldHdvcmtNb2RlbC5oZXkgPSBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHJcblx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKXtcclxuXHRcdC8qIGlzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgR2FtZUNvbnRyb2xsZXIudXBkYXRlX2FsbCAqL1xyXG5cclxuXHRcdHZhciBjbWRzID0gS2V5Ym9hcmRDb250cm9sbGVyLmRlYnVnX2NvbW1hbmRzKCk7XHJcblxyXG5cdFx0aWYoIU5ldHdvcmtNb2RlbC5ibG9ja19jb25uZWN0aW9ucyAmJiBjbWRzKFwiY29ubmVjdFwiKSAmJiBDb25maWcuSW5pdC5tb2RlID09IFwidGVzdFwiKXsgXHJcblx0XHRcdE5ldHdvcmtNb2RlbC5ibG9ja19jb25uZWN0aW9ucyA9IHRydWU7XHJcblx0XHRcdHN0YXJ0X211bHRpcGxheWVyX3Nlc3Npb24oW1wicGxheWVyMVwiLCBcInBsYXllcjJcIiwgXCJwbGF5ZXIzXCIsIFwicGxheWVyNFwiLCBcInBsYXllcjVcIiwgXCJwbGF5ZXI2XCIsIFwicGxheWVyN1wiLCBcInBsYXllcjhcIl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKENvbmZpZy5SZW1vdGUuY29ubmVjdGVkKXtcclxuXHRcdFx0aWYoQ29uZmlnLlJlbW90ZS5tYXN0ZXIpe1xyXG5cdFx0XHRcdC8vIGlmIEkgYW0gdGhlIG1hc3RlciwgZGlzdHJpYnV0ZSBkYXRhXHJcblx0XHRcdFx0c2VuZF9vdXRfZGF0YSgpO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvLyBpZiBub3QgdGhlIG1hc3RlciwganVzdCBzZW5kIGRhdGEgdG8gdGhlIG1hc3RlclxyXG5cdFx0XHRcdHNlbmRfZGF0YV90b19tYXN0ZXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgc3RhcnRfbXVsdGlwbGF5ZXJfc2Vzc2lvbiA9IGZ1bmN0aW9uKGlkcyl7XHJcblx0XHQvKipcclxuXHRcdCogcGVyZm9ybSBwcm9jZWR1cmVzIHRvIHN0YXJ0IHBsYXlpbmcgd2l0aCBhbGxcclxuXHRcdCogb3RoZXIgY29ubmVjdGVkIHBlb3BsZVxyXG5cdFx0Ki9cclxuXHRcdE5ldHdvcmtNb2RlbC5wZWVyc190b19jb25uZWN0ID0gaWRzO1xyXG5cclxuXHRcdC8vIHRvIG5vdCBpbnRlcnJ1cHQgY29ubmVjdGlvbiBwcm9jZXNzXHJcblx0XHRHYW1lQ29udHJvbGxlci5zdG9wX2dhbWUoKTtcclxuXHJcblx0XHRpZihDb25maWcuSW5pdC5tb2RlICE9IFwidGVzdFwiKXtcdFxyXG5cdFx0XHQvLyBjcmVhdGUgcGVlciwgYXNzaWduIGlkXHJcblx0XHRcdHZhciBwZWVyID0gTmV0d29ya01vZGVsLm15X3BlZXIgPSBuZXdfcGVlcihDb25maWcuSW5pdC5wbGF5ZXJfaWQpOyBcclxuXHRcdFx0cGVlci5vbignZXJyb3InLCBoYW5kbGVfc3RhbmRhcnRfcGVlcl9lcnJvcik7XHJcblx0XHRcdHBlZXIub24oJ29wZW4nLCBvbl9vYnRhaW5pbmdfaWRfc3VjY2Vzc2Z1bGx5KTtcclxuXHRcdFx0TmV0d29ya01vZGVsLm15X3BlZXIgPSBwZWVyO1xyXG5cdFx0XHROZXR3b3JrTW9kZWwubXlfaWQgPSBDb25maWcuSW5pdC5wbGF5ZXJfaWQ7XHJcblxyXG5cdFx0fWVsc2V7XHJcblxyXG5cdFx0XHRzZXR1cF9uZXR3b3JrX3ZhcmlhYmxlc19mb3JfdGVzdGluZ19tb2RlKCk7XHJcblx0XHRcdHNldHVwX215X3BlZXJfdGVzdCgpOyAvLyBzZXR1cCBwZWVyIC8vIGFsc28gcGlja3MgZnJlZSBpZHIvLyBjYWxscyA+b25fb2J0YWluaW5nX2lkX3N1Y2Nlc3NmdWxseVxyXG5cdFx0fVxyXG5cdFx0XHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciBzZXR1cF9uZXR3b3JrX3ZhcmlhYmxlc19mb3JfdGVzdGluZ19tb2RlID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBzZXR1cCB2YXJpb3VzIHBhcmFtZXRlcnMgZm9yIHRoZSB0ZXN0aW5nIG1vZGUgZ2FtZVxyXG5cdFx0Ki9cclxuXHRcdHZhciBpZHMgPSBOZXR3b3JrTW9kZWwucGVlcnNfdG9fY29ubmVjdDtcclxuXHJcblx0XHROZXR3b3JrTW9kZWwuY29ubmVjdGlvbnMgPSB7fTtcclxuXHRcdE5ldHdvcmtNb2RlbC5mcmVlX2lkcyA9IFtdO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHR2YXIgaWQgPSBpZHNbaV07XHJcblx0XHRcdE5ldHdvcmtNb2RlbC5jb25uZWN0aW9uc1tpZF0gPSBudWxsO1xyXG5cdFx0XHROZXR3b3JrTW9kZWwuZnJlZV9pZHMucHVzaChpZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0TmV0d29ya01vZGVsLm5vbl9mcmVlX2lkcyA9IFtdO1xyXG5cclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHZhciBoYW5kbGVfc3RhbmRhcnRfcGVlcl9lcnJvciA9IGZ1bmN0aW9uKGVycm9yKXtcclxuXHRcdC8qKlxyXG5cdFx0KiB0aGlzIGZ1bmN0aW9uIGlzIGZvciBjb25uZWN0aW9uIGVycm9yc1xyXG5cdFx0KiBpbiBub24tdGVzdCBtb2RlXHJcblx0XHQqL1xyXG5cclxuXHRcdC8vY29uc29sZS5sb2coZXJyb3IpO1xyXG5cdFx0Ly90aHJvdyBcIlBlZXIgZXJyb3JcIjtcclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblxyXG5cdHZhciBvbl9vYnRhaW5pbmdfaWRfc3VjY2Vzc2Z1bGx5ID0gZnVuY3Rpb24oaWQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHdoZW4gdGhlIHBsYXllciBpZCBmb3IgdGhpcyBjbGllbnQgd2FzIHN1Y2Nlc3NmdWxseVxyXG5cdFx0KiBmb3VuZCB0aHJvdWdoIHRoZSBwcm9jZXNzIGluIHRoZSBzZXR1cF9teV9wZWVyX3Rlc3QoKTsgZnVuY3Rpb24sXHJcblx0XHQqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3aGljaCBzaG91bGQgc2V0dXAgYWxsIG5lY2Vzc2FyeSB0aGluZ3MgZm9yIFxyXG5cdFx0KiB0aGUgbXVsdGlwbGF5ZXIgdG8gd29yaywgYW5kIGNvbm5lY3QgdG8gdGhlIG90aGVyIHBsYXllclxyXG5cdFx0Ki9cclxuXHJcblx0XHROZXR3b3JrTW9kZWwubXlfaWQgPSBpZDtcclxuXHRcdENvbmZpZy5SZW1vdGUuY29ubmVjdGVkID0gdHJ1ZTtcclxuXHJcblx0XHR2YXIgcGVlciA9IE5ldHdvcmtNb2RlbC5teV9wZWVyO1xyXG5cclxuXHRcdHBlZXIub24oJ2Vycm9yJywgb25fcGVlcl9lcnJvcik7XHJcblxyXG5cdFx0aWYoTmV0d29ya01vZGVsLm15X2lkICE9IE5ldHdvcmtNb2RlbC5teV9wZWVyLmlkKXtcclxuXHRcdFx0Ly8gbm90IGEgbWVhbmluZ2Z1bCBjaGVjaywgdGVycmlibGUgcHJhY3RpY2VzIGFyZSB0ZXJyaWJsZVxyXG5cdFx0XHR0aHJvdyBcIklkJ3MgZG8gbm90IG1hdGNoLiBTbXRoIHdlbnQgd3JvbmdcIiBcclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIk9idGFpbmVkIGlkIHN1Y2Vzc2Z1bGx5LCBteSBpZCBpc1wiLCBpZCk7XHJcblxyXG5cdFx0aWYoQ29uZmlnLkluaXQubW9kZSA9PSBcInRlc3RcIil7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiUGxheWluZyBpbiB0ZXN0aW5nIG11bHRpcGxheWVyIG1vZGVcIik7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJQbGF5aW5nIGluIG5vcm1hbCBtdWx0aXBsYXllciBtb2RlXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIG5vdGUgdGhhdCBpZiBvdGhlciBwZWVycyBjb25uZWN0IGluIHRoZSBmdXR1cmUsIFxyXG5cdFx0ICogY29ubmVjdGlvbiB3aXRoIHRoZW0gd2lsbCBiZSBoYW5kbGVkIGF0IHRoYXQgdGltZVxyXG5cdFx0ICogdGhyb3VnaCBhY2NlcHRfY29ubmVjdGlvbiBmdW5jdGlvblxyXG5cdFx0ICovXHJcblx0XHRjb25uZWN0X3RvX290aGVycygpO1xyXG5cclxuXHRcdC8vIGFsbG93IHRpbWUgZm9yIGNvbm5lY3Rpb25zIHRvIGJlIGVzdGFibGlzaGVkLCB0aGVuIHBpY2sgdGhlIG1hc3RlclxyXG5cdFx0TmV0d29ya01vZGVsLnRpbWVvdXRfaWQgPSBzZXRUaW1lb3V0KHBpY2tfdGhlX21hc3RlciwgQ29uZmlnLlJlbW90ZS5ub3RpZmljYXRpb25fd2FpdCk7XHJcblx0fTtcclxuXHJcblxyXG5cdHZhciBjb25uZWN0X3RvX290aGVycyA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKipcclxuXHRcdCogY29ubmVjdCB0byBhbGwgb3RoZXIgcGVlcnMgdGhhdCBhcmUgYXZhaWxhYmxlIGF0IHRoaXMgdGltZVxyXG5cdFx0Ki9cclxuXHRcdHZhciBpZHMgPSBOZXR3b3JrTW9kZWwucGVlcnNfdG9fY29ubmVjdDtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspe1xyXG5cclxuXHRcdFx0dmFyIGlkID0gaWRzW2ldO1xyXG5cclxuXHRcdFx0aWYoaWQgIT0gTmV0d29ya01vZGVsLm15X2lkKXtcclxuXHRcdFx0XHR2YXIgY29ubmVjdGlvbiA9IE5ldHdvcmtNb2RlbC5teV9wZWVyLmNvbm5lY3QoaWQpO1xyXG5cclxuXHRcdFx0XHRzZXR1cF9jb25uZWN0aW9uX2xpc3RlbmVycyhjb25uZWN0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRcclxuXHR2YXIgb25fcGVlcl9lcnJvciA9IGZ1bmN0aW9uKGVycm9yKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBjYWxsZWQgb24gcGVlciBlcnJvcjtcclxuXHRcdCogbm90aWNlIHRoYXQgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IGhhbmRsZVxyXG5cdFx0KiBwZWVyIGVycm9ycyB0aGF0IGFyaXNlIGZyb20gaW5hYmlsaXR5IHRvIGNyZWF0ZSBwZWVyIGJlY2F1c2Ugb2YgaWQgY29uZmxpY3RzLFxyXG5cdFx0KiBhcyB0aGlzIGZ1bmN0aW9uIGlzIGF0dGFjaGVkIGFzIGxpc3RlbmVyIG9ubHkgYWZ0ZXIgdGhlIHBlZXIgaXMgc3VjZXNzZnVsbHlcclxuXHRcdCogY3JlYXRlZFxyXG5cdFx0Ki9cclxuXHRcdC8vY29uc29sZS53YXJuKFwiUGVlciBlcnJvclwiLCBlcnJvcik7XHJcblx0fTtcclxuXHJcblx0XHJcblx0dmFyIHNldHVwX215X3BlZXJfdGVzdCA9IGZ1bmN0aW9uKGVycm9yKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBzZXR1cHMgeW91ciBwZXJzb25hbCBwZWVyIHBpY2tpbmcgZnJlZSBpZCwgYW5kIHJldHVybmluZyBpdFxyXG5cdFx0KiBsb29raW5nIHVwIGZvciB0aGUgZnJlZSBpZCdzIGlzIGEgaHVnZSBwYWluIG5vdywgb25jZSB3ZSBydW4gb3VyXHJcblx0XHQqIG93biBwZWVyIG1hdGNoaW5nIHNlcnZlciwgaXQnbGwgYmUgYSBsb3QgZWFzaWVyXHJcblx0XHQqXHJcblx0XHQqID5lcnJvcjwgcGFyYW1ldGVyIGlzIG51bGwgb24gdGhlIGZpcnN0IGNhbGwsIGJ1dCBpZiBmaXJzdCBpZCB0aGF0IHdhc1xyXG5cdFx0KiB0cmllZCB3YXMgYWxyZWFkeSB0YWtlbiwgYW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZ2FpbiwgaXQnbGwgbm90IGJlIG51bGwgXHJcblx0XHQqL1xyXG5cclxuXHRcdGlmKGVycm9yID09IG51bGwgfHwgZXJyb3IudHlwZSA9PSBcInVuYXZhaWxhYmxlLWlkXCIpe1xyXG5cdFx0XHRpZihOZXR3b3JrTW9kZWwuZnJlZV9pZHMubGVuZ3RoID4gMCl7XHJcblx0XHRcdFx0dmFyIGlkID0gTmV0d29ya01vZGVsLmZyZWVfaWRzLnBvcCgpO1xyXG5cdFx0XHRcdE5ldHdvcmtNb2RlbC5ub25fZnJlZV9pZHMucHVzaChpZCk7XHJcblx0XHRcdFx0dmFyIHBlZXIgPSBOZXR3b3JrTW9kZWwubXlfcGVlciA9IG5ld19wZWVyKGlkKTsgXHJcblx0XHRcdFx0cGVlci5vbignZXJyb3InLCBzZXR1cF9teV9wZWVyX3Rlc3QpO1xyXG5cdFx0XHRcdHBlZXIub24oJ29wZW4nLCBvbl9vYnRhaW5pbmdfaWRfc3VjY2Vzc2Z1bGx5KTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiQ291bGRuJ3QgZXN0YWJsaXNoIG11bHRpcGxheWVyIHNlc3Npb24sIGFsbCBcIiArIFN0cmluZyhOZXR3b3JrTW9kZWwucGVlcnNfdG9fY29ubmVjdC5sZW5ndGgpICsgXCIgYXZhaWxhYmxlIHNsb3RzIHRha2VuXCIpO1xyXG5cdFx0XHRcdENvbmZpZy5SZW1vdGUuY29ubmVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0TmV0d29ya01vZGVsLmJsb2NrX2Nvbm5lY3Rpb25zID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdHNldHVwX25ldHdvcmtfdmFyaWFibGVzX2Zvcl90ZXN0aW5nX21vZGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdC8vY29uc29sZS53YXJuKFwiUGVlciBlcnJvclwiLCBlcnJvcik7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgb25fY29ubmVjdGlvbl9vcGVuID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBvbiBvcGVuaW5nIHRoZSBjb25uZWN0aW9uXHJcblx0XHQqL1xyXG5cclxuXHRcdHZhciBpZCA9IHRoaXMucGVlcjtcdFxyXG5cdFx0XHJcblx0XHRjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQgbmV3IGNvbm5lY3Rpb24gd2l0aCB0aGUgcGVlclwiLCBpZCk7XHJcblxyXG5cdFx0TmV0d29ya01vZGVsLmNvbm5lY3Rpb25zW2lkXSA9IHRoaXM7XHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgb25fY29ubmVjdGlvbl9jbG9zZWQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGNhbGxlZCB3aGVuIHNvbWUgY29ubmVjdGlvbiBjbG9zZXNcclxuXHRcdCovXHJcblx0XHR2YXIgaWQgPSB0aGlzLnBlZXI7XHJcblx0XHR2YXIgbmZyZWUgPSBOZXR3b3JrTW9kZWwubm9uX2ZyZWVfaWRzO1xyXG5cclxuXHRcdG5mcmVlLnNwbGljZShuZnJlZS5pbmRleE9mKGlkKSwgMSk7XHJcblxyXG5cdFx0TmV0d29ya01vZGVsLmZyZWVfaWRzLnB1c2goaWQpO1xyXG5cclxuXHRcdGRlbGV0ZSBOZXR3b3JrTW9kZWwuY29ubmVjdGlvbnNbaWRdO1xyXG5cclxuXHJcblx0XHRpZihOZXR3b3JrTW9kZWwubWFzdGVyX2lkID09PSBpZCl7XHJcblx0XHRcdEdhbWVDb250cm9sbGVyLnN0b3BfZ2FtZSgpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkNsb3NpbmcgY29ubmVjdGlvbiB3aXRoIHRoZSBtYXN0ZXJcIik7XHJcblx0XHRcdE5ldHdvcmtNb2RlbC5tYXN0ZXJfaWQgPSBudWxsO1xyXG5cdFx0XHRwaWNrX3RoZV9tYXN0ZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHRNdWx0aXBsYXllclN5bmNDb250cm9sbGVyLnB1cmdlX2FsbF9kYXRhX2ZvcihpZCk7XHJcblxyXG5cdFx0Y29uc29sZS5sb2coXCJDb25uZWN0aW9uIHdpdGggcGVlclwiLCBpZCwgXCJ3YXMgc3VjY2Vzc2Z1bGx5IGNsb3NlZFwiKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb25fY29ubmVjdGlvbl9lcnJvciA9IGZ1bmN0aW9uKGVycm9yKXtcclxuXHRcdC8qKlxyXG5cdFx0KiB3aGVuIGVycm9yIG9uIHRyeWluZyB0byBlc3RhYmxpc2ggY29ubmVjdGlvbiBvY2N1cnM7XHJcblx0XHQqIG1vc3Qgb2Z0ZW4gaXQgd2lsbCBiZSBlcnJvciBmb3IgcGVlciBub3QgZXhpc3RpbmcuIHRoYXQncyBwYXJ0IG9mIHRoZSBub3JtYWwgcHJvY2Vzc1xyXG5cdFx0Ki9cclxuXHRcdFxyXG5cdFx0Y29uc29sZS5sb2coXCJjb25uZWN0aW9uIGVycm9yIChsaWtlbHkgbm90IGEgYnVnKVwiKTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBwaWNrX3RoZV9tYXN0ZXIgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHBpY2sgdGhlIG1hc3RlciAob25lIHdpdGggd2hvbWUgZXZlcnlvbmUgc3luY2hyb25pemVzKVxyXG5cdFx0KiBmb3IgdGhlIGN1cnJlbnQgZ3JvdXAgb2YgcGVlcnMuXHJcblx0XHQqL1xyXG5cclxuXHRcdGlmKE5ldHdvcmtNb2RlbC5tYXN0ZXJfaWQgIT0gbnVsbCl7XHJcblx0XHRcdC8vIGlmIG1hc3RlciB3YXMgY2hvc2VuIGFscmVhZHlcclxuXHRcdFx0Y29uc29sZS5sb2coXCJtYXN0ZXIgaXMgYWxyZWFkeSBjaG9zZW5cIik7XHJcblx0XHR9ZWxzZXtcclxuXHJcblx0XHRcdHZhciBpZHMgPSBOZXR3b3JrTW9kZWwucGVlcnNfdG9fY29ubmVjdDtcclxuXHJcblx0XHRcdHZhciBjb25ucyA9IE5ldHdvcmtNb2RlbC5jb25uZWN0aW9ucztcclxuXHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdHZhciBpZCA9IGlkc1tpXTtcclxuXHJcblx0XHRcdFx0aWYoY29ubnNbaWRdICE9IG51bGwgJiYgaWQgIT0gTmV0d29ya01vZGVsLm15X2lkKXtcclxuXHRcdFx0XHRcdHNldF9tYXN0ZXIoaWQpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJUaGUgbWFzdGVyIGlzXCIsIGlkKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1lbHNlIGlmKGlkID09IE5ldHdvcmtNb2RlbC5teV9pZCl7XHJcblx0XHRcdFx0XHQvLyBpIGFtIHRoZSBiZXN0IGNhbmRpZGF0ZSBmb3IgbWFzdGVyXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkkgYW0gdGhlIGxhdyAod2FzIGNob3NlbiBhcyBtYXN0ZXIpXCIpO1xyXG5cdFx0XHRcdFx0c2V0X21hc3RlcihpZCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRHYW1lQ29udHJvbGxlci5jb250aW51ZV9nYW1lKCk7XHJcblxyXG5cdH07IC8vIGVuZCBwaWNrX3RoZV9tYXN0ZXJcclxuXHRcclxuXHR2YXIgc2V0X21hc3RlciA9IGZ1bmN0aW9uKGlkKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBzZXQgdGhlIG1hc3RlciB0byB0aGUgcGVlciB3aXRoIGdpdmVuIGlkXHJcblx0XHQqIGFuZCBwZXJmb3JtIGFsbCBhc3NvY2lhdGVkIHByb2NlZHVyZXNcclxuXHRcdCovXHJcblxyXG5cdFx0TmV0d29ya01vZGVsLm1hc3Rlcl9pZCA9IGlkO1xyXG5cdFx0XHJcblx0XHRpZihOZXR3b3JrTW9kZWwubWFzdGVyX2lkID09IE5ldHdvcmtNb2RlbC5teV9pZCl7XHJcblx0XHRcdC8vIGlmIG1hc3RlclxyXG5cclxuXHRcdFx0Ly8gc2V0IHRoZSBtYXN0ZXIgZmxhZ1xyXG5cdFx0XHRDb25maWcuUmVtb3RlLm1hc3RlciA9IHRydWU7XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdH0vLyBmaVxyXG5cclxuXHRcdC8vIHNlbmQgb3V0IGluaXRpYWwgc3luYyBkYXRhXHJcblx0XHRzZW5kX2luaXRpYWxpemF0aW9uX2RhdGEoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgc2VuZF9pbml0aWFsaXphdGlvbl9kYXRhID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBzZW5kIHRoZSBpbml0aWFsaXphdGlvbiBkYXRhIHRvIHRoZSBwZWVyIHdpdGggdGhlIGdpdmVuIGlkXHJcblx0XHQqXHJcblx0XHQqL1xyXG5cclxuXHRcdHZhciBjb25ucyA9IE5ldHdvcmtNb2RlbC5jb25uZWN0aW9ucztcclxuXHRcdGZvcih2YXIgaWQgaW4gY29ubnMpe1xyXG5cdFx0XHRpZihpZCAhPSBOZXR3b3JrTW9kZWwubXlfaWQgJiYgY29ubnNbaWRdKXtcclxuXHRcdFx0XHRzZW5kX2luaXRpYWxpemF0aW9uX2RhdGFfdG8oaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHR2YXIgc2VuZF9pbml0aWFsaXphdGlvbl9kYXRhX3RvID0gZnVuY3Rpb24oaWQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGRlc2NyaXB0aW9uXHJcblx0XHQqL1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwic2VuZGluZyBpbml0aWFsaXphdGlvbiBkYXRhIHRvXCIsIGlkKTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRpZihOZXR3b3JrTW9kZWwubWFzdGVyX2lkID09IE5ldHdvcmtNb2RlbC5teV9pZCl7XHJcblx0XHRcdGRhdGEgPSBbXTtcclxuXHJcblx0XHRcdHZhciBhcnIgPSBNdWx0aXBsYXllclN5bmNDb250cm9sbGVyLmdldF9pbml0aWFsaXphdGlvbl9kYXRhX21hc3RlcigpO1xyXG5cclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0ZGF0YS5wdXNoKGFycltpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNlbmRfdG8oaWQsIHtvcDogXCJzcGVjaWFsX2NvbW11bmljYXRpb25cIiwgc3BlY2lhbF9jb21tdW5pY2F0aW9uOiB0cnVlLCBtZXNzYWdlOiBcIkkgYW0gdGhlIGxhdyFcIiwgbWFzdGVyX2lkOiBOZXR3b3JrTW9kZWwubXlfaWR9KTtcclxuXHRcdFx0c2VuZF90byhpZCwgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0dmFyIG5ld19wZWVyID0gZnVuY3Rpb24oaWQpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHBhc3MgdGhlIGlkIHlvdSB3YW50IHRoZSBwZWVyIHRvIGhhdmVcclxuXHRcdCogcmV0dXJucyBjcmVhdGVkIHBlZXJcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdHZhciBwZWVyID0gbmV3IFBlZXIoaWQsIHtrZXk6IE1FRElBVE9SX1NFUlZFUl9LRVl9KTtcclxuXHJcblx0XHRwZWVyLm9uKCdjb25uZWN0aW9uJywgYWNjZXB0X2Nvbm5lY3Rpb24pO1xyXG5cclxuXHJcblx0XHRyZXR1cm4gcGVlcjtcclxuXHR9O1xyXG5cclxuXHR2YXIgYWNjZXB0X2Nvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uKXtcclxuXHRcdC8qKlxyXG5cdFx0KiB0YWtlcyBjb25uZWN0aW9uXHJcblx0XHQqIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgYXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb25cclxuXHRcdCogd2l0aCB0aGlzIGNsaWVudFxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgZnJlZV9pZHMgPSBOZXR3b3JrTW9kZWwuZnJlZV9pZHM7XHJcblx0XHR2YXIgbmZyZWVfaWRzID0gTmV0d29ya01vZGVsLm5vbl9mcmVlX2lkcztcclxuXHJcblx0XHR2YXIgaWQgPSBjb25uLnBlZXI7XHJcblx0XHROZXR3b3JrTW9kZWwuY29ubmVjdGlvbnNbaWRdID0gY29ubjtcclxuXHJcblx0XHQvLyByZW1vdmUgdGhlIGlkIGZyb20gbGlzdCBvZiBmcmVlIGlkcy4gbm90aWNlIHRoYXQgXHJcblx0XHQvLyBhcnJheSBpcyByZWxhdGl2ZWx5IHNtYWxsLCBhbmQgb3BlcmF0aW9uIGhhcHBlbmRzIHNlbGRvbWx5XHJcblx0XHRmcmVlX2lkcy5zcGxpY2UoZnJlZV9pZHMuaW5kZXhPZihpZCksIDEpOyBcclxuXHJcblx0XHRjb25zb2xlLmxvZyhcImFjY2VwdGluZyBjb25uZWN0aW9uIGZyb20gcGVlclwiLCBpZCk7XHJcblx0XHRcclxuXHRcdG5mcmVlX2lkcy5wdXNoKGlkKTtcclxuXHJcblx0XHRzZXR1cF9jb25uZWN0aW9uX2xpc3RlbmVycyhjb25uKTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0c2VuZF9pbml0aWFsaXphdGlvbl9kYXRhX3RvKGlkKVxyXG5cdFx0XHR9XHJcblx0XHRcdCwgQ29uZmlnLlJlbW90ZS5jb25uZWN0aW9uX3RpbWVvdXQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgc2V0dXBfY29ubmVjdGlvbl9saXN0ZW5lcnMgPSBmdW5jdGlvbihjb25uZWN0aW9uKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBkZXNjcmlwdGlvblxyXG5cdFx0Ki9cclxuXHRcdGNvbm5lY3Rpb24ub24oJ2RhdGEnLCBvbl9kYXRhX2Fycml2YWwpO1xyXG5cdFx0Y29ubmVjdGlvbi5vbignY2xvc2UnLCBvbl9jb25uZWN0aW9uX2Nsb3NlZCk7XHJcblx0XHRjb25uZWN0aW9uLm9uKCdvcGVuJywgb25fY29ubmVjdGlvbl9vcGVuKTtcclxuXHRcdGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgb25fY29ubmVjdGlvbl9lcnJvcik7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHJcblx0dmFyIGNvbm5lY3Rpb25fdW5zdWNjZXNzZnVsID0gZnVuY3Rpb24oZXJyb3Ipe1xyXG5cdFx0LyoqXHJcblx0XHQqIGZvciBub3csIGp1c3QgYWRkIHRoZSBwZWVyIHRvIHdoaWNoIHdhcyB0cnlpbmcgdG8gY29ubmVjdCB0byB0aGVcclxuXHRcdCogZnJlZSBwZWVycyBsaXN0LiBMYXRlciBzb21lIGludmVzdGlnYXRpb24gb3IgcmVjb25uZWN0aW9uIGF0dGVtcHRzXHJcblx0XHQqIG1heSBiZSBpbXBsZW1lbnRlZFxyXG5cdFx0Ki9cclxuXHJcblx0XHRjb25zb2xlLmxvZyhlcnJvcik7XHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgc2VuZF90byA9IGZ1bmN0aW9uKHBlZXJfaWQsIGRhdGEpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHNlbmQgZGF0YSB0byB0aGUgcGVlciB3aXRoIHRoZSBwZWVyX2lkXHJcblx0XHQqIHlvdSBjYW4gbWFrZSBkZWNpc2lvbiB0byBkZWxheSBkYXRhIHNlbmRpbmcsIG9yIGNoYW5nZVxyXG5cdFx0KiBwcm9jZWR1cmUgc29tZWhvdyByaWdodCBoZXJlXHJcblx0XHQqIGJ1dCBkbyBub3QgdHJ5IHRvIGNvbXByZXNzIHRoZSBkYXRhIGluIHRoaXMgZnVuY3Rpb24uXHJcblx0XHQqIHNlbmRfdG8gd2lsbCBiZSBmaXJlZCBtdWx0aXBsZSB0aW1lcyBwZXIgZWFjaCBwaWVjZSBvZiBkYXRhXHJcblx0XHQqIChpdCdsbCBiZSBzZW50IHRvIGFsbCBvdGhlciBwbGF5ZXJzKSBzbyBhbnkgY29tcHJlc3Npb24gc2hvdWxkXHJcblx0XHQqIHRha2UgcGxhY2UgaW4gdGhlIFwiZGlzdHJpYnV0ZV9kYXRhXCIgZnVuY3Rpb25cclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIGNvbm4gPSBOZXR3b3JrTW9kZWwuY29ubmVjdGlvbnNbcGVlcl9pZF07XHJcblxyXG5cdFx0aWYoY29ubiAhPSBudWxsKXtcclxuXHRcdFx0Y29ubi5zZW5kKGRhdGEpO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHRocm93IFwiTm8gY29ubmVjdGlvbiBleGlzdHMgZm9yIHRoZSBwZWVyIHdpdGggaWQgXCIgKyBTdHJpbmcoaWQpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fTtcclxuXHJcblxyXG5cdHZhciBkaXN0cmlidXRlX2RhdGEgPSBmdW5jdGlvbihkYXRhKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBGaXJzdCwgbWFuaXB1bGF0ZSB0aGUgZGF0YSB0byBwcm9wZXJseSBjb21wcmVzcyBpdCwgb3IgZGVjaWRlIHdoYXQgc2hvdWxkXHJcblx0XHQqIGFuZCB3aGF0IHNob3VsZG4ndCBiZSBzZW50IChtYWtlIHN1cmUgdG8gZG9jdW1lbnQgc3R1ZmYgaGVyZSwgYmVjYXVzZSBwZW9wbGVcclxuXHRcdCogd2lsbCBwdWxsIHRoZWlyIGhhaXIgb3V0IHRyeWluZyB0byB1bmRlcnN0YW5kIHdoeSB0aGVpciBzdHVmZiBkb2Vzbid0IGdldCBzZW50KVxyXG5cdFx0KiBTZWNvbmQsIHNlbmQgdGhlIGRhdGEgdG8gYWxsIHRoZSBjb25uZWN0ZWQgcGxheWVycyBpbiB0aGlzIGdhbWVcclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIGNvbm5zID0gTmV0d29ya01vZGVsLmNvbm5lY3Rpb25zO1xyXG5cdFx0Zm9yKHZhciBpZCBpbiBjb25ucyl7XHJcblx0XHRcdGlmKGlkICE9IE5ldHdvcmtNb2RlbC5teV9pZCAmJiBjb25uc1tpZF0pe1xyXG5cdFx0XHRcdGNvbm5zW2lkXS5zZW5kKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHJcblx0dmFyIG9uX3VubG9hZCA9IGZ1bmN0aW9uKGFyZ3VtZW50cyl7XHJcblx0XHQvKipcclxuXHRcdCogd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBpcyBhYm91dCB0byBsZWF2ZSB0aGUgd2ViIHBhZ2VcclxuXHRcdCogd2lsbCBtYWtlIHN1cmUgY29ubmVjdGlvbnMgYXJlIGdyYWNlZnVsbHkgY2xvc2VkIGFuZCBwZWVycyBhcmUgZGVzdHJveWVkXHJcblx0XHQqL1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwiZG9jdW1lbnQgaXMgdW5sb2FkZWQgbm93LiBEZXN0cm95aW5nIHBlZXIsIGRpc2Nvbm5lY3RpbmcgZnJvbSBvdGhlcnNcIik7XHJcblx0XHROZXR3b3JrTW9kZWwubXlfcGVlci5kZXN0cm95KCk7XHRcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHZhciBvbl9ldmVudCA9IGZ1bmN0aW9uKHNtdGgpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGR1bW15IGZ1bmN0aW9uLCBkZWxldGUgd2hlbiBpc24ndCBjYWxsZWQgZnJvbSBhbnl3aGVyZVxyXG5cdFx0Ki9cclxuXHRcdFxyXG5cdH07XHJcblxyXG5cclxuXHR2YXIgb25fZGF0YV9hcnJpdmFsID0gZnVuY3Rpb24oZGF0YSl7XHJcblx0XHQvKipcclxuXHRcdCogaXMgY2FsbGVkIHdoZW5ldmVyIG5ldyBkYXRhIGFycml2ZXNcclxuXHRcdCovXHJcblxyXG5cdFx0aWYoZGF0YS5zcGVjaWFsX2NvbW11bmljYXRpb24gIT0gbnVsbCl7XHJcblx0XHRcdC8vIGlmIHRoaXMgaXMgbmV0d29yayBoYW5kbGluZyBkYXRhLFxyXG5cdFx0XHQvLyBub3QgdGhlIHJlZ3VsYXIgbXVsdGlwbGF5ZXIgZGF0YSB0cmFuc2ZlclxyXG5cclxuXHRcdFx0aWYoZGF0YS5tZXNzYWdlID09IFwiSSBhbSB0aGUgbGF3IVwiKXtcclxuXHRcdFx0XHR2YXIgbV9pZCA9IGRhdGEubWFzdGVyX2lkO1xyXG5cclxuXHRcdFx0XHRzZXRfbWFzdGVyKG1faWQpO1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiVGhlIG1hc3RlciBpc1wiLCBtX2lkKTtcclxuXHRcdFx0XHQvL2NsZWFyVGltZW91dChOZXR3b3JrTW9kZWwudGltZW91dF9pZCk7IC8vIHdpbGwgZ2l2ZSBhbiBlcnJvciBpZiB0aW1lb3V0IHBhc3NlZD9cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc3RvcCBwcm9jZXNzaW5nXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihOZXR3b3JrTW9kZWwucmVjaWV2ZV9hcnJheSA9PSBudWxsKXtcclxuXHRcdFx0TmV0d29ya01vZGVsLnJlY2lldmVfYXJyYXkgPSBkYXRhO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHROZXR3b3JrTW9kZWwucmVjaWV2ZV9hcnJheS5wdXNoKGRhdGFbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdHZhciBvbl9lcnJvciA9IGZ1bmN0aW9uKGVycm9yKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBjYWxsZWQgd2hlbiBlcnJvciBvY2N1cnMgd2l0aCB0aGUgcGVlclxyXG5cdFx0Ki9cclxuXHR9O1xyXG5cclxuXHJcblx0dmFyIGNvbm5lY3RfdG8gPSBmdW5jdGlvbihpZCwgcGVlcil7XHJcblx0XHQvKipcclxuXHRcdCogY29ubmVjdCBwZWVyID5wZWVyPCB0byB0aGUgcGVlciB3aXRoIHRoZSBnaXZlbiA+aWQ8XHJcblx0XHQqIHJldHVybnMgY29ubmVjdGlvbiBvYmplY3RcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdHZhciBjb25uID0gcGVlci5jb25uZWN0KGlkKTtcclxuXHJcblx0XHRyZXR1cm4gY29ubjtcclxuXHR9O1xyXG5cdFxyXG5cclxuXHR2YXIgcmV0cmlldmVfZnJvbV9iYWNrbG9nID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBnZXRzIHBhY2tldCBmcm9tIHRoZSBsaW5rZWQgbGlzdFxyXG5cdFx0KiBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBsaXN0XHJcblx0XHQqL1xyXG5cdFx0XHJcblx0XHR2YXIgbGlzdCA9IE5ldHdvcmtNb2RlbC5wYWNrYWdlX2JhY2tsb2c7XHJcblxyXG5cdFx0aWYobGlzdC5IRUFEID09IG51bGwpe1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFja2V0ID0gbGlzdC5IRUFELnBhY2tldDtcclxuXHJcblx0XHRsaXN0LkhFQUQgPSBsaXN0LkhFQUQubmV4dDtcclxuXHRcdGxpc3QuSEVBRC5wcmV2aW91cyA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHBhY2tldDtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdHZhciBwbGFjZV90b19iYWNrbG9nID0gZnVuY3Rpb24ocGFja2V0KXtcclxuXHRcdC8qKlxyXG5cdFx0KiBwdXRzIHBhY2tldCBpbnRvIHRoZSBsaW5rZWQgbGlzdFxyXG5cdFx0Ki9cclxuXHRcdHZhciBsaXN0ID0gTmV0d29ya01vZGVsLnBhY2thZ2VfYmFja2xvZztcclxuXHRcdHZhciBwYWNrZXRfY29udGFpbmVyID0ge3BhY2tldDogcGFja2V0fTsgXHJcblx0XHRpZihsaXN0LkhFQUQgPT0gbnVsbCl7XHJcblx0XHRcdGxpc3QuSEVBRCA9IHBhY2tldF9jb250YWluZXI7XHJcblx0XHRcdGxpc3QuVEFJTCA9IHBhY2tldF9jb250YWluZXI7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0cGFja2V0X2NvbnRhaW5lci5wcmV2aW91cyA9IGxpc3QuVEFJTDtcclxuXHRcdFx0bGlzdC5UQUlMLm5leHQgPSBwYWNrZXRfY29udGFpbmVyO1xyXG5cdFx0XHRsaXN0LlRBSUwgPSBwYWNrZXRfY29udGFpbmVyO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblxyXG5cdHZhciBhZGRfdG9fbmV4dF91cGRhdGUgPSBmdW5jdGlvbihkYXRhKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgdGhlIGRhdGEgdG8gYmUgcGFzc2VkIHRvIHRoZSBtYXN0ZXIvY2xpZW50cy5cclxuXHRcdCogbm90ZSB0aGF0IHRoaXMgbW9kdWxlIHdpbGwgZGVjaWRlIGl0c2VsZiB3aGVuIGFuZCBob3cgdG8gc2VuZCB0aGUgZGF0YSxcclxuXHRcdCogc28geW91IGFyZSBub3QgZ3VhcmFudGVlZCB0aGF0IGl0J2xsIGJlIHNlbmQgaW1tZWRpYXRlbHksIG9yIHdpdGggdGhlIG5leHQgdXBkYXRlXHJcblx0XHQqIFlvdSBzaG91bGQgYWNjb3VudCBmb3IgdGhhdC4gVGhpcyBmdW5jdGlvbiBpcyBtZWFudCB0byBiZSBpbnRlbGxpZ2VudCBhbmQgcHJpb3JpdGl6ZSBtb3JlIGltcG9ydGFudFxyXG5cdFx0KiBzdHVmZlxyXG5cdFx0Ki9cclxuXHJcblx0XHROZXR3b3JrTW9kZWwuc2VuZF9hcnJheSA9IE5ldHdvcmtNb2RlbC5zZW5kX2FycmF5IHx8IFtdO1xyXG5cclxuXHRcdE5ldHdvcmtNb2RlbC5zZW5kX2FycmF5LnB1c2goZGF0YSk7XHJcblx0fTtcclxuXHJcblx0dmFyIHNlbmRfb3V0X2RhdGEgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyoqXHJcblx0XHQqIHRlbXBcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdGlmKE5ldHdvcmtNb2RlbC5zZW5kX2FycmF5ICE9IG51bGwpe1xyXG5cdFx0XHRcclxuXHRcdFx0ZGlzdHJpYnV0ZV9kYXRhKE5ldHdvcmtNb2RlbC5zZW5kX2FycmF5KTtcclxuXHRcdFx0TmV0d29ya01vZGVsLnNlbmRfYXJyYXkgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgc2VuZF9kYXRhX3RvX21hc3RlciA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKipcclxuXHRcdCogc2VuZCB0aGUgcHJlcGFyZWQgZGF0YSB0byB0aGUgbWFzdGVyXHJcblx0XHQqL1xyXG5cdFx0dmFyIG1hc3Rlcl9jb25uID0gTmV0d29ya01vZGVsLmNvbm5lY3Rpb25zW05ldHdvcmtNb2RlbC5tYXN0ZXJfaWRdO1xyXG5cdFx0aWYoTmV0d29ya01vZGVsLnNlbmRfYXJyYXkgIT0gbnVsbCAmJiBtYXN0ZXJfY29ubiAhPSBudWxsKXtcclxuXHRcdFx0bWFzdGVyX2Nvbm4uc2VuZChOZXR3b3JrTW9kZWwuc2VuZF9hcnJheSk7XHJcblx0XHRcdE5ldHdvcmtNb2RlbC5zZW5kX2FycmF5ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHRcclxuXHJcblx0dmFyIGdldF9kYXRhID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBnZXQgdGhlIGRhdGEgYXJyYXlcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdHZhciBkYXRhID0gTmV0d29ya01vZGVsLnJlY2lldmVfYXJyYXk7XHJcblx0XHRcclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH07XHJcblxyXG5cdHZhciBjbGVhbl9kYXRhID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBkZXNjcmlwdGlvblxyXG5cdFx0Ki9cclxuXHRcdGRlbGV0ZSBOZXR3b3JrTW9kZWwucmVjaWV2ZV9hcnJheTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBnZXRfbmV0d29ya19pZCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvLyByZXR1cm5zIG15IG5ldHdvcmsgaWQgaWYgSSBhbSBjb25uZWN0ZWQsXHJcblx0XHQvLyBvciBcImxvY2FsXCIgaWYgbm90XHJcblx0XHRpZihDb25maWcuUmVtb3RlLmNvbm5lY3RlZCl7XHJcblx0XHRcdHJldHVybiBOZXR3b3JrTW9kZWwubXlfaWQ7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0cmV0dXJuIFwibG9jYWxcIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHR1cGRhdGU6IHVwZGF0ZSxcclxuXHRcdGFkZF90b19uZXh0X3VwZGF0ZTogYWRkX3RvX25leHRfdXBkYXRlLFxyXG5cdFx0Z2V0X2RhdGE6IGdldF9kYXRhLFxyXG5cdFx0Y2xlYW5fZGF0YTogY2xlYW5fZGF0YSxcclxuXHRcdGdldF9uZXR3b3JrX2lkOiBnZXRfbmV0d29ya19pZCxcclxuXHRcdHNlbmRfdG86IHNlbmRfdG8sXHJcblx0XHRzdGFydF9tdWx0aXBsYXllcl9zZXNzaW9uOiBzdGFydF9tdWx0aXBsYXllcl9zZXNzaW9uLFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHdvcmtDb250cm9sbGVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiTmV0d29ya0NvbnRyb2xsZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkRFRkFVTFRcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG4iLCIvLyBOb3RlczpcclxuLy8gbm90aWNlIHRoYXQgeW91IGNhbiByZXVzZSBib2R5IGRlZmluaXRpb25zIG11bHRpcGxlIHRpbWVzLCBpdCBtYWtlcyBzZW5zZSB0byBoYXZlXHJcbi8vIGNvbGxlY3Rpb24gb2YgYm9keSBkZWZpbml0aW9ucyB0aGF0IGFyZSBjb21tb25seSB1c2UgYW5kIG1heWJlIGFsbG93IHNvbWUgc29ydCBvZiBcclxuLy8gaW5oZXJpdGFuY2UgKGkuZS4geW91IGNhbiBtYWtlIHNvbWUgZGVmaW5pdGlvbiBvbiB0b3Agb2YgdGhlIGFub3RoZXIgZGVmaW5pdGlvbilcclxuLy8gLy8gYm9kaWVzIGFyZSBhbGxvd2VkIHRvIGhhdmUgdXNlckRhdGEgb24gdGhlbSB0aGF0IGlzIGp1c3QgcmVmZXJlbmNlIHRvIHNvbWUgb2JqZWN0LlxyXG4vLyBtYXkgYmUgdXNlZnVsIGluIHNvbWUgc2l0dWF0aW9uc1xyXG4vL1xyXG4vLyBRdWVzdGlvbjpcclxuLy8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIGFsbG93IHVzZXJzIHRvIHBhc3MgYW55IHByb3BlcnRpZXMgYXMgcGFydCBvZiBvYmplY3QgZGVmaW5pdGlvblxyXG4vLyBhbmQganVzdCBhcHBseSB0aG9zZSBwcm9wZXJ0aWVzIGF1dG9tYXRpY2FsbHkgdG8gdGhlIHVzZXJEYXRhIHByb3BlcnR5IG9mIGJvZHk/XHJcblxyXG52YXIgQjJkQ29uZmlnO1xyXG5cclxudmFyIFBoeXNpY3NDb250cm9sbGVyID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdGluY2x1ZGUoKTtcclxuXHJcblx0XHRCMmRDb25maWcgPSBDb25maWcuQjJEO1xyXG5cclxuXHRcdFBoeXNpY3NNb2RlbC5zY2FsZSA9IEIyZENvbmZpZy5TQ0FMRTtcclxuXHRcdFBoeXNpY3NNb2RlbC5zdGVwX2Ftb3VudCA9IDEvKEIyZENvbmZpZy5TUFMpO1xyXG5cclxuXHRcdFBoeXNpY3NNb2RlbC5ncmF2aXR5ID0gbmV3IEIyZC5iMlZlYzIoMCwzMCk7IC8vIGVhcnRoIGdyYXZpdHlcclxuXHRcdFBoeXNpY3NNb2RlbC53b3JsZCA9IG5ldyBCMmQuYjJXb3JsZChQaHlzaWNzTW9kZWwuZ3Jhdml0eSwgdHJ1ZSk7XHJcblxyXG5cdFx0aW5pdF9jb2xsaXNpb25fbGlzdGVuZXIoKTtcclxuXHJcblx0fTtcclxuXHRcclxuXHR2YXIgc3RlcCA9IGZ1bmN0aW9uIChkZWx0YV9tcykge1xyXG5cdFx0Ly8gIT8gc2hvdWxkIEkgc2V0IHVwcGVyIGxpbWl0IG9uIGRlbHRhIHRvIHByZXZlbnQgd29ybGQgZnJvbVxyXG5cdFx0Ly8gZmFzdCBmb3J3YXJkaW5nIGlmIHRoZSB0aWNrZXIgd2FzIHBhdXNlZD8gb3IgdGhhdCBpcyBub3QgYSBwcm9ibGVtIGluIG91ciBjYXNlP1xyXG5cdFx0Ly8gaW52ZXN0aWdhdGlvbiBpcyBuZWVkZWRcclxuXHJcblx0XHR2YXIgZGVsdGEgPSBkZWx0YV9tcy8xMDAwO1xyXG5cclxuXHRcdFBoeXNpY3NNb2RlbC50aW1lVG9Db3ZlciArPSBkZWx0YTtcclxuXHJcblx0XHR3aGlsZSAoUGh5c2ljc01vZGVsLnRpbWVUb0NvdmVyID4gUGh5c2ljc01vZGVsLnN0ZXBfYW1vdW50KSB7XHJcblx0XHRcdFBoeXNpY3NNb2RlbC50aW1lVG9Db3ZlciAtPSBQaHlzaWNzTW9kZWwuc3RlcF9hbW91bnQ7XHJcblx0XHRcdFBoeXNpY3NNb2RlbC53b3JsZC5TdGVwKFxyXG5cdFx0XHRcdFBoeXNpY3NNb2RlbC5zdGVwX2Ftb3VudCxcclxuXHRcdFx0XHRCMmRDb25maWcuUE9TSVRJT05fSVRSLCAvLyB2ZWxvY2l0eSBpdGVyYXRpb25zXHJcblx0XHRcdFx0QjJkQ29uZmlnLlZFTE9DSVRZX0lUUiAvLyBwb3NpdGlvbiBpdGVyYXRpb25zXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0fTsgIC8vIGVuZCBzdGVwIFxyXG5cclxuXHR2YXIgZHJhd19kZWJ1ZyA9IGZ1bmN0aW9uKCl7XHJcblx0XHRpZiAoQjJkQ29uZmlnLmRlYnVnX2RyYXcpIHtcclxuXHRcdFx0UGh5c2ljc01vZGVsLndvcmxkLkRyYXdEZWJ1Z0RhdGEoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR2YXIgZ2V0X3BhcmVudF9jaGFpbiA9IGZ1bmN0aW9uKHRlbXBsYXRlLCBkZWZhdWx0X2RlZil7XHJcblx0XHR2YXIgbmV4dCA9IHRlbXBsYXRlO1xyXG5cdFx0dmFyIGFuY2VzdG9ycyA9IFtdO1xyXG5cclxuXHRcdHdoaWxlKG5leHQgIT0gbnVsbCl7XHJcblx0XHRcdGFuY2VzdG9ycy5wdXNoKG5leHQpO1xyXG5cdFx0XHRuZXh0ID0gbmV4dFtcInBhcmVudFwiXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihkZWZhdWx0X2RlZil7XHJcblx0XHRcdGFuY2VzdG9ycy5wdXNoKGRlZmF1bHRfZGVmKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5jZXN0b3JzO1xyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIGFwcGx5X3BhcmVudHMgPSBmdW5jdGlvbih0ZW1wbGF0ZV9uYW1lLCB0ZW1wbGF0ZV9jb2xsZWN0aW9uKXtcclxuXHRcdC8vIFRPRE86IHJlZmFjdG9yIHRoZSBjb2RlIHNvIHRoaXMgdGhpbmcgaXMgZG9uZSBvbmx5IG9uY2VcclxuXHRcdC8vIGF0IHRoZSBsb2FkIHRpbVxyXG5cdFx0Ly8gdGhhdCBjb3VsZCBwcm9iYWJseSBiZSBkb25lIGV2ZW4gZm9yIG90aGVyIHRoaW5ncy5cclxuXHRcdC8vIGlkZWE6IHN0b3JlIGNvbXBpbGVkIGJvZHkvZml4dHVyZSBldGMuIHRvZ2V0aGVyIHdpdGggdGhlXHJcblx0XHQvLyB0ZW1wbGF0ZS4gdGhpcyB3YXkgeW91J2xsIGhhdmUgZWFzeSBhY2Nlc3MgdG8gdGhlIGFsbCBkZWZpbmVkXHJcblx0XHQvLyBvcHRpb25zIGZvciBkZWJ1Z2dpbmc7XHJcblx0XHRcclxuXHRcdHZhciBkZWZhdWx0X3RtcGxhdGUgPSB0ZW1wbGF0ZV9jb2xsZWN0aW9uW1wiZGVmYXVsdFwiXTtcclxuXHJcblx0XHR2YXIgY2hhaW4gPSBnZXRfcGFyZW50X2NoYWluKHRlbXBsYXRlX2NvbGxlY3Rpb25bdGVtcGxhdGVfbmFtZV0sIGRlZmF1bHRfdG1wbGF0ZSk7XHJcblxyXG5cdFx0dmFyIGZpbmFsX2RlZmluaXRpb24gPSB7fTtcclxuXHJcblx0XHRmb3IodmFyIGkgPSBjaGFpbi5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pe1xyXG5cdFx0XHQvLyBtYXkgYmUgbmVlZGVkIHRvIGJlIG1hZGUgbW9yZSBlZmZpY2llbnQgYnkgbW92aW5nIHRoZSBvdGhlciB3YXlcclxuXHRcdFx0Ly8gYW5kIG5vdCBjb25zaWRlcmluZyBvcHRpb25zIHRoYXQgd2VyZSBhbHJlYWR5IGVuY291bnRlcmVkIGluIGNoaWxkcmVuXHJcblx0XHRcdHZhciBjdXJyZW50ID0gY2hhaW5baV07XHJcblxyXG5cclxuXHRcdFx0Zm9yKHZhciBwcm9wIGluIGN1cnJlbnQpe1xyXG5cdFx0XHRcdGZpbmFsX2RlZmluaXRpb25bcHJvcF0gPSBjdXJyZW50W3Byb3BdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZpbmFsX2RlZmluaXRpb247XHJcblx0fTsgLy8gZW5kIGFwcGx5X3BhcmVudHNcclxuXHRcdFxyXG5cdHZhciB0YXJnZXRfcHJvcHMgPSB7XHJcblx0XHRib2R5X2RlZjogW1xyXG5cdFx0XHRcImFjdGl2ZVwiLFxyXG5cdFx0XHRcImFsbG93U2xlZXBcIixcclxuXHRcdFx0XCJhbmdsZVwiLFxyXG5cdFx0XHRcImFuZ3VsYXJEYW1waW5nXCIsXHJcblx0XHRcdFwiYW5ndWxhclZlbG9jaXR5XCIsXHJcblx0XHRcdFwiYXdha2VcIixcclxuXHRcdFx0XCJidWxsZXRcIixcclxuXHRcdFx0XCJmaXhlZFJvdGF0aW9uXCIsXHJcblx0XHRcdFwiaW5lcnRpYVNjYWxlXCIsXHJcblx0XHRcdFwibGluZWFyRGFtcGluZ1wiLFxyXG5cdFx0XHRcImxpbmVhclZlbG9jaXR5XCIsXHJcblx0XHRcdFwicG9zaXRpb25cIixcclxuXHRcdFx0XCJ0eXBlXCIsXHJcblx0XHRcdC8vXCJ1c2VyRGF0YVwiIC8vIGRvZXNuJ3Qgc2VlbSB0byBwcm9wZXJseSB3b3JrLCBkb2luZyBpdCBkaWZmZXJlbnRseVxyXG5cdFx0XSxcclxuXHRcdGZpeHR1cmVfZGVmOiBbXHJcblx0XHRcdFwiZGVuc2l0eVwiLFxyXG5cdFx0XHQvL1wiZmlsdGVyXCIsIGltcGxlbWVudCBsYXRlciBpZiBuZWVkZWRcclxuXHRcdFx0XCJmcmljdGlvblwiLFxyXG5cdFx0XHRcImlzU2Vuc29yXCIsXHJcblx0XHRcdFwicmVzdGl0dXRpb25cIixcclxuXHRcdFx0XCJzaGFwZVwiLFxyXG5cdFx0XHRcInVzZXJEYXRhXCJcclxuXHRcdF1cclxuXHR9O1xyXG5cclxuXHR2YXIgYXBwbHlfcHJvcGVydHlfbGlzdCA9IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24sIGxpc3Qpe1xyXG5cdFx0LyoqXHJcblx0XHQgKiB0YWtlcyB0d28gb2JqZWN0cyBhbmQgdGhlIGxpc3Qgb2Ygc3RyaW5nc1xyXG5cdFx0ICogY29waWVzIGFsbCBwcm9wZXJ0aWVzIHdpdGggbmFtZXMgZm91bmQgaW4gdGhlIGxpc3RcclxuXHRcdCAqIGZyb20gc291cmNlIHRvIGRlc3RpbmF0aW9uXHJcblx0XHQgKiBzY2lwcyBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBudWxsL3VuZGVmaW5lZFxyXG5cdFx0ICovXHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHR2YXIgcHJvcCA9IGxpc3RbaV07XHJcblx0XHRcdGlmKHNvdXJjZVtwcm9wXSAhPSBudWxsKXtcclxuXHRcdFx0XHRkZXN0aW5hdGlvbltwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkZXN0aW5hdGlvbjtcclxuXHR9O1xyXG5cclxuXHR2YXIgUHJvcGVydHlVbmRlZmluZWQgPSBmdW5jdGlvbiBQcm9wZXJ0eVVuZGVmaW5lZChwcm9wZXJ0eV9uYW1lKXtcclxuXHRcdHRoaXMubmFtZSA9IFwiUHJvcGVydHlVbmRlZmluZWRcIjtcclxuXHRcdHRoaXMubWVzc2FnZSA9IFwiRXJyb3I6IFwiICsgcHJvcGVydHlfbmFtZSArIFwiIGlzIG5vdCBkZWZpbmVkXCI7XHJcblx0fTtcclxuXHRQcm9wZXJ0eVVuZGVmaW5lZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblx0UHJvcGVydHlVbmRlZmluZWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJvcGVydHlVbmRlZmluZWQ7XHJcblxyXG5cdHZhciBnZXRfZm9ybWFsX2JvZHlfZGVmID0gZnVuY3Rpb24obm9uX2Zvcm1hbF9kZWYpe1xyXG5cdFx0LyoqXHJcblx0XHQgKiB0dXJuIG5vbiBmb3JtYWwgZGVmaW5pdGlvbiBpbnRvIHRoZSBmb3JtYWwgb25lXHJcblx0XHQgKiBub24tZm9ybWFsIGRlZmluaXRpb24gaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnNcclxuXHRcdCAqIHByb3BlcnRpZXMgU09NRSBvZiB3aGljaCBhcmUgYm94MmQgcHJvcGVydGllcyBvciBhcmUgXHJcblx0XHQgKiBpbnRlbmRlZCB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHN1Y2guIEUuZy4gdGhlIG5vbi1mb3JtYWxcclxuXHRcdCAqIGRlZmluaXRpb24gbWF5IGNvbnRhaW4gcHJvcGVydGllcyB2eCBhbmQgdnkgd2hpY2ggd2lsbCBiZSB0cmFuc2Zvcm1lZFxyXG5cdFx0ICogaW50byB0aGUgbGluZWFyVmVsb2NpdHkgdmVjdG9yIGluIHRoZSBmb3JtYWwgZGVmaW5pdGlvblxyXG5cdFx0ICovXHJcblxyXG5cdFx0dmFyIG5mZGVmID0gbm9uX2Zvcm1hbF9kZWY7XHJcblxyXG5cdFx0dmFyIGRlZmluaXRpb24gPSBuZXcgQjJkLmIyQm9keURlZigpO1xyXG5cclxuXHRcdGlmKG5mZGVmLnZ4ICE9IG51bGwgJiYgbmZkZWYudnkgIT0gbnVsbCl7XHJcblx0XHRcdC8vIGNoZWNrIGZvciBpbmZvcm1hbCBwYXJhbWV0ZXIgc3BlY2lmaWNhdGlvbiBmaXJzdFxyXG5cdFx0XHRuZmRlZi5saW5lYXJWZWxvY2l0eSA9IG5ldyBCMmQuYjJWZWMyKG5mZGVmLnZ4LCBuZmRlZi52eSk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly8gbWF5YmUgdGhlIGxpbmVhclZlbG9jaXR5IHdhcyBzcGVjaWZpZWQgZGlyZWN0bHkgYXMgdmVjdG9yLFxyXG5cdFx0XHQvLyBhbmQgbm90IHRocm91Z2ggaW5mb3JtYWwgcGFyYW1ldGVyczsgY2hlY2tpbmcgdGhhdCwgYW5kIGlmIG5vdCxcclxuXHRcdFx0Ly8gZXhjZXB0aW9uXHJcblx0XHRcdGlmKCEobmZkZWYubGluZWFyVmVsb2NpdHkpKXtcclxuXHRcdFx0XHR0aHJvdyBuZXcgUHJvcGVydHlVbmRlZmluZWQoXCJsaW5lYXJWZWxvY2l0eVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKG5mZGVmLnggIT0gbnVsbCAmJiBuZmRlZi55ICE9IG51bGwpe1xyXG5cdFx0XHQvLyBzYW1lIHByb2NlZHVyZSBhcyBmb3IgdGhlIGxpbmVhciB2ZWxvY2l0eVxyXG5cdFx0XHQvLyBjaGVja2luZyBmb3IgaW5mb3JtYWwgc3BlY2lmaWNhdGlvbiBoZXJlXHJcblx0XHRcdC8vIGFuZCBpZiBwcmVzZW50LCB0dXJuaW5nIGludG8gdGhlIGZvcm1hbFxyXG5cdFx0XHRuZmRlZi5wb3NpdGlvbiA9IG5ldyBCMmQuYjJWZWMyKG5mZGVmLngsIG5mZGVmLnkpO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdC8vIGNoZWNraW5nIGlmIGZvcm1hbCB3YXMgc3BlY2lmaWVkIGRpcmVjdGx5XHJcblx0XHRcdGlmKCEobmZkZWYucG9zaXRpb24pKXtcclxuXHRcdFx0XHQvLyBpZiBub3QsIHRocm93IGN1c3RvbSBleGNlcHRpb25cclxuXHRcdFx0XHR0aHJvdyBuZXcgUHJvcGVydHlVbmRlZmluZWQoXCJwb3NpdGlvblwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKG5mZGVmLnR5cGUpe1xyXG5cdFx0XHRuZmRlZi50eXBlID0ge1xyXG5cdFx0XHRcdFwic3RhdGljXCI6IEIyZC5iMkJvZHkuYjJfc3RhdGljQm9keSwgXHJcblx0XHRcdFx0XCJkeW5hbWljXCI6IEIyZC5iMkJvZHkuYjJfZHluYW1pY0JvZHksXHJcblx0XHRcdFx0XCJraW5lbWF0aWNcIjogQjJkLmIyQm9keS5iMl9raW5lbWF0aWNCb2R5XHJcblx0XHRcdH1bbmZkZWYudHlwZV07IC8vIHR1cm4gc3RyaW5nLXR5cGUgaW50byBiMmQgdHlwZVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHRocm93IG5ldyBQcm9wZXJ0eVVuZGVmaW5lZChcInR5cGVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0YXBwbHlfcHJvcGVydHlfbGlzdChuZmRlZiwgZGVmaW5pdGlvbiwgdGFyZ2V0X3Byb3BzLmJvZHlfZGVmKTtcclxuXHJcblx0XHRyZXR1cm4gZGVmaW5pdGlvbjtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGdldF9mb3JtYWxfZml4dHVyZV9kZWYgPSBmdW5jdGlvbihub25fZm9ybWFsX2RlZil7XHJcblx0XHQvKipcclxuXHRcdCAqIHR1cm5zIG5vbi1mb3JtYWwgZGVmaW5pdGlvbiBpbnRvIHRoZSBmb3JtYWwgb25lXHJcblx0XHQgKiBzZWUgZ2V0X2Zyb21hbF9ib2R5X2RlZiBmb3IgZXhwbGFuYXRpb25cclxuXHRcdCAqL1xyXG5cclxuXHRcdHZhciBuZmRlZiA9IG5vbl9mb3JtYWxfZGVmO1xyXG5cdFx0dmFyIHNoYXBlID0gbmZkZWYuc2hhcGU7XHJcblx0XHR2YXIgZml4dHVyZV9kZWYgPSBuZXcgQjJkLmIyRml4dHVyZURlZigpO1xyXG5cclxuXHRcdGFwcGx5X3Byb3BlcnR5X2xpc3Qobm9uX2Zvcm1hbF9kZWYsIGZpeHR1cmVfZGVmLCB0YXJnZXRfcHJvcHMuZml4dHVyZV9kZWYpO1xyXG5cclxuXHRcdHN3aXRjaCAoc2hhcGUpIHtcclxuXHRcdFx0Y2FzZSBcInJlY3RhbmdsZVwiOlxyXG5cclxuXHRcdFx0XHRpZihuZmRlZi53aWR0aCAhPSBudWxsICYmIG5mZGVmLmhlaWdodCAhPSBudWxsKXtcclxuXHRcdFx0XHRcdGZpeHR1cmVfZGVmLnNoYXBlID0gbmV3IEIyZC5iMlBvbHlnb25TaGFwZSgpO1xyXG5cdFx0XHRcdFx0aWYgKG5mZGVmLm9mZnNldCAhPSBudWxsKXtcclxuXHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IG5ldyBCMmQuYjJWZWMyKG5mZGVmLm9mZnNldC54ICxuZmRlZi5vZmZzZXQueSk7XHJcblx0XHRcdFx0XHRcdGZpeHR1cmVfZGVmLnNoYXBlLlNldEFzT3JpZW50ZWRCb3gobmZkZWYud2lkdGgvMiwgbmZkZWYuaGVpZ2h0LzIsIG9mZnNldCwgMCk7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0Zml4dHVyZV9kZWYuc2hhcGUuU2V0QXNCb3gobmZkZWYud2lkdGgvMiwgbmZkZWYuaGVpZ2h0LzIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IFByb3BlcnR5VW5kZWZpbmVkKFwid2lkdGggb3IgaGVpZ2h0XCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInBvbHlnb25cIjpcclxuXHJcblx0XHRcdFx0aWYobmZkZWYucG9pbnRzICE9IG51bGwpe1xyXG5cdFx0XHRcdFx0Zml4dHVyZV9kZWYuc2hhcGUgPSBuZXcgQjJkLmIyUG9seWdvblNoYXBlKCk7XHJcblx0XHRcdFx0XHRmaXh0dXJlX2RlZi5zaGFwZS5TZXRBc0FycmF5KG5mZGVmLnBvaW50cywgbmZkZWYucG9pbnRzLmxlbmd0aCk7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgUHJvcGVydHlVbmRlZmluZWQoXCJwb2ludHNcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiY2lyY2xlXCI6XHJcblxyXG5cdFx0XHRcdGlmKG5mZGVmLnJhZGl1cyAhPSBudWxsKXtcclxuXHRcdFx0XHRcdGZpeHR1cmVfZGVmLnNoYXBlID0gbmV3IEIyZC5iMkNpcmNsZVNoYXBlKG5mZGVmLnJhZGl1cyk7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgUHJvcGVydHlVbmRlZmluZWQoXCJyYWRpdXNcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IFwiRXJyb3I6IHNoYXBlIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6IFwiICsgXHJcblx0XHRcdFx0XHQnXCJwb2x5Z29uXCIsIFwicmVjdGFuZ2xlXCIsIFwiY2lyY2xlXCIuIFlvdSBzcGVjaWZpZWQ6ICcgK1xyXG5cdFx0XHRcdFx0U3RyaW5nKHNoYXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZml4dHVyZV9kZWY7XHJcblxyXG5cdH07XHJcblx0XHJcblxyXG5cdHZhciBnZXRfYm9keSA9IGZ1bmN0aW9uKG5vbl9mb3JtYWxfZGVmLCBlbnRpdHlfaW5zdGFuY2Upe1xyXG5cdFx0LyoqXHJcblx0XHQgKiB0YWtlcyBub24tZm9ybWFsIGRlZmluaXRpb25cclxuXHRcdCAqIHJldHVybnMgYm9keSBiYXNlZCBvbiB0aGlzIGRlZmluaXRpb25cclxuXHRcdCAqXHJcblx0XHQgKi9cclxuXHRcdGlmIChlbnRpdHlfaW5zdGFuY2UgPT0gbnVsbCl7XHJcblx0XHR0aHJvdyBuZXcgUHJvcGVydHlVbmRlZmluZWQoXCJlbnRpdHlfaW5zdGFuY2VcIik7XHJcblx0XHR9XHJcblx0XHR2YXIgZGVmaW5pdGlvbiA9IGdldF9mb3JtYWxfYm9keV9kZWYobm9uX2Zvcm1hbF9kZWYpO1xyXG5cclxuXHRcdHZhciBib2R5ID0gUGh5c2ljc01vZGVsLndvcmxkLkNyZWF0ZUJvZHkoZGVmaW5pdGlvbik7XHJcblxyXG5cdFx0Ly9pZihib2R5LnVzZXJEYXRhID09IG51bGwpe1xyXG5cdFx0XHQvL2JvZHkudXNlckRhdGEgPSB7fTtcclxuXHRcdC8vfVxyXG5cclxuXHRcdC8vIGFwcGVuZCBwYXNzZWQgZGVmaW5pdGlvbiB0byB0aGUgdXNlciBkYXRhIG9mIHRoZSBib2R5XHJcblx0XHQvLyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLCBhbmQgYWxzbyB0byBhbGxvdyBlYXN5IHNwZWNpZmljYXRpb24gb2YgXHJcblx0XHQvLyBjdXN0b20gcGFyYW1ldGVycyBkdXJpbmcgZGVmaW5pdGlvbi4gSWYgdGhpcyB3aWxsIGNhdXNlIGNvbmZ1c2lvbixcclxuXHRcdC8vIEknbGwgcmVtb3ZlIHRoYXRcclxuXHRcdC8vYm9keS51c2VyRGF0YS5kZWYgPSBub25fZm9ybWFsX2RlZjtcclxuXHRcdGJvZHkuU2V0VXNlckRhdGEoe2RlZjogbm9uX2Zvcm1hbF9kZWYsIGVudGl0eV9pbnN0YW5jZTogZW50aXR5X2luc3RhbmNlfSk7XHJcblx0XHRcclxuXHRcdHJldHVybiBib2R5O1xyXG5cdFxyXG5cdH07XHJcblxyXG5cdHZhciBhdHRhY2hfZml4dHVyZSA9IGZ1bmN0aW9uKGJvZHksIG5vbl9mb3JtYWxfZGVmLCBmaXh0dXJlX25hbWUpe1xyXG5cdFx0LyoqXHJcblx0XHQgKiBnaXZlbiBiMmQgYm9keSwgKG5vbi1mb3JtYWwpIGZpeHR1cmUgZGVmaW5pdGlvbiBhbmQgKE9QVElPTkFMKSBmaXh0dXJlX25hbWVcclxuXHRcdCAqIHRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgZml4dHVyZSB0byB0aGUgYm9keVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dmFyIGZpeHR1cmVfZGVmID0gZ2V0X2Zvcm1hbF9maXh0dXJlX2RlZihub25fZm9ybWFsX2RlZik7XHJcblxyXG5cdFx0aWYoZml4dHVyZV9kZWYudXNlckRhdGEgPT0gbnVsbCl7XHJcblx0XHRcdGZpeHR1cmVfZGVmLnVzZXJEYXRhID0ge307XHJcblx0XHR9XHJcblxyXG5cdFx0Zml4dHVyZV9kZWYudXNlckRhdGEuZGVmID0gbm9uX2Zvcm1hbF9kZWY7XHJcblx0XHRmaXh0dXJlX2RlZi51c2VyRGF0YS5uYW1lID0gZml4dHVyZV9uYW1lO1xyXG5cdFx0XHJcblx0XHRib2R5LkNyZWF0ZUZpeHR1cmUoZml4dHVyZV9kZWYpO1xyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIGF0dGFjaF9zZW5zb3JzID0gZnVuY3Rpb24oYm9keSl7XHJcblx0XHR2YXIgU0VOU09SX1RISUNLTkVTUyA9IDAuMTtcclxuXHRcdFxyXG5cdFx0Ly8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBib2R5J3MgbWFpbiBmaXh0dXJlXHJcblx0XHQvLyBhbmQgY3JlYXRlIDQgc2Vuc29yIGZpeHR1cmVzIGJhc2VkIG9uIHRob3NlIHBhcmFtZXRlcnNcclxuXHRcdC8vIGNhbGN1bGF0ZSBvZmZzZXQgb2Ygc2Vuc29ycyBzbyB0aGF0IHRoZXkgbWF0Y2ggdGhlIG1haW4gZml4dHVyZVxyXG5cdFx0dmFyIHggPSBib2R5LkdldFBvc2l0aW9uKCkueDtcclxuXHRcdHZhciB5ID0gYm9keS5HZXRQb3NpdGlvbigpLnk7XHJcblxyXG5cdFx0Ly8gVE9ETzogY2hhbmdlIHRvIGdldHRpbmcgZGltZW50aW9ucyBvZiBtYWluIGZpeHR1cmVcclxuXHRcdHZhciBoID0gYm9keS5HZXRGaXh0dXJlTGlzdCgpLkdldEFBQkIoKS5HZXRFeHRlbnRzKCkueTtcclxuXHRcdHZhciB3ID0gYm9keS5HZXRGaXh0dXJlTGlzdCgpLkdldEFBQkIoKS5HZXRFeHRlbnRzKCkueDtcclxuXHRcdFxyXG5cdFx0Ly9hdHRhY2ggdG9wIGZpeHR1cmVcclxuXHRcdHZhciB0b3Bfc2Vuc29yID0ge307XHJcblx0XHR0b3Bfc2Vuc29yLnNoYXBlID0gXCJyZWN0YW5nbGVcIjtcclxuXHRcdHRvcF9zZW5zb3IuZGVuc2l0eSA9IDA7XHJcblx0XHR0b3Bfc2Vuc29yLmlzU2Vuc29yID0gdHJ1ZTtcclxuXHRcdHRvcF9zZW5zb3IuaGVpZ2h0ID0gU0VOU09SX1RISUNLTkVTUztcclxuXHRcdHRvcF9zZW5zb3Iud2lkdGggPSAodyoyIC0gU0VOU09SX1RISUNLTkVTUyoyKSAtIDAuMztcclxuXHRcdHRvcF9zZW5zb3Iub2Zmc2V0ID0ge3g6MCwgeTogKC0xKmgpICsgU0VOU09SX1RISUNLTkVTUy8yfTtcclxuXHRcdGF0dGFjaF9maXh0dXJlKGJvZHksdG9wX3NlbnNvcixcInRvcFwiKTtcclxuXHRcdFxyXG5cdFx0Ly9hdHRhY2ggYm90dG9tIGZpeHR1cmVcclxuXHRcdHZhciBib3R0b21fc2Vuc29yID0gdG9wX3NlbnNvcjtcclxuXHRcdC8vYm90dG9tX3NlbnNvci53aWR0aCArPSAwLjQ7XHJcblx0XHRib3R0b21fc2Vuc29yLm9mZnNldCA9IHt4OjAsIHk6IGggLSBTRU5TT1JfVEhJQ0tORVNTLzJ9O1xyXG5cdFx0YXR0YWNoX2ZpeHR1cmUoYm9keSxib3R0b21fc2Vuc29yLFwiYm90dG9tXCIpO1xyXG5cdFx0XHJcblx0XHQvL2F0dGFjaCBsZWZ0IGZpeHR1cmVcclxuXHRcdHZhciBsZWZ0X3NlbnNvciA9IHRvcF9zZW5zb3I7XHJcblx0XHRsZWZ0X3NlbnNvci5oZWlnaHQgPSAoaCoyIC0gU0VOU09SX1RISUNLTkVTUyoyKSAtIDAuMztcclxuXHRcdGxlZnRfc2Vuc29yLndpZHRoID0gU0VOU09SX1RISUNLTkVTUztcclxuXHRcdGxlZnRfc2Vuc29yLm9mZnNldCA9IHt4OigtMSp3KSArIFNFTlNPUl9USElDS05FU1MvMix5OjB9O1xyXG5cdFx0YXR0YWNoX2ZpeHR1cmUoYm9keSxsZWZ0X3NlbnNvcixcImxlZnRcIik7XHJcblx0XHRcclxuXHRcdC8vYXR0YWNoIHJpZ2h0IGZpeHR1cmVcclxuXHRcdHZhciByaWdodF9zZW5zb3IgPSBsZWZ0X3NlbnNvcjtcclxuXHRcdHJpZ2h0X3NlbnNvci5vZmZzZXQgPSB7eDp3IC0gU0VOU09SX1RISUNLTkVTUy8yLCB5OjB9O1xyXG5cdFx0YXR0YWNoX2ZpeHR1cmUoYm9keSxyaWdodF9zZW5zb3IsXCJyaWdodFwiKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cclxuXHR2YXIgZ2V0X3JlY3Rhbmd1bGFyID0gZnVuY3Rpb24oZGVmLCBlbnRpdHlfaW5zdGFuY2Upe1xyXG5cdFx0Ly8gZ2V0IGFwcHJvcHJpYXRlIHRlbXBsYXRlIGNvbGxlY3Rpb24gdG8gZHJhdyBmcm9tXHJcblx0XHR2YXIgdGVtcGxhdGVfbmFtZSA9IGVudGl0eV9pbnN0YW5jZS50eXBlO1xyXG5cdFx0dmFyIHRlbXBsYXRlX2NvbGxlY3Rpb24gPSBQaHlzaWNzTW9kZWwucl90ZW1wbGF0ZXM7XHJcblx0XHR2YXIgY29tcGlsZWRfdGVtcGxhdGUgPSBhcHBseV9wYXJlbnRzKHRlbXBsYXRlX25hbWUsIHRlbXBsYXRlX2NvbGxlY3Rpb24pO1xyXG5cclxuXHRcdC8vIGFwcGx5IGN1c3RvbSBvdmVycmlkZVxyXG5cdFx0dmFyIGZpbmFsX2RlZiA9IGNvbXBpbGVkX3RlbXBsYXRlO1xyXG5cdFx0Zm9yKHZhciBwcm9wIGluIGRlZil7XHJcblx0XHRcdGZpbmFsX2RlZltwcm9wXSA9IGRlZltwcm9wXTtcclxuXHRcdH1cclxuXHJcblx0XHRmaW5hbF9kZWYuc2hhcGUgPSBcInJlY3RhbmdsZVwiO1xyXG5cclxuXHRcdC8vIGZpbmFsX2RlZiBjb250YWlucyBhbGwgZmluYWwgZGF0YSwgYWJvdXQgYm9keSB3ZSBhcmUgYWJvdXQgdG8gY3JlYXRlXHJcblx0XHQvLyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdGVtcGxhdGUgZ2l2ZW4gYW5kIGFsbCBpdCdzIHBhcmVudHNcclxuXHRcdC8vIGFuZCBhbHNvIG1hbnVhbGx5IHNwZWNpZmllZCBwYXJhbWV0ZXJzLiBIb3dldmVyLCB0aGlzIGRlZmluaXRpb24gaXMgcmF3LFxyXG5cdFx0Ly8gaS5lLiBzb21lIGRhdGEgaW4gaXQgbWF5IG5vdCBiZSBpbiBpdHMgZmluYWwgZm9ybSwgZS5nLiBsaW5lYXIgdmVsb2NpdHkgaXMgc3BlY2lmaWVkXHJcblx0XHQvLyBhcyB0d28gcGFyYW1ldGVycywgdnggYW5kIHZ5LCB3aGlsZSBpdCB3aG91bGQgYmUgY29udmVydGVkIGludG8gdGhlIHZlY3RvclxyXG5cdFx0Ly8gZm9yIGJveDJkLiBzbyBmaW5hbF9kZWYgaXMgYSBmaW5hbCBkZXNjcmlwdGlvbiwgYnV0IG5vdCBpbiBmaW5hbCBmb3JtXHJcblxyXG5cclxuXHRcdHZhciBib2R5ID0gZ2V0X2JvZHkoZmluYWxfZGVmLCBlbnRpdHlfaW5zdGFuY2UpO1xyXG5cdFx0IFxyXG5cdFx0YXR0YWNoX2ZpeHR1cmUoYm9keSwgZmluYWxfZGVmLCBcIm1haW5cIik7XHJcblx0XHRcclxuXHRcdC8vSWYgdGhlIG9iamVjdCBoYXMgZGlyZWN0aW9uYWwgc2Vuc29ycywgYXR0YWNoIHNlbnNvcnMgaGVyZVxyXG5cdFx0aWYoZmluYWxfZGVmLmJvcmRlcl9zZW5zb3JzKXtcclxuXHRcdFx0YXR0YWNoX3NlbnNvcnMoYm9keSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJvZHk7XHJcblx0fTtcclxuXHJcblx0dmFyIGdldF9jaXJjdWxhciA9IGZ1bmN0aW9uKGRlZiwgdGVtcGxhdGUpe1xyXG5cdFx0dmFyIHR5cGUgPSBcImNpcmN1bGFyXCI7XHJcblx0XHQvLyBkb250JyBmb3JnZXQgYWJvdXQgcmVmYWN0b3Jpbmcgc29tZSBzdHVmZiBpbnRvIHRoZVxyXG5cdFx0Ly8gc2V0X2NvbW1vbiBmdW5jdGlvblxyXG5cdFx0XHJcblx0XHR2YXIgZGVmaW5pdGlvbiA9IG5ldyBCMmQuYjJCb2R5RGVmKCk7XHJcblx0XHRcclxuXHR9O1xyXG5cdFx0XHJcblx0dmFyIGdldF9wb2x5Z29uYWwgPSBmdW5jdGlvbihkZWYsIHRlbXBsYXRlKXtcclxuXHRcdHZhciB0eXBlID0gXCJwb2x5Z29uYWxcIjtcclxuXHRcdFxyXG5cdFx0dmFyIGRlZmluaXRpb24gPSBuZXcgQjJkLmIyQm9keURlZigpO1xyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIHNldF9kZWJ1Z19kcmF3ID0gZnVuY3Rpb24oZGVidWdfZHJhdyl7XHJcblx0XHRQaHlzaWNzTW9kZWwud29ybGQuU2V0RGVidWdEcmF3KGRlYnVnX2RyYXcpO1xyXG5cdH07XHJcblxyXG5cclxuXHRcclxuXHR2YXIgbGlzdGVuX2Zvcl9jb250YWN0X3dpdGggPSBmdW5jdGlvbih3aGF0LCBjb2xsaXNpb25fZXZlbnRfbmFtZSwgY3VzdG9tX2Z1bmN0aW9uKXtcclxuXHRcdC8qKlxyXG5cdFx0ICogc2V0dXBzIGN1c3RvbV9mdW5jdGlvbiB0byBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSBjb2xsaXNpb24gZXZlbnQgXHJcblx0XHQgKiBvY2N1cnMgYW5kIGludm9sdmVzID53aGF0PFxyXG5cdFx0ICogVEFLRVM6XHJcblx0XHQgKiBcdD53aGF0PFxyXG5cdFx0ICogXHRcdHN0cmluZyBcclxuXHRcdCAqIFx0XHRpZCBvZiBhbiBvYmplY3QgKFwiMzgzXCIpIG9yIGl0J3MgdHlwZSAoXCJwbGF5ZXJcIilcclxuXHRcdCAqIFx0PmNvbGxpc2lvbl9ldmVudF9uYW1lPFxyXG5cdFx0ICogXHRcdHN0cmluZy4gb25lIG9mOlxyXG5cdFx0ICogXHRcdEJlZ2luQ29udGFjdCwgRW5kQ29udGFjdCwgUHJlU29sdmUsIFBvc3RTb2x2ZVxyXG5cdFx0ICogXHQ+Y3VzdG9tX2Z1bmN0aW9uPCBcclxuXHRcdCAqIFx0XHRmdW5jdGlvblxyXG5cdFx0ICogXHRcdGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBvbmUgb2YgdGhvc2UgZXZlbnRzXHJcblx0XHQgKiBcdFx0bm90aWNlIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSB3cmFwcGVkLCBzbyBpdCBzaG91bGRcclxuXHRcdCAqIFx0XHRhY2NlcHQgZXh0cmEgcGFyYW1ldGVyID5pbmZvPCB0aGF0IHdpbGwgY29udGFpblxyXG5cdFx0ICogXHRcdHVucGFja2VkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2xsaXNpb25cclxuXHRcdCAqL1xyXG5cclxuXHJcblx0XHRpZih3aGF0ID09IG51bGwpe1xyXG5cdFx0XHR0aHJvdyBuZXcgUHJvcGVydHlVbmRlZmluZWQoXCJ3aGF0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKFxyXG5cdFx0XHRjb2xsaXNpb25fZXZlbnRfbmFtZSAhPSBcIkJlZ2luQ29udGFjdFwiICYmIGNvbGxpc2lvbl9ldmVudF9uYW1lICE9IFwiRW5kQ29udGFjdFwiICYmXHJcblx0XHRcdGNvbGxpc2lvbl9ldmVudF9uYW1lICE9IFwiUHJlU29sdmVcIiAmJiBjb2xsaXNpb25fZXZlbnRfbmFtZSAhPSBcIlBvc3RTb2x2ZVwiIFxyXG5cdFx0KXtcclxuXHRcdFx0dGhyb3cgXCJjb2xsaXNpb25fZXZlbnRfbmFtZSBzaG91bGQgYmUgb25lIG9mOiBQcmVTb2x2ZSwgUG9zdFNvbHZlLCBFbmRDb250YWN0LCBCZWdpbkNvbnRhY3RcIjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihjdXN0b21fZnVuY3Rpb24gPT0gbnVsbCB8fCB0eXBlb2YoY3VzdG9tX2Z1bmN0aW9uKSAhPSBcImZ1bmN0aW9uXCIpe1xyXG5cdFx0XHR0aHJvdyBcIlByb3BlcnR5IGN1c3RvbV9mdW5jdGlvbiBpcyBub3QgZGVmaW5lZCBvciBpc24ndCBhIGZ1bmN0aW9uXCJcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0X2Z1bmN0aW9uX3RhYmxlID0gUGh5c2ljc01vZGVsLmF3YWl0aW5nX2NvbnRhY3RbY29sbGlzaW9uX2V2ZW50X25hbWVdOyBcclxuXHJcblx0XHRpZih0YXJnZXRfZnVuY3Rpb25fdGFibGVbd2hhdF0gPT0gbnVsbCl7XHJcblx0XHRcdHRhcmdldF9mdW5jdGlvbl90YWJsZVt3aGF0XSA9IFtjdXN0b21fZnVuY3Rpb25dO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHRhcmdldF9mdW5jdGlvbl90YWJsZVt3aGF0XS5wdXNoKGN1c3RvbV9mdW5jdGlvbik7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHRcclxuXHR2YXIgaW5pdF9jb2xsaXNpb25fbGlzdGVuZXIgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqL1xyXG5cdFx0XHJcblx0XHR2YXIgY2FsbF9hbGwgPSBmdW5jdGlvbihsaXN0LCBhcmdzKXtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGNhbGwgYWxsIGZ1bmN0aW9ucyBpbiBsaXN0IHByb3ZpZGluZyBhcmd1bWVudHNcclxuXHRcdFx0ICogZnJvbSB0aGUgYXJyYXkgYXJnc1xyXG5cdFx0XHQgKiBpZiBsaXN0IGdpdmUgaXMgbnVsbC91bmRlZmluZWQsIGRvIG5vdGhpbmdcclxuXHRcdFx0ICovXHJcblxyXG5cdFx0XHRpZihsaXN0ICE9IG51bGwpe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHRcdGxpc3RbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBnZXRfaWQgPSBmdW5jdGlvbihvYmope1xyXG5cdFx0XHR1c2VyRGF0YSA9IG9iai5HZXRVc2VyRGF0YSgpO1xyXG5cdFx0XHRpZih1c2VyRGF0YSAhPSBudWxsICYmIHVzZXJEYXRhLmlkICE9IG51bGwpe1xyXG5cdFx0XHRcdHJldHVybiB1c2VyRGF0YS5pZDtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0cmV0dXJuIFwiW05PX0lEXVwiXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBnZXRfdHlwZSA9IGZ1bmN0aW9uKG9iail7XHJcblx0XHRcdHZhciB1c2VyRGF0YSA9IG9iai5HZXRVc2VyRGF0YSgpO1xyXG5cdFx0XHRpZih1c2VyRGF0YSAhPSBudWxsICYmIHVzZXJEYXRhLmVudGl0eV9pbnN0YW5jZS50eXBlICE9IG51bGwpe1xyXG5cdFx0XHRcdHJldHVybiB1c2VyRGF0YS5lbnRpdHlfaW5zdGFuY2UudHlwZTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciB1bnBhY2tfY29udGFjdF9pbmZvID0gZnVuY3Rpb24oY29udGFjdCwgbXlfdHlwZSl7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB1bnBhY2tzIGluZm8gYWJvdXQgdGhlIGNvbGxpc2lvbiBhbmQgXHJcblx0XHRcdCAqIHJldHVybnMgaXRcclxuXHRcdFx0ICogPm15X3R5cGU8IGlzIGFuIHR5cGUgb2YgYW4gb2JqZWN0IHRoYXQgd2lsbFxyXG5cdFx0XHQgKiBnbyB1bmRlciB0aGUgPk1lPCBwYXJhbWVldGVyIGluc2lkZSBvZiBpbmZvXHJcblx0XHRcdCAqIChBcyBvcHBvc2VkIHRvIFRoZW0sIHdoaWNoIGlzIHRoZSBvdGhlciBvYmplY3QpXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRpZihteV90eXBlID09IG51bGwpe1xyXG5cdFx0XHRcdC8vID5teV90eXBlPCBpc24ndCBzdXBwb3NlZCB0byBiZSBudWxsL3VuZGVmaW5lZFxyXG5cdFx0XHRcdHRocm93IG5ldyBQcm9wZXJ0eVVuZGVmaW5lZChcIm15X3R5cGVcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBBID0ge307XHJcblx0XHRcdHZhciBCID0ge307XHJcblxyXG5cdFx0XHRBLmZpeHR1cmUgPSBjb250YWN0Lm1fZml4dHVyZUE7XHJcblx0XHRcdEIuZml4dHVyZSA9IGNvbnRhY3QubV9maXh0dXJlQjtcclxuXHRcdFx0QS5ib2R5ID0gQS5maXh0dXJlLkdldEJvZHkoKTtcclxuXHRcdFx0Qi5ib2R5ID0gQi5maXh0dXJlLkdldEJvZHkoKTtcclxuXHJcblx0XHRcdEEuaWQgPSBnZXRfaWQoQS5ib2R5KTtcclxuXHRcdFx0Qi5pZCA9IGdldF9pZChCLmJvZHkpO1xyXG5cclxuXHRcdFx0Ly9BLmVudGl0eSA9IElkZW50aWZpY2F0aW9uQ29udHJvbGxlci5nZXRfYnlfaWQoQS5pZCk7XHJcblx0XHRcdC8vQi5lbnRpdHkgPSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuZ2V0X2J5X2lkKEIuaWQpO1xyXG5cdFx0XHRBLmVudGl0eSA9IEEuYm9keS5HZXRVc2VyRGF0YSgpLmVudGl0eV9pbnN0YW5jZTtcclxuXHRcdFx0Qi5lbnRpdHkgPSBCLmJvZHkuR2V0VXNlckRhdGEoKS5lbnRpdHlfaW5zdGFuY2U7XHJcblxyXG5cdFx0XHRBLnR5cGUgPSBnZXRfdHlwZShBLmJvZHkpO1xyXG5cdFx0XHRCLnR5cGUgPSBnZXRfdHlwZShCLmJvZHkpO1xyXG5cclxuXHRcdFx0QS5maXh0dXJlX25hbWUgPSBnZXRfY3VzdG9tX3Byb3BlcnR5KEEuZml4dHVyZSwgXCJuYW1lXCIpO1xyXG5cdFx0XHRCLmZpeHR1cmVfbmFtZSA9IGdldF9jdXN0b21fcHJvcGVydHkoQi5maXh0dXJlLCBcIm5hbWVcIik7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiB1bnBhY2sgbW9yZSBpbmZvIGlmIG5lY2Vzc2FyeVxyXG5cclxuXHRcdFx0dmFyIGluZm8gPSB7fTtcclxuXHJcblx0XHRcdGlmKEEudHlwZSA9PSBteV90eXBlKXtcclxuXHRcdFx0XHRpbmZvLk1lID0gQTtcclxuXHRcdFx0XHRpbmZvLlRoZW0gPSBCO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRpbmZvLk1lID0gQjtcclxuXHRcdFx0XHRpbmZvLlRoZW0gPSBBO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gaW5mbztcclxuXHRcdFx0XHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHR2YXIgY29tbW9uX2NvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0LCBhcmdzLCBsaXN0cyl7XHJcblx0XHRcdC8vIGNyZWF0ZSBpbmZvLCBjYWxsIHJlc3BlY3RpdmUgZnVuY3Rpb25zIGZvciBlYWNoIGlkLiB1c2UgcHJvdmlkZWQgYXJndW1lbnRzID5hcmdzPFxyXG5cdFx0XHQvLyBsb29rdXAgaWRzIGluIHRoZSBwcm92aWRlZCB0YWJsZSBvZiBsaXN0cyA+bGlzdHM8XHJcblx0XHRcdFxyXG5cdFx0XHQvKiBuZXh0IGF2YWlsYWJsZSBpbmRleCBpbiB0aGUgYXJncyBhcnJheSBcclxuXHRcdFx0ICogaXQncyB1c2VkIHRvIGRldGVybWluZSBhdCB3aGF0IGluZGV4IHRoZSBpbmZvIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgYXMqL1xyXG5cdFx0XHR2YXIgbmV4dF9hcmdfaW5kZXggPSBhcmdzLmxlbmd0aDsgXHJcblxyXG5cdFx0XHR2YXIgdHlwZTEgPSBnZXRfdHlwZShjb250YWN0Lm1fZml4dHVyZUEuR2V0Qm9keSgpKTtcclxuXHRcdFx0dmFyIHR5cGUyID0gZ2V0X3R5cGUoY29udGFjdC5tX2ZpeHR1cmVCLkdldEJvZHkoKSk7XHJcblxyXG5cdFx0XHRpZih0eXBlMSAhPSBudWxsKXtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRhcmdzW25leHRfYXJnX2luZGV4XSA9IHVucGFja19jb250YWN0X2luZm8oY29udGFjdCwgdHlwZTEpO1xyXG5cdFx0XHRcdGNhbGxfYWxsKGxpc3RzW3R5cGUxXSwgYXJncyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHR5cGUyICE9IG51bGwpe1xyXG5cdFx0XHRcdGFyZ3NbbmV4dF9hcmdfaW5kZXhdID0gdW5wYWNrX2NvbnRhY3RfaW5mbyhjb250YWN0LCB0eXBlMik7XHJcblx0XHRcdFx0Y2FsbF9hbGwobGlzdHNbdHlwZTJdLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblx0XHRcclxuXHRcdHZhciBQcmVTb2x2ZSA9IGZ1bmN0aW9uKGNvbnRhY3QsIGltcHVsc2Upe1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIGxpc3RzID0gUGh5c2ljc01vZGVsLmF3YWl0aW5nX2NvbnRhY3QuUHJlU29sdmU7XHJcblxyXG5cdFx0XHR2YXIgYXJncyA9IFtjb250YWN0LCBpbXB1bHNlXTtcclxuXHJcblx0XHRcdGNvbW1vbl9jb250YWN0KGNvbnRhY3QsIGFyZ3MsIGxpc3RzKTtcclxuXHRcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdHZhciBQb3N0U29sdmUgPSBmdW5jdGlvbihjb250YWN0LCBvbGRNYW5pZm9sZCl7XHJcblx0XHRcdHZhciBsaXN0cyA9IFBoeXNpY3NNb2RlbC5hd2FpdGluZ19jb250YWN0LlBvc3RTb2x2ZTtcclxuXHJcblx0XHRcdHZhciBhcmdzID0gW2NvbnRhY3QsIG9sZE1hbmlmb2xkXTtcclxuXHJcblx0XHRcdGNvbW1vbl9jb250YWN0KGNvbnRhY3QsIGFyZ3MsIGxpc3RzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIEJlZ2luQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3Qpe1xyXG5cdFx0XHR2YXIgbGlzdHMgPSBQaHlzaWNzTW9kZWwuYXdhaXRpbmdfY29udGFjdC5CZWdpbkNvbnRhY3Q7XHJcblxyXG5cdFx0XHR2YXIgYXJncyA9IFtjb250YWN0XTtcclxuXHJcblx0XHRcdGNvbW1vbl9jb250YWN0KGNvbnRhY3QsIGFyZ3MsIGxpc3RzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIEVuZENvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0KXtcclxuXHRcdFx0dmFyIGxpc3RzID0gUGh5c2ljc01vZGVsLmF3YWl0aW5nX2NvbnRhY3QuRW5kQ29udGFjdDtcclxuXHJcblx0XHRcdHZhciBhcmdzID0gW2NvbnRhY3RdO1xyXG5cclxuXHRcdFx0Y29tbW9uX2NvbnRhY3QoY29udGFjdCwgYXJncywgbGlzdHMpO1xyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRcclxuXHRcdHZhciBsaXN0ZW5lciA9IG5ldyBCMmQuYjJDb250YWN0TGlzdGVuZXI7XHJcblx0XHRsaXN0ZW5lci5QcmVTb2x2ZSA9IFByZVNvbHZlO1xyXG5cdFx0bGlzdGVuZXIuUG9zdFNvbHZlID0gUG9zdFNvbHZlO1xyXG5cdFx0bGlzdGVuZXIuQmVnaW5Db250YWN0ID0gQmVnaW5Db250YWN0O1xyXG5cdFx0bGlzdGVuZXIuRW5kQ29udGFjdCA9IEVuZENvbnRhY3Q7XHJcblx0XHRcclxuXHRcdFBoeXNpY3NNb2RlbC53b3JsZC5TZXRDb250YWN0TGlzdGVuZXIobGlzdGVuZXIpO1xyXG5cdFxyXG5cdH07XHJcblxyXG5cdHZhciBnZXRfY3VzdG9tX3Byb3BlcnR5ID0gZnVuY3Rpb24oYjJkX29iaiwgcHJvcGVydHlfbmFtZSl7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2l2ZW4gYW55IGJveDJkIG9iamVjdCB0aGF0IGhhcyBHZXRVc2VyRGF0YSBtZXRob2RcclxuXHRcdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gY3VzdG9tIHByb3BlcnR5IHdpdGggZ2l2ZW5cclxuXHRcdCAqIHByb3BlcnR5X25hbWUgaWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgb24gdXNlckRhdGEgb2YgdGhlIG9iamVjdFxyXG5cdFx0ICogaWYgbm90LCB0aGUgZnVuY3Rpb24gcmV0dXJucyBudWxsXHJcblx0XHQgKi9cclxuXHRcdHZhciB1c2VyX2RhdGEgPSBiMmRfb2JqLkdldFVzZXJEYXRhKCk7XHJcblx0XHRpZih1c2VyX2RhdGEgJiYgdXNlcl9kYXRhW3Byb3BlcnR5X25hbWVdKXtcclxuXHRcdFx0cmV0dXJuIHVzZXJfZGF0YVtwcm9wZXJ0eV9uYW1lXTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdHZhciByZW1vdmVfYm9keSA9IGZ1bmN0aW9uKGJvZHkpe1xyXG5cdFx0LyoqXHJcblx0XHQqIGRlc3Ryb3kgZ2l2ZW4gYm9keSAocmVtb3ZlIGl0IGZyb20gd29ybGQgYW5kIHJlbW92ZSBhbGwgcmVmZXJlbmNlcyBQaHlzaWNzIGhhcyB0byBpdClcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdC8vIFRPRE86IElNUE9SVEFOVCEhISB1cGRhdGUgdGhpcyBmdW5jdGlvbiBpZiB5b3Ugc3RvcmUgZXh0cmEgcmVmZXJlbmNlc1xyXG5cdFx0Ly8gdG8gdGhlIGJvZHkgd2l0aGluIFBoeXNpY3NNb2RlbC9Db250cm9sbGVyLlxyXG5cdFx0Ly8gRXZlbiBhIHNpbmdsZSByZWZlcmVuY2UgdG8gdGhlIGJvZHkgbWF5IGtlZXAgaXQgZnJvbSBiZWluZyBkZWxldGVkXHJcblx0XHQvLyBmcm9tIHRoZSBtZW1vcnkgXHJcblx0XHRQaHlzaWNzTW9kZWwud29ybGQuRGVzdHJveUJvZHkoYm9keSk7XHJcblx0fTtcclxuXHRcclxuXHQvL2EgdmVyeSBpbXBvcnRhbnQgZnVuY3Rpb24gdGhhdCBJIG5lZWQgZm9yIHRoZSBoeWVuYVxyXG5cdC8vcmV0dXJucyB0aGUgbnVtYmVyIG9mIHNoYXBlcyBpbiBjb250YWN0IHdpdGggYSBnaXZlbiBib3VuZGluZyBib3hcclxuXHR2YXIgcXVlcnlfYWFiYiA9IGZ1bmN0aW9uKGFhYmIpe1xyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHRcdFBoeXNpY3NNb2RlbC53b3JsZC5RdWVyeUFBQkIoXHJcblx0XHRmdW5jdGlvbihtYXgpe1xyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRhYWJiKTtcclxuXHRcdHJldHVybiBjb3VudDtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHRnZXRfYm9keTogZ2V0X2JvZHksXHJcblx0XHRnZXRfcmVjdGFuZ3VsYXI6IGdldF9yZWN0YW5ndWxhcixcclxuXHRcdHN0ZXA6IHN0ZXAsXHJcblx0XHRpbml0OiBpbml0LFxyXG5cdFx0c2V0X2RlYnVnX2RyYXc6IHNldF9kZWJ1Z19kcmF3LFxyXG5cdFx0ZHJhd19kZWJ1ZzogZHJhd19kZWJ1ZyxcclxuXHRcdGxpc3Rlbl9mb3JfY29udGFjdF93aXRoOiBsaXN0ZW5fZm9yX2NvbnRhY3Rfd2l0aCxcclxuXHRcdHJlbW92ZV9ib2R5OiByZW1vdmVfYm9keSxcclxuXHRcdHF1ZXJ5X2FhYmI6IHF1ZXJ5X2FhYmIsXHJcblx0fTtcclxufSkoKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBoeXNpY3NDb250cm9sbGVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiUGh5c2ljc0NvbnRyb2xsZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkRFRkFVTFRcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG5cclxuIiwiXHJcbnZhciBSZWdpc3RlckFzQ29udHJvbGxlciA9IChmdW5jdGlvbigpe1xyXG5cdC8qIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgb2JqZWN0IGFzIHNvbWV0aGluZyxcclxuXHQgKiBmb3Igb3RoZXIgbW9kdWxlcyB0byBhY2Nlc3NcclxuXHQgKiBPbmUgdXNlIGNvdWxkIGJlIHJlZ2lzdGVyaW5nIG5ld2x5IGdlbmVyYXRlZCB0ZXJyYWluIHNsaWNlIGZyb20gdGhlIHNsaWNlIGNvbnRyb2xsZXIsXHJcblx0ICogZm9yIHRoZSBHcmFwaGljc0NvbnRyb2xsZXIgdG8gbm90aWNlIGFuZCBnZW5lcmF0ZSBncmFwaGljcyBmb3IgaXRcclxuXHQqL1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSB0aGUgSW5pdENvbnRyb2xsZXIgb25jZSB3aGVuIHRoZSBnYW1lIGlzIGxvYWRlZCAqL1xyXG5cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKXtcclxuXHRcdC8qIGlzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgR2FtZUNvbnRyb2xsZXIudXBkYXRlX2FsbCAqL1xyXG5cclxuXHRcdC8vIFRPRE86IGF1dG9tYXRpY2FsbHkgZGVsZXRlIHN0dWZmIGRlcGVuZGluZyBvbiB0aW1lb3V0IHN0dWZmXHJcblx0XHQvLyBjYWxjdWxhdGUgdGltZW91dCBvZiBcclxuXHR9O1xyXG5cclxuXHR2YXIgcmVnaXN0ZXJfYXMgPSBmdW5jdGlvbih3aGF0LCBvYmope1xyXG5cdFx0LyoqXHJcblx0XHQqIHNpbXBsZSBvbmUgdGltZSBsb29rdXAgcmVnaXN0ZXJpbmcgb2Ygb2JqZWN0XHJcblx0XHQqID53aGF0PCAtIHN0cmluZy4gZS5nLiBcIm5ld190ZXJyYWluX3NsaWNlXCJcclxuXHRcdCogPm9iajwgLSBvYmplY3QgdG8gcmVnaXN0ZXJcclxuXHRcdCovXHJcblx0XHRcclxuXHRcdHZhciB0YWJsZSA9IFJlZ2lzdGVyQXNNb2RlbC5zaW1wbGVfb25lX3RpbWVfbG9va3VwO1xyXG5cclxuXHRcdGlmKHRhYmxlW3doYXRdKXtcclxuXHRcdFx0dGFibGVbd2hhdF0ucHVzaChvYmopO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHRhYmxlW3doYXRdID0gW29ial07XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIHJldHJpZXZlX3JlZ2lzdGVyZWRfYXMgPSBmdW5jdGlvbih3aGF0KXtcclxuXHRcdC8qKlxyXG5cdFx0KiByZXR1cm5zIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IGNvbnRhdGluaW5nXHJcblx0XHQqIHRoaW5ncyBjdXJyZW50bHkgcmVnaXN0ZXJlZCBhcyA+d2hhdDxcclxuXHRcdCogeW91IGFyZSByZXNwb25zaWJsZSBmb3IgcG9wcGluZyAob3Igbm90IHBvcHBpbmcpIHRoZW1cclxuXHRcdCogZnJvbSB0aGUgYXJyYXkgdG8gbm8gbG9uZ2VyIGNvbnNpZWRlciAob3IgY29udGludWUgdG8gY29uc2lkZXIpXHJcblx0XHQqIHRoZW0gYXMgcmVnaXN0ZXJlZCBhcyA+d2hhdDxcclxuXHRcdCovXHJcblx0XHR2YXIgbGlzdCA9IFJlZ2lzdGVyQXNNb2RlbC5zaW1wbGVfb25lX3RpbWVfbG9va3VwW3doYXRdO1xyXG5cdFx0aWYobGlzdCl7XHJcblx0XHRcdHJldHVybiBsaXN0O1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHVwZGF0ZTogdXBkYXRlLFxyXG5cdFx0cmVnaXN0ZXJfYXM6IHJlZ2lzdGVyX2FzLFxyXG5cdFx0cmV0cmlldmVfcmVnaXN0ZXJlZF9hczogcmV0cmlldmVfcmVnaXN0ZXJlZF9hc1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lzdGVyQXNDb250cm9sbGVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiUmVnaXN0ZXJBc0NvbnRyb2xsZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkRFRkFVTFRcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG5cclxuIiwiY29uZmlnID0gcmVxdWlyZSAoXCIuLi9Db25maWcuanNcIik7XHJcblxyXG52YXIgVGVycmFpbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKXtcclxuXHQvKiB0aGlzIHdpbGwgYmUgdGhlIHBoeXNpY2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZXJyYWluXHJcblx0ICogY3VycmVudGx5IGl0IGNvbnRhaW5zIGdyYXBoaWNhbCBiaXRzLCBidXQgdGhhdCB3aWxsIGNoYW5nZVxyXG5cdCAqL1xyXG5cdFxyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0ICAgIGluY2x1ZGUoKTtcclxuXHQgICAgVGVycmFpbk1vZGVsLnNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMjAwMCkgKyAxMDAwOy8vcGxhY2Vob2xkZXIgZm9yIHNlZWRcclxuXHJcblx0fTtcclxuXHRcclxuXHRcclxuXHR2YXIgdXBkYXRlID0gZnVuY3Rpb24oKXtcclxuXHRcdC8vIGNoZWNrIGZvciBhbnkgY2h1bmtzIHRvIGJlIHVubG9hZGVkL2RlbGV0ZWQgd2lsbCBnbyBoZXJlLCBmb3Igbm93XHJcblx0XHQvLyBtYXliZSBpdCdsbCBjaGVjayBmb3IgYWxsIHBsYXllcnMgdG8gYmUgc3VmZmljaWVudGx5IGZhciB0byB0aGUgcmlnaHRcclxuXHRcdC8vIG9mIGl0LCBtYXliZSBvbmUgY2h1bmsgaW4gYWR2YW5jZSwgb3Igc210aCBsaWtlIHRoYXRcclxuXHRcdC8vaWYgKGNvbmZpZy5tb3ZlbWVudF9lZGdlLnggPiB4KVxyXG5cdFx0d2hpbGUoVGVycmFpbk1vZGVsLnRlcnJhaW5fc2xpY2VzX3F1ZXVlLmxlbmd0aCA8IDQpe1xyXG5cdFx0XHR2YXIgc2xpY2UgPSBOZXdUZXJyYWluU2xpY2UoKTtcclxuXHRcdFx0VGVycmFpbk1vZGVsLnRlcnJhaW5fc2xpY2VzX3F1ZXVlLnB1c2goc2xpY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjbWRzID0gS2V5Ym9hcmRDb250cm9sbGVyLmRlYnVnX2NvbW1hbmRzKCk7XHJcblxyXG5cdFx0aWYoY21kcyhcIm5ld19zbGljZVwiKSl7XHJcblx0XHRcdGNvbnNvbGUubG9nKFRlcnJhaW5Nb2RlbC5zZWVkKTtcclxuXHRcdFx0dmFyIHNsaWNlID0gTmV3VGVycmFpblNsaWNlKCk7XHJcblx0XHRcdFRlcnJhaW5Nb2RlbC50ZXJyYWluX3NsaWNlc19xdWV1ZS5wdXNoKHNsaWNlKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cclxuXHRcdGlmKFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpID4gKFRlcnJhaW5Nb2RlbC50ZXJyYWluX3NsaWNlc19xdWV1ZS5sZW5ndGgtMykqKDIwKSl7XHJcblx0XHRcdHZhciBzbGljZSA9IE5ld1RlcnJhaW5TbGljZShUZXJyYWluTW9kZWwuc2VlZCk7XHJcblx0XHRcdFRlcnJhaW5Nb2RlbC50ZXJyYWluX3NsaWNlc19xdWV1ZS5wdXNoKHNsaWNlKTtcclxuXHRcdFx0VGVycmFpbk1vZGVsLnNlZWQgPSAoKChUZXJyYWluTW9kZWwuc2VlZCkgKiAoVGVycmFpbk1vZGVsLnNlZWQpIC0gVGVycmFpbk1vZGVsLnNlZWQgLyAyKSkgJSAyMDAwICsgMTAwMTtcclxuXHRcdFx0V29ybGRDb250cm9sbGVyLnNldF9zcGF3bigpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjaGVja19mb3Jfb2xkX3NsaWNlcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBnZXRfc2VlZCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRyZXR1cm4gVGVycmFpbk1vZGVsLnNlZWQ7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgc2V0X3NlZWQgPSBmdW5jdGlvbihuZXdfc2VlZCl7XHJcblx0XHRUZXJyYWluTW9kZWwuc2VlZCA9IG5ld19zZWVkO1xyXG5cdH07XHJcblxyXG5cdHZhciBOZXdUZXJyYWluU2xpY2UgPSBmdW5jdGlvbihzZWVkKXtcclxuXHRcdC8qIHRoaXMgdGFrZXMgY2FyZSBvZiBhcHBlbmRpbmcgbmV3IHRlcnJhaW4gc2xpY2UgdG8gdGhlIGdlbmVyYXRlZCB0ZXJyYWluXHJcblx0XHQgKiBpdCBjYWxjdWxhdGVzIGl0J3Mgb3JpZ2luIHggYW5kIHkgcG9zaXRpb25zIGFuZCB3aGF0ZXZlciBvdGhlciBzdHVmZixcclxuXHRcdCAqIGdlbmVyYXRlcyBzbGljZTsgc2V0cyB1cCBldmVyeXRoaW5nXHJcblx0XHQgKi9cclxuXHRcdHZhciB4X29mZnNldCA9IFRlcnJhaW5Nb2RlbC5zbGljZV9jb3VudGVyICogQ29uZmlnLlRlcnJhaW5TbGljZS5ncmlkX2NvbHVtbnM7XHJcblxyXG5cdFx0VGVycmFpbk1vZGVsLnNsaWNlX2NvdW50ZXIrKzsgLy8gVE9ETzogY2hhbmdlIGhvdyBpdCB3b3JrcyB3aGVuIHRydWx5IGluZmluaXRlXHJcblxyXG5cdFx0aWYoVGVycmFpbk1vZGVsLmluaXRpYWxfZ2VuZXJhdGVkIDwgMyl7XHJcblx0XHRcdFRlcnJhaW5Nb2RlbC5pbml0aWFsX2dlbmVyYXRlZCsrO1xyXG5cdFx0XHR2YXIgc2xpY2UgPSBuZXcgVGVycmFpblNsaWNlQ29udHJvbGxlci5nZW5lcmF0ZV9pbml0aWFsKHhfb2Zmc2V0KTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHR2YXIgc2xpY2UgPSBuZXcgVGVycmFpblNsaWNlQ29udHJvbGxlci5nZW5lcmF0ZV9yYW5kb20oeF9vZmZzZXQsIHNlZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdElkZW50aWZpY2F0aW9uQ29udHJvbGxlci5hc3NpZ25faWQoc2xpY2UpO1xyXG5cclxuXHRcdE1hcmtBc05ld1RlcnJhaW5TbGljZShzbGljZSk7IFxyXG5cclxuXHRcdHJldHVybiBzbGljZTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGNoZWNrX2Zvcl9vbGRfc2xpY2VzID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBjaGVjayBmb3Igc2xpY2VzIHRoYXQgYXJlIHRvbyBmYXIgYmVoaW5kIGFuZCBzaG91bGQgYmUgcmVtb3ZlZFxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgdHF1ZXVlID0gVGVycmFpbk1vZGVsLnRlcnJhaW5fc2xpY2VzX3F1ZXVlO1xyXG5cdFx0dmFyIGN1dF9vZmZfaW5kZXggPSAwOyAvLyB3aGF0IGFtbnQgb2Ygc2xpY2VzIHNob3VsZCBnbyBvZmYgdGhlIHF1ZXVlXHJcblxyXG5cdFx0Ly8gZmluZCB0aGUgb2xkIHNsaWNlcyBhbmQgaGFuZGxlIHRoZWlyIGRlbGV0aW9uXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdHF1ZXVlLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0dmFyIHNsaWNlID0gdHF1ZXVlW2ldO1xyXG5cdFx0XHR2YXIgc2xpY2VfZW5kX3ggPSBzbGljZS5vcmlnaW4ueCArIHNsaWNlLmdyaWRfY29sdW1ucyAqIHNsaWNlLmNlbGxfdztcclxuXHJcblx0XHRcdGlmKHNsaWNlX2VuZF94IDwgV29ybGRDb250cm9sbGVyLmdldF9tb3ZlbWVudF9lZGdlKXtcclxuXHRcdFx0XHQvLyBpZiBzbGljZSBpcyB1bnJlYWNoYWJsZSwgZGVsZXRlIGl0IFxyXG5cdFx0XHRcdGN1dF9vZmZfaW5kZXgrKztcclxuXHRcdFx0XHRkZWxldGVfc2xpY2Uoc2xpY2UpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbm93IHJlbW92ZSBhbGwgZm91bmQgb2xkIHNsaWNlcyBmcm9tIHRoZSBxdWV1ZVxyXG5cdFx0aWYoY3V0X29mZl9pbmRleCA+IDApe1xyXG5cdFx0XHRUZXJyYWluTW9kZWwudGVycmFpbl9zbGljZXNfcXVldWUgPSB0cXVldWUuc2xpY2UoY3V0X29mZl9pbmRleCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHJcblx0dmFyIGRlbGV0ZV9zbGljZSA9IGZ1bmN0aW9uKHNsaWNlKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBhc3N1bWVzIHRoYXQgc2xpY2Ugd2lsbCBiZSBwb3BwZWQgZnJvbSB0aGUgdGVycmFpbiBzbGljZSBxdWV1ZSBlbHNld2hlcmVcclxuXHRcdCogKG9yIHdhcyBhbHJlYWR5KVxyXG5cdFx0KiBvdGhlcndpc2UgdGhlIHNsaWNlIHdvbid0IGJlIHByb3Blcmx5IGRlbGV0ZWRcclxuXHRcdCovXHJcblx0XHRcdFxyXG5cdFx0Y29uc29sZS5sb2coXCJkZWxldGluZyBzbGljZSB3aXRoIG9yaWdpblwiLCBzbGljZS5vcmlnaW4pO1xyXG5cdFx0XHJcblx0XHR2YXIgZ3JpZCA9IHNsaWNlLmdyaWQ7XHJcblx0XHRcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBncmlkLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0dmFyIHJvdyA9IGdyaWRbaV07XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspe1xyXG5cdFx0XHRcdHZhciBjZWxsID0gcm93W2pdO1xyXG5cdFx0XHRcdGlmKGNlbGwua2luZCAhPSAwKXtcclxuXHRcdFx0XHRcdFBoeXNpY3NDb250cm9sbGVyLnJlbW92ZV9ib2R5KGNlbGwuYm9keSk7XHJcblx0XHRcdFx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIucmVtb3ZlX2lkKGNlbGwuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdFxyXG5cdFx0Ly8gRm9yIGdyYXBoaWNzIHRvIHBpY2sgdXAgYW5kIGRlbGV0ZSB1bm5lZWRlZCBncmFwaGljc1xyXG5cdFx0UmVnaXN0ZXJBc0NvbnRyb2xsZXIucmVnaXN0ZXJfYXMoXCJyZW1vdmVkX3NsaWNlXCIsIHNsaWNlKTtcclxuXHJcblx0XHQvLyBmcmVlIHRoZSBpZCAoeWVzLCB0ZXJyYWluIHNsaWNlIGhhcyBpZCBpZFxyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLnJlbW92ZV9pZChzbGljZS5pZCk7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHJcblx0XHJcblx0dmFyIGZvcl9lYWNoX3RpbGUgPSBmdW5jdGlvbihmKXtcclxuXHRcdC8vIHRha2VzIGZ1bmN0aW9uID5mPCB0aGF0IHRha2VzIHRocmVlIHBhcmFtZXRlcnM6IHRpbGUgKGVhc2VsanMgb2JqZWN0KSxcclxuXHRcdC8vIHRlcnJhaW5fbHZsIChpbnQpLCBhbmQgdGlsZV9pbmRleCAoaW50KVxyXG5cdFx0Ly8gY2FsbHMgdGhpcyBmdW5jdGlvbiBmb3IgZXZlcnkgdGlsZSBvZiB0aGUgdGVycmFpblxyXG5cdFx0XHJcblx0XHR2YXIgcXVldWVzID0gVGVycmFpbk1vZGVsLnRlcnJhaW5fcXVldWVzO1xyXG5cclxuXHRcdCQuZWFjaChxdWV1ZXMsIGZ1bmN0aW9uKHRlcnJhaW5fbHZsKXtcclxuXHRcdFx0JC5lYWNoKHF1ZXVlc1t0ZXJyYWluX2x2bF0sIGZ1bmN0aW9uKHRpbGVfaW5kZXgpe1xyXG5cdFx0XHRcdGYocXVldWVzW3RlcnJhaW5fbHZsXVt0aWxlX2luZGV4XSwgdGVycmFpbl9sdmwsIHRpbGVfaW5kZXgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHR9O1xyXG5cclxuXHRcclxuXHR2YXIgTWFya0FzTmV3VGVycmFpblNsaWNlID0gZnVuY3Rpb24oc2xpY2Upe1xyXG5cdFx0Ly9UZXJyYWluTW9kZWwubmV3X3NsaWNlcy5wdXNoKHNsaWNlKTtcclxuXHRcdFJlZ2lzdGVyQXNDb250cm9sbGVyLnJlZ2lzdGVyX2FzKFwiYXdhaXRpbmdfZ3JhcGhpY3NfaW5pdGlhbGl6YXRpb25cIiwgc2xpY2UpO1xyXG5cdH07XHJcblxyXG5cdC8vdmFyIE5ld1NsaWNlc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvL3JldHVybiAoVGVycmFpbk1vZGVsLm5ld19zbGljZXMubGVuZ3RoID4gMCk7XHJcblx0Ly99O1xyXG5cclxuXHQvL3ZhciBHZXROZXdUZXJyYWluU2xpY2VzID0gZnVuY3Rpb24oKXtcclxuXHRcdC8vcmV0dXJuIFRlcnJhaW5Nb2RlbC5uZXdfc2xpY2VzO1xyXG5cdC8vfTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHVwZGF0ZTogdXBkYXRlLFxyXG5cdFx0aW5pdDogaW5pdCxcclxuXHRcdE5ld1RlcnJhaW5TbGljZTogTmV3VGVycmFpblNsaWNlLFxyXG5cdFx0TWFya0FzTmV3VGVycmFpblNsaWNlOiBNYXJrQXNOZXdUZXJyYWluU2xpY2UsXHJcblx0XHRnZXRfc2VlZDogZ2V0X3NlZWQsXHJcblx0XHRzZXRfc2VlZDogc2V0X3NlZWQsXHJcblx0XHQvL05ld1NsaWNlc0F2YWlsYWJsZTogTmV3U2xpY2VzQXZhaWxhYmxlLFxyXG5cdFx0Ly9HZXROZXdUZXJyYWluU2xpY2VzOiBHZXROZXdUZXJyYWluU2xpY2VzLFxyXG5cdH1cclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGVycmFpbkNvbnRyb2xsZXI7XHJcblxyXG52YXIgSW5jbHVkZXMgPSByZXF1aXJlKFwiLi4vSW5jbHVkZXMuanNcIik7IHZhciBpbmNsdWRlX2RhdGEgPSBJbmNsdWRlcy5nZXRfaW5jbHVkZV9kYXRhKHtcclxuXHRjdXJyZW50X21vZHVsZTogXCJUZXJyYWluQ29udHJvbGxlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuREVGQVVMVFxyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJcclxudmFyIFRlcnJhaW5TbGljZUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSB0aGUgSW5pdENvbnRyb2xsZXIgb25jZSB3aGVuIHRoZSBnYW1lIGlzIGxvYWRlZCAqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50c1xyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl90eXBlKFRlcnJhaW5TbGljZU1vZGVsLkNlbGwsIFwidGVycmFpbl9jZWxsXCIpO1xyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl90eXBlKFRlcnJhaW5TbGljZU1vZGVsLlNsaWNlLCBcInRlcnJhaW5fc2xpY2VcIik7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciB1cGRhdGUgPSBmdW5jdGlvbihzbGljZSl7XHJcblx0XHRcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGdldF9uZXh0X29yaWdpbiA9IGZ1bmN0aW9uKCl7XHJcblx0fTtcclxuXHRcclxuXHJcblx0XHJcblx0dmFyIHNwYXduQmxvY2sgPSBmdW5jdGlvbih4LCB5LCBraW5kKXtcclxuXHRcdC8vc3Bhd24gaW5zdGFuY2Ugb2YgdGhpcyBlbnRpdHkgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXHJcblx0XHR2YXIgYmxvY2sgPSBuZXcgVGVycmFpblNsaWNlTW9kZWwuQ2VsbChraW5kJTMpOyAvL2tpbmQgaXMgYW4gaW50LCAxID0gYmxvY2ssIDIgPSBwbGF0Zm9ybVxyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChibG9jayk7IC8vZXZlbnR1YWxseSB3ZSBtYXkgd2FudCB0byByZW1vdmUgdGhpcyBmb3IgdGhlIHNha2Ugb2YgZWZmaWNpZW5jeVxyXG5cdFx0YmxvY2suYm9keSA9IFBoeXNpY3NDb250cm9sbGVyLmdldF9yZWN0YW5ndWxhcih7eDogeCwgeTogeX0sIGJsb2NrKTtcclxuXHRcdHJldHVybiBibG9jaztcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBzcGF3blNwaWtlID0gZnVuY3Rpb24oeCwgeSl7XHJcblx0XHQvL3NwYXduIGluc3RhbmNlIG9mIHRoaXMgZW50aXR5IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xyXG5cdFx0dmFyIHNwaWtlID0gbmV3IFRlcnJhaW5TbGljZU1vZGVsLkNlbGwoMyk7IC8va2luZCA9IDMgbWVhbnMgc3Bpa2VzXHJcblx0XHRzcGlrZS5jYW5fYXR0YWNrID0gdHJ1ZTtcclxuXHRcdHNwaWtlLmRhbWFnZSA9IDQ7XHJcblx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKHNwaWtlKTsgLy9ldmVudHVhbGx5IHdlIG1heSB3YW50IHRvIHJlbW92ZSB0aGlzIGZvciB0aGUgc2FrZSBvZiBlZmZpY2llbmN5XHJcblx0XHRzcGlrZS5ib2R5ID0gUGh5c2ljc0NvbnRyb2xsZXIuZ2V0X3JlY3Rhbmd1bGFyKHt4OiB4LCB5OiB5fSwgc3Bpa2UpO1xyXG5cdFx0cmV0dXJuIHNwaWtlO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIHNwYXduR2FwID0gZnVuY3Rpb24oeCx5KXtcclxuXHRcdC8vIDAgd2lsbCBiZSB0aGUgaWQgZm9yIHRoZSBcImFpclwiIGkuZS4gbm90aGluZ1xyXG5cdFx0dmFyIGdhcDtcclxuXHRcdGdhcCA9IG5ldyBUZXJyYWluU2xpY2VNb2RlbC5DZWxsKDApO1xyXG5cdFx0Ly9JZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKGdhcCk7IC8vIERPIE5PVCBBU1NJR04gSURTIFRPIEVNUFRZIFNQQUNFU1xyXG5cdFx0cmV0dXJuIGdhcDtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBnZXRSYW5kb21OdW1iZXIgPSBmdW5jdGlvbiAoc2VlZCkge1xyXG5cdFx0cmV0dXJuIChzZWVkKnNlZWQpJTIwMDAgKyAxMDAwO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGJ1aWxkVGVycmFpblNsaWNlXzAwID0gZnVuY3Rpb24oc2xpY2Usc2VlZCl7XHJcblx0XHJcblx0ICAgIC8vc2V0IHZhcmlhYmxlc1xyXG5cdCAgICAvL2NvbnNvbGUubG9nKHNlZWQpO1xyXG5cdCAgICB2YXIgc2VlZCA9IHNlZWQ7XHJcblx0XHR2YXIgcm93cyA9IHNsaWNlLmdyaWRfcm93cztcclxuXHRcdHZhciBjb2x1bW5zID0gc2xpY2UuZ3JpZF9jb2x1bW5zO1xyXG5cdFx0dmFyIGksajtcclxuXHRcdHZhciBncm91bmRfbHZsID0gcm93cyAtIDM7IC8vdGhlIHJvdyB0aGF0IGlzIGNvbnNpZGVyZWQgZ3JvdW5kIGxldmVsLlxyXG5cdFx0dmFyIHZnYXBfbWluID0gNztcclxuXHRcdHZhciB2Z2FwX2xlbiA9IDA7XHJcblx0XHR2YXIgaGdhcF9taW4gPSAxMDtcdFx0XHRcdC8vbWluaW11bSBzaXplIG9mIGdhcHMgYmV0d2VlbiBwbGF0Zm9ybXNcclxuXHRcdHZhciBoZ2FwX2xlbiA9IDA7IFx0XHQvL2N1cnJlbnQgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGhvcml6b250YWwgZ2Fwc1xyXG5cdFx0dmFyIHBpdF9tYXggPSA4O1x0XHRcdFx0Ly9tYXhpbXVtIGxlbiBvZiBwaXRzIGluIGJsb2Nrc1xyXG5cdFx0dmFyIHBpdF9sZW4gPSAwOyBcdFx0Ly9jdXJyZW50IG51bWJlciBvZiBjb25zZWN1dGl2ZSBwaXRzXHJcblx0XHR2YXIgaGFzX3BpdCA9IFtdO1xyXG5cdFx0dmFyIHBpdF9mcmVxdWVuY3kgPSA2OyBcdFx0Ly9iYXNlIHBlcmNlbnRhZ2UgY2hhbmNlIG9mIGEgcGl0IGJlaW5nIGR1Z1xyXG5cdFx0dmFyIHBsYXRmb3JtX2xlbl9tYXggPSA3O1x0Ly9tYXhpbXVtIGxlbiBvZiBhIHBsYXRmb3JtXHJcblx0XHR2YXIgcGxhdGZvcm1fbGVuX21pbiA9IDM7IC8vbWluaW11bSBsZW4gb2YgYSBwbGF0Zm9ybVxyXG5cdFx0dmFyIHBsYXRmb3JtX2xlbiA9IDA7IFx0XHQvL2xlbiBvZiBjdXJyZW50bHkgZ2VuZXJhdGVkIHBsYXRmb3JtXHJcblx0XHR2YXIgcGxhdGZvcm1fY291bnRfbWF4ID0gMjsgLy9tYXhpbXVtIG51bWJlciBvZiBwbGF0Zm9ybXMgcGVyIGNvbHVtblxyXG5cdFx0dmFyIHBsYXRmb3JtX2NvdW50ID0gW107IFx0XHQvL2tlZXBzIHRyYWNrIG9mIHBsYXRmb3JtcyBwZXIgY29sdW1uXHJcblx0XHR2YXIgcGxhdGZvcm1fZnJlcXVlbmN5ID0gMTU7Ly9iYXNlIHBlcmNlbnRhZ2UgY2hhbmNlIG9mIGEgcGxhdGZvcm0gdG8gYmUgZ2VuZXJhdGVkXHJcblx0XHR2YXIgc3Bpa2VfZnJlcXVlbmN5ID0gNTA7Ly9iYXNlIHBlcmNlbnRhZ2UgY2hhbmNlIG9mIGEgcGxhdGZvcm0gdG8gaGF2ZSBzcGlrZXNcclxuXHRcdC8qXHJcblx0XHR2YXIgc3Bpa2UgZnJlcXVlbmN5XHJcblx0XHR2YXIgY29sdW1uIGZyZXF1ZW5jeVxyXG5cdFx0ZXRjLlxyXG5cdFx0Ki9cclxuXHRcdGZvcihpPTA7IGk8PWNvbHVtbnM7aSsrKXtcclxuXHRcdFx0cGxhdGZvcm1fY291bnRbaV0gPSAwO1xyXG5cdFx0XHRoYXNfcGl0W2ldID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9idWlsZCB0aGUgc3RhZ2UgZnJvbSB0aGUgYm90dG9tIHVwXHJcblx0XHQvKlxyXG5cdFx0QnVpbGQgU3RhZ2UgZnJvbSBib3R0b20gdXAsIGxlZnQgdG8gcmlnaHRcclxuXHRcdGxvYWQgYmxvY2tzIGFuZCBnYXBzIGludG8gc2xpY2UuZ3JpZFtpXVtqXVxyXG5cdFx0XHJcblx0XHQqL1xyXG5cdFx0Zm9yKGk9cm93cy0xO2k+PTA7aS0tKXtcclxuXHRcdFx0c2xpY2UuZ3JpZFtpXSA9IFtdO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRmb3IoaT1yb3dzIC0gMTtpPj0wO2ktLSl7IC8vb3V0ZXIgbG9vcDogZ2VuZXJhdGUgcm93cyBib3R0b20gdG8gdG9wXHJcblx0XHRcdGlmICh2Z2FwX2xlbiA8IHZnYXBfbWluKXtcclxuXHRcdFx0XHR2Z2FwX2xlbisrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzZWVkICUgMTAgPT0gMCkge1xyXG5cdFx0XHQgICAgc2VlZCArPSBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcihqPTA7ajxjb2x1bW5zO2orKyl7IC8vaW5uZXIgbG9vcDogZ2VuZXJhdGUgZnJvbSBsZWZ0IHRvIHJpZ2h0IHdpdGhpbiBjdXJyZW50IHJvd1xyXG5cdFx0XHRcdHZhciB4ID0gc2xpY2Uub3JpZ2luLnggKyBqICogc2xpY2UuY2VsbF93ICsgc2xpY2UuY2VsbF93LzI7XHJcblx0XHRcdFx0dmFyIHkgPSBzbGljZS5vcmlnaW4ueSArIGkgKiBzbGljZS5jZWxsX3cgKyBzbGljZS5jZWxsX3cvMjtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoaSA+PSBncm91bmRfbHZsKXtcdC8vSWYgb24gb3IgYmVsb3cgZ3JvdW5kIGxldmVsLCBHZW5lcmF0ZSBHcm91bmRcclxuXHRcdFx0XHQgICAgaWYgKHBpdF9sZW4gPCBwaXRfbWF4ICYmIChnZXRSYW5kb21OdW1iZXIoc2VlZCkgJSBpIDwgcGl0X2ZyZXF1ZW5jeSB8fCBwaXRfbGVuICE9IDApIHx8IGhhc19waXRbal0pIHtcclxuXHRcdFx0XHRcdFx0c2xpY2UuZ3JpZFtpXVtqXSA9IHNwYXduR2FwKHgseSk7IC8vY3JlYXRlIGdhcFxyXG5cdFx0XHRcdFx0XHRoYXNfcGl0W2pdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0cGl0X2xlbisrOyAvL3RoZSBwaXQgZ2V0cyB3aWRlclxyXG5cdFx0XHRcdFx0XHRzZWVkID0gZ2V0UmFuZG9tTnVtYmVyKHNlZWQpICsgNzE7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0XHRzbGljZS5ncmlkW2ldW2pdID0gc3Bhd25CbG9jayh4LHksMSk7Ly9jcmVhdGUgYSBncm91bmQgYmxvY2sgKDEgbWVhbnMgZ3JvdW5kKVxyXG5cdFx0XHRcdFx0XHRwaXRfbGVuID0gMDsgLy9hbnkgcGl0cyBiZWluZyBzcGF3bmVkIGhhdmUgYmVlbiBpbnRlcnJ1cHRlZFxyXG5cdFx0XHRcdFx0XHRpZiAoaSA9PSBncm91bmRfbHZsKXtcclxuXHRcdFx0XHRcdFx0XHRzbGljZS5ncmlkW2ldW2pdLnBvc2l0aW9uID0gXCJzdXJmYWNlXCI7XHJcblx0XHRcdFx0XHRcdFx0aWYoZ2V0UmFuZG9tTnVtYmVyKHNlZWQpJTEwMCA8IHNwaWtlX2ZyZXF1ZW5jeSAmJiBqID4gMCl7Ly9jaGVjayBmb3IgcmFuZG9tIHNwaWtlXHJcblx0XHRcdFx0XHRcdFx0XHRpZihzbGljZS5ncmlkW2ktMV1bai0xXSA9PSBudWxsICYmIHNsaWNlLmdyaWRbaV1bai0xXS5raW5kICE9IDApe1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzbGljZS5ncmlkW2kgLSAxXVtqXSA9IHNwYXduU3Bpa2UoeCwgeSAtIHNsaWNlLmNlbGxfdyk7IC8vY3JlYXRlIGEgc3Bpa2UgYWJvdmUgdGhlIGN1cnJlbnQgYmxvY2tcclxuXHRcdFx0XHRcdFx0XHRcdFx0c2VlZCA9IGdldFJhbmRvbU51bWJlcihzZWVkKSArIDIxO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRcdHNsaWNlLmdyaWRbaV1bal0ucG9zaXRpb24gPSBcInVuZGVyZ3JvdW5kXCI7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9ZWxzZXsgLy9FbFNFIEdlbmVyYXRlIFBsYXRmb3Jtc1xyXG5cdFx0XHRcdFx0aWYoKGhnYXBfbGVuID49IGhnYXBfbWluIHx8IHBsYXRmb3JtX2xlbiA+IDApIC8vaWYgdGhlcmUgaXMgYSBsYXJnZSBnYXAgb3IgYSBwbGF0Zm9ybSBiZWluZyBidWlsdFxyXG5cdFx0XHRcdFx0JiYgKHBsYXRmb3JtX2xlbiA8IHBsYXRmb3JtX2xlbl9tYXgpIC8vIGFuZCBhbnkgcGxhdGZvcm0gYmVpbmcgYnVpbHQgaXMgbGVzcyB0aGFuIG1heCBsZW5cclxuXHRcdFx0XHRcdCYmIChwbGF0Zm9ybV9jb3VudFtqXSA8IHBsYXRmb3JtX2NvdW50X21heCkgLy8gYW5kIHRoZSBjdXJyZW50IGNvbHVtbidzIHBsYXRmb3JtIGxpbWl0IGhhcyBub3QgYmVlbiBtZXRcclxuXHRcdFx0XHRcdCYmICh2Z2FwX2xlbiA+PSB2Z2FwX21pbikgLy9pZiB0aGUgdmVydGljYWwgZ2FwIG1pbmltdW0gaGFzIGJlZW4gbWV0XHJcblx0XHRcdFx0XHQmJiAocGxhdGZvcm1fbGVuID4gMCB8fCAoajxjb2x1bW5zLTEgJiYgcGxhdGZvcm1fY291bnRbaisxXSA8IHBsYXRmb3JtX2NvdW50X21heCkpKXsgLy9hbmQgdGhlIHBsYXRmb3JtIGlzIG5vdCBnb2luZyB0byBiZSBhIHNpbmdsZXRvblxyXG5cdFx0XHRcdFx0XHRpZiAoZ2V0UmFuZG9tTnVtYmVyKHNlZWQpJTEwMCA8IHBsYXRmb3JtX2ZyZXF1ZW5jeSB8fCAocGxhdGZvcm1fbGVuID4gMCAmJiBwbGF0Zm9ybV9sZW4gPD0gcGxhdGZvcm1fbGVuX21pbikpe1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRzbGljZS5ncmlkW2ldW2pdID0gc3Bhd25CbG9jayh4LHksMik7Ly9jcmVhdGUgcGxhdGZvcm0gKDIgbWVhbnMgcGxhdGZvcm0pXHJcblx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0Ly9jaGVjayBhZXN0aGV0aWMgc3R1ZmYsIGxpa2UgcGxhdGZvcm0gZWRnZXNcclxuXHRcdFx0XHRcdFx0XHRpZiAocGxhdGZvcm1fbGVuID09IDApe1xyXG5cdFx0XHRcdFx0XHRcdFx0c2xpY2UuZ3JpZFtpXVtqXS5wb3NpdGlvbiA9IFwibGVmdFwiO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0XHRcdFx0c2xpY2UuZ3JpZFtpXVtqXS5wb3NpdGlvbiA9IFwicmlnaHRcIjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYgKGo+MCl7aWYgKHNsaWNlLmdyaWRbaV1bai0xXS5raW5kICE9IDApe1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHNsaWNlLmdyaWRbaV1bai0xXS5wb3NpdGlvbiAhPSBcImxlZnRcIil7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHNsaWNlLmdyaWRbaV1bai0xXS5wb3NpdGlvbiA9IFwibWlkZGxlXCI7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fX1cclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRzZWVkID0gZ2V0UmFuZG9tTnVtYmVyKHNlZWQpO1xyXG5cdFx0XHRcdFx0XHRcdHBsYXRmb3JtX2xlbisrO1x0Ly9wbGF0Zm9ybSBnZXRzIGxvbmdlciwgYW5kIFxyXG5cdFx0XHRcdFx0XHRcdHBsYXRmb3JtX2NvdW50W2pdKys7Ly90aGUgbnVtYmVyIG9mIHBsYXRmb3JtcyBpbiB0aGUgY3VycmVudCBjb2x1bW4gaW5jcmVhc2VzXHJcblx0XHRcdFx0XHRcdFx0aGdhcF9sZW4gPSAwOyBcdFx0Ly9yZXNldCB0aGUgZ2FwIGNvdW50ZXIgdG8gMFxyXG5cdFx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc2xpY2UuZ3JpZFtpXVtqXSA9PSBudWxsKXtcclxuXHRcdFx0XHRcdFx0XHRcdHNsaWNlLmdyaWRbaV1bal0gPSBzcGF3bkdhcCh4LHkpOyAvL2NyZWF0ZSBhIGdhcFxyXG5cdFx0XHRcdFx0XHRcdFx0cGxhdGZvcm1fbGVuID0gMDsgLy9pZiB0aGVyZSB3YXMgYSBwbGF0Zm9ybSwgaXQgaGFzIGJlZW4gaW50ZXJydXB0ZWRcclxuXHRcdFx0XHRcdFx0XHRcdGhnYXBfbGVuKys7IC8vdGhlIGdhcCBnZXRzIHdpZGVyXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0aWYgKHNsaWNlLmdyaWRbaV1bal0gPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRcdFx0c2xpY2UuZ3JpZFtpXVtqXSA9IHNwYXduR2FwKHgseSk7IC8vY3JlYXRlIGEgZ2FwXHJcblx0XHRcdFx0XHRcdFx0cGxhdGZvcm1fbGVuID0gMDsgLy9pZiB0aGVyZSB3YXMgYSBwbGF0Zm9ybSwgaXQgaGFzIGJlZW4gaW50ZXJydXB0ZWRcclxuXHRcdFx0XHRcdFx0XHRoZ2FwX2xlbisrOyAvL3RoZSBnYXAgZ2V0cyB3aWRlclxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzZWVkID0gZ2V0UmFuZG9tTnVtYmVyKHNlZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR2Z2FwX2xlbiA9IHZnYXBfbGVuJXZnYXBfbWluO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHNsaWNlO1xyXG5cdH07XHJcblx0XHJcblx0Ly9wcmVnZW5lcmF0ZWQgc2xpY2VcclxuXHR2YXIgYnVpbGRUZXJyYWluU2xpY2VfMDEgPSBmdW5jdGlvbihzbGljZSxzZWVkKXtcclxuXHRcdC8vc2V0IHZhcmlhYmxlc1xyXG5cdFx0dmFyIHJvd3MgPSBzbGljZS5ncmlkX3Jvd3M7XHJcblx0XHR2YXIgY29sdW1ucyA9IHNsaWNlLmdyaWRfY29sdW1ucztcclxuXHRcdHZhciBpLGo7XHJcblx0XHR2YXIgZ3JvdW5kX2x2bCA9IHJvd3MgLSAzOyAvL3RoZSByb3cgdGhhdCBpcyBjb25zaWRlcmVkIGdyb3VuZCBsZXZlbC5cclxuXHRcdHZhciB2Z2FwX21pbiA9IDc7XHJcblx0XHR2YXIgdmdhcF9sZW4gPSAwO1xyXG5cdFx0dmFyIGhnYXBfbWluID0gMTA7XHRcdFx0XHQvL21pbmltdW0gc2l6ZSBvZiBnYXBzIGJldHdlZW4gcGxhdGZvcm1zXHJcblx0XHR2YXIgaGdhcF9sZW4gPSAwOyBcdFx0Ly9jdXJyZW50IG51bWJlciBvZiBjb25zZWN1dGl2ZSBob3Jpem9udGFsIGdhcHNcclxuXHRcdHZhciBwaXRfbWF4ID0gMjA7XHRcdFx0XHQvL21heGltdW0gbGVuIG9mIHBpdHMgaW4gYmxvY2tzXHJcblx0XHR2YXIgcGl0X2xlbiA9IDA7IFx0XHQvL2N1cnJlbnQgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIHBpdHNcclxuXHRcdHZhciBoYXNfcGl0ID0gW107XHJcblx0XHR2YXIgcGl0X2ZyZXF1ZW5jeSA9IDA7IFx0XHQvL2Jhc2UgcGVyY2VudGFnZSBjaGFuY2Ugb2YgYSBwaXQgYmVpbmcgZHVnXHJcblx0XHR2YXIgcGxhdGZvcm1fbGVuX21heCA9IDc7XHQvL21heGltdW0gbGVuIG9mIGEgcGxhdGZvcm1cclxuXHRcdHZhciBwbGF0Zm9ybV9sZW5fbWluID0gMzsgLy9taW5pbXVtIGxlbiBvZiBhIHBsYXRmb3JtXHJcblx0XHR2YXIgcGxhdGZvcm1fbGVuID0gMDsgXHRcdC8vbGVuIG9mIGN1cnJlbnRseSBnZW5lcmF0ZWQgcGxhdGZvcm1cclxuXHRcdHZhciBwbGF0Zm9ybV9jb3VudF9tYXggPSAyOyAvL21heGltdW0gbnVtYmVyIG9mIHBsYXRmb3JtcyBwZXIgY29sdW1uXHJcblx0XHR2YXIgcGxhdGZvcm1fY291bnQgPSBbXTsgXHRcdC8va2VlcHMgdHJhY2sgb2YgcGxhdGZvcm1zIHBlciBjb2x1bW5cclxuXHRcdHZhciBwbGF0Zm9ybV9mcmVxdWVuY3kgPSA1Oy8vYmFzZSBwZXJjZW50YWdlIGNoYW5jZSBvZiBhIHBsYXRmb3JtIHRvIGJlIGdlbmVyYXRlZFxyXG5cdFx0Zm9yKGk9MDsgaTw9Y29sdW1ucztpKyspe1xyXG5cdFx0XHRwbGF0Zm9ybV9jb3VudFtpXSA9IDA7XHJcblx0XHRcdGhhc19waXRbaV0gPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGZvcihpPXJvd3MgLSAxO2k+PTA7aS0tKXsgLy9vdXRlciBsb29wOiBnZW5lcmF0ZSByb3dzIGJvdHRvbSB0byB0b3BcclxuXHRcdFx0c2xpY2UuZ3JpZFtpXSA9IFtdO1xyXG5cdFx0XHRmb3Ioaj0wO2o8Y29sdW1ucztqKyspeyAvL2lubmVyIGxvb3A6IGdlbmVyYXRlIGZyb20gbGVmdCB0byByaWdodCB3aXRoaW4gY3VycmVudCByb3dcclxuXHRcdFx0XHR2YXIgeCA9IHNsaWNlLm9yaWdpbi54ICsgaiAqIHNsaWNlLmNlbGxfdyArIHNsaWNlLmNlbGxfdy8yO1xyXG5cdFx0XHRcdHZhciB5ID0gc2xpY2Uub3JpZ2luLnkgKyBpICogc2xpY2UuY2VsbF93ICsgc2xpY2UuY2VsbF93LzI7XHJcblx0XHRcdFx0aWYgKGkgPj0gZ3JvdW5kX2x2bCl7XHQvL0lmIG9uIG9yIGJlbG93IGdyb3VuZCBsZXZlbCwgR2VuZXJhdGUgR3JvdW5kXHJcblx0XHRcdFx0XHRzbGljZS5ncmlkW2ldW2pdID0gc3Bhd25CbG9jayh4LHksMSk7Ly9jcmVhdGUgYSBncm91bmQgYmxvY2sgKDEgbWVhbnMgZ3JvdW5kKVxyXG5cdFx0XHRcdFx0aWYgKGkgPT0gZ3JvdW5kX2x2bClcclxuXHRcdFx0XHRcdFx0c2xpY2UuZ3JpZFtpXVtqXS5wb3NpdGlvbiA9IFwic3VyZmFjZVwiO1xyXG5cdFx0XHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRcdHNsaWNlLmdyaWRbaV1bal0ucG9zaXRpb24gPSBcInVuZGVyZ3JvdW5kXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRzbGljZS5ncmlkW2ldW2pdID0gc3Bhd25HYXAoeCx5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzbGljZTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBnZW5lcmF0ZV9pbml0aWFsID0gZnVuY3Rpb24oeF9vZmZzZXQpe1xyXG5cdFx0dmFyIHNsaWNlID0gbmV3IFRlcnJhaW5TbGljZU1vZGVsLlNsaWNlKCk7XHJcblx0XHRzbGljZS5vcmlnaW4ueCA9IHhfb2Zmc2V0O1xyXG5cdFx0c2xpY2Uub3JpZ2luLnkgPSAwO1xyXG5cdFx0c2xpY2UgPSBidWlsZFRlcnJhaW5TbGljZV8wMShzbGljZSk7XHJcblx0XHRcclxuXHRcdHJldHVybiBzbGljZTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGdlbmVyYXRlX3JhbmRvbSA9IGZ1bmN0aW9uKHhfb2Zmc2V0LCBzZWVkKXtcclxuXHRcdHZhciBzbGljZSA9IG5ldyBUZXJyYWluU2xpY2VNb2RlbC5TbGljZSgpO1xyXG5cdFx0c2xpY2Uub3JpZ2luLnggPSB4X29mZnNldDtcclxuXHRcdHNsaWNlLm9yaWdpbi55ID0gMDtcclxuXHRcdC8vZ2V0IGEgcmFuZG9tIGtpbmQgb2Ygc2xpY2VcclxuXHRcdGlmIChnZXRSYW5kb21OdW1iZXIoc2VlZCklMTAwIDwgOTUpe1xyXG5cdFx0XHRzbGljZSA9IGJ1aWxkVGVycmFpblNsaWNlXzAwKHNsaWNlLHNlZWQpO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHNsaWNlID0gYnVpbGRUZXJyYWluU2xpY2VfMDEoc2xpY2Usc2VlZCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiBzbGljZTtcclxuXHR9O1xyXG5cdFxyXG5cclxuXHJcblxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblx0XHRnZW5lcmF0ZV9pbml0aWFsOiBnZW5lcmF0ZV9pbml0aWFsLFxyXG5cdFx0Z2VuZXJhdGVfcmFuZG9tOiBnZW5lcmF0ZV9yYW5kb20sXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGVycmFpblNsaWNlQ29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIlRlcnJhaW5TbGljZUNvbnRyb2xsZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkRFRkFVTFRcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG5cclxuIiwidmFyIFRlc3RDb250cm9sbGVyID0gKGZ1bmN0aW9uKCl7XHJcblx0Ly8gcGxhY2Vob2xkZXIgZm9yIGltcGxlbWVudGluZyB0ZXN0aW5nXHJcblx0Ly8gbWF5IGJlIGNoYW5nZWQvcmVtb3ZlZC91cGdyYWRlZCBkZXBlbmRpbmcgb24gaG93IHdlIHdpbGwgaGFuZGxlIG91ciB0ZXN0c1xyXG5cdFxyXG5cdFxyXG5cdHZhciBwcmVpbml0X3Rlc3RzID0gZnVuY3Rpb24oKXtcclxuXHQvL0ZvciB0ZXN0cyByZXF1aXJpbmcgcnVuIGJlZm9yZSBpbml0IGlzIGNhbGxlZFxyXG5cdFxyXG5cdFxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0dmFyIHRlc3QgPSBmdW5jdGlvbigpe1xyXG5cdFx0Ly8gaWYgeW91IG5lZWQgc29tZSBzb3J0IG9mIHRlc3RzIGxhdW5jaGVkLCB0aGlzIGlzIG9uZSBvZiB0aGUgcGxhY2VzIHRvIGRvIGl0XHJcblx0XHRRVW5pdC50ZXN0KCBcImhlbGxvIHRlc3RcIiwgZnVuY3Rpb24oIGFzc2VydCApIHtcclxuXHRcdFx0YXNzZXJ0Lm9rKCAxID09IFwiMVwiLCBcIlBhc3NlZCFcIiApO1xyXG5cdFx0fSk7XHJcblx0XHRJbmNsdWRlcy5hdXRvbWF0ZWRfdGVzdHMoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcG9zdF9sb2FkaW5nX3Rlc3RzID0gZnVuY3Rpb24oKXtcclxuXHRcdC8vIFRPRE86IGNhbGwgd2hlbiBsb2FkaW5nIGFzc2V0cyBpcyBjb21wbGV0ZWQgaWYgdGhlcmUgYXJlIHNvbWUgdGVzdHMgdGhhdCBuZWVkXHJcblx0XHQvLyB0byBiZSBkb25lIGF0IHRoYXQgbW9tZW50LiAoUmVmZXIgdG8gSW5pdENvbnRyb2xsZXIuaW5pdCBhbmQgXHJcblx0XHQvLyBJbml0Q29udHJvbGxlci5zZXR1cF9hc3NldF9kZXBlbmRlbnQgbWV0aG9kc1xyXG5cdH07XHJcblxyXG5cdHZhciB0ZXN0TW9kZTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbihtb2RlKXtcclxuXHRcdGluY2x1ZGUoKTtcclxuXHRcdC8vIFNldHMgdXAgdGhlIGRlYnVnIGNhbnZhcyBkdXJpbmcgdGVzdGluZ1xyXG5cdFx0VGVzdE1vZGVsLmRfY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoQ29uZmlnLkRFQlVHX0NBTlZBU19OQU1FKTtcclxuXHRcdHRlc3RNb2RlID0gbW9kZTtcclxuXHJcblx0XHRpZihtb2RlID09IFwidGVzdFwiKXtcclxuXHRcdFx0VGVzdE1vZGVsLmNvbnRleHQgPSBUZXN0TW9kZWwuZF9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0VGVzdE1vZGVsLmRlYnVnRHJhdyA9IG5ldyBCMmQuYjJEZWJ1Z0RyYXcoKTtcclxuXHRcdFx0VGVzdE1vZGVsLmRlYnVnRHJhdy5TZXRTcHJpdGUoVGVzdE1vZGVsLmNvbnRleHQpO1xyXG5cdFx0XHRUZXN0TW9kZWwuZGVidWdEcmF3LlNldERyYXdTY2FsZShDb25maWcuQjJELlNDQUxFKTtcclxuXHRcdFx0VGVzdE1vZGVsLmRlYnVnRHJhdy5TZXRGaWxsQWxwaGEoMC4zKTtcclxuXHRcdFx0VGVzdE1vZGVsLmRlYnVnRHJhdy5TZXRMaW5lVGhpY2tuZXNzKDEuMCk7XHJcblx0XHRcdFRlc3RNb2RlbC5kZWJ1Z0RyYXcuU2V0RmxhZ3MoQjJkLmIyRGVidWdEcmF3LmVfc2hhcGVCaXQgfCBCMmQuYjJEZWJ1Z0RyYXcuZV9qb2ludEJpdCk7XHJcblxyXG5cdFx0XHRQaHlzaWNzQ29udHJvbGxlci5zZXRfZGVidWdfZHJhdyhUZXN0TW9kZWwuZGVidWdEcmF3KTtcclxuXHJcblx0XHRcdENvbmZpZy5CMkQuZGVidWdfZHJhdyA9IHRydWU7XHJcblx0XHRcdC8vIFNjcmVlbl9XIHdhcyBzZXR1cCBvbmx5IGFmdGVyIHRoaXMgd2FzIGNhbGxlZFxyXG5cclxuXHRcdFx0VGVzdE1vZGVsLmRfY2FudmFzLndpZHRoID0gQ29uZmlnLlNDUkVFTl9XO1xyXG5cdFx0XHRUZXN0TW9kZWwuZF9jYW52YXMuaGVpZ2h0ID0gQ29uZmlnLlNDUkVFTl9IO1xyXG5cclxuXHRcdFx0Ly8kKCcjJytDb25maWcuREVCVUdfQ0FOVkFTX05BTUUpLnNob3coKTtcclxuXHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly9kX2NhbnZhcy5oaWRlKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvL3RoaXMgZnVuY3Rpb24gc2V0cyB0aGUgeCBhbmQgeSBvZmZzZXRzIG9mIHRoZSBkZWJ1ZyBjYW52YXNcclxuXHR2YXIgc2V0X2RlYnVnX29mZnNldCA9IGZ1bmN0aW9uKHhfb2Zmc2V0LCB5X29mZnNldCl7XHJcblx0ICAgIGlmICh0ZXN0TW9kZSA9PSBcInRlc3RcIil7XHJcblx0ICAgICAgICBjb250ZXh0ID0gVGVzdE1vZGVsLmNvbnRleHQ7XHJcblx0ICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuXHQgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIENvbmZpZy5TQ1JFRU5fVywgQ29uZmlnLlNDUkVFTl9IKTtcclxuXHQgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHhfb2Zmc2V0LCB5X29mZnNldCk7XHJcblx0ICAgICAgICBQaHlzaWNzQ29udHJvbGxlci5kcmF3X2RlYnVnKCk7XHJcblx0ICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHRlc3Q6IHRlc3QsXHJcblx0XHRwb3N0X2xvYWRpbmdfdGVzdHM6IHBvc3RfbG9hZGluZ190ZXN0cyxcclxuXHRcdHByZWluaXRfdGVzdHM6IHByZWluaXRfdGVzdHMsXHJcblx0XHRzZXRfZGVidWdfb2Zmc2V0OiBzZXRfZGVidWdfb2Zmc2V0XHJcblx0fVxyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXN0Q29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIlRlc3RDb250cm9sbGVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5ERUZBVUxUXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuXHJcbiIsIlx0XHJcbnZhciBXb3JsZENvbnRyb2xsZXIgPSAoZnVuY3Rpb24oKXtcclxuXHQvKiBhbGwgdGhlIHBoeXNpY3MgY29udHJvbCBvZiB0aGUgd2hvbGUgd29ybGRcclxuXHQqL1xyXG4gICAgdmFyIG1vdmVtZW50X2VkZ2U7XHJcbiAgICB2YXIgc3Bhd25fZW5lbXk7XHJcbiAgICB2YXIgZGlmZmljdWx0eTtcclxuXHRcdHZhciBzZWFzb247XHJcblx0XHR2YXIgbW92ZW1lbnRfZWRnZV9idWZmZXI7XHJcblx0XHR2YXIgYm9keV90ZXN0O1xyXG5cdFx0dmFyIHNjb3JlO1xyXG5cdFx0dmFyIHByb2dyZXNzO1xyXG5cdC8vdmFyIHRlbXAgPSAwO1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSB0aGUgSW5pdENvbnRyb2xsZXIgb25jZSB3aGVuIHRoZSBnYW1lIGlzIGxvYWRlZCAqL1xyXG5cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHNcclxuXHRcdG1vdmVtZW50X2VkZ2VfYnVmZmVyID0gMjA7XHJcblx0XHRtb3ZlbWVudF9lZGdlID0gMDtcclxuXHRcdHNlYXNvbiA9IDA7XHJcblx0XHRzY29yZSA9IDA7XHJcblx0XHRwcm9ncmVzcyA9IDIwO1xyXG5cdFx0Ly9ib2R5X3Rlc3QgPSBuZXcgcGxhdGZvcm0oKTtcclxuXHRcdC8vdmFyIGlkID0gSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChib2R5X3Rlc3QpO1xyXG5cdFx0Ly92YXIgYm9keV90ZXN0ID0gUGh5c2ljc0NvbnRyb2xsZXIuZ2V0X3JlY3Rhbmd1bGFyKHt9LCBib2R5X3Rlc3QpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgdXBkYXRlID0gZnVuY3Rpb24oZGVsdGEpe1xyXG5cdFx0LyogaXMgcmFuIGVhY2ggdGljayBmcm9tIHRoZSBHYW1lQ29udHJvbGxlci51cGRhdGVfYWxsICovXHJcblx0XHRQaHlzaWNzQ29udHJvbGxlci5zdGVwKGRlbHRhKTtcclxuXHJcblx0XHR1cGRhdGVfbW92ZW1lbnRfZWRnZSgpO1xyXG5cdFx0dXBkYXRlX3Byb2dyZXNzKCk7XHJcblxyXG5cdFx0Z2V0X3NwYXduKCk7XHJcblx0XHQvL2lmKHRlbXArKyA9PSAwKXtcclxuXHRcdFx0Ly9UZXJyYWluQ29udHJvbGxlci5OZXdUZXJyYWluU2xpY2UoKTtcclxuXHRcdC8vfVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgdXBkYXRlX3Byb2dyZXNzID0gZnVuY3Rpb24oYXJndW1lbnRzKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBcclxuXHRcdCovXHJcblxyXG5cdFx0cHJvZ3Jlc3MgPSBnZXRfbW92ZW1lbnRfZWRnZSgpO1xyXG5cdFx0XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHR2YXIgdXBkYXRlX21vdmVtZW50X2VkZ2UgPSBmdW5jdGlvbigpe1xyXG5cdFx0dmFyIGhlcm9lcyA9IEVudGl0eUNvbnRyb2xsZXIuZ2V0X2FsbF9oZXJvZXMoKTtcclxuXHRcdHZhciBtaW5feCA9IEluZmluaXR5O1xyXG5cclxuXHRcdGZvcih2YXIgbmV0X2lkIGluIGhlcm9lcyl7XHJcblx0XHRcdC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgY29ubmVjdGVkIGhlcm9lc1xyXG5cdFx0XHQvLyBhbmQgY2hvb3NlIG1pbmltdW0gb2YgdGhlaXIgeCBwb3NpdGlvbnNcclxuXHRcdFx0dmFyIGhlcm9feCA9IGhlcm9lc1tuZXRfaWRdLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54O1xyXG5cdFx0XHRpZihoZXJvX3ggPCBtaW5feCl7XHJcblx0XHRcdFx0bWluX3ggPSBoZXJvX3g7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZigobW92ZW1lbnRfZWRnZSA8IG1pbl94IC0gbW92ZW1lbnRfZWRnZV9idWZmZXIpICYmIG1pbl94ICE9IEluZmluaXR5KXtcclxuXHRcdFx0bW92ZW1lbnRfZWRnZSA9IG1pbl94IC0gbW92ZW1lbnRfZWRnZV9idWZmZXI7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHR2YXIgZ2V0X21vdmVtZW50X2VkZ2UgPSBmdW5jdGlvbigpe1xyXG5cdFx0cmV0dXJuIG1vdmVtZW50X2VkZ2U7XHJcblx0fVxyXG5cclxuXHR2YXIgZ2V0X3NwYXduID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICBkaWZmaWN1bHR5ID0gTWF0aC5mbG9vcihwcm9ncmVzcyAvIDEwMCk7XHJcblxyXG5cdCAgICB2YXIgc3Bhd25fbnVtO1xyXG5cdCAgICBpZiAoc3Bhd25fZW5lbXkpIHtcclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSA7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHNwYXduX251bSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApO1xyXG5cdCAgICAgICAgICAgIC8vIGRlbW9uc3RyYXRpb24gcHVycG9zZXMgZm9yIGh5ZW5hXHJcbiAgICAgICAgICAgICAgICBpZiAoc3Bhd25fbnVtIDw9IDMgKiBkaWZmaWN1bHR5KSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBuZXdfbWVkdXNhID0gRW50aXR5Q29udHJvbGxlci5zcGF3big0MCArIGdldF9tb3ZlbWVudF9lZGdlKCkgKyAyMCAqIE1hdGgucmFuZG9tKCksIDEwLCBcIk1lZHVzYVwiKTtcclxuXHQgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzcGF3bl9udW0gPD0gNyAqIGRpZmZpY3VsdHkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5ld19oeWVuYSA9IEVudGl0eUNvbnRyb2xsZXIuc3Bhd24oNDAgKyBnZXRfbW92ZW1lbnRfZWRnZSgpICsgMjAgKiBNYXRoLnJhbmRvbSgpLCAxMCwgXCJIeWVuYVwiKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgLyogICAgLy8gZGVtb25zdHJhdGlvbiBwdXJwb3NlcyBmb3IgZ3JpZmZpblxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNwYXduX251bSA8PSAxNSAqIEVudGl0eU1vZGVsLmRpZmZpY3VsdHkgJiYgQ291bnQgPiA1KSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBuZXdfZ3JpZmZpbiA9IHNwYXduKDYwICsgV29ybGRDb250cm9sbGVyLmdldF9tb3ZlbWVudF9lZGdlKCkgKyBpLCAtMjAsIFwiR3JpZmZpblwiKTtcclxuXHQgICAgICAgICAgICAgICAgQ291bnQgPSAwO1xyXG5cdCAgICAgICAgICAgIH0qL1xyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNwYXduX251bSA8PSAxNCAqIGRpZmZpY3VsdHkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5ld19jZW50YXVyID0gRW50aXR5Q29udHJvbGxlci5zcGF3big0MCArIGdldF9tb3ZlbWVudF9lZGdlKCkgKyAyMCAqIE1hdGgucmFuZG9tKCksIDEwLCBcIkNlbnRhdXJcIik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNwYXduX251bSA8PSAyNSAqIGRpZmZpY3VsdHkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5ld19ncmlmZmluID0gRW50aXR5Q29udHJvbGxlci5zcGF3big0MCArIGdldF9tb3ZlbWVudF9lZGdlKCkgKyAyMCAqIE1hdGgucmFuZG9tKCksIDEwLCBcIkdyaWZmaW5cIik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIGZvciBhbnRcclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5ld19hbnQgPSBFbnRpdHlDb250cm9sbGVyLnNwYXduKGdldF9tb3ZlbWVudF9lZGdlKCkgKyA0MCArIDIwICogTWF0aC5yYW5kb20oKSwgMTAsIFwiYW50XCIpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHNwYXduX2VuZW15ID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHNwYXduX251bTtcclxuXHR9XHJcblxyXG5cdHZhciBzZXRfc3Bhd24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHNwYXduX2VuZW15ID0gdHJ1ZTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGdldF9zZWFzb24gPSBmdW5jdGlvbigpe1xyXG5cdFx0cmV0dXJuIHNlYXNvbjtcclxuXHR9XHJcblx0XHJcblx0dmFyIHNldF9zZWFzb24gPSBmdW5jdGlvbihpbmRleCl7XHJcblx0XHRzZWFzb24gPSBpbmRleDtcclxuXHR9XHJcblx0XHJcblx0dmFyIE1hcmtBc05ld1RlcnJhaW5TbGljZSA9IGZ1bmN0aW9uKHNsaWNlKXtcclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0dmFyIGdldF9wcm9ncmVzcyA9IGZ1bmN0aW9uKCl7XHJcblx0XHRyZXR1cm4gcHJvZ3Jlc3M7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgaW5jcmVhc2VfcHJvZ3Jlc3MgPSBmdW5jdGlvbihhbW91bnQpe1xyXG5cdFx0cHJvZ3Jlc3MgKz0gYW1vdW50O1xyXG5cdH07XHJcblx0XHJcblx0dmFyIGdldF9zY29yZSA9IGZ1bmN0aW9uKCl7XHJcblx0XHRyZXR1cm4gc2NvcmU7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgaW5jcmVhc2Vfc2NvcmUgPSBmdW5jdGlvbihhbW91bnQpe1xyXG5cdFx0aWYoYW1vdW50ICE9IG51bGwpe1xyXG5cdFx0XHRzY29yZSArPSBhbW91bnQ7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0dGhyb3cgXCJFcnJvcjogPmFtb3VudDwgaXMgbm90IGRlZmluZWRcIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblx0XHRnZXRfbW92ZW1lbnRfZWRnZTogZ2V0X21vdmVtZW50X2VkZ2UsXHJcblx0XHRnZXRfc2Vhc29uOiBnZXRfc2Vhc29uLFxyXG5cdFx0c2V0X3NlYXNvbjogc2V0X3NlYXNvbixcclxuXHRcdGdldF9zcGF3bjogZ2V0X3NwYXduLFxyXG5cdFx0c2V0X3NwYXduOiBzZXRfc3Bhd24sXHJcblx0XHRpbmNyZWFzZV9zY29yZTogaW5jcmVhc2Vfc2NvcmUsXHJcblx0XHRpbmNyZWFzZV9wcm9ncmVzczogaW5jcmVhc2VfcHJvZ3Jlc3MsXHJcblx0XHRnZXRfc2NvcmU6IGdldF9zY29yZSxcclxuXHRcdGdldF9wcm9ncmVzczogZ2V0X3Byb2dyZXNzLFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkQ29udHJvbGxlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIldvcmxkQ29udHJvbGxlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuREVGQVVMVFxyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJ2YXIgR2FtZVV0aWxpdHkgPSAoZnVuY3Rpb24oKVxyXG57XHJcbiAgZnVuY3Rpb24gYXJyb3dfa2V5X3Njcm9sbGluZyhmbGFnKSB7XHJcbiAgICAvLyBDb25maWd1cmVzIGFycm93IGtleSBzY3JvbGxpbmcgZm9yIGNhbnZhc1xyXG4gICAgaWYgKGZsYWcgPT0gZmFsc2UpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7IC8vIC5nZXRFbGVtZW50QnlJZChcImRpc3BsYXlfY2FudmFzXCIpXHJcbiAgICAgICAgYXJyb3dzID0gWzM3LCAzOCwgMzksIDQwXTtcclxuICAgICAgICBpZiAoYXJyb3dzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblx0dmFyIGxnID0gZnVuY3Rpb24oKVxyXG5cdHtcclxuXHRcdC8qXHJcblx0XHQgKiBzaG9ydGN1dCB0byBjb25zb2xlLmxvZygpXHJcblx0XHQgKiBwcmludHMgYWxsIGFyZ3VtZW50cyB0byBjb25zb2xlXHJcblx0XHQgKiBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgbGFiZWwgZm9yIHRoZSByZXN0XHJcblx0XHQgKlxyXG5cdFx0ICogZWFjaCBsYWJlbGVkIGdyb3VwIGlzIGVuY2xvc2VkIGludG8gdGhlIGNvbG9yZWQgZGVsaW1pdGVyc1xyXG5cdFx0ICogPj4+IGFuZCA8PDwgc28gaXQncyBlYXNpbHkgZGlzdGluZ3Vpc2hlZC4gSSBmb3VuZCBpdCBoZWxwZnVsLFxyXG5cdFx0ICogaWYgeW91IGRvbid0IGxldCBtZSBrbm93LCBvciB1c2Ugc29tZXRoaW5nIGVsc2VcclxuXHRcdCAqL1xyXG5cdFx0Y29uc29sZS5sb2coXCIlcyAlYyAlc1wiLCBhcmd1bWVudHNbMF0sIFwiYmFja2dyb3VuZDogI0RBRjJCMVwiLCBcIj4+PlwiKTtcclxuXHRcdFxyXG5cdFx0Zm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuXHRcdHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJcXHRcIiwgYXJndW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdGNvbnNvbGUubG9nKFwiJWM8PDxcIiwgXCJiYWNrZ3JvdW5kOiAjREFGMkIxXCIpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgcmFuZG9tX2Nob2ljZSA9IGZ1bmN0aW9uKHByb2JhYmlsaXRpZXMsIGNob2ljZXMpe1xyXG5cdFx0LypcclxuXHRcdCAgIHRha2VzIDIgYXJyYXlzIHdpdGggZWxlbWVudHMgYXQgY29ycmVzcG9uZGluZyBpbmRleGVzXHJcblx0XHQgICBiZWluZyBjaG9pY2UgYW5kIGl0J3MgcHJvYmFiaWxpdHkuIHBpY2tzIHJhbmRvbSBvbmUuXHJcblx0XHQgICBjaG9pY2VzIGFyZSBhbnl0aGluZywgcHJvYmFiaWxpdHkgaXMgaW50ZWdlciBhLCBzdWNoIHRoYXRcclxuXHRcdCAgIHByb2JhYmlsaXR5IG9mIGEgY2hvaWNlIGlzIGEvMTAuIHdpdGggYSA8IDEwLCBvZiBjb3Vyc2VcclxuXHRcdCAgIGFuZCBwcm9iYWJpbGl0aWVzIGFkZGluZyB1cCB0byAxMC4gXHJcblx0XHQgICBZZXMsIGl0J3Mgbm90IHZlcnkgZ29vZCBpbXBsZW1lbnRhdGlvbiAocmVhZDogdGVycmlibGUpLCBcclxuXHRcdCAgIGFuZCBzaW5jZSB5b3Ugbm90aWNlZCwgbm93IGl0J3MgeW91ciBqb2IgdG8gaW1wcm92ZSBpdC5cclxuXHJcblx0XHQqL1xyXG5cclxuXHRcdC8vIGFycmF5IHdpdGggY2hvaWNlcyBkdXBsaWNhdGVkIGEgcHJvcGVyIGFtb3VudCBvZiB0aW1lcyBiYXNlZCBvblxyXG5cdFx0Ly8gdGhlaXIgcHJvYmFiaWxpdHlcclxuXHRcdHZhciBibGFoID0gW107IFxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjaG9pY2VzLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHByb2JhYmlsaXRpZXNbaV07IGorKyl7XHJcblx0XHRcdFx0YmxhaC5wdXNoKGNob2ljZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJhbmRfaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBibGFoLmxlbmd0aCk7XHJcblxyXG5cdFx0cmV0dXJuIGJsYWhbcmFuZF9pbmRleF07XHJcblx0fTtcclxuXHJcblx0XHJcblx0dmFyIHJlYWRfcXVlcnlfc3RyaW5nID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiByZWFkIHRoZSBxdWVyeSBzdHJpbmcgYW5kIHB1dCBpdCBpbnRvIHRoZSBvYmplY3RcclxuXHRcdCovXHJcblx0ICB2YXIgcXVlcmllcyA9IHt9O1xyXG5cdCAgJC5lYWNoKGRvY3VtZW50LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHIoMSkuc3BsaXQoJyYnKSxmdW5jdGlvbihjLHEpe1xyXG5cdFx0aWYoIShjID09IDAgJiYgcSA9PSBcIlwiKSl7XHJcblx0XHRcdHZhciBpID0gcS5zcGxpdCgnPScpO1xyXG5cdFx0XHRxdWVyaWVzW2lbMF0udG9TdHJpbmcoKV0gPSBpWzFdLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0ICB9KTtcdFxyXG5cclxuXHQgIHJldHVybiBxdWVyaWVzO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRsZzogbGcsXHJcblx0XHRyYW5kb21fY2hvaWNlOiByYW5kb21fY2hvaWNlLFxyXG5cdFx0cmVhZF9xdWVyeV9zdHJpbmc6IHJlYWRfcXVlcnlfc3RyaW5nLFxyXG5cdFx0XHJcblx0fTtcclxuXHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVVdGlsaXR5O1xyXG4iLCJ2YXIgSW5jbHVkZSA9IGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciBtb2R1bGVzO1xyXG5cclxuXHQvLyBzaW1wbGUgZW51bWVyYXRvciAvLyBvcHRpb24gY29kZXMgTVVTVCBiZSBwb3dlciBvZiAyIG9yIHN1bSBvZiBvdGhlciBvcHRpb25zICh3aXRoIDAgYmVpbmcgdGhlIG9ubHkgZXhjZXB0aW9uKSwgYW5kIHVuaXF1ZVxyXG5cdHZhciBjaG9pY2VzID0gKGZ1bmN0aW9uKCl7XHJcblx0XHQvLyBzaW1wbGUgb3B0aW9uczogbnVtYmVyaWMgdmFsdWUgbXVzdCBiZSAwIG9yIHNvbWUgcG93ZXIgb2YgMiwgbmFtZSBzaG91bGQgYmUgYWxsIGNhcHMgYW5kIHVuaXF1ZVxyXG5cdFx0dmFyIHJlc3VsdCA9IHtOT05FOiAwLCBBTExfQ09OVFJPTExFUlM6IDEsIEFMTF9NT0RFTFM6IDIsIE9XTl9NT0RFTDogNCwgT1RIRVJfU1RVRkY6IDgsIFJFTkRFUkVSUzogMTYsIExPR0lDOiAzMn07XHJcblxyXG5cdFx0Ly8gY29tcGxleCBvcHRpb25zOiBzaG91bGQgY29uc2lzdCBvZiBzaW1wbGUgb3B0aW9ucywgYml0d2lzZSghKSBPUidlZCBvciBBTkQnZWQgdG9nZXRoZXIgaW4gYW55IGZhc2hpb25cclxuXHRcdHJlc3VsdC5ERUZBVUxUID0gKHJlc3VsdC5BTExfQ09OVFJPTExFUlMgfCByZXN1bHQuT1dOX01PREVMIHwgcmVzdWx0Lk9USEVSX1NUVUZGKTtcclxuXHRcdHJlc3VsdC5BTEwgPSAgKHJlc3VsdC5BTExfQ09OVFJPTExFUlMgfCByZXN1bHQuQUxMX01PREVMUyB8IHJlc3VsdC5PVEhFUl9TVFVGRik7IFxyXG5cdFx0cmVzdWx0LlJFTkRFUkVSX1NQRUNJRklDID0gKHJlc3VsdC5BTExfQ09OVFJPTExFUlMgfCByZXN1bHQuT1RIRVJfU1RVRkYpO1xyXG5cdFx0cmVzdWx0LkxPR0lDX1NQRUNJRklDID0gKHJlc3VsdC5BTExfQ09OVFJPTExFUlMgfCByZXN1bHQuT1RIRVJfU1RVRkYpO1xyXG5cclxuXHRcdC8vIG9iamVjdCBpcyBpbW11dGFibGVcclxuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XHJcblx0fSkoKTtcclxuXHJcblx0dmFyIG1vZHVsZV9uYW1lcyA9IHtcclxuXHRcdENvbnRyb2xsZXJzOiBbXHJcblx0XHRcdFwiQXNzZXRDb250cm9sbGVyXCIsXHJcblx0XHRcdFwiRW50aXR5Q29udHJvbGxlclwiLFxyXG5cdFx0XHRcIkdhbWVDb250cm9sbGVyXCIsXHJcblx0XHRcdFwiR3JhcGhpY3NDb250cm9sbGVyXCIsXHJcblx0XHRcdFwiSW5pdENvbnRyb2xsZXJcIixcclxuXHRcdFx0XCJLZXlib2FyZENvbnRyb2xsZXJcIixcclxuXHRcdFx0XCJQaHlzaWNzQ29udHJvbGxlclwiLFxyXG5cdFx0XHRcIlRlcnJhaW5Db250cm9sbGVyXCIsXHJcblx0XHRcdFwiVGVycmFpblNsaWNlQ29udHJvbGxlclwiLFxyXG5cdFx0XHRcIlRlc3RDb250cm9sbGVyXCIsXHJcblx0XHRcdFwiV29ybGRDb250cm9sbGVyXCIsXHJcblx0XHRcdFwiSWRlbnRpZmljYXRpb25Db250cm9sbGVyXCIsXHJcblx0XHRcdFwiUmVnaXN0ZXJBc0NvbnRyb2xsZXJcIixcclxuXHRcdFx0XCJOZXR3b3JrQ29udHJvbGxlclwiLFxyXG5cdFx0XHRcIk11bHRpcGxheWVyU3luY0NvbnRyb2xsZXJcIixcclxuXHRcdF0sXHJcblxyXG5cdFx0TW9kZWxzOiBbXHJcblx0XHRcclxuXHRcdFx0XCJBc3NldE1vZGVsXCIsXHJcblx0XHRcdFwiR2FtZU1vZGVsXCIsXHJcblx0XHRcdFwiR3JhcGhpY3NNb2RlbFwiLFxyXG5cdFx0XHRcIktleWJvYXJkTW9kZWxcIixcclxuXHRcdFx0XCJQaHlzaWNzTW9kZWxcIixcclxuXHRcdFx0XCJUZXJyYWluTW9kZWxcIixcclxuXHRcdFx0XCJUZXJyYWluU2xpY2VNb2RlbFwiLFxyXG5cdFx0XHRcIlRlc3RNb2RlbFwiLFxyXG5cdFx0XHRcIldvcmxkTW9kZWxcIixcclxuXHRcdFx0XCJFbnRpdHlNb2RlbFwiLFxyXG5cdFx0XHRcIlJlZ2lzdGVyQXNNb2RlbFwiLFxyXG5cdFx0XHRcIk5ldHdvcmtNb2RlbFwiLFxyXG5cdFx0XHRcIk11bHRpcGxheWVyU3luY01vZGVsXCIsXHJcblx0XHRdLFxyXG5cclxuXHRcdE90aGVyOiBbXHJcblx0XHRcclxuXHRcdFx0XCJCMmRcIixcclxuXHRcdFx0XCJCb3gyRFwiLFxyXG5cdFx0XHRcIkNvbmZpZ1wiLFxyXG5cdFx0XHRcIkdhbWVVdGlsaXR5XCIsXHJcblx0XHRdLFxyXG5cclxuXHRcdFJlbmRlcmVyczogW1xyXG5cdFx0XHRcIkFudFJlbmRlcmVyXCIsXHJcblx0XHRcdFwiSGVyb1JlbmRlcmVyXCIsXHJcbiAgICAgICAgICAgIFwiTWVkdXNhUmVuZGVyZXJcIixcclxuXHRcdFx0XCJUZXJyYWluQ2VsbFJlbmRlcmVyXCIsXHJcblx0XHRcdFwiR3JpZmZpblJlbmRlcmVyXCIsXHJcbiAgICAgICAgICAgIFwiQ2VudGF1clJlbmRlcmVyXCIsXHJcblx0XHRcdFwiSHllbmFSZW5kZXJlclwiLFxyXG5cdFx0XHRcIlRlcnJhaW5TbGljZVJlbmRlcmVyXCIsXHJcblx0XHRcdFwiQmFja2dyb3VuZFJlbmRlcmVyXCIsXHJcblx0XHRcdFwiSFVEUmVuZGVyZXJcIixcclxuICAgICAgICAgICAgXCJQaXp6YVJlbmRlcmVyXCIsXHJcblx0XHRcdFwiRXN0ZWVtZWRDb21wYW5pb25SZW5kZXJlclwiLFxyXG5cdFx0XSxcclxuXHJcblx0XHRMb2dpYzogW1xyXG5cdFx0XHRcIkFudExvZ2ljXCIsXHJcblx0XHRcdFwiSGVyb0xvZ2ljXCIsXHJcblx0XHRcdFwiR3JpZmZpbkxvZ2ljXCIsXHJcbiAgICAgICAgICAgIFwiQ2VudGF1ckxvZ2ljXCIsXHJcbiAgICAgICAgICAgIFwiTWVkdXNhTG9naWNcIixcclxuXHRcdFx0XCJIeWVuYUxvZ2ljXCIsXHJcblx0XHRcdFwiRXN0ZWVtZWRDb21wYW5pb25Mb2dpY1wiLFxyXG4gICAgICAgICAgICBcIlBpenphTG9naWNcIixcclxuXHRcdF0sXHJcblxyXG5cdH07Ly9lbmQgbW9kdWxlX25hbWVzXHJcblxyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0bW9kdWxlcyA9IHtcclxuXHRcdFx0QXNzZXRDb250cm9sbGVyOiByZXF1aXJlKFwiLi9Db250cm9sbGVycy9Bc3NldENvbnRyb2xsZXIuanNcIiksXHJcblx0XHRcdEdyYXBoaWNzQ29udHJvbGxlcjogcmVxdWlyZShcIi4vQ29udHJvbGxlcnMvR3JhcGhpY3NDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRLZXlib2FyZENvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL0tleWJvYXJkQ29udHJvbGxlci5qc1wiKSxcclxuXHRcdFx0UGh5c2ljc0NvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL1BoeXNpY3NDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRUZXJyYWluQ29udHJvbGxlcjogcmVxdWlyZShcIi4vQ29udHJvbGxlcnMvVGVycmFpbkNvbnRyb2xsZXIuanNcIiksXHJcblx0XHRcdFRlcnJhaW5TbGljZUNvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL1RlcnJhaW5TbGljZUNvbnRyb2xsZXIuanNcIiksXHJcblx0XHRcdFdvcmxkQ29udHJvbGxlcjogcmVxdWlyZShcIi4vQ29udHJvbGxlcnMvV29ybGRDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRJbml0Q29udHJvbGxlcjogcmVxdWlyZShcIi4vQ29udHJvbGxlcnMvSW5pdENvbnRyb2xsZXIuanNcIiksXHJcblx0XHRcdFRlc3RDb250cm9sbGVyOiByZXF1aXJlKFwiLi9Db250cm9sbGVycy9UZXN0Q29udHJvbGxlci5qc1wiKSxcclxuXHRcdFx0R2FtZUNvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL0dhbWVDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRFbnRpdHlDb250cm9sbGVyOiByZXF1aXJlKFwiLi9Db250cm9sbGVycy9FbnRpdHlDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL0lkZW50aWZpY2F0aW9uQ29udHJvbGxlci5qc1wiKSxcclxuXHRcdFx0UmVnaXN0ZXJBc0NvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL1JlZ2lzdGVyQXNDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRcclxuXHRcdFx0TmV0d29ya0NvbnRyb2xsZXI6IHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJzL05ldHdvcmtDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRNdWx0aXBsYXllclN5bmNDb250cm9sbGVyOiByZXF1aXJlKFwiLi9Db250cm9sbGVycy9NdWx0aXBsYXllclN5bmNDb250cm9sbGVyLmpzXCIpLFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTW9kZWxzXHJcblxyXG5cdFx0XHRHYW1lTW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9HYW1lTW9kZWwuanNcIiksXHJcblx0XHRcdFRlcnJhaW5TbGljZU1vZGVsOiByZXF1aXJlKFwiLi9Nb2RlbHMvVGVycmFpblNsaWNlTW9kZWwuanNcIiksXHJcblx0XHRcdEFzc2V0TW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9Bc3NldE1vZGVsLmpzXCIpLFxyXG5cdFx0XHRQaHlzaWNzTW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9QaHlzaWNzTW9kZWwuanNcIiksXHJcblx0XHRcdEdyYXBoaWNzTW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9HcmFwaGljc01vZGVsLmpzXCIpLFxyXG5cdFx0XHRUZXJyYWluTW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9UZXJyYWluTW9kZWwuanNcIiksXHJcblx0XHRcdFdvcmxkTW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9Xb3JsZE1vZGVsLmpzXCIpLFxyXG5cdFx0XHRLZXlib2FyZE1vZGVsOiByZXF1aXJlKFwiLi9Nb2RlbHMvS2V5Ym9hcmRNb2RlbC5qc1wiKSxcclxuXHRcdFx0VGVzdE1vZGVsOiByZXF1aXJlKFwiLi9Nb2RlbHMvVGVzdE1vZGVsLmpzXCIpLFxyXG5cdFx0XHRJZGVudGlmaWNhdGlvbk1vZGVsOiByZXF1aXJlKFwiLi9Nb2RlbHMvSWRlbnRpZmljYXRpb25Nb2RlbC5qc1wiKSxcclxuXHRcdFx0RW50aXR5TW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9FbnRpdHlNb2RlbC5qc1wiKSxcclxuXHRcdFx0UmVnaXN0ZXJBc01vZGVsOiByZXF1aXJlKFwiLi9Nb2RlbHMvUmVnaXN0ZXJBc01vZGVsLmpzXCIpLFxyXG5cdFx0XHROZXR3b3JrTW9kZWw6IHJlcXVpcmUoXCIuL01vZGVscy9OZXR3b3JrTW9kZWwuanNcIiksXHJcblx0XHRcdE11bHRpcGxheWVyU3luY01vZGVsOiByZXF1aXJlKFwiLi9Nb2RlbHMvTXVsdGlwbGF5ZXJTeW5jTW9kZWwuanNcIiksXHJcblx0XHRcdFx0XHRcdFxyXG5cdFx0XHQvLyBPdGhlciBzdHVmZlxyXG5cdFx0XHRcclxuXHRcdFx0Q29uZmlnOiByZXF1aXJlKFwiLi9Db25maWcuanNcIiksXHJcblx0XHRcdEdhbWVVdGlsaXR5OiByZXF1aXJlKFwiLi9HYW1lVXRpbGl0eS5qc1wiKSxcclxuXHRcdFx0QjJkOiByZXF1aXJlKFwiLi9CMmQuanNcIiksXHJcblx0XHRcdEJveDJEOiByZXF1aXJlKFwiYm94MmR3ZWJcIiksXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBSZW5kZXJlcnNcclxuXHRcdFx0XHJcblx0XHRcdEFudFJlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvQW50UmVuZGVyZXIuanNcIiksXHJcblx0XHRcdEdyaWZmaW5SZW5kZXJlcjogcmVxdWlyZShcIi4vUmVuZGVyZXJzL0dyaWZmaW5SZW5kZXJlci5qc1wiKSxcclxuICAgICAgICAgICAgTWVkdXNhUmVuZGVyZXI6IHJlcXVpcmUoXCIuL1JlbmRlcmVycy9NZWR1c2FSZW5kZXJlci5qc1wiKSxcclxuICAgICAgICAgICAgQ2VudGF1clJlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvQ2VudGF1clJlbmRlcmVyLmpzXCIpLFxyXG4gICAgICAgICAgICBIeWVuYVJlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvSHllbmFSZW5kZXJlci5qc1wiKSxcclxuXHRcdFx0SGVyb1JlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvSGVyb1JlbmRlcmVyLmpzXCIpLFxyXG5cdFx0XHRUZXJyYWluQ2VsbFJlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvVGVycmFpbkNlbGxSZW5kZXJlci5qc1wiKSxcclxuXHRcdFx0VGVycmFpblNsaWNlUmVuZGVyZXI6IHJlcXVpcmUoXCIuL1JlbmRlcmVycy9UZXJyYWluU2xpY2VSZW5kZXJlci5qc1wiKSxcclxuXHRcdFx0QmFja2dyb3VuZFJlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvQmFja2dyb3VuZFJlbmRlcmVyLmpzXCIpLFxyXG5cdFx0XHRIVURSZW5kZXJlcjogcmVxdWlyZShcIi4vUmVuZGVyZXJzL0hVRFJlbmRlcmVyLmpzXCIpLFxyXG5cdFx0XHRQaXp6YVJlbmRlcmVyOiByZXF1aXJlKFwiLi9SZW5kZXJlcnMvUGl6emFSZW5kZXJlci5qc1wiKSxcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0RXN0ZWVtZWRDb21wYW5pb25SZW5kZXJlcjogcmVxdWlyZShcIi4vUmVuZGVyZXJzL0VzdGVlbWVkQ29tcGFuaW9uUmVuZGVyZXIuanNcIiksXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBMb2dpY1xyXG5cdFx0XHRBbnRMb2dpYzogcmVxdWlyZShcIi4vTG9naWMvQW50TG9naWMuanNcIiksXHJcblx0XHRcdEdyaWZmaW5Mb2dpYzogcmVxdWlyZShcIi4vTG9naWMvR3JpZmZpbkxvZ2ljLmpzXCIpLFxyXG5cdFx0XHRNZWR1c2FMb2dpYzogcmVxdWlyZShcIi4vTG9naWMvTWVkdXNhTG9naWMuanNcIiksXHJcbiAgICAgICAgICAgIENlbnRhdXJMb2dpYzogcmVxdWlyZShcIi4vTG9naWMvQ2VudGF1ckxvZ2ljLmpzXCIpLFxyXG5cdFx0XHRIeWVuYUxvZ2ljOiByZXF1aXJlKFwiLi9Mb2dpYy9IeWVuYUxvZ2ljLmpzXCIpLFxyXG5cdFx0XHRIZXJvTG9naWM6IHJlcXVpcmUoXCIuL0xvZ2ljL0hlcm9Mb2dpYy5qc1wiKSxcclxuXHRcdFx0RXN0ZWVtZWRDb21wYW5pb25Mb2dpYzogcmVxdWlyZShcIi4vTG9naWMvRXN0ZWVtZWRDb21wYW5pb25Mb2dpYy5qc1wiKSxcclxuXHRcdFx0UGl6emFMb2dpYzogcmVxdWlyZShcIi4vTG9naWMvUGl6emFMb2dpYy5qc1wiKSxcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9OyAvLyBlbmQgaW5pdFxyXG5cclxuXHR2YXIgb3B0aW9uX2lzX3NldCA9IGZ1bmN0aW9uKHdoYXRfbW9kc19zZWxlY3RlZCwgb3B0aW9ucyl7XHJcblx0XHRpZih3aGF0X21vZHNfc2VsZWN0ZWQgPT0gMCAmJiBvcHRpb25zID09IDApe1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdC8vIGJlIG1pbmRmdWwgb2YgYml0d2lzZSBvcGVyYXRvciBhaGVhZFxyXG5cdFx0cmV0dXJuICh3aGF0X21vZHNfc2VsZWN0ZWQgJiBvcHRpb25zKTtcclxuXHR9Oy8vZW5kIG9wdGlvbl9pc19zZXRcclxuXHJcblx0dmFyIGdldF9tb2R1bGUgPSBmdW5jdGlvbihuYW1lKXtcclxuXHRcdC8vIGNhbiBiZSBtb2RpZmllZCB0byB0aHJvdyBvYmplY3QgZXJyb3IgaW5zdGVhZCBvZiBzaW1wbGUgb25lXHJcblx0XHQvLyBpbiB0aGF0IGNhc2UgaXQgbWF5IGNvbnRhaW4gbGlzdCBvZiBkZWZpbmVkIG1vZHVsZXNcclxuXHRcdC8vIG1heSBhbHNvIGJlIG1vZGlmaWVkIHRvIGNoZWNrIHdoZXRoZXIgbW9kdWxlIGlzIG1pc3NpbmcgZnJvbSBcclxuXHRcdC8vIG1vZHVsZV9uYW1lcywgbW9kdWxlcywgb3IgYm90aCwgYW5kIGdpdmUgbW9yZSBhY2N1cmF0ZSBkZXNjcmlwdGlvblxyXG5cdFx0dmFyIG1lc3NhZ2UgPSBcIk1vZHVsZSBcIiArIG5hbWUgKyBcclxuXHRcdFx0XCIgaXMgdW5kZWZpbmVkLiBOb3RlIHRoYXQgeW91IG11c3QgaGFyZGNvZGUgYWxsIG5ldyBtb2R1bGVzXCIgKyBcclxuXHRcdFx0XCIgaW50byB0aGUgSW5jbHVkZXMubW9kdWxlX25hbWVzIEFORCBJbmNsdWRlcy5tb2R1bGVzLlwiXHJcblx0XHRcclxuXHRcdGlmKG1vZHVsZXMpe1xyXG5cdFx0XHRpZihtb2R1bGVzW25hbWVdKXtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlc1tuYW1lXTtcclxuXHRcdFx0fWVsc2UgaWYoY29uc29sZS53YXJuKXsgLy8gY2hlY2sgaWYgY29uc29sZS53YXJuIGlzIGF2YWlsYWJsZVxyXG5cdFx0XHRcdGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0dGhyb3cgbWVzc2FnZTtcclxuXHRcdFx0fVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHRocm93IFwiRXJyb3I6IFlvdSBtdXN0IHJ1biB0aGUgSW5jbHVkZXMuaW5pdCgpIGJlZm9yZSB5b3UgY2FuIHVzZSBhbnkgbW9kdWxlc1wiO1xyXG5cdFx0fVxyXG5cdH07Ly9lbmQgZ2V0X21vZHVsZVxyXG5cdFxyXG5cclxuXHR2YXIgZ2V0X25hbWVzID0gZnVuY3Rpb24oY3VycmVudF9tb2R1bGVfbmFtZSwgb3B0aW9uc19jb2RlKXtcclxuXHRcdHZhciByZXN1bHQgPSB7TW9kZWxzOiBbXSwgQ29udHJvbGxlcnM6IFtdLCBPdGhlcjogW10sIFJlbmRlcmVyczogW10sIExvZ2ljOiBbXSx9O1xyXG5cclxuXHRcdGlmKG9wdGlvbl9pc19zZXQoY2hvaWNlcy5OT05FLCBvcHRpb25zX2NvZGUpKXtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9uX2lzX3NldChjaG9pY2VzLkFMTF9DT05UUk9MTEVSUywgb3B0aW9uc19jb2RlKSl7XHJcblxyXG5cdFx0XHR2YXIgY29udHJvbGxlcl9uYW1lcyA9IG1vZHVsZV9uYW1lcy5Db250cm9sbGVycztcclxuXHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb250cm9sbGVyX25hbWVzLmxlbmd0aDsgaSsrKXtcclxuXHJcblx0XHRcdFx0dmFyIGN0bF9uYW1lID0gY29udHJvbGxlcl9uYW1lc1tpXTtcclxuXHJcblx0XHRcdFx0aWYoY3RsX25hbWUgIT0gY3VycmVudF9tb2R1bGVfbmFtZSl7XHJcblx0XHRcdFx0XHRyZXN1bHQuQ29udHJvbGxlcnMucHVzaChjdGxfbmFtZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25faXNfc2V0KGNob2ljZXMuQUxMX01PREVMUywgb3B0aW9uc19jb2RlKSl7XHJcblx0XHRcdHJlc3VsdC5Nb2RlbHMgPSBtb2R1bGVfbmFtZXMuTW9kZWxzO1xyXG5cdFx0fWVsc2UgaWYob3B0aW9uX2lzX3NldChjaG9pY2VzLk9XTl9NT0RFTCwgb3B0aW9uc19jb2RlKSl7XHJcblx0XHRcdHZhciBvd25fbW9kZWwgPSBjdXJyZW50X21vZHVsZV9uYW1lLnJlcGxhY2UoXCJDb250cm9sbGVyXCIsIFwiTW9kZWxcIik7XHJcblx0XHRcdHJlc3VsdC5Nb2RlbHMucHVzaChvd25fbW9kZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKG9wdGlvbl9pc19zZXQoY2hvaWNlcy5PVEhFUl9TVFVGRiwgb3B0aW9uc19jb2RlKSl7XHJcblx0XHRcdHJlc3VsdC5PdGhlciA9IG1vZHVsZV9uYW1lcy5PdGhlcjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihvcHRpb25faXNfc2V0KGNob2ljZXMuUkVOREVSRVJTLCBvcHRpb25zX2NvZGUpKXtcclxuXHRcdFx0cmVzdWx0LlJlbmRlcmVycyA9IG1vZHVsZV9uYW1lcy5SZW5kZXJlcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYob3B0aW9uX2lzX3NldChjaG9pY2VzLkxPR0lDLCBvcHRpb25zX2NvZGUpKXtcclxuXHRcdFx0cmVzdWx0LkxvZ2ljID0gbW9kdWxlX25hbWVzLkxvZ2ljO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTsvL2VuZCBnZXRfbmFtZXNcclxuXHJcblx0dmFyIHNlY3Rpb25zID0gW1wiTW9kZWxzXCIsIFwiQ29udHJvbGxlcnNcIiwgXCJPdGhlclwiLCBcIlJlbmRlcmVyc1wiLCBcIkxvZ2ljXCJdO1xyXG5cdHZhciBnZXRfbmFtZV9zdGF0ZW1lbnRzID0gZnVuY3Rpb24obmFtZXMpe1xyXG5cdFx0dmFyIHJlc3VsdCA9IFwiXCI7XHJcblx0XHRmb3IodmFyIHNlY3Rpb25faW5kZXggPSAwOyBzZWN0aW9uX2luZGV4IDwgc2VjdGlvbnMubGVuZ3RoOyBzZWN0aW9uX2luZGV4Kyspe1xyXG5cdFx0XHR2YXIgc2VjdGlvbiA9IHNlY3Rpb25zW3NlY3Rpb25faW5kZXhdO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbmFtZXNbc2VjdGlvbl0ubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdHJlc3VsdCArPSAoXCJ2YXIgXCIgKyBuYW1lc1tzZWN0aW9uXVtpXSArIFwiOyBcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHJcblx0fTsvL2VuZCBnZXRfbmFtZV9zdGF0ZW1lbnRzXHJcblxyXG5cdHZhciBnZXRfbW9kdWxlX3N0YXRlbWVudHMgPSBmdW5jdGlvbihuYW1lcyl7XHJcblx0XHR2YXIgcmVzdWx0ID0gXCJcIjtcclxuXHRcdGZvcih2YXIgc2VjdGlvbl9pbmRleCA9IDA7IHNlY3Rpb25faW5kZXggPCBzZWN0aW9ucy5sZW5ndGg7IHNlY3Rpb25faW5kZXgrKyl7XHJcblx0XHRcdHZhciBzZWN0aW9uID0gc2VjdGlvbnNbc2VjdGlvbl9pbmRleF07XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBuYW1lc1tzZWN0aW9uXS5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0cmVzdWx0ICs9IChuYW1lc1tzZWN0aW9uXVtpXSArIFwiID0gSW5jbHVkZXMuZ2V0X21vZHVsZShcXFwiXCIgKyBuYW1lc1tzZWN0aW9uXVtpXSArIFwiXFxcIik7IFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTsvL2VuZCBnZXRfbW9kdWxlX3N0YXRlbWVudHNcclxuXHJcblx0dmFyIGdldF9pbmNsdWRlX2RhdGEgPSBmdW5jdGlvbihwYXJhbXMpe1xyXG5cdFx0dmFyIGN1cnJlbnRfbW9kdWxlID0gcGFyYW1zLmN1cnJlbnRfbW9kdWxlO1xyXG5cdFx0dmFyIGluY2x1ZGVfb3B0aW9ucyA9IHBhcmFtcy5pbmNsdWRlX29wdGlvbnM7XHJcblx0XHR2YXIgbmFtZXMgPSBnZXRfbmFtZXMoY3VycmVudF9tb2R1bGUsIGluY2x1ZGVfb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG5hbWVfc3RhdGVtZW50cyA9IGdldF9uYW1lX3N0YXRlbWVudHMobmFtZXMpO1xyXG5cdFx0dmFyIG1vZHVsZV9zdGF0ZW1lbnRzID0gZ2V0X21vZHVsZV9zdGF0ZW1lbnRzKG5hbWVzKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRpbXBvcnRlZF9tb2R1bGVzOiBuYW1lcyxcclxuXHRcdFx0bmFtZV9zdGF0ZW1lbnRzOiBuYW1lX3N0YXRlbWVudHMsXHJcblx0XHRcdG1vZHVsZV9zdGF0ZW1lbnRzOiBtb2R1bGVfc3RhdGVtZW50cyxcclxuXHRcdH07XHJcblxyXG5cdH07Ly9lbmQgZ2V0X2luY2x1ZGVfZGF0YVxyXG5cclxuXHR2YXIgYXV0b21hdGVkX3Rlc3RzID0gZnVuY3Rpb24oKXtcclxuXHRcdFxyXG5cdFx0UVVuaXQudGVzdChcIm9wdGlvbiBtYXRjaGluZyBmdW5jdGlvblwiLCBmdW5jdGlvbiggYXNzZXJ0KSB7XHJcblxyXG5cdFx0XHQvL0lmIGJvdGggYXJlIG5vbmVcclxuXHRcdFx0YXNzZXJ0LmVxdWFsKG9wdGlvbl9pc19zZXQoY2hvaWNlcy5OT05FLCBjaG9pY2VzLk5PTkUpLCB0cnVlKTtcclxuXHJcblx0XHRcdGFzc2VydC50aHJvd3Mob3B0aW9uX2lzX3NldChjaG9pY2VzLk5PTkUsIC0xKSk7XHJcblxyXG5cdFx0XHQvL0lmIGJvdGggbWF0Y2gsIGl0IHJldHVybnMgdGhlIHZhbHVlIG9mIGNob2ljZXNcclxuXHRcdFx0Ly9JZiB0aGV5IGRvbid0IG1hdGNoLCBpdCByZXR1cm5zIDBcclxuXHRcdFx0XHJcblx0XHRcdC8vTUFUQ0hcclxuXHRcdFx0YXNzZXJ0LmVxdWFsKG9wdGlvbl9pc19zZXQoY2hvaWNlcy5BTExfQ09OVFJPTExFUlMsIGNob2ljZXMuQUxMX0NPTlRST0xMRVJTKSwgMSk7XHJcblx0XHRcdGFzc2VydC5lcXVhbChvcHRpb25faXNfc2V0KGNob2ljZXMuQUxMX01PREVMUywgY2hvaWNlcy5BTExfTU9ERUxTKSwgMik7XHJcblx0XHRcdGFzc2VydC5lcXVhbChvcHRpb25faXNfc2V0KGNob2ljZXMuT1RIRVJfU1RVRkYsIGNob2ljZXMuT1RIRVJfU1RVRkYpLCA4KTtcclxuXHJcblx0XHRcdC8vTWlzbWF0Y2hcclxuXHRcdFx0YXNzZXJ0LmVxdWFsKG9wdGlvbl9pc19zZXQoY2hvaWNlcy5OT05FLCBjaG9pY2VzLkFMTF9DT05UUk9MTEVSUyksIDApO1xyXG5cdFx0XHRhc3NlcnQuZXF1YWwob3B0aW9uX2lzX3NldChjaG9pY2VzLk9USEVSX1NUVUZGLCBjaG9pY2VzLk5PTkUpLCAwKTtcclxuXHRcdFx0YXNzZXJ0LmVxdWFsKG9wdGlvbl9pc19zZXQoY2hvaWNlcy5BTExfTU9ERUxTLCBjaG9pY2VzLkFMTF9DT05UUk9MTEVSUyksIDApO1xyXG5cdFx0XHRhc3NlcnQuZXF1YWwob3B0aW9uX2lzX3NldChjaG9pY2VzLk9XTl9NT0RFTCwgY2hvaWNlcy5BTExfTU9ERUxTKSwgMCk7XHJcblx0XHR9KTsvL2VuZCBvcHRpb24gbWF0Y2hpbmcgdGVzdFxyXG5cdFx0XHJcblx0fTsvL2VuZCBhdXRvbWF0ZWRfdGVzdHNcclxuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRpbml0OiBpbml0LFxyXG5cdFx0bW9kdWxlX25hbWVzOiBtb2R1bGVfbmFtZXMsXHJcblx0XHRnZXRfbW9kdWxlOiBnZXRfbW9kdWxlLFxyXG5cdFx0Z2V0X2luY2x1ZGVfZGF0YTogZ2V0X2luY2x1ZGVfZGF0YSxcclxuXHRcdGNob2ljZXM6IGNob2ljZXMsXHJcblx0XHRhdXRvbWF0ZWRfdGVzdHM6IGF1dG9tYXRlZF90ZXN0c1xyXG5cdH07XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgSW5jbHVkZTtcclxuXHJcbiIsInZhciBBbnRMb2dpYyA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgQW50ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIFdpbGwgYmUgaW5zdGFudGlhdGVkIGZvciBldmVyeSBjcmVhdGVkIGVudGl0eSB0byBob2xkIGFsbCB0aGUgaW5mb3JtYXRpb24gXHJcblx0XHRcdGFib3V0IHRoZSBwaHlzaWNhbCAobm90IGdyYXBoaWNhbCkgc3RhdGUgb2YgdGhlIGVudGl0eSBpbiBxdWVzdGlvbi4gXHJcblx0XHRcdGRlY2xhcmUgdGhlIHByb3BlcnRpZXMgbGlrZSB0aGlzOlxyXG5cdFx0XHR0aGlzLnNvbWVfc3RhdGVfdmFyaWFibGVfaW5pdGlhbF92YWx1ZSA9IDA7XHJcblx0XHRcdGluc3RhbnRpYXRlIChtb3N0IGxpa2VseSBpbiB0aGUgc3Bhd24gZnVuY3Rpb24pIGxpa2UgdGhhdDpcclxuXHRcdFx0dmFyIG5ld19lbnRpdHlfaW5zdGFuY2UgPSBuZXcgQW50KCk7XHJcblx0XHQqL1xyXG5cdFx0dmFyIGVudGl0eSA9IEVudGl0eUNvbnRyb2xsZXIuY3JlYXRlX2Fic3RyYWN0X2VudGl0eSgpO1xyXG5cdFx0XHJcblx0XHRlbnRpdHkuaGVyb19odXJ0X21lID0gZmFsc2U7XHJcblx0XHRlbnRpdHkubWVfaHVydF9oZXJvID0gZmFsc2U7XHJcblx0XHRlbnRpdHkuZGVhdGhfdGljayA9IDA7XHJcblxyXG5cdFx0ZW50aXR5LmhwID0gMztcclxuXHRcdGVudGl0eS5zcGVlZCA9IDM7XHJcblx0XHRlbnRpdHkuZGFtYWdlID0gMTtcclxuXHRcdGVudGl0eS5wb2ludF92YWx1ZSA9IDUwO1xyXG5cclxuXHRcdGVudGl0eS5BSV9zdGF0ZSA9IFwid2Fsa1wiOy8vdXNlIGVudGl0eSB0byBrZWVwIHRyYWNrIG9mIHRoZSBlbmVteSdzIEFJIHN0YXRlXHJcblx0XHRcclxuXHRcdGVudGl0eS5jYW5fYXR0YWNrID0gdHJ1ZTtcclxuXHRcdGVudGl0eS5hbGl2ZWZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5LnVuaHVydGZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5Lm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGVudGl0eS5kaXJlY3Rpb24gPSBmYWxzZTtcclxuXHRcdGVudGl0eS5wb3AgPSA0MDtcclxuXHRcdGVudGl0eS5wb3B1cCA9IDA7XHJcblx0XHRcclxuXHRcdGVudGl0eS5jYW5fbGVhcCA9IHRydWU7XHRcdC8vbGVhcGluZyBlbmFibGVkXHJcblxyXG5cdFx0ZW50aXR5Lm1haW50ZW5hbmNlX2ZyZXF1ZW5jeSA9IDIwOy8vdGlja3MgYmV0d2VlbiByb3V0aW5lIG1haW50ZW5hbmNlIGNoZWNrc1xyXG5cdFx0ZW50aXR5Lm1haW50ZW5hbmNlX3RpbWVyID0gZW50aXR5Lm1haW50ZW5hbmNlX2ZyZXF1ZW5jeTtcclxuXHRcdGVudGl0eS5ibGlua2luZyA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LmJhcmVseV9vYnN0cnVjdGVkID0gZmFsc2U7XHJcblx0XHRlbnRpdHkuY29sbGlzaW9uX2J1ZmZlciA9IDAuMlx0Ly90aGUgcmVnaW9uIG9mIG92ZXJsYXAgYWNjb3VudGVkIGZvciBkdXJpbmcgY29sbGlzaW9uIGNoZWNraW5nXHJcblx0XHRlbnRpdHkucGF0aF9ibG9ja2VkID0gZmFsc2U7XHQvL2lzIGVudGl0eSBkZXByZWNhdGVkPyBzZXQgZHVyaW5nIGNvbGxpc2lvblxyXG5cdFx0ZW50aXR5Lm9ic3RydWN0aW9uX3RvbGVyYW5jZSA9IDI7Ly9ob3cgbWFueSB0aW1lcyB0aGUgaHllbmEgY2FuIGJlIGJsb2NrZWQgYmVmb3JlIGhlIHRha2VzIGFjdGlvblxyXG5cdFx0ZW50aXR5LmJsb2NrZWRfY291bnQgPSAwO1x0XHRcdC8vdHJhY2tzIG51bWJlciBvZiB0aW1lcyBibG9ja2VkIGJldHdlZW4gbWFpbnRlbmFuY2UgY2hlY2tzXHJcblxyXG5cclxuXHRcdHJldHVybiBlbnRpdHk7XHJcblx0fTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogSXMgcnVuIGZyb20gdGhlIEVudGl0eUNvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmcgXHJcblx0XHQgXHR5b3Ugc2hvdWxkIGFzc2lnbiB0eXBlIHRvIHlvdXIgbW9kZWwgaGVyZSB1c2luZyB0aGUgaWRlbnRpZmljYXRpb24gY29udHJvbGxlclxyXG5cdFx0ICovXHJcblx0XHRpbmNsdWRlKCk7IC8vIHNhdGlzZnkgcmVxdWlyZW1lbnRzLCBHT0VTIEZJUlNUXHJcblx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX3R5cGUoQW50LCBcImFudFwiKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgc3Bhd24gPSBmdW5jdGlvbih4LCB5KXtcclxuXHRcdC8qIHNwYXduIGluc3RhbmNlIG9mIHRoaXMgZW50aXR5IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xyXG5cdFx0XHR5b3Ugd2lsbCBoYXZlIHRvIGNyZWF0ZSBuZXcgZW50aXR5IGluc3RhbmNlLCBhc3NpZ24gaXQgaWRcclxuXHRcdFx0dXNpbmcgdGhlIElkZW50aWZpY2F0aW9uQ29udHJvbGxlci5hc3NpZ25faWQoZW50aXR5X2luc3RhbmNlKSxcclxuXHRcdFx0YXNzaWduIGl0IGEgYm9keSB3aGljaCB5b3UgY2FuIGdldCB0aHJvdWdoIFBoeXNpY3NDb250cm9sbGVyXHJcblx0XHRcdGRvIGFueSBvdGhlciBzdHVmZiB5b3Ugd2FudCB0byBkbyBkdXJpbmcgc3Bhd25pbmcsXHJcblx0XHRcdGFuZCBmaW5hbGx5IHlvdSBIQVZFIFRPKCEhISkgcmV0dXJuIHRoZSBpbnN0YW5jZSB5b3UganVzdCBjcmVhdGVkIGZyb20gdGhpcyBmdW5jdGlvblxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgbmV3X2FudCA9IG5ldyBBbnQoKTtcclxuXHRcdG5ld19hbnQudHlwZSA9IFwiYW50XCI7XHJcblx0XHR2YXIgaWQgPSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKG5ld19hbnQpO1xyXG5cclxuXHRcdG5ld19hbnQuYm9keSA9IFBoeXNpY3NDb250cm9sbGVyLmdldF9yZWN0YW5ndWxhcih7eDogeCwgeTogeSwgYm9yZGVyX3NlbnNvcnM6IHRydWV9LCBuZXdfYW50KTtcdFxyXG5cclxuXHRcdHJldHVybiBuZXdfYW50O1xyXG5cclxuXHR9O1xyXG5cclxuICAgIC8vQmVnaW4gQW50IEFJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0dmFyIHRpY2tfQUkgPSBmdW5jdGlvbihhbnQpe1xyXG5cdCAgICAvKiBJcyByYW4gZWFjaCB0aWNrIGZyb20gdGhlIEVudGl0eUNvbnRyb2xsZXIudXBkYXRlIGZvciBldmVyeSByZWdpc3RlcmVkXHJcblx0XHRcdGVudGl0eSBvZiB0aGlzIHR5cGUuIEkgZ2l2ZW4gZW50aXR5X2luc3RhbmNlXHJcblx0XHQqL1xyXG5cclxuXHQgICAgLy9pZiBlbmVteSBpcyBkZWFkLCBkaWVcclxuXHQgICAgLy9pZiAoYW50LmJvZHkuR2V0V29ybGRDZW50ZXIoKS55ID4gMjIgfHwgYW50LmJvZHkuR2V0V29ybGRDZW50ZXIoKS54IDwgQ29uZmlnLlBsYXllci5tb3ZlbWVudF9lZGdlIC0gMSkge1xyXG5cdCAgICAvL0VudGl0eUNvbnRyb2xsZXIuZGVsZXRlX2VudGl0eSgpO1xyXG5cdCAgICAvL2NvbnNvbGUubG9nKFwiZHJvcCBvZiBkZWF0aFwiKTtcclxuXHQgICAgLy99XHJcblx0ICAgIC8vXHJcblx0ICAgIGlmIChhbnQuaHAgPD0gMCkgeyAvL0lmIEFudCBpcyBEZWFkLCBEaWVcclxuXHQgICAgICAgIGFudC5kaWUoKTtcclxuXHRcdFx0XHRpZiAoYW50LmJsaW5raW5nKSB7XHJcblx0XHRcdFx0ICAgIGFudC5ibGlua190aW1lci0tO1xyXG5cdFx0XHRcdCAgICBpZiAoYW50LmJsaW5rX3RpbWVyID09IDApIHtcclxuXHRcdFx0XHQgICAgICAgIGFudC5ibGlua2luZyA9IGZhbHNlO1xyXG5cdFx0XHRcdCAgICB9XHJcblx0XHRcdFx0fVxyXG5cdCAgICB9IGVsc2UgeyAvLyBocCA+IDFcclxuXHJcblx0ICAgICAgICBhbnQuY2hhbmdlX2FuaW1hdGlvbihcIndhbGtcIik7XHJcblxyXG5cdCAgICAgICAgLy9NYWludGVuYW5jZS4uLi5cclxuXHQgICAgICAgIGFudC5kaXJlY3Rpb25fcHJldmlvdXMgPSBhbnQuZGlyZWN0aW9uO1x0XHRcdFx0Ly9yZW1lbWJlciBkaXJlY3Rpb24gYXQgc3RhcnQgb2YgdGlja1xyXG5cdCAgICAgICAgYW50LnhfcHJldmlvdXMgPSBhbnQuYm9keS5HZXRXb3JsZENlbnRlcigpLng7IC8vcmVtZW1iZXIgeCBhdCBzdGFydCBvZiB0aWNrXHJcblx0XHRcdFxyXG5cdCAgICAgICAgLy9kbyBtYWludGVuYW5jZVxyXG5cdCAgICAgICAgLy9hbnQuZGlyZWN0aW9uX3ByZXZpb3VzID0gYW50LmRpcmVjdGlvbjtcclxuXHQgICAgICAgIC8vYW50LnhfcHJldmlvdXMgPSBhbnQuYm9keS5HZXRXb3JsZENlbnRlcigpLnhcclxuXHQgICAgICAgIC8vaWYgYmxvY2tlZCwgdHVybiBhcm91bmRcclxuXHQgICAgICAgIC8vaWYgKCghYW50LnBhdGhfZnJlZSgpIHx8IGFudC54cHJldmlvdXMgPT0gYW50LmJvZHkuR2V0V29ybGRDZW50ZXIoKS54KSAmJiAhYW50LmluX2FpcigpKSB7XHJcblx0ICAgICAgICAvLyAgICBhbnQuZGlyZWN0aW9uID0gIWFudC5kaXJlY3Rpb247XHJcblx0ICAgICAgICAvL31cclxuXHRcdFx0XHJcblx0ICAgICAgICBpZiAoYW50LmFuaW1hdGlvbiA9PSBcIndhbGtcIikgeyAvL01vdmUgZm9yd2FyZFxyXG5cdCAgICAgICAgICAgIGFudC5tb3ZlKGFudC5zcGVlZCk7XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgLy9SdW4gTWFpbiBBSSBTY3JpcHQuLi4uLlxyXG5cdCAgICAgICAgaWYgKCFhbnQuaW5fYWlyKCkgfHwgYW50LmJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS55ID09IDApIHsgLy9pZiBvbiBncm91bmQgT1IgaWYgd2Ugc3VzcGVjdCBoZSdzIHN0dWNrIG9uIGEgY29ybmVyXHJcblx0ICAgICAgICAgICAgaWYgKGFudC5lbmVteV9pbl9yYW5nZShhbnQuc2lnaHRfcmFuZ2UpKSB7IC8vaWYgZW5lbXkgbmVhcmJ5XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoYW50LmhpdF90YWtlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYW50LmNoYW5nZV9hbmltYXRpb24oXCJ1cHNpZGVfZG93blwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGFudC50YWtlX2RhbWFnZSgpO1xyXG5cdFx0XHRcdFx0XHRhbnQuYmxpbmtpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICgoYW50LnBhdGhfYmxvY2tlZCkgJiYgYW50LmNhbl9sZWFwICYmIGFudC5sZWFwX2Nvb2xkb3duX3RpbWVyIDw9IDApIHsgLy9pZiAgcGF0aCBpcyBibG9ja2VkLCBhbmQgbGVhcGluZyBpcyBlbmFibGVkLCBsZWFwXHJcblx0ICAgICAgICAgICAgICAgICAgICBhbnQuZGlyZWN0aW9uID0gYW50LmRpcmVjdGlvbl9uZWFyZXN0X2VuZW15KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWFwKGFudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBhbnQuY2FuX2xlYXAgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGFudC5sZWFwX2Nvb2xkb3duX3RpbWVyID0gYW50LmxlYXBfY29vbGRvd247XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFudC5pbl9haXIoKSkgeyAvL2lmIGh5ZW5hIGlzbid0IGNvd2VyaW5nIG9yIGluIHRoZSBhaXIsIGZhY2UgdGhlIGVuZW15XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYW50LmRpcmVjdGlvbiA9IGFudC5kaXJlY3Rpb25fbmVhcmVzdF9lbmVteSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgLy9jaGVjayBwZXJpb2RpY2FsbHkgdG8gZW5zdXJlIHRoZSBhbnQgaXMgbm90IHN0dWNrIGFuZCBvdGhlciByb3V0aW5lIG1haW50ZW5hbmNlXHJcbiAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBhbnQubWFpbnRlbmFuY2VfdGltZXItLTtcclxuXHQgICAgICAgICAgICBpZiAoYW50Lm1haW50ZW5hbmNlX3RpbWVyID09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgYW50Lmp1bXAoMCwgLTIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoYW50LnBhdGhfZnJlZSgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBhbnQucGF0aF9ibG9ja2VkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGFudC5ibG9ja2VkX2NvdW50ID4gYW50Lm9ic3RydWN0aW9uX3RvbGVyYW5jZSkge1x0Ly95b3Uga25vdyBoZSdzIHN0dWNrIG5vd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFudC5jYW5fbGVhcCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFudC5wYXRoX2Jsb2NrZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlYXAoYW50KTtcdC8vYXR0ZW1wdCB0byBnZXQgb3V0IG9mIGphbSBvciBzdHVja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFudC5wYXRoX2Jsb2NrZWQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBhbnQuYmxvY2tlZF9jb3VudCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgIGFudC5tYWludGVuYW5jZV90aW1lciA9IGFudC5tYWludGVuYW5jZV9mcmVxdWVuY3k7IC8vcmVzZXQgY2hlY2sgdGltZXJcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIC8vaWYgKGFudC5ocCA9PSAxKSB7XHJcblx0ICAgICAgICAgICAgLy8gICAgYW50LnBvcHVwKys7XHJcblx0ICAgICAgICAgICAgLy8gICAgaWYgKGFudC5wb3B1cCA9PSBhbnQucG9wKSB7XHJcblx0ICAgICAgICAgICAgLy8gICAgICAgIGFudC5qdW1wKDEwLCAtMjApO1xyXG5cdCAgICAgICAgICAgIC8vICAgICAgICBhbnQuaHArKztcclxuXHQgICAgICAgICAgICAvLyAgICAgICAgYW50LnBvcHVwID0gMDtcclxuXHQgICAgICAgICAgICAvLyAgICAgICAgYW50LmNhbl9hdHRhY2sgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIC8vICAgICAgICBhbnQudW5odXJ0ZmxhZyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgLy8gICAgICAgIGFudC5jaGFuZ2VfYW5pbWF0aW9uKFwid2Fsa1wiKTtcclxuXHQgICAgICAgICAgICAvLyAgICB9XHJcblx0ICAgICAgICAgICAgLy99XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuICAgIC8vRW5kIEFudCBBSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy9IZWxwZXIgRnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHR2YXIgbGVhcCA9IGZ1bmN0aW9uIChhbnQpIHtcclxuXHQgICAgaWYgKGFudC5wYXRoX2Jsb2NrZWQpIHsvL2p1bXAgb3V0IG9mIGEgaG9sZSBvciBvdmVyIGEgd2FsbFxyXG5cdCAgICAgICAgYW50Lmp1bXAoLTEwICsgKDIwICogYW50LmRpcmVjdGlvbiksIC0xICogYW50Lmp1bXBfZm9yY2UpO1xyXG5cdCAgICB9IGVsc2UgeyAvL2xlYXAgdmljaW91c2x5IGF0IGhlcm9cclxuXHQgICAgICAgIGFudC5qdW1wKCgyICogYW50Lmp1bXBfZm9yY2UgKiBhbnQuZGlyZWN0aW9uKSAtIGFudC5qdW1wX2ZvcmNlLCAtMSAqIGFudC5qdW1wX2ZvcmNlIC8gMik7XHJcblx0ICAgIH1cclxuXHQgICAgYW50LmNhbl9sZWFwID0gZmFsc2U7XHJcblx0fTtcclxuXHJcblxyXG5cclxuXHQvL0NvbGxpc2lvbiBIYW5kbGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0dmFyIGJlZ2luX2NvbnRhY3QgPSBmdW5jdGlvbiAoY29udGFjdCwgaW5mbykge1xyXG5cdCAgICAvL2hhbmRsZSBjb2xsaXNpb25zIGhlcmVcclxuXHQgICAgaWYgKChpbmZvLk1lLmZpeHR1cmVfbmFtZSA9PSBcInJpZ2h0XCIgfHwgaW5mby5NZS5maXh0dXJlX25hbWUgPT0gXCJsZWZ0XCIpICYmIGluZm8uVGhlbS50eXBlICE9IFwicGl6emFcIikge1xyXG5cdCAgICAgICAgaW5mby5NZS5lbnRpdHkuZGlyZWN0aW9uID0gIWluZm8uTWUuZW50aXR5LmRpcmVjdGlvbjtcclxuXHQgICAgICAgIGNvbnNvbGUubG9nKCdoaXQnKTtcclxuXHQgICAgICAgIGlmIChpbmZvLlRoZW0uZW50aXR5LnBvaW50X3ZhbHVlID4gMCkge1xyXG5cdCAgICAgICAgICAgIGluZm8uTWUuZW50aXR5LmRpcmVjdGlvbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSk7XHJcblx0ICAgICAgICAgICAgaW5mby5UaGVtLmVudGl0eS5kaXJlY3Rpb24gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaW5mby5UaGVtLnR5cGUgPT0gXCJoZXJvXCIpIHtcclxuXHQgICAgICAgIGlmIChpbmZvLlRoZW0uZml4dHVyZV9uYW1lICE9IFwiYm90dG9tXCIgJiYgaW5mby5NZS5lbnRpdHkuY2FuX2F0dGFjaykge1xyXG5cdCAgICAgICAgICAgIGluZm8uTWUuZW50aXR5Lm1lX2h1cnRfaGVybyA9IHRydWU7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGluZm8uTWUuZW50aXR5LmhpdF90YWtlbiA9IHRydWU7Ly90YWtlIGRhbWFnZSBpZiBlbmVteSBjb2xsaWRlcyBmcm9tIGFib3ZlIGFuZCBkaXN0YW5jZSA8IHZ1bG5lcmFiaWxpdHkgcmFkaXVzXHJcblx0ICAgICAgICAgICAgaW5mby5NZS5lbnRpdHkuZGFtYWdlX3Rha2VuID0gaW5mby5UaGVtLmVudGl0eS5kYW1hZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuXHR2YXIgZW5kX2NvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0LCBpbmZvKSB7XHJcblx0XHJcblx0fTtcclxuXHJcblx0XHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHNwYXduOiBzcGF3bixcclxuXHRcdHRpY2tfQUk6IHRpY2tfQUksXHJcblx0XHRiZWdpbl9jb250YWN0OiBiZWdpbl9jb250YWN0LFxyXG5cdFx0ZW5kX2NvbnRhY3Q6IGVuZF9jb250YWN0LFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFudExvZ2ljO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiQW50TG9naWNcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkxPR0lDX1NQRUNJRklDXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuIiwidmFyIENlbnRhdXJMb2dpYyA9IChmdW5jdGlvbigpe1xyXG4gICBcclxuXHR2YXIgQ2VudGF1ciA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBXaWxsIGJlIGluc3RhbnRpYXRlZCBmb3IgZXZlcnkgY3JlYXRlZCBlbnRpdHkgdG8gaG9sZCBhbGwgdGhlIGluZm9ybWF0aW9uIFxyXG5cdFx0XHRhYm91dCB0aGUgcGh5c2ljYWwgKG5vdCBncmFwaGljYWwpIHN0YXRlIG9mIHRoZSBlbnRpdHkgaW4gcXVlc3Rpb24uIFxyXG5cdFx0XHRkZWNsYXJlIHRoZSBwcm9wZXJ0aWVzIGxpa2UgZW50aXR5OlxyXG5cdFx0XHRlbnRpdHkuc29tZV9zdGF0ZV92YXJpYWJsZV9pbml0aWFsX3ZhbHVlID0gMDtcclxuXHRcdFx0aW5zdGFudGlhdGUgKG1vc3QgbGlrZWx5IGluIHRoZSBzcGF3biBmdW5jdGlvbikgbGlrZSB0aGF0OlxyXG5cdFx0XHR2YXIgbmV3X2VudGl0eV9pbnN0YW5jZSA9IG5ldyBDZW50YXVyKCk7XHJcblx0XHQqL1xyXG5cdFx0dmFyIGVudGl0eSA9IEVudGl0eUNvbnRyb2xsZXIuY3JlYXRlX2Fic3RyYWN0X2VudGl0eSgpO1xyXG5cdFx0XHJcblx0XHRlbnRpdHkuaGVyb19odXJ0X21lID0gZmFsc2U7XHJcblx0XHRlbnRpdHkubWVfaHVydF9oZXJvID0gZmFsc2U7XHJcblx0XHRlbnRpdHkuZGVhdGhfdGljayA9IDA7XHJcblxyXG5cdFx0Ly9zZXQgeW91ciBnYW1lIGxvZ2ljIHBhcmFtZXRlcnMgaGVyZVxyXG5cdFx0Ly9lbnRpdHkub2JqZWN0X2lkID0gMTsgLy9oYXJkY29kZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIG5ldyBlbmVteSBjbGFzc1xyXG5cdFx0ZW50aXR5LmhwID0gNDtcclxuXHRcdGVudGl0eS5zcGVlZCA9IDQ7XHJcblx0XHRlbnRpdHkuZGFtYWdlID0gMTI7XHJcblx0XHRlbnRpdHkucG9pbnRfdmFsdWUgPSAxMDA7XHJcblx0XHQvL2VudGl0eS5hdHRhY2tfY29vbGRvd24gPSA0OyAvL3VzZSBlbnRpdHkgZm9yIGVuZW1pZXMgd2hvIG5lZWRcclxuXHRcdGVudGl0eS5jYW5fYXR0YWNrID0gdHJ1ZTsvL3VzZSBlbnRpdHkgZm9yIGVuZW1pZXMgd2hvIGFsdGVybmF0ZSBiZXR3ZWVuIFxyXG5cdFx0Ly9lbnRpdHkuY29vbGRvd25fdGltZXI9LTE7XHJcblx0XHRlbnRpdHkuQUlfc3RhdGUgPSBcIndhbGtcIjsvL3VzZSBlbnRpdHkgdG8ga2VlcCB0cmFjayBvZiB0aGUgZW5lbXkncyBBSSBzdGF0ZVxyXG5cclxuXHRcdGVudGl0eS5jYW5fYXR0YWNrID0gdHJ1ZTtcclxuXHRcdGVudGl0eS5hbGl2ZWZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5LnVuaHVydGZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5Lm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGVudGl0eS5tYWludGVuYW5jZV9mcmVxdWVuY3kgPSAyMDsvL3RpY2tzIGJldHdlZW4gcm91dGluZSBtYWludGVuYW5jZSBjaGVja3NcclxuXHRcdGVudGl0eS5tYWludGVuYW5jZV90aW1lciA9IGVudGl0eS5tYWludGVuYW5jZV9mcmVxdWVuY3k7XHJcblxyXG5cdFx0ZW50aXR5LmRpcmVjdGlvbiA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LmpvbHRfZm9yY2UgPSAxMDA7XHJcblxyXG5cdFx0ZW50aXR5LmJsaW5raW5nID0gZmFsc2U7XHJcblx0XHRlbnRpdHkuYmxpbmtfdGltZXIgPSAtMTtcclxuXHRcdGVudGl0eS5ibGlua19kdXJhdGlvbiA9IDIwOy8vaG93IGxvbmcgdGhlIGVudGl0eSBibGlua3MgYWZ0ZXIgdGFraW5nIGRhbWFnZVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gZW50aXR5O1xyXG5cdH07XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIElzIHJhbiBmcm9tIHRoZSBFbnRpdHlDb250cm9sbGVyLmluaXQgb25jZSBkdXJpbmcgZ2FtZSBsb2FkaW5nIFxyXG5cdFx0IFx0eW91IHNob3VsZCBhc3NpZ24gdHlwZSB0byB5b3VyIG1vZGVsIGhlcmUgdXNpbmcgdGhlIGlkZW50aWZpY2F0aW9uIGNvbnRyb2xsZXJcclxuXHRcdCAqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl90eXBlKENlbnRhdXIsIFwiQ2VudGF1clwiKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgc3Bhd24gPSBmdW5jdGlvbih4LCB5KXtcclxuXHRcdC8qIHNwYXduIGluc3RhbmNlIG9mIHRoaXMgZW50aXR5IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xyXG5cdFx0XHR5b3Ugd2lsbCBoYXZlIHRvIGNyZWF0ZSBuZXcgZW50aXR5IGluc3RhbmNlLCBhc3NpZ24gaXQgaWRcclxuXHRcdFx0dXNpbmcgdGhlIElkZW50aWZpY2F0aW9uQ29udHJvbGxlci5hc3NpZ25faWQoZW50aXR5X2luc3RhbmNlKSxcclxuXHRcdFx0YXNzaWduIGl0IGEgYm9keSB3aGljaCB5b3UgY2FuIGdldCB0aHJvdWdoIFBoeXNpY3NDb250cm9sbGVyXHJcblx0XHRcdGRvIGFueSBvdGhlciBzdHVmZiB5b3Ugd2FudCB0byBkbyBkdXJpbmcgc3Bhd25pbmcsXHJcblx0XHRcdGFuZCBmaW5hbGx5IHlvdSBIQVZFIFRPKCEhISkgcmV0dXJuIHRoZSBpbnN0YW5jZSB5b3UganVzdCBjcmVhdGVkIGZyb20gdGhpcyBmdW5jdGlvblxyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgbmV3X0NlbnRhdXIgPSBuZXcgQ2VudGF1cigpO1xyXG5cdFx0bmV3X0NlbnRhdXIudHlwZSA9IFwiQ2VudGF1clwiO1xyXG5cdFx0dmFyIGlkID0gSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChuZXdfQ2VudGF1cik7XHJcblxyXG5cdFx0bmV3X0NlbnRhdXIuYm9keSA9IFBoeXNpY3NDb250cm9sbGVyLmdldF9yZWN0YW5ndWxhcih7eDogeCwgeTogeSwgYm9yZGVyX3NlbnNvcnM6IHRydWV9LCBuZXdfQ2VudGF1cik7XHRcclxuXHJcblx0XHRyZXR1cm4gbmV3X0NlbnRhdXI7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciB0aWNrX0FJID0gZnVuY3Rpb24oQ2VudGF1cil7XHJcblx0XHQvKiBJcyByYW4gZWFjaCB0aWNrIGZyb20gdGhlIEVudGl0eUNvbnRyb2xsZXIudXBkYXRlIGZvciBldmVyeSByZWdpc3RlcmVkXHJcblx0XHRcdGVudGl0eSBvZiB0aGlzIHR5cGUuIEkgZ2l2ZW4gZW50aXR5X2luc3RhbmNlXHJcblx0XHQqL1xyXG5cclxuXHRcdC8vaWYgZGVhZCwgZGllXHJcblx0XHRpZiAoQ2VudGF1ci5ocCA8PSAwKSB7XHJcblx0XHRcdENlbnRhdXIuZGllKCk7XHJcblx0XHR9ZWxzZXsgLy8gQ2VudGF1ci5ocCA+PSAxXHJcblx0XHRcdFx0Q2VudGF1ci5jaGFuZ2VfYW5pbWF0aW9uKFwid2Fsa1wiKTtcclxuXHRcdFx0XHJcblx0XHRcdFx0aWYgKENlbnRhdXIuYmxpbmtpbmcpIHtcclxuXHRcdFx0XHQgICAgQ2VudGF1ci5ibGlua190aW1lci0tO1xyXG5cdFx0XHRcdCAgICBpZiAoQ2VudGF1ci5ibGlua190aW1lciA9PSAwKSB7XHJcblx0XHRcdFx0ICAgICAgICBDZW50YXVyLmJsaW5raW5nID0gZmFsc2U7XHJcblx0XHRcdFx0ICAgIH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoQ2VudGF1ci5hbmltYXRpb24gPT0gXCJ3YWxrXCIpe1xyXG5cdFx0XHRcdENlbnRhdXIubW92ZShDZW50YXVyLnNwZWVkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoQ2VudGF1ci5hbmltYXRpb24gPT0gXCJqb2x0XCIpe1xyXG5cdFx0XHQgICAgQ2VudGF1ci5qdW1wKCgyICogQ2VudGF1ci5qb2x0X2ZvcmNlICogQ2VudGF1ci5kaXJlY3Rpb24pIC0gQ2VudGF1ci5qb2x0X2ZvcmNlLCBDZW50YXVyLmpvbHRfZm9yY2UvMik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKENlbnRhdXIuaGl0X3Rha2VuKXtcclxuXHRcdFx0XHRDZW50YXVyLnRha2VfZGFtYWdlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdENlbnRhdXIubWFpbnRlbmFuY2VfdGltZXItLTtcclxuXHRcdFx0aWYgKENlbnRhdXIubWFpbnRlbmFuY2VfdGltZXIgPT0gMCkge1xyXG5cdFx0XHQgICAgQ2VudGF1ci5qdW1wKDAsIC0yKTtcclxuXHRcdFx0ICAgIENlbnRhdXIubWFpbnRlbmFuY2VfdGltZXIgPSBDZW50YXVyLm1haW50ZW5hbmNlX2ZyZXF1ZW5jeTsgLy9yZXNldCBjaGVjayB0aW1lclxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gLy8gLy9TZXQgdXAgQ29sbGlzaW9uIGhhbmRsZXJcclxuXHRcclxuXHRcclxuXHR2YXIgYmVnaW5fY29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QsIGluZm8pe1xyXG5cdCAgICAvL2hhbmRsZSBjb2xsaXNpb25zIGhlcmVcclxuXHJcblx0ICAgIGlmICgoaW5mby5NZS5maXh0dXJlX25hbWUgPT0gXCJyaWdodFwiIHx8IGluZm8uTWUuZml4dHVyZV9uYW1lID09IFwibGVmdFwiKSAmJiBpbmZvLlRoZW0udHlwZSAhPSBcInBpenphXCIpIHtcclxuXHQgICAgICAgIGluZm8uTWUuZW50aXR5LmRpcmVjdGlvbiA9ICFpbmZvLk1lLmVudGl0eS5kaXJlY3Rpb247XHJcblx0ICAgICAgICBjb25zb2xlLmxvZygnaGl0Jyk7XHJcblx0ICAgICAgICBpZiAoaW5mby5UaGVtLmVudGl0eS5wb2ludF92YWx1ZSA+IDApIHtcclxuXHQgICAgICAgICAgICBpbmZvLk1lLmVudGl0eS5kaXJlY3Rpb24gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkpO1xyXG5cdCAgICAgICAgICAgIGluZm8uVGhlbS5lbnRpdHkuZGlyZWN0aW9uID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdFx0XHJcblx0XHRpZihpbmZvLlRoZW0udHlwZSA9PSBcImhlcm9cIil7XHJcblx0XHRcdGlmKGluZm8uVGhlbS5maXh0dXJlX25hbWUgIT0gXCJib3R0b21cIiAmJiBpbmZvLk1lLmVudGl0eS5jYW5fYXR0YWNrKXtcclxuXHRcdFx0XHRpbmZvLk1lLmVudGl0eS5tZV9odXJ0X2hlcm8gPSB0cnVlO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRpbmZvLk1lLmVudGl0eS5oaXRfdGFrZW4gPSB0cnVlOy8vdGFrZSBkYW1hZ2UgaWYgZW5lbXkgY29sbGlkZXMgZnJvbSBhYm92ZSBhbmQgZGlzdGFuY2UgPCB2dWxuZXJhYmlsaXR5IHJhZGl1c1xyXG5cdFx0XHRcdGluZm8uTWUuZW50aXR5LmRhbWFnZV90YWtlbiA9IGluZm8uVGhlbS5lbnRpdHkuZGFtYWdlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIGVuZF9jb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCwgaW5mbyl7XHJcblx0XHJcblx0fTtcclxuXHJcblx0XHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHNwYXduOiBzcGF3bixcclxuXHRcdHRpY2tfQUk6IHRpY2tfQUksXHJcblx0XHRiZWdpbl9jb250YWN0OiBiZWdpbl9jb250YWN0LFxyXG5cdFx0ZW5kX2NvbnRhY3Q6IGVuZF9jb250YWN0LFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENlbnRhdXJMb2dpYztcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkNlbnRhdXJMb2dpY1wiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuTE9HSUNfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fSIsInZhciBFc3RlZW1lZENvbXBhbmlvbkxvZ2ljID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0XHJcblx0dmFyIENvbXBhbmlvbiA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBXaWxsIGJlIGluc3RhbnRpYXRlZCBmb3IgZXZlcnkgY3JlYXRlZCBlbnRpdHkgdG8gaG9sZCBhbGwgdGhlIGluZm9ybWF0aW9uIFxyXG5cdFx0XHRhYm91dCB0aGUgcGh5c2ljYWwgKG5vdCBncmFwaGljYWwpIHN0YXRlIG9mIHRoZSBlbnRpdHkgaW4gcXVlc3Rpb24uIFxyXG5cdFx0XHRkZWNsYXJlIHRoZSBwcm9wZXJ0aWVzIGxpa2UgdGhpczpcclxuXHRcdFx0dGhpcy5zb21lX3N0YXRlX3ZhcmlhYmxlX2luaXRpYWxfdmFsdWUgPSAwO1xyXG5cdFx0XHRpbnN0YW50aWF0ZSAobW9zdCBsaWtlbHkgaW4gdGhlIHNwYXduIGZ1bmN0aW9uKSBsaWtlIHRoYXQ6XHJcblx0XHRcdHZhciBuZXdfZW50aXR5X2luc3RhbmNlID0gbmV3IEVzdGVlbWVkQ29tcGFuaW9uKCk7XHJcblx0XHQqL1xyXG5cdFx0dGhpcy5ocCA9IDEwMDtcclxuXHRcdHRoaXMud291bmQgPSBmYWxzZTtcclxuXHRcdHRoaXMuanVtcHMgPSAwO1xyXG5cdFx0dGhpcy5zY29yZSA9IDA7XHJcblx0fTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogSXMgcmFuIGZyb20gdGhlIEVudGl0eUNvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmcgXHJcblx0XHRcdHlvdSBzaG91bGQgYXNzaWduIHR5cGUgdG8geW91ciBtb2RlbCBoZXJlIHVzaW5nIHRoZSBpZGVudGlmaWNhdGlvbiBjb250cm9sbGVyXHJcblx0XHQqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl90eXBlKENvbXBhbmlvbiwgXCJjb21wYW5pb25cIik7XHJcblx0fTtcclxuXHJcblx0dmFyIHNwYXduID0gZnVuY3Rpb24oeCwgeSl7XHJcblx0XHQvKiBzcGF3biBpbnN0YW5jZSBvZiB0aGlzIGVudGl0eSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXNcclxuXHRcdFx0eW91IHdpbGwgaGF2ZSB0byBjcmVhdGUgbmV3IGVudGl0eSBpbnN0YW5jZSwgYXNzaWduIGl0IGlkXHJcblx0XHRcdHVzaW5nIHRoZSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKGVudGl0eV9pbnN0YW5jZSksXHJcblx0XHRcdGFzc2lnbiBpdCBhIGJvZHkgd2hpY2ggeW91IGNhbiBnZXQgdGhyb3VnaCBQaHlzaWNzQ29udHJvbGxlclxyXG5cdFx0XHRkbyBhbnkgb3RoZXIgc3R1ZmYgeW91IHdhbnQgdG8gZG8gZHVyaW5nIHNwYXduaW5nLFxyXG5cdFx0XHRhbmQgZmluYWxseSB5b3UgSEFWRSBUTyghISEpIHJldHVybiB0aGUgaW5zdGFuY2UgeW91IGp1c3QgY3JlYXRlZCBmcm9tIHRoaXMgZnVuY3Rpb25cclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIGNvbXBhbmlvbiA9IG5ldyBDb21wYW5pb24oKTtcclxuXHJcblx0XHRjb21wYW5pb24uYm9keSA9IFBoeXNpY3NDb250cm9sbGVyLmdldF9yZWN0YW5ndWxhcih7eDogeCwgeTogeSwgYm9yZGVyX3NlbnNvcnM6IHRydWV9LCBjb21wYW5pb24pO1xyXG5cclxuXHRcdC8vdmFyIGlkID0gSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChjb21wYW5pb24pO1xyXG5cclxuXHRcdGNvbXBhbmlvbi5ocCA9IDEwMDtcclxuXHRcdGNvbXBhbmlvbi53b3VuZCA9IGZhbHNlO1xyXG5cdFx0Y29tcGFuaW9uLmp1bXBzID0gMDtcclxuXHRcdGNvbXBhbmlvbi5zY29yZSA9IDA7XHJcblxyXG5cclxuXHRcdHJldHVybiBjb21wYW5pb247XHJcblx0XHJcblx0fTtcclxuXHJcblx0dmFyIHRpY2tfQUkgPSBmdW5jdGlvbihjb21wYW5pb24pe1xyXG5cdFx0LyogSXMgcmFuIGVhY2ggdGljayBmcm9tIHRoZSBFbnRpdHlDb250cm9sbGVyLnVwZGF0ZSBmb3IgZXZlcnkgcmVnaXN0ZXJlZFxyXG5cdFx0XHRlbnRpdHkgb2YgdGhpcyB0eXBlLiBJIGdpdmVuIGVudGl0eV9pbnN0YW5jZVxyXG5cdFx0Ki9cclxuXHJcblx0XHRcclxuXHRcdGNvbnNvbGUud2FybihcInRpY2tpbmcgY29tcGFuaW9uXCIpO1xyXG5cclxuXHRcdFxyXG5cclxuXHRcdHZhciBjbWRzID0gS2V5Ym9hcmRDb250cm9sbGVyLm1vdmVtZW50X2NvbW1hbmRzKCk7XHJcblxyXG5cdFx0dmFyIE1PVkVNRU5UX0VER0UgPSA1MDA7IC8vIHdoZXJlIHRlcnJhaW4gc3RhcnQgc2Nyb2xsaW5nXHJcblxyXG5cclxuXHRcdC8vIFRFTVBPUkFSWVlZWVlZWVlZWVlZWVlZWVxyXG5cclxuXHRcdGlmKGNvbXBhbmlvbi53b3VuZClcclxuXHRcdHtcclxuXHRcdFx0Y29tcGFuaW9uLmhwLS07XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiVGFraW5nIGRhbWFnZVwiKTtcclxuXHRcdFx0R3JhcGhpY3NDb250cm9sbGVyLnVwZGF0ZV9oZWFsdGgoY29tcGFuaW9uLmhwKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYoY29tcGFuaW9uLmhwIDw9IDApXHJcblx0XHR7XHJcblx0XHRcdGNyZWF0ZWpzLlRpY2tlci5wYXVzZWQgPSB0cnVlO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlBsYXllciBJcyBEZWFkXCIpO1xyXG5cdFx0fVxyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnVwZGF0ZV9zY29yZShjb21wYW5pb24uc2NvcmUpO1xyXG5cdH07XHJcblxyXG5cdHZhciBiZWdpbl9jb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCwgaW5mbyl7XHJcblx0XHQvL2NvbnNvbGUubG9nKGluZm8uTWUuaWQsIFwiOlwiLCBcIk15IGZpeHR1cmVcIiwgXCInXCIgKyBpbmZvLk1lLmZpeHR1cmVfbmFtZSArIFwiJ1wiLCBcImNhbWUgaW50byBjb250YWN0IHdpdGggZml4dHVyZVwiLCBcclxuXHRcdFx0Ly9cIidcIiArIGluZm8uVGhlbS5maXh0dXJlX25hbWUgKyBcIidcIiwgXCJvZlwiLCBpbmZvLlRoZW0uaWQpO1xyXG5cdFx0aWYgKGluZm8uTWUuZml4dHVyZV9uYW1lID09IFwiYm90dG9tXCIpe1xyXG5cdFx0XHRpbmZvLk1lLmVudGl0eS5qdW1wcyA9IDA7XHJcblx0XHR9XHJcblx0XHRpZiAoaW5mby5NZS5maXh0dXJlX25hbWUgPT0gXCJ0b3BcIil7XHJcblx0XHRcdHRha2VfaGl0KGluZm8uTWUuZW50aXR5LCAxKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYoaW5mby5NZS5maXh0dXJlX25hbWUgIT0gXCJib3R0b21cIiAmJiBpbmZvLlRoZW0uZW50aXR5LmNhbl9hdHRhY2spXHJcblx0XHR7XHJcblx0XHQgICAgaW5mby5NZS5lbnRpdHkud291bmQgPSB0cnVlO1xyXG5cdFx0ICAgIGFkZF9zY29yZShpbmZvLk1lLmVudGl0eSwgMTAwKTtcclxuXHRcdH1cclxuXHRcdFx0XHRcclxuXHR9O1xyXG5cdFxyXG5cdHZhciBhZGRfc2NvcmUgPSBmdW5jdGlvbiAoY29tcGFuaW9uLCBhbW91bnQpIHtcclxuXHQgICAgY29tcGFuaW9uLnNjb3JlICs9IGFtb3VudDtcclxuXHR9XHJcblx0XHJcblxyXG5cdHZhciB0YWtlX2hpdCA9IGZ1bmN0aW9uKGNvbXBhbmlvbiwgYW1vdW50KXtcclxuXHQgICAgY29tcGFuaW9uLmhwIC09IGFtb3VudDtcclxuXHRcdC8vR3JhcGhpY3NDb250cm9sbGVyLnVwZGF0ZV9oZWFsdGgoY29tcGFuaW9uLmhwKTtcclxuXHR9XHJcblxyXG5cdHZhciBlbmRfY29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QsIGluZm8pe1xyXG5cdFx0XHRcclxuXHRcdGluZm8uTWUuZW50aXR5LndvdW5kID0gZmFsc2U7XHJcblx0fTtcclxuXHJcblx0dmFyIG1vdmVfcmlnaHQgPSBmdW5jdGlvbihjb21wYW5pb24pe1xyXG5cdFx0dmFyIGJvZHkgPSBjb21wYW5pb24uYm9keTtcclxuXHRcdHZhciB2ZWxvY2l0eSA9IGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdHZlbG9jaXR5LnggPSA1O1xyXG5cdFx0Ym9keS5TZXRMaW5lYXJWZWxvY2l0eSh2ZWxvY2l0eSk7IC8vIGJvZHkuU2V0TGluZWFyVmVsb2NpdHkobmV3IGIyVmVjMig1LCAwKSk7IHdvdWxkIHdvcmsgdG9vXHJcblx0XHRib2R5LlNldEF3YWtlKHRydWUpO1xyXG5cdFx0Ly9jb21wYW5pb24ueCArPSAxMDsgLy8gb2xkXHJcblx0XHQvL2NvbXBhbmlvbi54ID0gKGJvZHkuR2V0UG9zaXRpb24oKS54ICsgMS41LzIpICogMzAgOyBcclxuXHR9O1xyXG5cclxuXHR2YXIganVtcCA9IGZ1bmN0aW9uKGNvbXBhbmlvbil7XHJcblx0ICAgIHZhciBib2R5ID0gY29tcGFuaW9uLmJvZHk7XHJcblx0XHRpZiAoY29tcGFuaW9uLmp1bXBzID09IDApe1xyXG5cdFx0ICAgIGJvZHkuQXBwbHlJbXB1bHNlKG5ldyBCMmQuYjJWZWMyKDAsIC0xMDApLCBib2R5LkdldFdvcmxkQ2VudGVyKCkpO1xyXG5cdFx0ICAgIGNvbXBhbmlvbi5qdW1wcyArPSAxO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29tcGFuaW9uLmp1bXBzID09IDEgJiYgYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpLnkgPiAtMSkge1xyXG5cdFx0ICAgIGJvZHkuQXBwbHlJbXB1bHNlKG5ldyBCMmQuYjJWZWMyKDAsIC0xMDApLCBib2R5LkdldFdvcmxkQ2VudGVyKCkpO1xyXG5cdFx0ICAgIGNvbXBhbmlvbi5qdW1wcyArPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29tcGFuaW9uLnkgPSBib2R5LkdldFBvc2l0aW9uKCkueSAqIDMwO1xyXG5cdFxyXG5cdH07XHJcblxyXG5cdHZhciBzZXRfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbihwb3NpdGlvbl92ZWN0b3IsIGNvbXBhbmlvbil7XHJcblx0XHQvLyBUT0RPOiByZW1vdmU7XHJcblx0XHQvLyB0ZW1wb3JhcnkvdGVzdGluZ1xyXG5cdFx0Y29tcGFuaW9uLnggPSAocG9zaXRpb25fdmVjdG9yLnggLSAxLjUvMikgKiAzMCA7XHJcblx0XHRjb21wYW5pb24ueSA9IChwb3NpdGlvbl92ZWN0b3IueSArIDIuNS8yKSAqIDMwIDtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGIyYl9nZXRfY29vcmRpbmF0ZXMgPSBmdW5jdGlvbihjb21wYW5pb24pe1xyXG5cdFx0cmV0dXJuIGNvbXBhbmlvbi5ib2R5LkdldFdvcmxkQ2VudGVyKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIG1vdmVfbGVmdCA9IGZ1bmN0aW9uKGNvbXBhbmlvbil7XHJcblx0XHR2YXIgdmVsb2NpdHkgPSBjb21wYW5pb24uYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpO1xyXG5cdFx0dmVsb2NpdHkueCA9IC01O1xyXG5cdFx0Y29tcGFuaW9uLmJvZHkuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkpOyAvLyBjb21wYW5pb24uU2V0TGluZWFyVmVsb2NpdHkobmV3IGIyVmVjMig1LCAwKSk7IHdvdWxkIHdvcmsgdG9vXHJcblx0XHRjb21wYW5pb24uYm9keS5TZXRBd2FrZSh0cnVlKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgbW92ZV9yaWdodCA9IGZ1bmN0aW9uKGNvbXBhbmlvbil7XHJcblx0XHR2YXIgdmVsb2NpdHkgPSBjb21wYW5pb24uYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpO1xyXG5cdFx0dmVsb2NpdHkueCA9ICs1O1xyXG5cdFx0Y29tcGFuaW9uLmJvZHkuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkpOyAvLyBjb21wYW5pb24uU2V0TGluZWFyVmVsb2NpdHkobmV3IGIyVmVjMig1LCAwKSk7IHdvdWxkIHdvcmsgdG9vXHJcblx0XHRjb21wYW5pb24uYm9keS5TZXRBd2FrZSh0cnVlKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgbW92ZSA9IGZ1bmN0aW9uKG9mZnNldF94LCBvZmZzZXRfeSwgY29tcGFuaW9uKXtcclxuXHRcdC8vIHVuaW1wbGVtZW50ZWRcclxuXHRcdC8vIHNob3VsZCBpdCBoYXJkLXNldCBwb3NpdGlvbiAobm90IHNhZmUhKVxyXG5cdFx0Ly8gb3IganVzdCBhbGxvdyB0byBzZXQgYW55IHZlbG9jaXR5L2ltcHVsc2UgdmVjdG9yP1xyXG5cdH07XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRzcGF3bjogc3Bhd24sXHJcblx0XHR0aWNrX0FJOiB0aWNrX0FJLFxyXG5cdFx0YmVnaW5fY29udGFjdDogYmVnaW5fY29udGFjdCxcclxuXHRcdGVuZF9jb250YWN0OiBlbmRfY29udGFjdCxcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFc3RlZW1lZENvbXBhbmlvbkxvZ2ljO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiRXN0ZWVtZWRDb21wYW5pb25Mb2dpY1wiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuTE9HSUNfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG4iLCJ2YXIgR3JpZmZpbkxvZ2ljID0gKGZ1bmN0aW9uKCl7XHJcbiAgIFxyXG5cdHZhciBHcmlmZmluID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIFdpbGwgYmUgaW5zdGFudGlhdGVkIGZvciBldmVyeSBjcmVhdGVkIGVudGl0eSB0byBob2xkIGFsbCB0aGUgaW5mb3JtYXRpb24gXHJcblx0XHRcdGFib3V0IHRoZSBwaHlzaWNhbCAobm90IGdyYXBoaWNhbCkgc3RhdGUgb2YgdGhlIGVudGl0eSBpbiBxdWVzdGlvbi4gXHJcblx0XHRcdGRlY2xhcmUgdGhlIHByb3BlcnRpZXMgbGlrZSBlbnRpdHk6XHJcblx0XHRcdGVudGl0eS5zb21lX3N0YXRlX3ZhcmlhYmxlX2luaXRpYWxfdmFsdWUgPSAwO1xyXG5cdFx0XHRpbnN0YW50aWF0ZSAobW9zdCBsaWtlbHkgaW4gdGhlIHNwYXduIGZ1bmN0aW9uKSBsaWtlIHRoYXQ6XHJcblx0XHRcdHZhciBuZXdfZW50aXR5X2luc3RhbmNlID0gbmV3IEdyaWZmaW4oKTtcclxuXHRcdCovXHJcblx0XHR2YXIgZW50aXR5ID0gRW50aXR5Q29udHJvbGxlci5jcmVhdGVfYWJzdHJhY3RfZW50aXR5KCk7XHJcblx0XHRcclxuXHRcdGVudGl0eS5oZXJvX2h1cnRfbWUgPSBmYWxzZTtcclxuXHRcdGVudGl0eS5tZV9odXJ0X2hlcm8gPSBmYWxzZTtcclxuXHRcdGVudGl0eS5kZWF0aF90aWNrID0gMDtcclxuXHJcblx0XHQvL3NldCB5b3VyIGdhbWUgbG9naWMgcGFyYW1ldGVycyBoZXJlXHJcblx0XHQvL2VudGl0eS5vYmplY3RfaWQgPSAxOyAvL2hhcmRjb2RlIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggbmV3IGVuZW15IGNsYXNzXHJcblx0XHRlbnRpdHkuaHAgPSAzO1xyXG5cdFx0ZW50aXR5LnNwZWVkID0gNjtcclxuXHRcdGVudGl0eS5kYW1hZ2UgPSAxMDtcclxuXHRcdGVudGl0eS5wb2ludF92YWx1ZSA9IDEwMDtcclxuXHRcdC8vZW50aXR5LmF0dGFja19jb29sZG93biA9IDQ7IC8vdXNlIGVudGl0eSBmb3IgZW5lbWllcyB3aG8gbmVlZFxyXG5cdFx0ZW50aXR5LmNhbl9hdHRhY2sgPSB0cnVlOy8vdXNlIGVudGl0eSBmb3IgZW5lbWllcyB3aG8gYWx0ZXJuYXRlIGJldHdlZW4gXHJcblx0XHQvL2VudGl0eS5jb29sZG93bl90aW1lcj0tMTtcclxuXHRcdGVudGl0eS5BSV9zdGF0ZSA9IFwiZmx5XCI7Ly91c2UgZW50aXR5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGVuZW15J3MgQUkgc3RhdGVcclxuXHRcdGVudGl0eS5hbGl2ZWZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5LnVuaHVydGZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5Lm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGVudGl0eS5tYWludGVuYW5jZV9mcmVxdWVuY3kgPSAyMDsvL3RpY2tzIGJldHdlZW4gcm91dGluZSBtYWludGVuYW5jZSBjaGVja3NcclxuXHRcdGVudGl0eS5tYWludGVuYW5jZV90aW1lciA9IGVudGl0eS5tYWludGVuYW5jZV9mcmVxdWVuY3k7XHJcblxyXG5cdFx0ZW50aXR5LmRpcmVjdGlvbiA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LmZseV9mb3JjZSA9IDEwMDtcclxuXHRcdGVudGl0eS5ibGlua2luZyA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LmJsaW5rX3RpbWVyID0gLTE7XHJcblx0XHRlbnRpdHkuYmxpbmtfZHVyYXRpb24gPSAyMDsvL2hvdyBsb25nIHRoZSBlbnRpdHkgYmxpbmtzIGFmdGVyIHRha2luZyBkYW1hZ2VcclxuXHRcdHJldHVybiBlbnRpdHk7XHJcblx0fTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogSXMgcmFuIGZyb20gdGhlIEVudGl0eUNvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmcgXHJcblx0XHQgXHR5b3Ugc2hvdWxkIGFzc2lnbiB0eXBlIHRvIHlvdXIgbW9kZWwgaGVyZSB1c2luZyB0aGUgaWRlbnRpZmljYXRpb24gY29udHJvbGxlclxyXG5cdFx0ICovXHJcblx0XHRpbmNsdWRlKCk7IC8vIHNhdGlzZnkgcmVxdWlyZW1lbnRzLCBHT0VTIEZJUlNUXHJcblx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX3R5cGUoR3JpZmZpbiwgXCJHcmlmZmluXCIpO1xyXG5cdH07XHJcblxyXG5cdHZhciBzcGF3biA9IGZ1bmN0aW9uKHgsIHkpe1xyXG5cdFx0Lyogc3Bhd24gaW5zdGFuY2Ugb2YgdGhpcyBlbnRpdHkgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXHJcblx0XHRcdHlvdSB3aWxsIGhhdmUgdG8gY3JlYXRlIG5ldyBlbnRpdHkgaW5zdGFuY2UsIGFzc2lnbiBpdCBpZFxyXG5cdFx0XHR1c2luZyB0aGUgSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChlbnRpdHlfaW5zdGFuY2UpLFxyXG5cdFx0XHRhc3NpZ24gaXQgYSBib2R5IHdoaWNoIHlvdSBjYW4gZ2V0IHRocm91Z2ggUGh5c2ljc0NvbnRyb2xsZXJcclxuXHRcdFx0ZG8gYW55IG90aGVyIHN0dWZmIHlvdSB3YW50IHRvIGRvIGR1cmluZyBzcGF3bmluZyxcclxuXHRcdFx0YW5kIGZpbmFsbHkgeW91IEhBVkUgVE8oISEhKSByZXR1cm4gdGhlIGluc3RhbmNlIHlvdSBqdXN0IGNyZWF0ZWQgZnJvbSB0aGlzIGZ1bmN0aW9uXHJcblx0XHQqL1xyXG5cclxuXHRcdHZhciBuZXdfR3JpZmZpbiA9IG5ldyBHcmlmZmluKCk7XHJcblx0XHRuZXdfR3JpZmZpbi50eXBlID0gXCJHcmlmZmluXCI7XHJcblx0XHR2YXIgaWQgPSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKG5ld19HcmlmZmluKTtcclxuXHJcblx0XHRuZXdfR3JpZmZpbi5ib2R5ID0gUGh5c2ljc0NvbnRyb2xsZXIuZ2V0X3JlY3Rhbmd1bGFyKHt4OiB4LCB5OiB5LCBib3JkZXJfc2Vuc29yczogdHJ1ZX0sIG5ld19HcmlmZmluKTtcdFxyXG5cclxuXHRcdHJldHVybiBuZXdfR3JpZmZpbjtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHRpY2tfQUkgPSBmdW5jdGlvbihHcmlmZmluKXtcclxuXHRcdC8qIElzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgRW50aXR5Q29udHJvbGxlci51cGRhdGUgZm9yIGV2ZXJ5IHJlZ2lzdGVyZWRcclxuXHRcdFx0ZW50aXR5IG9mIHRoaXMgdHlwZS4gSSBnaXZlbiBlbnRpdHlfaW5zdGFuY2VcclxuXHRcdCovXHJcblxyXG5cdFx0Ly9pZiBkZWFkLCBkaWVcclxuXHRcdGlmIChHcmlmZmluLmhwIDw9IDApIHtcclxuXHRcdFx0R3JpZmZpbi5kaWUoKTtcclxuXHRcdH1lbHNleyAvLyBHcmlmZmluLmhwID49IDFcclxuXHJcblx0XHQgICAgaWYgKEdyaWZmaW4uYmxpbmtpbmcpIHtcclxuXHRcdCAgICAgICAgR3JpZmZpbi5ibGlua190aW1lci0tO1xyXG5cdFx0ICAgICAgICBpZiAoR3JpZmZpbi5ibGlua190aW1lciA9PSAwKSB7XHJcblx0XHQgICAgICAgICAgICBHcmlmZmluLmJsaW5raW5nID0gZmFsc2U7XHJcblx0XHQgICAgICAgIH1cclxuXHRcdCAgICB9XHJcblxyXG5cdFx0ICAgIGlmIChHcmlmZmluLmluX2FpcigpKSB7XHJcblx0XHRcdFx0R3JpZmZpbi5jaGFuZ2VfYW5pbWF0aW9uKFwiZmx5XCIpO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRHcmlmZmluLmNoYW5nZV9hbmltYXRpb24oXCJ3YWxrXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChHcmlmZmluLmFuaW1hdGlvbiA9PSBcIndhbGtcIil7XHJcblx0XHRcdFx0R3JpZmZpbi5tb3ZlKEdyaWZmaW4uc3BlZWQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChHcmlmZmluLmFuaW1hdGlvbiA9PSBcImZseVwiKXtcclxuXHRcdFx0ICAgIEdyaWZmaW4uanVtcCgoMiAqIEdyaWZmaW4uZmx5X2ZvcmNlICogR3JpZmZpbi5kaXJlY3Rpb24pIC0gR3JpZmZpbi5mbHlfZm9yY2UsIEdyaWZmaW4uZmx5X2ZvcmNlLzIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChHcmlmZmluLmhpdF90YWtlbil7XHJcblx0XHRcdCAgICAgICAgR3JpZmZpbi50YWtlX2RhbWFnZSgpOyAvL2lmIGhpdCwgdGFrZSBkYW1hZ2VcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0R3JpZmZpbi5tYWludGVuYW5jZV90aW1lci0tO1xyXG5cdFx0XHRpZiAoR3JpZmZpbi5tYWludGVuYW5jZV90aW1lciA9PSAwKSB7XHJcblx0XHRcdCAgICBHcmlmZmluLmp1bXAoMCwgLTIpO1xyXG5cdFx0XHQgICAgR3JpZmZpbi5tYWludGVuYW5jZV90aW1lciA9IEdyaWZmaW4ubWFpbnRlbmFuY2VfZnJlcXVlbmN5OyAvL3Jlc2V0IGNoZWNrIHRpbWVyXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyAvLyAvL1NldCB1cCBDb2xsaXNpb24gaGFuZGxlclxyXG5cdFxyXG5cdFxyXG5cdHZhciBiZWdpbl9jb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCwgaW5mbyl7XHJcblx0XHQvL2hhbmRsZSBjb2xsaXNpb25zIGhlcmVcclxuXHRcdFxyXG5cdCAgICBpZiAoKGluZm8uTWUuZml4dHVyZV9uYW1lID09IFwicmlnaHRcIiB8fCBpbmZvLk1lLmZpeHR1cmVfbmFtZSA9PSBcImxlZnRcIikgJiYgaW5mby5UaGVtLnR5cGUgIT0gXCJwaXp6YVwiKSB7XHJcblx0ICAgICAgICBpbmZvLk1lLmVudGl0eS5kaXJlY3Rpb24gPSAhaW5mby5NZS5lbnRpdHkuZGlyZWN0aW9uO1xyXG5cdCAgICAgICAgY29uc29sZS5sb2coJ2hpdCcpO1xyXG5cdCAgICAgICAgaWYgKGluZm8uVGhlbS5lbnRpdHkucG9pbnRfdmFsdWUgPiAwKSB7XHJcblx0ICAgICAgICAgICAgaW5mby5NZS5lbnRpdHkuZGlyZWN0aW9uID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKTtcclxuXHQgICAgICAgICAgICBpbmZvLlRoZW0uZW50aXR5LmRpcmVjdGlvbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0XHRpZihpbmZvLlRoZW0udHlwZSA9PSBcImhlcm9cIil7XHJcblx0XHRcdGlmKGluZm8uVGhlbS5maXh0dXJlX25hbWUgIT0gXCJib3R0b21cIiAmJiBpbmZvLk1lLmVudGl0eS5jYW5fYXR0YWNrKXtcclxuXHRcdFx0XHRpbmZvLk1lLmVudGl0eS5tZV9odXJ0X2hlcm8gPSB0cnVlO1xyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRpbmZvLk1lLmVudGl0eS5oaXRfdGFrZW4gPSB0cnVlOy8vdGFrZSBkYW1hZ2UgaWYgZW5lbXkgY29sbGlkZXMgZnJvbSBhYm92ZSBhbmQgZGlzdGFuY2UgPCB2dWxuZXJhYmlsaXR5IHJhZGl1c1xyXG5cdFx0XHRcdGluZm8uTWUuZW50aXR5LmRhbWFnZV90YWtlbiA9IGluZm8uVGhlbS5lbnRpdHkuZGFtYWdlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIGVuZF9jb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCwgaW5mbyl7XHJcblx0XHJcblx0fTtcclxuXHJcblx0XHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHNwYXduOiBzcGF3bixcclxuXHRcdHRpY2tfQUk6IHRpY2tfQUksXHJcblx0XHRiZWdpbl9jb250YWN0OiBiZWdpbl9jb250YWN0LFxyXG5cdFx0ZW5kX2NvbnRhY3Q6IGVuZF9jb250YWN0LFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWZmaW5Mb2dpYztcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkdyaWZmaW5Mb2dpY1wiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuTE9HSUNfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG4iLCJ2YXIgSGVyb0xvZ2ljID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciBIZXJvID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIFdpbGwgYmUgaW5zdGFudGlhdGVkIGZvciBldmVyeSBjcmVhdGVkIGVudGl0eSB0byBob2xkIGFsbCB0aGUgaW5mb3JtYXRpb24gXHJcblx0XHRcdGFib3V0IHRoZSBwaHlzaWNhbCAobm90IGdyYXBoaWNhbCkgc3RhdGUgb2YgdGhlIGVudGl0eSBpbiBxdWVzdGlvbi4gXHJcblx0XHRcdGRlY2xhcmUgdGhlIHByb3BlcnRpZXMgbGlrZSB0aGlzOlxyXG5cdFx0XHR0aGlzLnNvbWVfc3RhdGVfdmFyaWFibGVfaW5pdGlhbF92YWx1ZSA9IDA7XHJcblx0XHRcdGluc3RhbnRpYXRlIChtb3N0IGxpa2VseSBpbiB0aGUgc3Bhd24gZnVuY3Rpb24pIGxpa2UgdGhhdDpcclxuXHRcdFx0dmFyIG5ld19lbnRpdHlfaW5zdGFuY2UgPSBuZXcgSGVybygpO1xyXG5cdFx0Ki9cclxuXHRcdGVudGl0eSA9IG5ldyBFbnRpdHlDb250cm9sbGVyLmNyZWF0ZV9hYnN0cmFjdF9lbnRpdHkoKTtcclxuXHRcdFxyXG5cdFx0ZW50aXR5LmhwID0gMTAwO1xyXG5cdFx0ZW50aXR5LnNwZWVkID0gODtcclxuXHRcdGVudGl0eS5oaXRfdGFrZW4gPSBmYWxzZTtcclxuXHRcdGVudGl0eS5kYW1hZ2VfdGFrZW4gPSAwO1xyXG5cdFx0ZW50aXR5LmRhbWFnZSA9IDE7XHJcblx0XHRlbnRpdHkuaXNfd2Fsa2luZyA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LnBvaW50X3ZhbHVlID0gMDtcclxuXHRcdFxyXG5cdFx0ZW50aXR5Lmp1bXBzID0gMDtcclxuXHRcdGVudGl0eS5kZWNheV9kdXJhdGlvbiA9IDM1Oy8vdGltZSBiZXR3ZWVuIGRlY2F5IGFuaW1hdGlvbiBhbmQgZGVsZXRpb25cclxuXHRcdGVudGl0eS5kZWF0aF9kdXJhdGlvbiA9IDYwOy8vdGltZSBiZXR3ZWVuIGRlYXRoIGFuZCBkZWxldGlvblxyXG5cdFx0ZW50aXR5Lmp1bXBfdGljaz0wO1xyXG5cclxuXHRcdGVudGl0eS5kaXJlY3Rpb24gPSAxOyAvL2RlZmF1bHQgZGlyZWN0aW9uID0gbGVmdFxyXG5cdFx0XHJcblx0XHRlbnRpdHkubmVlZHNfZ3JhcGhpY3NfdXBkYXRlID0gZmFsc2U7IC8vYWNjZXNzZWQgYnkgcmVuZGVyZXIgZm9yIGFuaW1hdGlvbiBwdXJwb3Nlc1xyXG5cdFx0ZW50aXR5LmFuaW1hdGlvbiA9IFwic3RhbmRcIjsgLy9hY2Nlc3NlZCBieSByZW5kZXJlciBmb3IgYW5pbWF0aW9uIHB1cnBvc2VzXHJcblx0XHRcclxuXHRcdHJldHVybiBlbnRpdHk7XHJcblx0fTtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogSXMgcmFuIGZyb20gdGhlIEVudGl0eUNvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmcgXHJcblx0XHRcdHlvdSBzaG91bGQgYXNzaWduIHR5cGUgdG8geW91ciBtb2RlbCBoZXJlIHVzaW5nIHRoZSBpZGVudGlmaWNhdGlvbiBjb250cm9sbGVyXHJcblx0XHQqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl90eXBlKEhlcm8sIFwiaGVyb1wiKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgc3Bhd24gPSBmdW5jdGlvbih4LCB5KXtcclxuXHRcdC8qIHNwYXduIGluc3RhbmNlIG9mIHRoaXMgZW50aXR5IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xyXG5cdFx0XHR5b3Ugd2lsbCBoYXZlIHRvIGNyZWF0ZSBuZXcgZW50aXR5IGluc3RhbmNlLCBhc3NpZ24gaXQgaWRcclxuXHRcdFx0dXNpbmcgdGhlIElkZW50aWZpY2F0aW9uQ29udHJvbGxlci5hc3NpZ25faWQoZW50aXR5X2luc3RhbmNlKSxcclxuXHRcdFx0YXNzaWduIGl0IGEgYm9keSB3aGljaCB5b3UgY2FuIGdldCB0aHJvdWdoIFBoeXNpY3NDb250cm9sbGVyXHJcblx0XHRcdGRvIGFueSBvdGhlciBzdHVmZiB5b3Ugd2FudCB0byBkbyBkdXJpbmcgc3Bhd25pbmcsXHJcblx0XHRcdGFuZCBmaW5hbGx5IHlvdSBIQVZFIFRPKCEhISkgcmV0dXJuIHRoZSBpbnN0YW5jZSB5b3UganVzdCBjcmVhdGVkIGZyb20gdGhpcyBmdW5jdGlvblxyXG5cdFx0Ki9cclxuXHJcblxyXG5cdFx0dmFyIGhlcm8gPSBuZXcgSGVybygpO1xyXG5cdFx0aGVyby50eXBlID0gXCJoZXJvXCI7XHJcblx0XHRoZXJvLmJvZHkgPSBQaHlzaWNzQ29udHJvbGxlci5nZXRfcmVjdGFuZ3VsYXIoe3g6IHgsIHk6IHksIGJvcmRlcl9zZW5zb3JzOiB0cnVlfSwgaGVybyk7XHJcblxyXG5cdFx0aGVyby5ocCA9IDEwMDtcclxuXHRcdGhlcm8ud291bmQgPSBmYWxzZTtcclxuXHRcdGhlcm8uanVtcHMgPSAwO1xyXG5cdFx0aGVyby5zY29yZSA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIGhlcm87XHJcblx0XHJcblx0fTtcclxuXHJcblx0dmFyIHRpY2tfQUkgPSBmdW5jdGlvbihoZXJvKXtcclxuXHRcdC8qIElzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgRW50aXR5Q29udHJvbGxlci51cGRhdGUgZm9yIGV2ZXJ5IHJlZ2lzdGVyZWRcclxuXHRcdFx0ZW50aXR5IG9mIHRoaXMgdHlwZS4gSSBnaXZlbiBlbnRpdHlfaW5zdGFuY2VcclxuXHRcdCovXHJcblx0XHRpZihoZXJvLnBsYXllcl9pZCA9PSBOZXR3b3JrQ29udHJvbGxlci5nZXRfbmV0d29ya19pZCgpKXtcclxuXHRcdFx0dmFyIGNtZHMgPSBLZXlib2FyZENvbnRyb2xsZXIubW92ZW1lbnRfY29tbWFuZHMoKTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHR2YXIgY21kcyA9IEtleWJvYXJkQ29udHJvbGxlci5nZXRfcmVtb3RlX21vdmVtZW50KGhlcm8ucGxheWVyX2lkKTtcclxuXHRcdH1cclxuXHJcblx0XHRoZXJvLmRpcmVjdGlvbl9wcmV2aW91cyA9IGhlcm8uZGlyZWN0aW9uO1xyXG5cdFx0aGVyby54X3ByZXZpb3VzID0gaGVyby5ib2R5LkdldFdvcmxkQ2VudGVyKCkueDtcclxuXHRcdGhlcm8ueV9wcmV2aW91cyA9IGhlcm8uYm9keS5HZXRXb3JsZENlbnRlcigpLnk7XHJcbiAgICAgICBcclxuXHRcdGlmKGhlcm8uaHAgPD0gMCl7XHJcblx0XHRcdGhlcm8uZGllKCk7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0aGVyby5pc193YWxraW5nID0gZmFsc2U7XHRcclxuXHRcdFx0XHJcblx0XHRcdGlmKGNtZHMoXCJyaWdodFwiKSl7XHJcblx0XHRcdFx0IGlmKGhlcm8uanVtcHM9PTApe1xyXG5cdFx0XHRcdFx0aGVyby5jaGFuZ2VfYW5pbWF0aW9uKFwid2Fsa1wiKTtcclxuXHRcdFx0XHRcdGhlcm8uaXNfd2Fsa2luZyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGhlcm8uZGlyZWN0aW9uID0gdHJ1ZTsvL2RpcmVjdGlvbiA9IHJpZ2h0XHJcblx0XHRcdFx0aGVyby5tb3ZlKGhlcm8uc3BlZWQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZihjbWRzKFwibGVmdFwiKSl7XHJcblx0XHRcdFx0aWYoaGVyby5qdW1wcz09MCl7XHJcblx0XHRcdFx0XHRoZXJvLmNoYW5nZV9hbmltYXRpb24oXCJ3YWxrXCIpO1xyXG5cdFx0XHRcdFx0aGVyby5pc193YWxraW5nID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aGVyby5kaXJlY3Rpb24gPSBmYWxzZTsvL2RpcmVjdGlvbiA9IGxlZnRcclxuXHRcdFx0XHRoZXJvLm1vdmUoaGVyby5zcGVlZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmKGNtZHMoXCJkb3duXCIpKXtcclxuXHRcdFx0XHRzbGFtKGhlcm8pO1xyXG5cdFx0XHRcdHN0b3BfaGVybyhoZXJvKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0aWYoY21kcyhcInVwXCIpKXtcclxuXHRcdFx0XHRqdW1wKGhlcm8pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZighaGVyby5pc193YWxraW5nICYmIGhlcm8uYW5pbWF0aW9uICE9IFwianVtcFwiICYmIGhlcm8uYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpLnkgPT0gMCl7XHJcblx0XHRcdFx0aGVyby5jaGFuZ2VfYW5pbWF0aW9uKFwic3RhbmRcIik7XHJcblx0XHRcdFx0aGVyby5qdW1wX3RpY2sgPSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZihoZXJvLmFuaW1hdGlvbj09XCJqdW1wXCIpe1xyXG5cdFx0XHRcdGlmKGhlcm8uanVtcF90aWNrID09IDEpe1xyXG5cdFx0XHRcdFx0aGVyby5jaGFuZ2VfYW5pbWF0aW9uKFwianVtcFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aGVyby5qdW1wX3RpY2srKztcclxuXHRcdFx0XHRpZihoZXJvLmp1bXBfdGljayA+PSAyMCl7XHJcblx0XHRcdFx0XHRoZXJvLmNoYW5nZV9hbmltYXRpb24oXCJmaW5pc2hcIik7XHJcblx0XHRcdFx0XHRpZihoZXJvLmp1bXBzID09IDApe1xyXG5cdFx0XHRcdFx0XHRoZXJvLmFuaW1hdGlvbiA9IFwiZmluaXNoXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcclxuXHRcdFx0aWYoaGVyby5oaXRfdGFrZW4pe1xyXG5cdFx0XHQgICAgaGVyby50YWtlX2RhbWFnZSgpO1xyXG5cdFx0XHQgICAgLy9jb25zb2xlLmxvZyhcImhvbGQgb25cIik7XHJcblx0XHRcdH1cclxuXHRcdFxyXG5cdFx0XHRpZiAoaGVyby5ib2R5LkdldFdvcmxkQ2VudGVyKCkueCA8IFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpICsgaGVyby5ib2R5LkdldFVzZXJEYXRhKCkuZGVmLndpZHRoLzIpe1xyXG5cdFx0XHRcdHN0b3BfaGVybyhoZXJvKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHR2YXIgYmVnaW5fY29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QsIGluZm8pe1xyXG5cdFx0dmFyIGhlcm8gPSBpbmZvLk1lLmVudGl0eTtcclxuXHRcdHZhciBvdGhlciA9IGluZm8uVGhlbS5lbnRpdHk7XHJcblx0XHRpZiAob3RoZXIudHlwZSA9PSBcInBpenphXCIpIHtcclxuXHRcdCAgICBpZiAoaGVyby5ocCA8PSAxMDArb3RoZXIucmVnZW4pIHtcclxuXHRcdCAgICAgICAgaGVyby5kYW1hZ2VfdGFrZW4gPSBvdGhlci5yZWdlbjtcclxuXHRcdCAgICAgICAgaGVyby5oaXRfdGFrZW4gPSB0cnVlO1xyXG5cdFx0ICAgIH1cclxuXHRcdCAgICBlbHNlIGlmIChoZXJvLmhwICE9IDEwMCkge1xyXG5cdFx0ICAgICAgICBoZXJvLmRhbWFnZV90YWtlbiA9IGhlcm8uaHAgLSAxMDA7XHJcblx0XHQgICAgICAgIGhlcm8uaGl0X3Rha2VuID0gdHJ1ZTtcclxuXHRcdCAgICB9XHJcblx0XHR9XHJcblx0XHRpZiAoaW5mby5NZS5maXh0dXJlX25hbWUgPT0gXCJib3R0b21cIil7XHJcblx0XHRcdGlmKGluZm8uVGhlbS5maXh0dXJlX25hbWUgPT0gXCJ0b3BcIiB8fCBvdGhlci5raW5kID09IDEgfHwgb3RoZXIua2luZCA9PSAyKXtcclxuXHRcdFx0XHRoZXJvLmp1bXBzID0gMDsvL2lmIGNvbGxpZGluZyB3aXRoIHN1cmZhY2UsIHJlc2V0IGp1bXBzXHJcblx0XHRcdH1cclxuXHRcdFx0aWYob3RoZXIua2luZCA9PSAzKXtcclxuXHRcdFx0XHRpZiAoaGVyby5ocCA+IDApe1xyXG5cdFx0XHRcdFx0aGVyby5oaXRfdGFrZW4gPSB0cnVlO1xyXG5cdFx0XHRcdFx0aGVyby5kYW1hZ2VfdGFrZW4gPSBvdGhlci5kYW1hZ2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZihpbmZvLk1lLmZpeHR1cmVfbmFtZSAhPSBcImJvdHRvbVwiICYmIG90aGVyLmNhbl9hdHRhY2spe1xyXG5cdFx0XHRpZihvdGhlci5raW5kID09IG51bGwpe1xyXG5cdFx0XHRcdHZhciBteV9leHRlbnRzID0gaGVyby5nZXRfZml4dHVyZShoZXJvLFwibWFpblwiKS5HZXRBQUJCKCkuR2V0RXh0ZW50cygpO1xyXG5cdFx0XHRcdHZhciBteV9jb29yZGluYXRlcyA9IGhlcm8uYm9keS5HZXRXb3JsZENlbnRlcigpO1xyXG5cdFx0XHRcdHZhciBvdGhlcl9leHRlbnRzID0gaGVyby5nZXRfZml4dHVyZShvdGhlcixcIm1haW5cIikuR2V0QUFCQigpLkdldEV4dGVudHMoKTtcclxuXHRcdFx0XHR2YXIgb3RoZXJfY29vcmRpbmF0ZXMgPSBvdGhlci5ib2R5LkdldFdvcmxkQ2VudGVyKCk7XHJcblx0XHRcdFx0Ly9wcmV2ZW50cyB0YWtpbmcgZGFtYWdlIHdoaWxlIG9uIHRvcCBvZiBlbmVtaWVzXHJcblx0XHRcdFx0aWYgKCEobXlfY29vcmRpbmF0ZXMueSA8PSBvdGhlcl9jb29yZGluYXRlcy55IC0gKG15X2V4dGVudHMueSArIG90aGVyX2V4dGVudHMueSAtIDAuNSkpKSB7XHJcblx0XHRcdFx0XHRpZiAoaGVyby5ocCA+IDApIHtcclxuXHRcdFx0XHRcdFx0aGVyby5oaXRfdGFrZW4gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRoZXJvLmRhbWFnZV90YWtlbiA9IG90aGVyLmRhbWFnZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNley8vaWYgdGhleSdyZSBzcGlrZXMsIHRha2UgZGFtYWdlIG5vIG1hdHRlciB3aGF0XHJcblx0XHRcdFx0aGVyby5oaXRfdGFrZW4gPSB0cnVlO1xyXG5cdFx0XHRcdGhlcm8uZGFtYWdlX3Rha2VuID0gb3RoZXIuZGFtYWdlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIGVuZF9jb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCwgaW5mbyl7XHJcblx0XHRcdFxyXG5cdFx0Ly9pbmZvLk1lLmVudGl0eS5oaXRfdGFrZW4gPSBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHR2YXIgc3RvcF9oZXJvID0gZnVuY3Rpb24gKGhlcm8pIHtcclxuXHRcdC8vdmFyIGJvZHkgPSBoZXJvLmJvZHk7XHJcblx0XHQvL3ZhciB2ZWxvY2l0eSA9IGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdC8vdmVsb2NpdHkueCA9IDA7XHJcblx0XHQvL2JvZHkuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkpOyAvLyBib2R5LlNldExpbmVhclZlbG9jaXR5KG5ldyBiMlZlYzIoNSwgMCkpOyB3b3VsZCB3b3JrIHRvb1xyXG5cdFx0Ly9ib2R5LlNldEF3YWtlKHRydWUpO1xyXG5cclxuXHRcdHZhciBib2R5ID0gaGVyby5ib2R5O1xyXG5cdFx0dmFyIHcgPSBoZXJvLmJvZHkuR2V0VXNlckRhdGEoKS5kZWYud2lkdGgvMjtcclxuXHRcdHZhciBwb3MgPSBuZXcgQjJkLmIyVmVjMihXb3JsZENvbnRyb2xsZXIuZ2V0X21vdmVtZW50X2VkZ2UoKSArIHcsIGJvZHkuR2V0V29ybGRDZW50ZXIoKS55KVxyXG5cdFx0dmFyIHZlbCA9IGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdGlmKHZlbC54IDwgMCB8fCBib2R5LkdldFdvcmxkQ2VudGVyKCkueCA+IHBvcy54KXtcclxuXHRcdFx0dmFyIHZlbCA9IG5ldyBCMmQuYjJWZWMyKDAsIHZlbC55KTtcclxuXHRcdFx0Ym9keS5TZXRMaW5lYXJWZWxvY2l0eSh2ZWwpO1xyXG5cdFx0fVxyXG5cclxuXHQgICAgYm9keS5TZXRBd2FrZSh0cnVlKTtcclxuXHR9XHJcblxyXG5cdHZhciBzbGFtID0gZnVuY3Rpb24oaGVybyl7XHJcblx0ICAgIHZhciBib2R5ID0gaGVyby5ib2R5O1xyXG5cdCAgICBib2R5LkFwcGx5SW1wdWxzZShuZXcgQjJkLmIyVmVjMigwLCAyMCksIGJvZHkuR2V0V29ybGRDZW50ZXIoKSk7XHJcblx0fTtcclxuXHR2YXIgbW92ZV9sZWZ0ID0gZnVuY3Rpb24oaGVybyl7XHJcblx0XHR2YXIgYm9keSA9IGhlcm8uYm9keTtcclxuXHRcdHZhciB2ZWxvY2l0eSA9IGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdHZlbG9jaXR5LnggPSAtNTtcclxuXHRcdGJvZHkuU2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkpOyAvLyBib2R5LlNldExpbmVhclZlbG9jaXR5KG5ldyBiMlZlYzIoNSwgMCkpOyB3b3VsZCB3b3JrIHRvb1xyXG5cdFx0Ym9keS5TZXRBd2FrZSh0cnVlKTtcclxuXHRcdC8vaGVyby54ICs9IDEwOyAvLyBvbGRcclxuXHRcdC8vaGVyby54ID0gKGJvZHkuR2V0UG9zaXRpb24oKS54ICsgMS41LzIpICogMzAgOyBcclxuXHR9O1xyXG5cclxuXHR2YXIganVtcCA9IGZ1bmN0aW9uKGhlcm8pe1xyXG5cdCAgICB2YXIgYm9keSA9IGhlcm8uYm9keTtcclxuXHQgICAgdmFyIHcgPSBoZXJvLmJvZHkuR2V0VXNlckRhdGEoKS5kZWYud2lkdGggLyAyO1xyXG5cdCAgICB2YXIgcG9zID0gbmV3IEIyZC5iMlZlYzIoV29ybGRDb250cm9sbGVyLmdldF9tb3ZlbWVudF9lZGdlKCkgKyB3LCBib2R5LkdldFdvcmxkQ2VudGVyKCkueSlcclxuXHQgICAgdmFyIHZlbCA9IGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdC8vY29uc29sZS5sb2coaGVyby5qdW1wcyk7XHJcblx0XHRpZiAoaGVyby5qdW1wcyA9PSAwKXtcclxuXHRcdFx0aGVyby5jaGFuZ2VfYW5pbWF0aW9uKFwianVtcFwiKTtcclxuXHRcdFx0dmFyIHZlbCA9IG5ldyBCMmQuYjJWZWMyKHZlbC54LCAtMTgpO1xyXG5cdFx0XHRib2R5LlNldExpbmVhclZlbG9jaXR5KHZlbCk7XHJcblx0XHRcdGhlcm8uYm9keS5TZXRBd2FrZSh0cnVlKTtcclxuXHRcdCAgICBoZXJvLmp1bXBzICs9IDE7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChoZXJvLmp1bXBzID09IDEgJiYgYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpLnkgPiAtMSl7XHJcblx0XHRcdGhlcm8uY2hhbmdlX2FuaW1hdGlvbihcImp1bXBcIik7XHJcblx0XHRcdHZhciBtaW5fY2hlY2sgPSB2ZWwueSAtIDE4O1xyXG5cdFx0XHRpZiAobWluX2NoZWNrID4gLTkpe1xyXG5cdFx0XHRcdG1pbl9jaGVjayA9IC05O1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciB2ZWwgPSBuZXcgQjJkLmIyVmVjMih2ZWwueCwgbWluX2NoZWNrKTtcclxuXHRcdFx0Ym9keS5TZXRMaW5lYXJWZWxvY2l0eSh2ZWwpO1xyXG5cdFx0XHRoZXJvLmJvZHkuU2V0QXdha2UodHJ1ZSk7XHJcblx0XHRcdGhlcm8uanVtcHMgKz0gMTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRcclxuXHR2YXIgYjJiX2dldF9jb29yZGluYXRlcyA9IGZ1bmN0aW9uKGhlcm8pe1xyXG5cdFx0cmV0dXJuIGhlcm8uYm9keS5HZXRXb3JsZENlbnRlcigpO1xyXG5cdH07XHJcblxyXG5cdC8vdmFyIG1vdmVfbGVmdCA9IGZ1bmN0aW9uKGhlcm8pe1xyXG5cdFx0Ly92YXIgdmVsb2NpdHkgPSBoZXJvLmJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKTtcclxuXHRcdC8vbW92ZShoZXJvLCB2ZWxvY2l0eS54IC0gNSwgdmVsb2NpdHkueSlcclxuXHJcblx0Ly99O1xyXG5cclxuXHQvL3ZhciBtb3ZlX3JpZ2h0ID0gZnVuY3Rpb24oaGVybyl7XHJcblx0XHQvL3ZhciB2ZWxvY2l0eSA9IGhlcm8uYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpO1xyXG5cdFx0Ly9tb3ZlKGhlcm8sIHZlbG9jaXR5LnggKyA1LCB2ZWxvY2l0eS55KVxyXG5cdC8vfTtcclxuXHJcblx0Ly92YXIgbW92ZSA9IGZ1bmN0aW9uKGhlcm8sIHgsIHkpe1xyXG5cdFx0Ly92YXIgdmVsb2NpdHkgPSBuZXcgQjJkLmIyVmVjMih4LCB5KTtcclxuXHRcdC8vaGVyby5ib2R5LlNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5KTsgLy8gaGVyby5TZXRMaW5lYXJWZWxvY2l0eShuZXcgYjJWZWMyKDUsIDApKTsgd291bGQgd29yayB0b29cclxuXHRcdC8vaGVyby5ib2R5LlNldEF3YWtlKHRydWUpO1xyXG5cdC8vfTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHNwYXduOiBzcGF3bixcclxuXHRcdHRpY2tfQUk6IHRpY2tfQUksXHJcblx0XHRiZWdpbl9jb250YWN0OiBiZWdpbl9jb250YWN0LFxyXG5cdFx0ZW5kX2NvbnRhY3Q6IGVuZF9jb250YWN0LFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhlcm9Mb2dpYztcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkhlcm9Mb2dpY1wiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuTE9HSUNfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG4iLCIvKiBcclxuXHRFbmVteTogSHllbmEgXHJcblx0Y2xhc3MgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlIEh5ZW5hIHR5cGUgZW5lbXlcclxuXHRwdWJsaWMgZnVuY3Rpb25zOlxyXG5cdFx0LWluaXQoKVxyXG5cdFx0XHRpbml0aWFsaXplcyBkZWZhdWx0IGNsYXNzIGRhdGEgZm9yIGFsbCBpbnN0YW5jZXMgb2YgY2xhc3MgSHllbmFcclxuXHRcdC1zcGF3bihpbnQgeCwgaW50IHkpXHJcblx0XHRcdHJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgY2xhc3MgSHllbmEgd2l0aCB1bmlxdWUgaW5zdGFuY2UgSUQgYXQgZ2xvYmFsIGNvb3JkaW5hdGVzKHgseSlcclxuXHRcdC10aWNrX0FJKClcclxuXHRcdFx0cnVucyBoeWVuYSBBSSBzY3JpcHQsIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBpbnN0YW5jZSBvbiBnYW1lIHRpY2tcclxuXHRcdC1iZWdpbl9jb250YWN0KClcclxuXHRcdFx0aGFuZGxlcyBjb2xsaXNpb25zLCBjYWxsZWQgb24gY29sbGlzaW9uIHdpdGggYW55IG9iamVjdFxyXG5cdFx0LWVuZF9jb250YWN0KClcclxuXHRcdFx0Y2FsbGJhY2sgZnVuY3Rpb24gZm9yIGJveDJkXHJcbiovXHJcblxyXG52YXIgSHllbmFMb2dpYyA9IChmdW5jdGlvbigpe1xyXG5cdC8vSW5zdGFudGlhdGVkIGZvciBlYWNoIGluc3RhbmNlIG9mIGh5ZW5hIGF0IGNyZWF0aW9uXHJcblx0Ly9jYWxsIGNvbnN0cnVjdG9yIHRocm91Z2ggd3JhcHBlciBmdW5jdGlvbiBzcGF3bigpXHJcblx0dmFyIEh5ZW5hID0gZnVuY3Rpb24oKXtcclxuXHJcblx0XHR2YXIgZW50aXR5ID0gRW50aXR5Q29udHJvbGxlci5jcmVhdGVfYWJzdHJhY3RfZW50aXR5KCk7XHJcblxyXG5cdFx0Ly9EZWNsYXJlIGluaXRpYWwgdmFyaWFibGVzIGZvciB0aGUgSHllbmFcclxuXHRcclxuXHRcdGVudGl0eS5ocCA9IDI7XHJcblx0XHRlbnRpdHkuc3BlZWQgPSA3O1xyXG5cdFx0ZW50aXR5Lmp1bXBfZm9yY2UgPSAxMjU7XHJcblx0XHRlbnRpdHkuZGFtYWdlID0gNTtcclxuXHRcdGVudGl0eS5wb2ludF92YWx1ZSA9IDIwMDtcclxuXHRcdGVudGl0eS5zaWdodF9yYW5nZSA9IDE2OyAvL2Rpc3RhbmNlIGF0IHdoaWNoIGh5ZW5hIGRldGVjdHMgaGVyb2VzXHJcblx0XHRlbnRpdHkuYXR0YWNrX3JhbmdlID0gODsgLy9kaXN0YW5jZSBhdCB3aGljaCBoeWVuYSBsZWFwcyBhdCB0aGUgaGVyb1xyXG5cdFx0XHJcblx0XHRlbnRpdHkuaGl0X3Rha2VuID0gZmFsc2U7IC8vd2hldGhlciBhIGhpdCBoYXMgYmVlbiB0YWtlbiBzaW5jZSB0aGUgbGFzdCB0aWNrXHJcblx0XHRlbnRpdHkuZGFtYWdlX3Rha2VuID0gMDsgLy90aGUgYW1vdW50IG9mIGRhbWFnZSBpbmZsaWN0ZWQgYnkgaGl0cyBzaW5jZSB0aGUgbGFzdCB0aWNrXHJcblx0XHRcclxuXHRcdGVudGl0eS5kaXJlY3Rpb24gPSBmYWxzZTtcdC8vZmFsc2U9bGVmdCwgdHJ1ZT1yaWdodDtcclxuXHRcdGVudGl0eS5kaXJlY3Rpb25fcHJldmlvdXMgPSBmYWxzZTsvL3N0b3JlIGRpcmVjdGlvbiBmcm9tIGVuZCBvZiBwcmV2aW91cyB0aWNrXHJcblx0XHRlbnRpdHkueF9wcmV2aW91cyA9IDA7XHRcdC8vc3RvcmUgeCB2YWx1ZSBmcm9tIGVuZCBvZiBwcmV2aW91cyB0aWNrXHJcblx0XHRcclxuXHRcdGVudGl0eS5pc19pZGxlID0gdHJ1ZTsgLy9kZXRlcm1pbmVzIHdoZXRoZXIgaHllbmEgaXMgYWdncmVzc2l2ZSBvciBpZGxlXHJcblx0XHRlbnRpdHkuaWRsZV9kdXJhdGlvbiA9IDQwOyAvLyB0aW1lIGJ1ZmZlciBiZXR3ZWVuIGNoYW5naW5nIGlkbGUgc3RhdGVzXHJcblx0XHRlbnRpdHkuaWRsZV90aW1lciA9IGVudGl0eS5pZGxlX2R1cmF0aW9uO1xyXG5cdFx0ZW50aXR5LmlkbGVfY291bnRlciA9IDA7IC8vdXNlZCB0byBtYW5hZ2UgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaHllbmEgaGFzIGNoYW5nZWQgc3RhdGUgd2hpbGUgaWRsZVxyXG5cdFx0ZW50aXR5LmlzX2FsaXZlID0gdHJ1ZTsgLy9kaXNhYmxlcyBhdHRhY2tpbmcgYW5kIHBsYXlzIGRlYXRoIGFuaW1hdGlvbiB3aGlsZSBmYWxzZVxyXG5cdFx0ZW50aXR5LmRlYXRoX2R1cmF0aW9uID0gMzA7Ly90aW1lIGJldHdlZW4gZGVhdGggYW5kIGRlbGV0aW9uXHJcblx0XHRlbnRpdHkuZGVjYXlfZHVyYXRpb24gPSAyMDsvL3RpbWUgYmV0d2VlbiBkZWNheSBhbmltYXRpb24gYW5kIGRlbGV0aW9uXHJcblx0XHRlbnRpdHkuZGVhdGhfdGltZXIgPSAtMTtcclxuXHRcdGVudGl0eS5ydW5uaW5nX2F3YXkgPSBmYWxzZTsgLy93aGV0aGVyIHRoZSBoeWVuYSBpcyBydW5uaW5nIGF3YXlcclxuXHRcdGVudGl0eS5ydW5fYXdheV9kdXJhdGlvbiA9IDMwOyAvL3NldCBjb3dhcmRpY2UgbGV2ZWxcclxuXHRcdGVudGl0eS5ydW5fYXdheV90aW1lciA9IC0xO1xyXG5cdFx0ZW50aXR5LmNhbl9hdHRhY2sgPSB0cnVlO1x0Ly93aGV0aGVyIGF0dGFja2luZyBpcyBlbmFibGVkXHJcblx0XHRlbnRpdHkuYXR0YWNrX2Nvb2xkb3duID0gMTA7IC8vYXR0YWNrIGNvb2xkb3duXHJcblx0XHRlbnRpdHkuYXR0YWNrX2Nvb2xkb3duX3RpbWVyID0gLTE7XHJcblx0XHRlbnRpdHkuY2FuX2xlYXAgPSB0cnVlO1x0XHQvL2xlYXBpbmcgZW5hYmxlZFxyXG5cdFx0ZW50aXR5LmxlYXBfY29vbGRvd24gPSA0MDsvL21pbmltdW0gdGltZSBiZXR3ZWVuIGxlYXBzXHJcblx0XHRlbnRpdHkubGVhcF9jb29sZG93bl90aW1lciA9IC0xOyBcclxuXHRcdGVudGl0eS5jaGFyZ2VfZHVyYXRpb24gPSA4MDsvL21heGltdW0gbGVuZ3RoIG9mIGEgY2hhcmdlXHJcblx0XHRlbnRpdHkuY2hhcmdlX3RpbWVyID0gZW50aXR5LmNoYXJnZV9kdXJhdGlvbjtcclxuXHRcdGVudGl0eS5jaGFyZ2VfY29vbGRvd24gPSAyMDsvL21pbmltdW0gdGltZSBiZXR3ZWVuIGNoYXJnZXNcclxuXHRcdGVudGl0eS5jaGFyZ2VfY29vbGRvd25fdGltZXIgPSAtMTtcclxuXHRcdGVudGl0eS5ibGlua2luZyA9IGZhbHNlO1x0Ly93aGV0aGVyIGh5ZW5hIGlzIGJsaW5raW5nXHJcblx0XHRlbnRpdHkuYmxpbmtfZHVyYXRpb24gPSAyMDsvL2hvdyBsb25nIHRoZSBoeWVuYSBibGlua3MgYWZ0ZXIgdGFraW5nIGRhbWFnZVxyXG5cdFx0ZW50aXR5LmJsaW5rX3RpbWVyID0gLTE7XHJcblx0XHRlbnRpdHkubWFpbnRlbmFuY2VfZnJlcXVlbmN5ID0gMjA7Ly90aWNrcyBiZXR3ZWVuIHJvdXRpbmUgbWFpbnRlbmFuY2UgY2hlY2tzXHJcblx0XHRlbnRpdHkubWFpbnRlbmFuY2VfdGltZXIgPSBlbnRpdHkubWFpbnRlbmFuY2VfZnJlcXVlbmN5O1xyXG5cdFx0XHJcblx0XHRlbnRpdHkuYmFyZWx5X29ic3RydWN0ZWQgPSBmYWxzZTtcclxuXHRcdGVudGl0eS5jb2xsaXNpb25fYnVmZmVyID0gMC4yXHQvL3RoZSByZWdpb24gb2Ygb3ZlcmxhcCBhY2NvdW50ZWQgZm9yIGR1cmluZyBjb2xsaXNpb24gY2hlY2tpbmdcclxuXHRcdGVudGl0eS5wYXRoX2Jsb2NrZWQgPSBmYWxzZTtcdC8vaXMgZW50aXR5IGRlcHJlY2F0ZWQ/IHNldCBkdXJpbmcgY29sbGlzaW9uXHJcblx0XHRlbnRpdHkub2JzdHJ1Y3Rpb25fdG9sZXJhbmNlID0gNDsvL2hvdyBtYW55IHRpbWVzIHRoZSBoeWVuYSBjYW4gYmUgYmxvY2tlZCBiZWZvcmUgaGUgdGFrZXMgYWN0aW9uXHJcblx0XHRlbnRpdHkuYmxvY2tlZF9jb3VudCA9IDA7XHRcdFx0Ly90cmFja3MgbnVtYmVyIG9mIHRpbWVzIGJsb2NrZWQgYmV0d2VlbiBtYWludGVuYW5jZSBjaGVja3NcclxuXHRcdFxyXG5cdFx0ZW50aXR5Lm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlOyAvL2FjY2Vzc2VkIGJ5IHJlbmRlcmVyIGZvciBhbmltYXRpb24gcHVycG9zZXNcclxuXHRcdGVudGl0eS5hbmltYXRpb24gPSBcInN0YW5kXCI7IC8vYWNjZXNzZWQgYnkgcmVuZGVyZXIgZm9yIGFuaW1hdGlvbiBwdXJwb3Nlc1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gZW50aXR5O1xyXG5cdH07XHJcblxyXG5cdC8vSW5pdGlhbGl6ZSBjbGFzcyB2YXJpYWJsZXMsIGNhbGxlZCBvbmNlIGluIEVudGl0eUNvbnRyb2xsZXIuaW5pdCgpIGR1cmluZyBnYW1lIGxvYWRcclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRpbmNsdWRlKCk7IC8vIHNhdGlzZnkgcmVxdWlyZW1lbnRzLCBHT0VTIEZJUlNUXHJcblx0XHRJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX3R5cGUoSHllbmEsIFwiSHllbmFcIik7IC8vYXNzaWduIGNsYXNzIGlkXHJcblx0fTtcclxuXHJcblx0Ly9JbnN0YW50aWF0ZXMgY2xhc3MgSHllbmFcclxuXHQvL1dyYXBwZXIgZm9yIGNvbnN0cnVjdG9yLCBhc3NpZ25zIHVuaXF1ZSBJRFxyXG5cdHZhciBzcGF3biA9IGZ1bmN0aW9uKHgsIHkpe1xyXG5cdFx0dmFyIG5ld19oeWVuYSA9IG5ldyBIeWVuYSgpO1xyXG5cdFx0bmV3X2h5ZW5hLnR5cGUgPSBcIkh5ZW5hXCI7XHJcblx0XHR2YXIgaWQgPSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKG5ld19oeWVuYSk7XHJcblxyXG5cdFx0bmV3X2h5ZW5hLmJvZHkgPSBQaHlzaWNzQ29udHJvbGxlci5nZXRfcmVjdGFuZ3VsYXIoe3g6IHgsIHk6IHksIGJvcmRlcl9zZW5zb3JzOiB0cnVlfSwgbmV3X2h5ZW5hKTtcdFxyXG5cdFx0bmV3X2h5ZW5hLlBoeXNpY3NDb250cm9sbGVyID0gUGh5c2ljc0NvbnRyb2xsZXI7XHJcblx0XHRcclxuXHRcdHJldHVybiBuZXdfaHllbmE7XHJcblx0fTtcclxuXHRcclxuLy8uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5DT01NRU5DRS4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cXFxcXHJcbi8vLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5BUlRJRklDSUFMLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXFxcXFxyXG4vLy4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5IWUVOQS4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLlxcXFxcclxuLy8uLi4uLi4uLi4uLi4uLi4uLi4uLi4uSU5URUxMSUdFTkNFLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cXFxcXHJcblx0XHJcblx0Ly8gSXMgcnVuIGVhY2ggdGljayBmcm9tIHRoZSBFbnRpdHlDb250cm9sbGVyLnVwZGF0ZSBmb3IgZXZlcnkgcmVnaXN0ZXJlZCBpbnN0YW5jZVxyXG5cdHZhciB0aWNrX0FJID0gZnVuY3Rpb24oSHllbmEpe1xyXG5cdFx0Ly9DaGVjayBpZiBEZWFkLi4uLi4uLi5cclxuXHRcdC8vSWYgSHllbmEgaXMgY2xvc2UgdG8gdGhlIG1vdmVtZW50IGVkZ2UsIGxlYXAgYXdheVxyXG5cdFx0aWYgKEh5ZW5hLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54IDw9IFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpICsgMS4xMjUpe1xyXG5cdFx0XHRIeWVuYS5qdW1wKEh5ZW5hLmp1bXBfZm9yY2UsIDApO1xyXG5cdFx0fVxyXG5cdFx0aWYgKEh5ZW5hLmhwIDw9IDApey8vaWYgbW9ydGFsbHkgd291bmRlZFxyXG5cdFx0XHRIeWVuYS5kaWUoKTsgLy9kaWVcclxuXHRcdH1lbHNleyAvLyBEbyBMaXZlIEh5ZW5hIFN0dWZmXHJcblx0XHRcdC8vTWFpbnRlbmFuY2UuLi4uXHJcblx0XHRcdEh5ZW5hLmRpcmVjdGlvbl9wcmV2aW91cyA9IEh5ZW5hLmRpcmVjdGlvbjtcdFx0XHRcdC8vcmVtZW1iZXIgd2hhdCBoeWVuYSdzIGRpcmVjdGlvbiB3YXMgYXQgc3RhcnQgb2YgdGlja1xyXG5cdFx0XHRIeWVuYS54X3ByZXZpb3VzID0gSHllbmEuYm9keS5HZXRXb3JsZENlbnRlcigpLng7IC8vcmVtZW1iZXIgd2hhdCBoeWVuYSdzIHggd2FzIGF0IHN0YXJ0IG9mIHRpY2tcclxuXHRcdFx0SHllbmEubGVhcF9jb29sZG93bl90aW1lci0tO1x0XHRcdC8vZW5zdXJlIHRoZSBoeWVuYSBpcyBub3QgZXRlcm5hbGx5IGp1bXBpbmdcclxuXHRcdFx0Ly9tYWludGFpbiBibGlua2luZ1xyXG5cdFx0XHRpZihIeWVuYS5ibGlua2luZyl7XHJcblx0XHRcdFx0SHllbmEuYmxpbmtfdGltZXItLTtcclxuXHRcdFx0XHRpZihIeWVuYS5ibGlua190aW1lciA9PSAwKXtcclxuXHRcdFx0XHRcdEh5ZW5hLmJsaW5raW5nID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vbWFpbnRhaW4gYXR0YWNrIGNvb2xkb3duXHJcblx0XHRcdGlmKEh5ZW5hLmF0dGFja19jb29sZG93bl90aW1lciA+IDApeyBcclxuXHRcdFx0XHRIeWVuYS5hdHRhY2tfY29vbGRvd25fdGltZXItLTtcclxuXHRcdFx0XHRIeWVuYS5jYW5fYXR0YWNrID0gKEh5ZW5hLmF0dGFja19jb29sZG93bl90aW1lciA9PSAwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvL21haW50YWluIHRoZSBoeWVuYSdzIGFsdGVybmF0aW5nIHBoYXNlcyBvZiBydW5uaW5nIGFuZCBzdG9wcGluZ1xyXG5cdFx0XHRpZihIeWVuYS5jaGFyZ2VfdGltZXIgPD0gMCl7XHJcblx0XHRcdFx0SHllbmEuY2hhcmdlX2Nvb2xkb3duX3RpbWVyLS07XHJcblx0XHRcdFx0aWYgKEh5ZW5hLmNoYXJnZV9jb29sZG93bl90aW1lciA8PSAwKXtcclxuXHRcdFx0XHRcdEh5ZW5hLmNoYXJnZV90aW1lciA9IEh5ZW5hLmNoYXJnZV9kdXJhdGlvbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9tYWludGFpbiB0aGUgaHllbmEncyBjb3dhcmRseSB0YWN0aWNzXHJcblx0XHRcdGlmIChIeWVuYS5ydW5uaW5nX2F3YXkpe1x0Ly9pZiBoeWVuYSBpcyBkZWxpYmVyYXRlbHkgcnVubmluZyBhd2F5XHJcblx0XHRcdFx0SHllbmEucnVuX2F3YXlfdGltZXItLTtcdC8vdGlja2Rvd24gcnVuX2F3YXkgdGltZXJcclxuXHRcdFx0XHRpZiAoSHllbmEucnVuX2F3YXlfdGltZXIgPT0gMCl7IC8vbWF5YmUgc3RvcCBydW5uaW5nIGF3YXlcclxuXHRcdFx0XHRcdEh5ZW5hLnJ1bl9hd2F5X3RpbWVyID0gLTE7XHJcblx0XHRcdFx0XHRIeWVuYS5kaXJlY3Rpb24gPSBIeWVuYS5kaXJlY3Rpb25fbmVhcmVzdF9lbmVteSgpO1xyXG5cdFx0XHRcdFx0SHllbmEucnVubmluZ19hd2F5ID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vY2hlY2sgcGVyaW9kaWNhbGx5IHRvIGVuc3VyZSB0aGUgaHllbmEgaXMgbm90IHN0dWNrIGluIGEgY29ybmVyIGFuZCBvdGhlciByb3V0aW5lIG1haW50ZW5hbmNlXHJcblx0XHRcdEh5ZW5hLm1haW50ZW5hbmNlX3RpbWVyLS07XHJcblx0XHRcdGlmIChIeWVuYS5tYWludGVuYW5jZV90aW1lciA9PSAwKXtcclxuXHRcdFx0XHRpZiAoSHllbmEucGF0aF9mcmVlKCkpe1xyXG5cdFx0XHRcdFx0SHllbmEucGF0aF9ibG9ja2VkID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChIeWVuYS5ibG9ja2VkX2NvdW50ID4gSHllbmEub2JzdHJ1Y3Rpb25fdG9sZXJhbmNlKXtcdC8veW91IGtub3cgaGUncyBzdHVjayBub3dcclxuXHRcdFx0XHRcdGlmIChIeWVuYS5jYW5fbGVhcCl7XHJcblx0XHRcdFx0XHRcdEh5ZW5hLnBhdGhfYmxvY2tlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGxlYXAoSHllbmEpO1x0Ly90aW1lIHRvIGp1bXAgZm9yIGl0XHJcblx0XHRcdFx0XHRcdEh5ZW5hLnBhdGhfYmxvY2tlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRIeWVuYS5ibG9ja2VkX2NvdW50ID0gMDtcclxuXHRcdFx0XHRIeWVuYS5tYWludGVuYW5jZV90aW1lciA9IEh5ZW5hLm1haW50ZW5hbmNlX2ZyZXF1ZW5jeTsgLy9yZXNldCBjaGVjayB0aW1lclxyXG5cdFx0XHR9XHJcblx0XHRcdC8vUnVuIE1haW4gQUkgU2NyaXB0Li4uLi5cclxuXHRcdFx0aWYoIUh5ZW5hLmluX2FpcigpIHx8IEh5ZW5hLmJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS55ID09IDApeyAvL2lmIG9uIGdyb3VuZCBPUiBpZiB3ZSBzdXNwZWN0IGhlJ3Mgc3R1Y2sgb24gYSBjb3JuZXJcclxuXHRcdFx0XHRpZiAoSHllbmEuZW5lbXlfaW5fcmFuZ2UoSHllbmEuc2lnaHRfcmFuZ2UpKXsgLy9pZiBlbmVteSBuZWFyYnlcclxuXHRcdFx0XHRcdEh5ZW5hLmlkbGUgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGlmIChIeWVuYS5oaXRfdGFrZW4pe1x0Ly9pZiBoeWVuYSB3YXMgYXR0YWNrZWQsXHJcblx0XHRcdFx0XHRcdEh5ZW5hLnJ1bm5pbmdfYXdheSA9IHRydWU7XHQvL2JhY2sgb2ZmXHJcblx0XHRcdFx0XHRcdEh5ZW5hLnJ1bl9hd2F5X3RpbWVyID0gSHllbmEucnVuX2F3YXlfZHVyYXRpb247XHJcblx0XHRcdFx0XHRcdEh5ZW5hLmRpcmVjdGlvbiA9ICEoSHllbmEuZGlyZWN0aW9uKTtcclxuXHRcdFx0XHRcdH1lbHNlIGlmICgoSHllbmEuZW5lbXlfaW5fcmFuZ2UoSHllbmEuYXR0YWNrX3JhbmdlKSB8fCBIeWVuYS5wYXRoX2Jsb2NrZWQpICYmIEh5ZW5hLmNhbl9sZWFwICYmIEh5ZW5hLmxlYXBfY29vbGRvd25fdGltZXIgPD0gMCl7IC8vaWYgZW5lbXkgaW4gcmFuZ2Ugb3IgcGF0aCBpcyBibG9ja2VkLCBhbmQgbGVhcGluZyBpcyBlbmFibGVkLCBsZWFwXHJcblx0XHRcdFx0XHRcdEh5ZW5hLmRpcmVjdGlvbiA9IEh5ZW5hLmRpcmVjdGlvbl9uZWFyZXN0X2VuZW15KCk7XHJcblx0XHRcdFx0XHRcdGxlYXAoSHllbmEpO1xyXG5cdFx0XHRcdFx0XHRIeWVuYS5jYW5fbGVhcCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRIeWVuYS5sZWFwX2Nvb2xkb3duX3RpbWVyID0gSHllbmEubGVhcF9jb29sZG93bjtcclxuXHRcdFx0XHRcdFx0SHllbmEuY2hhbmdlX2FuaW1hdGlvbihcImxlYXBcIik7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0aWYoIUh5ZW5hLnJ1bm5pbmdfYXdheSAmJiAhSHllbmEuaW5fYWlyKCkpeyAvL2lmIGh5ZW5hIGlzbid0IGNvd2VyaW5nIG9yIGluIHRoZSBhaXIsIGZhY2UgdGhlIGVuZW15XHJcblx0XHRcdFx0XHRcdFx0SHllbmEuZGlyZWN0aW9uID0gSHllbmEuZGlyZWN0aW9uX25lYXJlc3RfZW5lbXkoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAoSHllbmEuY2hhcmdlX3RpbWVyID4gMCl7IC8vaWYgY2hhcmdlIGR1cmF0aW9uID4gMFxyXG5cdFx0XHRcdFx0XHRcdHJ1bihIeWVuYSk7XHJcblx0XHRcdFx0XHRcdFx0SHllbmEuY2hhbmdlX2FuaW1hdGlvbihcInJ1blwiKTsgLy9jaGFyZ2UgdGhlIGVuZW15XHJcblx0XHRcdFx0XHRcdFx0SHllbmEuY2hhcmdlX3RpbWVyLS07XHJcblx0XHRcdFx0XHRcdFx0aWYoSHllbmEuY2hhcmdlX3RpbWVyID09IDApe1xyXG5cdFx0XHRcdFx0XHRcdFx0SHllbmEuY2hhcmdlX2Nvb2xkb3duX3RpbWVyID0gSHllbmEuY2hhcmdlX2Nvb2xkb3duO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihIeWVuYS54X3ByZXZpb3VzID09IEh5ZW5hLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54KXsgLy9jaGVjayBpZiBoeWVuYSBoYXMgbW92ZWQgc3VjY2Vzc2Z1bGx5XHJcblx0XHRcdFx0XHRcdFx0XHRIeWVuYS5ibG9ja2VkX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9ZWxzZXsvL2Vsc2Ugc3RhbmQgYWdncmVzc2l2ZWx5XHJcblx0XHRcdFx0XHRcdFx0SHllbmEuY2hhbmdlX2FuaW1hdGlvbihcInN0YW5kXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRIeWVuYS5pZGxlID0gdHJ1ZTsgLy9pZGxlIG1vZGVcclxuXHRcdFx0XHRcdEh5ZW5hLmlkbGVfdGltZXItLTtcclxuXHRcdFx0XHRcdGlmIChIeWVuYS5pZGxlX3RpbWVyID09IDApe1xyXG5cdFx0XHRcdFx0XHRIeWVuYS5pZGxlX3RpbWVyID0gSHllbmEuaWRsZV9kdXJhdGlvbjtcclxuXHRcdFx0XHRcdFx0SHllbmEuaWRsZV9jb3VudGVyID0gKEh5ZW5hLmlkbGVfY291bnRlcisxKSUyNztcclxuXHRcdFx0XHRcdFx0aWYgKEh5ZW5hLmlkbGVfY291bnRlciU0ID09IDAgJiYgSHllbmEuaWRsZV9jb3VudGVyJTUgIT0gMCl7XHJcblx0XHRcdFx0XHRcdFx0SHllbmEuZGlyZWN0aW9uID0gIShIeWVuYS5kaXJlY3Rpb24pOy8vdXNlIHdlaXJkIG1vZHVsb3MgdG8gZ2V0IHJhbmRvbSBsb29raW5nIGlkbGUgYmVoYXZpb3JcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKEh5ZW5hLmlkbGVfY291bnRlciUyID09IDAgfHwgSHllbmEuaWRsZV9jb3VudGVyJTMgPT0gMCl7IC8vdXNlIHdlaXJkIG1vZHVsb3MgdG8gZ2V0IHJhbmRvbSBsb29raW5nIGlkbGUgYmVoYXZpb3JcclxuXHRcdFx0XHRcdFx0d2FsayhIeWVuYSk7XHJcblx0XHRcdFx0XHRcdEh5ZW5hLmNoYW5nZV9hbmltYXRpb24oXCJ3YWxrXCIpOy8vcGFjZVxyXG5cdFx0XHRcdFx0XHRpZihIeWVuYS54X3ByZXZpb3VzID09IEh5ZW5hLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54KXsgLy9jaGVjayBpZiBoeWVuYSBoYXMgd2FuZGVyZWQgc3VjY2Vzc2Z1bGx5XHJcblx0XHRcdFx0XHRcdFx0SHllbmEuYmxvY2tlZF9jb3VudCsrOyAvL2Vsc2UgY2hlY2sgZm9yIGJlaW5nIHN0dWNrXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0XHRIeWVuYS5jaGFuZ2VfYW5pbWF0aW9uKFwic3RhbmRcIik7Ly9sb2l0ZXJcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNley8vaWYgaW4gdGhlIGFpclxyXG5cdFx0XHRcdGlmKEh5ZW5hLm1vdmVtZW50X3ZvbHVudGFyeSgpKXtcclxuXHRcdFx0XHRcdEh5ZW5hLmNoYW5nZV9hbmltYXRpb24oXCJsZWFwXCIpOy8vaWYgdm9sdW50YXJ5LCBsZWFwXHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRIeWVuYS5jaGFuZ2VfYW5pbWF0aW9uKFwiZmFsbFwiKTsvL2Vsc2UsIGZhbGxcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKEh5ZW5hLmhpdF90YWtlbil7XHJcblx0XHRcdFx0SHllbmEudGFrZV9kYW1hZ2UoKTsgLy9pZiBoaXQsIHRha2UgZGFtYWdlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG4vLy4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLkVORC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cXFxcXHJcbi8vLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uQVJUSUZJQ0lBTC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLlxcXFxcclxuLy8uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLklOVEVMTElHRU5DRS4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXFxcXFxyXG5cclxuXHJcbi8vLi4uLi4uLi4uLi4uLi4uLi4uLi4uSEVMUEVSIEZVTkNUSU9OUy4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cclxuXHRcclxuXHRcclxuXHQvL3J1blxyXG5cdHZhciBydW4gPSBmdW5jdGlvbihoeWVuYSl7XHJcblx0XHRoeWVuYS5tb3ZlKGh5ZW5hLnNwZWVkKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vd2Fsa1xyXG5cdHZhciB3YWxrID0gZnVuY3Rpb24oaHllbmEpe1xyXG5cdFx0aHllbmEubW92ZShoeWVuYS5zcGVlZC8zKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vbGVhcFxyXG5cdHZhciBsZWFwID0gZnVuY3Rpb24oaHllbmEpe1xyXG5cdFx0aWYgKGh5ZW5hLnBhdGhfYmxvY2tlZCl7Ly9qdW1wIG91dCBvZiBhIGhvbGUgb3Igb3ZlciBhIHdhbGxcclxuXHRcdFx0aHllbmEuanVtcCgtMTArKDIwKmh5ZW5hLmRpcmVjdGlvbiksIC0xKmh5ZW5hLmp1bXBfZm9yY2UpO1xyXG5cdFx0fWVsc2V7IC8vbGVhcCB2aWNpb3VzbHkgYXQgaGVyb1xyXG5cdFx0XHRoeWVuYS5qdW1wKCgyKmh5ZW5hLmp1bXBfZm9yY2UqaHllbmEuZGlyZWN0aW9uKSAtIGh5ZW5hLmp1bXBfZm9yY2UsIC0xKmh5ZW5hLmp1bXBfZm9yY2UvMik7XHJcblx0XHR9XHJcblx0XHRoeWVuYS5jYW5fbGVhcCA9IGZhbHNlO1xyXG5cdH07XHJcblx0XHJcblxyXG4vLy4uLi4uLi4uLi4uLi4uLi4uLi4uLi5DT0xMSVNJT04gSEFORExFUlMuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5cclxuXHQvL2NhbGxlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsaXNpb25cclxuXHR2YXIgYmVnaW5fY29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QsIGluZm8pe1xyXG5cdFx0dmFyIHR5cGUgPSBpbmZvLk1lLnR5cGU7XHJcblx0XHR2YXIgaHllbmEgPSBpbmZvLk1lLmVudGl0eTtcclxuXHRcdHZhciBoeWVuYV94ID0gaHllbmEuYm9keS5HZXRXb3JsZENlbnRlcigpLng7XHJcblx0XHR2YXIgaHllbmFfeSA9IGh5ZW5hLmJvZHkuR2V0V29ybGRDZW50ZXIoKS54O1xyXG5cdFx0dmFyIGh5ZW5hX3cgPSAxLjEyNTsgLy9oYWxmIHdpZHRoIG9mIGh5ZW5hXHJcblx0XHR2YXIgaHllbmFfaCA9IDAuODc1OyAvL2hhbGYgdGhlIGhlaWdodCBvZiBoeWVuYVxyXG5cdFx0dmFyIG90aGVyX3ggPSBpbmZvLlRoZW0uZW50aXR5LmJvZHkuR2V0V29ybGRDZW50ZXIoKS54O1xyXG5cdFx0dmFyIG90aGVyX3kgPSBpbmZvLlRoZW0uZW50aXR5LmJvZHkuR2V0V29ybGRDZW50ZXIoKS55O1xyXG5cdFx0dmFyIG90aGVyX3cgPSBoeWVuYS5nZXRfZml4dHVyZShpbmZvLlRoZW0uZW50aXR5LFwibWFpblwiKS5HZXRBQUJCKCkuR2V0RXh0ZW50cygpLng7XHJcblx0XHR2YXIgb3RoZXJfaCA9IGh5ZW5hLmdldF9maXh0dXJlKGluZm8uVGhlbS5lbnRpdHksXCJtYWluXCIpLkdldEFBQkIoKS5HZXRFeHRlbnRzKCkueTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQoaHllbmFfdyArIG90aGVyX3cgKyBidWZmZXIpID0gbWluaW11bSBob3Jpem9udGFsIGRpc3RhbmNlIGZvciBub24tdmVydGljYWxseSBzdGFja2VkIGVudGl0aWVzXHJcblx0XHRhYnModGhlbS54IC0gbWUueCkgPSBhYnNvbHV0ZSBob3Jpem9udGFsIGRpc3RhbmNlXHJcblx0XHQoYWJzX2hkaXN0YW5jZSA8IG1pbl9oZGlzdGFuY2UpIGltcGxpZXMgdmVydGljYWwgc3RhY2tpbmdcclxuXHRcdFxyXG5cdFx0KGh5ZW5hX2ggKyBvdGhlcl9oICsgYnVmZmVyKSA9IG1pbmltdW0gdmVydGljYWwgZGlzdGFuY2UgZm9yIG5vbi1hZGphY2VudCBlbnRpdGllc1xyXG5cdFx0KGFic192ZGlzdGFuY2UgPCBtaW5fdmRpc3RhbmNlKSBpbXBsaWVzIGFkamFjZW5jeVxyXG5cdFx0XHJcblx0XHQoaHllbmEueCAtIG90aGVyLngpIDwgMCBpZiAoaHllbmEueCA8IG90aGVyLngpXHJcblx0XHQoaHllbmEueCAtIG90aGVyLngpID0gMCBpZiAoaHllbmEueCA9IG90aGVyLngpXHJcblx0XHQoaHllbmEueCAtIG90aGVyLngpID4gMCBpZiAoaHllbmEueCA+IG90aGVyLngpXHJcblx0XHRzbWFsbGVyIHggaXMgdG8gdGhlIGxlZnQgb2YgYmlnZ2VyIHhcclxuXHRcdHNtYWxsZXIgeSBpcyBhYm92ZSBiaWdnZXIgeVxyXG5cdFx0MCA9IGxlZnQ7XHJcblx0XHQxID0gcmlnaHQ7XHJcblx0XHQoKGh5ZW5hLnggLSBvdGhlci54KSA+IDApIHJldHVybnMgdHJ1ZSBpZiBoeWVuYSBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIGVuZW15LCBlbHNlIGZhbHNlXHJcblx0XHQoKGh5ZW5hLnggLSBvdGhlci54KSA8IDApIHJldHVybnMgdHJ1ZSBpZiBvdGhlciBpcyB0byB0aGUgcmlnaHQgb2YgaHllbmEsIGVsc2UgZmFsc2VcclxuXHRcdFxyXG5cdFx0KChoeWVuYS55IC0gb3RoZXIueSkgPiAwKSByZXR1cm5zIHRydWUgaWYgaHllbmEgaXMgYmVsb3cgdGhlIGVuZW15IChoeWVuYV95ID4gb3RoZXJfeSksIGVsc2UgZmFsc2VcclxuXHRcdCgoaHllbmEueSAtIG90aGVyLnkpIDwgMCkgcmV0dXJucyB0cnVlIGlmIG90aGVyIGlzIGFib3ZlIGh5ZW5hKGh5ZW5hX3kgPCBvdGhlcl95KSwgZWxzZSBmYWxzZVxyXG5cdFx0Ki9cclxuXHRcdFxyXG5cdFx0Ly91bHRpbWF0ZSBjb2xsaXNpb24gZGV0ZWN0b3JcclxuXHRcdGlmIChpbmZvLk1lLmZpeHR1cmVfbmFtZSA9PSBcIm1haW5cIil7XHJcblx0XHRcdC8vaWYgYWRqYWNlbnRcclxuXHRcdFx0aWYgKE1hdGguYWJzKGh5ZW5hX3kgLSBvdGhlcl95KSA8IChoeWVuYV9oICsgb3RoZXJfaCAtIGh5ZW5hLmNvbGxpc2lvbl9idWZmZXIpKXsgLy9pZiBhZGphY2VudFxyXG5cdFx0XHRcdGlmICgoaHllbmFfaCtvdGhlcl9oKSAtIChvdGhlcl95LWh5ZW5hX3kpIDwgaHllbmEuY29sbGlzaW9uX2J1ZmZlcil7Ly9pZiB0aGUgaHllbmEgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSB0b3AgdGhhdCBoZSBjb3VsZCBhbG1vc3Qgd2FsayBvdmVyIGl0Li4uXHJcblx0XHRcdFx0XHRoeWVuYS5iYXJlbHlfb2JzdHJ1Y3RlZCA9IHRydWU7Ly9jYWxsIGZvciBhIHRpbnkgYnVtcFxyXG5cdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0aHllbmEuYmxvY2tlZF9jb3VudCsrOyAvL2Vsc2UgY2FsbCBmb3IgYSByZWFsIGp1bXBcclxuXHRcdFx0XHRcdGh5ZW5hLnBhdGhfYmxvY2tlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChpbmZvLlRoZW0udHlwZSA9PSBcImhlcm9cIil7Ly9pZiBvdGhlciA9IGhlcm8sIGRlYWwgZGFtYWdlXHJcblx0XHRcdFx0XHRpZihoeWVuYS5jYW5fYXR0YWNrKXtcclxuXHRcdFx0XHRcdFx0aHllbmEuYXR0YWNrX2Nvb2xkb3duX3RpbWVyID0gaHllbmEuYXR0YWNrX2Nvb2xkb3duOy8vc2V0IGNvb2xkb3duIHRpbWVyXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvL2lmIG90aGVyIGlzIGJlbG93XHJcblx0XHRcdFx0aWYodHJ1ZSl7fVxyXG5cdFx0XHRcdFx0Ly9yZXNldCBqdW1wXHJcblx0XHRcdFx0XHQvL2lmIGhlcm8sIGRlYWwgZGFtYWdlXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly9pZiBvdGhlciBpcyBhYm92ZTpcclxuXHRcdFx0XHRcdC8vaWYgaGVybywgdGFrZSBkYW1hZ2VcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgdnVsbmVyYWJpbGl0eV9yYWRpdXMgPSAoMS4xMjUgKyAwLjQ1IC0gMC4zKTsvLyBoeWVuYV93aWR0aC8yICsgaGVyb193aWR0aC8yIC0gYnVmZmVyLCBpbiBtZXRlcnNcclxuXHRcdC8vaWYgYm90dG9tIGNvbGxpZGluZyB3aXRoIHRoZSBncm91bmQgb3IgdG9wIG9mIGFub3RoZXIgb2JqZWN0LCBlbmFibGUgbGVhcFxyXG5cdFx0aWYgKGluZm8uTWUuZml4dHVyZV9uYW1lID09IFwiYm90dG9tXCIgJiYgKGluZm8uVGhlbS5maXh0dXJlX25hbWUgPT0gXCJ0b3BcIiB8fCBpbmZvLlRoZW0uZW50aXR5LmtpbmQgPT0gMSB8fCBpbmZvLlRoZW0uZW50aXR5LmtpbmQgPT0gMikpe1xyXG5cdFx0XHRoeWVuYS5jYW5fbGVhcCA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vaWYgY29sbGlkaW5nIHdpdGggYSB3YWxsLCBkZXRlY3QgYmxvY2tlZCBwYXRoXHJcblx0XHRpZiAoKGluZm8uTWUuZml4dHVyZV9uYW1lID09IFwibGVmdFwiICYmICFoeWVuYS5kaXJlY3Rpb24pfHwoaW5mby5NZS5maXh0dXJlX25hbWUgPT0gXCJyaWdodFwiICYmIGh5ZW5hLmRpcmVjdGlvbikpe1xyXG5cdFx0XHRoeWVuYS5wYXRoX2Jsb2NrZWQgPSB0cnVlO1xyXG5cdFx0XHRoeWVuYS5ibG9ja2VkX2NvdW50Kys7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vaWYgY29sbGlkaW5nIHdpdGggYSBwbGF5ZXIsIGNoZWNrIGZvciBkYW1hZ2VcclxuXHRcdGlmKGluZm8uVGhlbS50eXBlID09IFwiaGVyb1wiKXtcclxuXHRcdFx0aWYoaW5mby5UaGVtLmZpeHR1cmVfbmFtZSAhPSBcImJvdHRvbVwiKXsgLy9pZiBjYW5fYXR0YWNrIGFuZCBjb2xsaWRpbmcgd2l0aCBhIGZpeHR1cmUgb3RoZXIgdGhhbiBcImJvdHRvbVwiXHJcblx0XHRcdFx0aWYoaHllbmEuY2FuX2F0dGFjayl7XHJcblx0XHRcdFx0XHRoeWVuYS5hdHRhY2tfY29vbGRvd25fdGltZXIgPSBoeWVuYS5hdHRhY2tfY29vbGRvd247Ly9zZXQgY29vbGRvd24gdGltZXJcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKE1hdGguYWJzKGluZm8uVGhlbS5lbnRpdHkuYm9keS5HZXRXb3JsZENlbnRlcigpLnggLSBoeWVuYS5ib2R5LkdldFdvcmxkQ2VudGVyKCkueCkgPCB2dWxuZXJhYmlsaXR5X3JhZGl1cyAmJiAhaHllbmEuYmxpbmtpbmcpe1xyXG5cdFx0XHRcdGh5ZW5hLmhpdF90YWtlbiA9IHRydWU7Ly90YWtlIGRhbWFnZSBpZiBlbmVteSBjb2xsaWRlcyBmcm9tIGFib3ZlIGFuZCBkaXN0YW5jZSA8IHZ1bG5lcmFiaWxpdHkgcmFkaXVzXHJcblx0XHRcdFx0aHllbmEuZGFtYWdlX3Rha2VuID0gaW5mby5UaGVtLmVudGl0eS5kYW1hZ2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvL2NhbGxlZCB1cG9uIGVuZCBvZiBjb2xsaXNpb25cclxuXHR2YXIgZW5kX2NvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0LCBpbmZvKXtcclxuXHRcdFxyXG5cdH07XHJcblxyXG5cclxuLy8uLi4uLi4uLi4uLi4uLi4uLkRFQ0xBUkUgUFVCTElDIEZVTkNUSU9OUy4uLi4uLi4uLi4uLi4uLi4uLi4uLlxyXG5cdHJldHVybiB7XHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHNwYXduOiBzcGF3bixcclxuXHRcdHRpY2tfQUk6IHRpY2tfQUksXHJcblx0XHRiZWdpbl9jb250YWN0OiBiZWdpbl9jb250YWN0LFxyXG5cdFx0ZW5kX2NvbnRhY3Q6IGVuZF9jb250YWN0LFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEh5ZW5hTG9naWM7XHJcblxyXG52YXIgSW5jbHVkZXMgPSByZXF1aXJlKFwiLi4vSW5jbHVkZXMuanNcIik7IHZhciBpbmNsdWRlX2RhdGEgPSBJbmNsdWRlcy5nZXRfaW5jbHVkZV9kYXRhKHtcclxuXHRjdXJyZW50X21vZHVsZTogXCJIeWVuYUxvZ2ljXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5MT0dJQ19TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcbiIsInZhciBNZWR1c2FMb2dpYyA9IChmdW5jdGlvbigpe1xyXG4gICBcclxuXHR2YXIgTWVkdXNhID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIFdpbGwgYmUgaW5zdGFudGlhdGVkIGZvciBldmVyeSBjcmVhdGVkIGVudGl0eSB0byBob2xkIGFsbCB0aGUgaW5mb3JtYXRpb24gXHJcblx0XHRcdGFib3V0IHRoZSBwaHlzaWNhbCAobm90IGdyYXBoaWNhbCkgc3RhdGUgb2YgdGhlIGVudGl0eSBpbiBxdWVzdGlvbi4gXHJcblx0XHRcdGRlY2xhcmUgdGhlIHByb3BlcnRpZXMgbGlrZSBlbnRpdHk6XHJcblx0XHRcdGVudGl0eS5zb21lX3N0YXRlX3ZhcmlhYmxlX2luaXRpYWxfdmFsdWUgPSAwO1xyXG5cdFx0XHRpbnN0YW50aWF0ZSAobW9zdCBsaWtlbHkgaW4gdGhlIHNwYXduIGZ1bmN0aW9uKSBsaWtlIHRoYXQ6XHJcblx0XHRcdHZhciBuZXdfZW50aXR5X2luc3RhbmNlID0gbmV3IE1lZHVzYSgpO1xyXG5cdFx0Ki9cclxuXHRcdHZhciBlbnRpdHkgPSBFbnRpdHlDb250cm9sbGVyLmNyZWF0ZV9hYnN0cmFjdF9lbnRpdHkoKTtcclxuXHRcdFxyXG5cdFx0ZW50aXR5Lmhlcm9faHVydF9tZSA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5Lm1lX2h1cnRfaGVybyA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LmRlYXRoX3RpY2sgPSAwO1xyXG5cclxuXHRcdC8vc2V0IHlvdXIgZ2FtZSBsb2dpYyBwYXJhbWV0ZXJzIGhlcmVcclxuXHRcdC8vZW50aXR5Lm9iamVjdF9pZCA9IDE7IC8vaGFyZGNvZGUgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCBuZXcgZW5lbXkgY2xhc3NcclxuXHRcdGVudGl0eS5ocCA9IDQ7XHJcblx0XHRlbnRpdHkuc3BlZWQgPSA0O1xyXG5cdFx0ZW50aXR5LmRhbWFnZSA9IDEyO1xyXG5cdFx0ZW50aXR5LnBvaW50X3ZhbHVlID0gMTAwO1xyXG5cdFx0Ly9lbnRpdHkuYXR0YWNrX2Nvb2xkb3duID0gNDsgLy91c2UgZW50aXR5IGZvciBlbmVtaWVzIHdobyBuZWVkXHJcblx0XHRlbnRpdHkuY2FuX2F0dGFjayA9IHRydWU7Ly91c2UgZW50aXR5IGZvciBlbmVtaWVzIHdobyBhbHRlcm5hdGUgYmV0d2VlbiBcclxuXHRcdC8vZW50aXR5LmNvb2xkb3duX3RpbWVyPS0xO1xyXG5cdFx0ZW50aXR5LkFJX3N0YXRlID0gXCJ3YWxrXCI7Ly91c2UgZW50aXR5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGVuZW15J3MgQUkgc3RhdGVcclxuXHRcdGVudGl0eS5hbGl2ZWZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5LnVuaHVydGZsYWcgPSB0cnVlO1xyXG5cdFx0ZW50aXR5Lm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGVudGl0eS5tYWludGVuYW5jZV9mcmVxdWVuY3kgPSAyMDsvL3RpY2tzIGJldHdlZW4gcm91dGluZSBtYWludGVuYW5jZSBjaGVja3NcclxuXHRcdGVudGl0eS5tYWludGVuYW5jZV90aW1lciA9IGVudGl0eS5tYWludGVuYW5jZV9mcmVxdWVuY3k7XHJcblxyXG5cdFx0ZW50aXR5LmRpcmVjdGlvbiA9IGZhbHNlO1xyXG5cdFx0ZW50aXR5LmpvbHRfZm9yY2UgPSAxMDA7XHJcblxyXG5cdFx0ZW50aXR5LmJsaW5raW5nID0gZmFsc2U7XHJcblx0XHRlbnRpdHkuYmxpbmtfdGltZXIgPSAtMTtcclxuXHRcdGVudGl0eS5ibGlua19kdXJhdGlvbiA9IDIwOy8vaG93IGxvbmcgdGhlIGVudGl0eSBibGlua3MgYWZ0ZXIgdGFraW5nIGRhbWFnZVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gZW50aXR5O1xyXG5cdH07XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIElzIHJhbiBmcm9tIHRoZSBFbnRpdHlDb250cm9sbGVyLmluaXQgb25jZSBkdXJpbmcgZ2FtZSBsb2FkaW5nIFxyXG5cdFx0IFx0eW91IHNob3VsZCBhc3NpZ24gdHlwZSB0byB5b3VyIG1vZGVsIGhlcmUgdXNpbmcgdGhlIGlkZW50aWZpY2F0aW9uIGNvbnRyb2xsZXJcclxuXHRcdCAqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0SWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl90eXBlKE1lZHVzYSwgXCJNZWR1c2FcIik7XHJcblx0fTtcclxuXHJcblx0dmFyIHNwYXduID0gZnVuY3Rpb24oeCwgeSl7XHJcblx0XHQvKiBzcGF3biBpbnN0YW5jZSBvZiB0aGlzIGVudGl0eSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXNcclxuXHRcdFx0eW91IHdpbGwgaGF2ZSB0byBjcmVhdGUgbmV3IGVudGl0eSBpbnN0YW5jZSwgYXNzaWduIGl0IGlkXHJcblx0XHRcdHVzaW5nIHRoZSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKGVudGl0eV9pbnN0YW5jZSksXHJcblx0XHRcdGFzc2lnbiBpdCBhIGJvZHkgd2hpY2ggeW91IGNhbiBnZXQgdGhyb3VnaCBQaHlzaWNzQ29udHJvbGxlclxyXG5cdFx0XHRkbyBhbnkgb3RoZXIgc3R1ZmYgeW91IHdhbnQgdG8gZG8gZHVyaW5nIHNwYXduaW5nLFxyXG5cdFx0XHRhbmQgZmluYWxseSB5b3UgSEFWRSBUTyghISEpIHJldHVybiB0aGUgaW5zdGFuY2UgeW91IGp1c3QgY3JlYXRlZCBmcm9tIHRoaXMgZnVuY3Rpb25cclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIG5ld19NZWR1c2EgPSBuZXcgTWVkdXNhKCk7XHJcblx0XHRuZXdfTWVkdXNhLnR5cGUgPSBcIk1lZHVzYVwiO1xyXG5cdFx0dmFyIGlkID0gSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChuZXdfTWVkdXNhKTtcclxuXHJcblx0XHRuZXdfTWVkdXNhLmJvZHkgPSBQaHlzaWNzQ29udHJvbGxlci5nZXRfcmVjdGFuZ3VsYXIoe3g6IHgsIHk6IHksIGJvcmRlcl9zZW5zb3JzOiB0cnVlfSwgbmV3X01lZHVzYSk7XHRcclxuXHJcblx0XHRyZXR1cm4gbmV3X01lZHVzYTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHRpY2tfQUkgPSBmdW5jdGlvbihNZWR1c2Epe1xyXG5cdFx0LyogSXMgcmFuIGVhY2ggdGljayBmcm9tIHRoZSBFbnRpdHlDb250cm9sbGVyLnVwZGF0ZSBmb3IgZXZlcnkgcmVnaXN0ZXJlZFxyXG5cdFx0XHRlbnRpdHkgb2YgdGhpcyB0eXBlLiBJIGdpdmVuIGVudGl0eV9pbnN0YW5jZVxyXG5cdFx0Ki9cclxuXHJcblx0XHQvL2lmIGRlYWQsIGRpZVxyXG5cdFx0aWYgKE1lZHVzYS5ocCA8PSAwKSB7XHJcblx0XHRcdE1lZHVzYS5kaWUoKTtcclxuXHRcdH1lbHNleyAvLyBNZWR1c2EuaHAgPj0gMVxyXG5cdFx0XHRcdE1lZHVzYS5jaGFuZ2VfYW5pbWF0aW9uKFwid2Fsa1wiKTtcclxuXHRcdFx0XHJcblx0XHRcdFx0aWYgKE1lZHVzYS5ibGlua2luZykge1xyXG5cdFx0XHRcdCAgICBNZWR1c2EuYmxpbmtfdGltZXItLTtcclxuXHRcdFx0XHQgICAgaWYgKE1lZHVzYS5ibGlua190aW1lciA9PSAwKSB7XHJcblx0XHRcdFx0ICAgICAgICBNZWR1c2EuYmxpbmtpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHQgICAgfVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChNZWR1c2EuYW5pbWF0aW9uID09IFwid2Fsa1wiKXtcclxuXHRcdFx0XHRNZWR1c2EubW92ZShNZWR1c2Euc3BlZWQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChNZWR1c2EuYW5pbWF0aW9uID09IFwiam9sdFwiKXtcclxuXHRcdFx0ICAgIE1lZHVzYS5qdW1wKCgyICogTWVkdXNhLmpvbHRfZm9yY2UgKiBNZWR1c2EuZGlyZWN0aW9uKSAtIE1lZHVzYS5qb2x0X2ZvcmNlLCBNZWR1c2Euam9sdF9mb3JjZS8yKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoTWVkdXNhLmhpdF90YWtlbil7XHJcblx0XHRcdFx0TWVkdXNhLnRha2VfZGFtYWdlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdE1lZHVzYS5tYWludGVuYW5jZV90aW1lci0tO1xyXG5cdFx0XHRpZiAoTWVkdXNhLm1haW50ZW5hbmNlX3RpbWVyID09IDApIHtcclxuXHRcdFx0ICAgIE1lZHVzYS5qdW1wKDAsIC0yKTtcclxuXHRcdFx0ICAgIE1lZHVzYS5tYWludGVuYW5jZV90aW1lciA9IE1lZHVzYS5tYWludGVuYW5jZV9mcmVxdWVuY3k7IC8vcmVzZXQgY2hlY2sgdGltZXJcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIC8vIC8vU2V0IHVwIENvbGxpc2lvbiBoYW5kbGVyXHJcblx0XHJcblx0XHJcblx0dmFyIGJlZ2luX2NvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0LCBpbmZvKXtcclxuXHQgICAgLy9oYW5kbGUgY29sbGlzaW9ucyBoZXJlXHJcblxyXG5cdCAgICBpZiAoKGluZm8uTWUuZml4dHVyZV9uYW1lID09IFwicmlnaHRcIiB8fCBpbmZvLk1lLmZpeHR1cmVfbmFtZSA9PSBcImxlZnRcIikgJiYgaW5mby5UaGVtLnR5cGUgIT0gXCJwaXp6YVwiKSB7XHJcblx0ICAgICAgICBpbmZvLk1lLmVudGl0eS5kaXJlY3Rpb24gPSAhaW5mby5NZS5lbnRpdHkuZGlyZWN0aW9uO1xyXG5cdCAgICAgICAgY29uc29sZS5sb2coJ2hpdCcpO1xyXG5cdCAgICAgICAgaWYgKGluZm8uVGhlbS5lbnRpdHkucG9pbnRfdmFsdWUgPiAwKSB7XHJcblx0ICAgICAgICAgICAgaW5mby5NZS5lbnRpdHkuZGlyZWN0aW9uID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKTtcclxuXHQgICAgICAgICAgICBpbmZvLlRoZW0uZW50aXR5LmRpcmVjdGlvbiA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHRcdFxyXG5cdFx0aWYoaW5mby5UaGVtLnR5cGUgPT0gXCJoZXJvXCIpe1xyXG5cdFx0XHRpZihpbmZvLlRoZW0uZml4dHVyZV9uYW1lICE9IFwiYm90dG9tXCIgJiYgaW5mby5NZS5lbnRpdHkuY2FuX2F0dGFjayl7XHJcblx0XHRcdFx0aW5mby5NZS5lbnRpdHkubWVfaHVydF9oZXJvID0gdHJ1ZTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0aW5mby5NZS5lbnRpdHkuaGl0X3Rha2VuID0gdHJ1ZTsvL3Rha2UgZGFtYWdlIGlmIGVuZW15IGNvbGxpZGVzIGZyb20gYWJvdmUgYW5kIGRpc3RhbmNlIDwgdnVsbmVyYWJpbGl0eSByYWRpdXNcclxuXHRcdFx0XHRpbmZvLk1lLmVudGl0eS5kYW1hZ2VfdGFrZW4gPSBpbmZvLlRoZW0uZW50aXR5LmRhbWFnZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHZhciBlbmRfY29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QsIGluZm8pe1xyXG5cdFxyXG5cdH07XHJcblxyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRzcGF3bjogc3Bhd24sXHJcblx0XHR0aWNrX0FJOiB0aWNrX0FJLFxyXG5cdFx0YmVnaW5fY29udGFjdDogYmVnaW5fY29udGFjdCxcclxuXHRcdGVuZF9jb250YWN0OiBlbmRfY29udGFjdCxcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZWR1c2FMb2dpYztcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIk1lZHVzYUxvZ2ljXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5MT0dJQ19TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcbiIsInZhciBQaXp6YUxvZ2ljID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgUGl6emEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyogV2lsbCBiZSBpbnN0UGl6emFpYXRlZCBmb3IgZXZlcnkgY3JlYXRlZCBlbnRpdHkgdG8gaG9sZCBhbGwgdGhlIGluZm9ybWF0aW9uIFxyXG5cdFx0XHRhYm91dCB0aGUgcGh5c2ljYWwgKG5vdCBncmFwaGljYWwpIHN0YXRlIG9mIHRoZSBlbnRpdHkgaW4gcXVlc3Rpb24uIFxyXG5cdFx0XHRkZWNsYXJlIHRoZSBwcm9wZXJ0aWVzIGxpa2UgdGhpczpcclxuXHRcdFx0dGhpcy5zb21lX3N0YXRlX3ZhcmlhYmxlX2luaXRpYWxfdmFsdWUgPSAwO1xyXG5cdFx0XHRpbnN0UGl6emFpYXRlIChtb3N0IGxpa2VseSBpbiB0aGUgc3Bhd24gZnVuY3Rpb24pIGxpa2UgdGhhdDpcclxuXHRcdFx0dmFyIG5ld19lbnRpdHlfaW5zdGFuY2UgPSBuZXcgUGl6emEoKTtcclxuXHRcdCovXHJcbiAgICAgICAgdmFyIGVudGl0eSA9IEVudGl0eUNvbnRyb2xsZXIuY3JlYXRlX2Fic3RyYWN0X2VudGl0eSgpO1xyXG5cclxuICAgICAgICBlbnRpdHkuYW5pbWF0aW9uID0gXCJub3JtYWxcIjtcclxuICAgICAgICBlbnRpdHkuY2FuX2F0dGFjayA9IGZhbHNlO1xyXG4gICAgICAgIGVudGl0eS51c2VkID0gZmFsc2U7XHJcbiAgICAgICAgZW50aXR5LnBvaW50X3ZhbHVlID0gMDtcclxuICAgICAgICBlbnRpdHkuaXNfYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICBlbnRpdHkucmVnZW4gPSAtMjU7XHJcblxyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qIElzIHJ1biBmcm9tIHRoZSBFbnRpdHlDb250cm9sbGVyLmluaXQgb25jZSBkdXJpbmcgZ2FtZSBsb2FkaW5nIFxyXG5cdFx0IFx0eW91IHNob3VsZCBhc3NpZ24gdHlwZSB0byB5b3VyIG1vZGVsIGhlcmUgdXNpbmcgdGhlIGlkZW50aWZpY2F0aW9uIGNvbnRyb2xsZXJcclxuXHRcdCAqL1xyXG4gICAgICAgIGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHMsIEdPRVMgRklSU1RcclxuICAgICAgICBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX3R5cGUoUGl6emEsIFwicGl6emFcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzcGF3biA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgLyogc3Bhd24gaW5zdGFuY2Ugb2YgdGhpcyBlbnRpdHkgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXHJcblx0XHRcdHlvdSB3aWxsIGhhdmUgdG8gY3JlYXRlIG5ldyBlbnRpdHkgaW5zdGFuY2UsIGFzc2lnbiBpdCBpZFxyXG5cdFx0XHR1c2luZyB0aGUgSWRlbnRpZmljYXRpb25Db250cm9sbGVyLmFzc2lnbl9pZChlbnRpdHlfaW5zdGFuY2UpLFxyXG5cdFx0XHRhc3NpZ24gaXQgYSBib2R5IHdoaWNoIHlvdSBjYW4gZ2V0IHRocm91Z2ggUGh5c2ljc0NvbnRyb2xsZXJcclxuXHRcdFx0ZG8gYW55IG90aGVyIHN0dWZmIHlvdSB3UGl6emEgdG8gZG8gZHVyaW5nIHNwYXduaW5nLFxyXG5cdFx0XHRhbmQgZmluYWxseSB5b3UgSEFWRSBUTyghISEpIHJldHVybiB0aGUgaW5zdGFuY2UgeW91IGp1c3QgY3JlYXRlZCBmcm9tIHRoaXMgZnVuY3Rpb25cclxuXHRcdCovXHJcblxyXG4gICAgICAgIHZhciBuZXdfUGl6emEgPSBuZXcgUGl6emEoKTtcclxuICAgICAgICBuZXdfUGl6emEudHlwZSA9IFwicGl6emFcIjtcclxuICAgICAgICB2YXIgaWQgPSBJZGVudGlmaWNhdGlvbkNvbnRyb2xsZXIuYXNzaWduX2lkKG5ld19QaXp6YSk7XHJcblxyXG4gICAgICAgIG5ld19QaXp6YS5ib2R5ID0gUGh5c2ljc0NvbnRyb2xsZXIuZ2V0X3JlY3Rhbmd1bGFyKHsgeDogeCwgeTogeSwgYm9yZGVyX3NlbnNvcnM6IGZhbHNlIH0sIG5ld19QaXp6YSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdfUGl6emE7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdGlja19BSSA9IGZ1bmN0aW9uIChQaXp6YSkge1xyXG4gICAgICAgIC8qIElzIHJhbiBlYWNoIHRpY2sgZnJvbSB0aGUgRW50aXR5Q29udHJvbGxlci51cGRhdGUgZm9yIGV2ZXJ5IHJlZ2lzdGVyZWRcclxuXHRcdFx0ZW50aXR5IG9mIHRoaXMgdHlwZS4gSSBnaXZlbiBlbnRpdHlfaW5zdGFuY2VcclxuXHRcdCovXHJcblxyXG4gICAgICAgIC8vaWYgZW5lbXkgaXMgZGVhZCwgZGllXHJcbiAgICAgICAgLy9pZiAoUGl6emEuYm9keS5HZXRXb3JsZENlbnRlcigpLnkgPiAyMiB8fCBQaXp6YS5ib2R5LkdldFdvcmxkQ2VudGVyKCkueCA8IENvbmZpZy5QbGF5ZXIubW92ZW1lbnRfZWRnZSAtIDEpIHtcclxuICAgICAgICAvL0VudGl0eUNvbnRyb2xsZXIuZGVsZXRlX2VudGl0eSgpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJkcm9wIG9mIGRlYXRoXCIpO1xyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYgKFBpenphLnVzZWQpIHtcclxuICAgICAgICAgICAgUGl6emEuZGllKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyAvLyAvL1NldCB1cCBDb2xsaXNpb24gaGFuZGxlclxyXG5cclxuXHJcbiAgICB2YXIgYmVnaW5fY29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0LCBpbmZvKSB7XHJcbiAgICAgICAgLy9oYW5kbGUgY29sbGlzaW9ucyBoZXJlXHJcbiAgICAgICAgaWYgKGluZm8uVGhlbS5lbnRpdHkudHlwZSA9PSBcImhlcm9cIiAmJiBpbmZvLlRoZW0uZW50aXR5LmhwIDwgMTAwKSB7XHJcbiAgICAgICAgICAgIGluZm8uTWUuZW50aXR5LnVzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlbmRfY29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0LCBpbmZvKSB7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBkZWNsYXJlIHB1YmxpY1xyXG4gICAgICAgIGluaXQ6IGluaXQsXHJcbiAgICAgICAgc3Bhd246IHNwYXduLFxyXG4gICAgICAgIHRpY2tfQUk6IHRpY2tfQUksXHJcbiAgICAgICAgYmVnaW5fY29udGFjdDogYmVnaW5fY29udGFjdCxcclxuICAgICAgICBlbmRfY29udGFjdDogZW5kX2NvbnRhY3QsXHJcbiAgICB9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQaXp6YUxvZ2ljO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcbiAgICBjdXJyZW50X21vZHVsZTogXCJQaXp6YUxvZ2ljXCIsXHJcbiAgICBpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuTE9HSUNfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24gKCkgeyBldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7IH1cclxuIiwidmFyIEFzc2V0TW9kZWwgPSBuZXcgZnVuY3Rpb24oKXtcclxuXHQvLyBBcyBhbHdheXMsIGFsbW9zdCBhbnl0aGluZyBpcyBpbml0aWFsaXplZCBpbiB0aGUgSW5pdENvbnRyb2xsZXJcclxuXHRcclxuXHR0aGlzLmxvYWRlcjtcclxuLy9tYWNrZXJlbFxyXG5cdHRoaXMubWFuaWZlc3QgPSBbIC8vIGRlZmluaW5nIHJlc291cmNlcyB0byBiZSBsb2FkZWQgaW4gYnVsayB3aXRoIHByZWxvYWQuanNcclxuXHRcdFx0e3NyYzogXCJncmVla193YXJyaW9yLnBuZ1wiLCBpZDogXCJncmVla193YXJyaW9yXCJ9LFxyXG5cdFx0XHQvL3tzcmM6LCBpZDp9LFxyXG5cdFx0XHR7c3JjOiBcIm1pZGRsZV90ZXJyYWluLnBuZ1wiLCBpZDpcIm1pZGRsZV90ZXJyYWluXCJ9LFxyXG5cdFx0XHR7c3JjOiBcImJvdHRvbV90ZXJyYWluLnBuZ1wiLCBpZDogXCJib3R0b21fdGVycmFpblwifSxcclxuXHRcdFx0e3NyYzogXCJncmFzc19zdW1tZXIucG5nXCIsIGlkOiBcImdyYXNzX3N1bW1lclwiIH0sXHJcblx0XHRcdHtzcmM6IFwiZ3Jhc3Nfd2ludGVyLnBuZ1wiLCBpZDogXCJncmFzc193aW50ZXJcIiB9LFxyXG5cdFx0XHR7c3JjOiBcImdyYXNzX2ZhbGwucG5nXCIsIGlkOiBcImdyYXNzX2ZhbGxcIiB9LFxyXG5cdFx0XHR7c3JjOiBcImdyYXNzX3NwcmluZy5wbmdcIiwgaWQ6IFwiZ3Jhc3Nfc3ByaW5nXCIgfSxcclxuXHRcdFx0e3NyYzogXCJBbnRDaG9tcGVycy5wbmdcIiwgaWQ6IFwiQW50MVwifSxcclxuXHRcdFx0e3NyYzogXCJBbnRDaG9tcGVyczIucG5nXCIsIGlkOiBcIkFudDJcIn0sXHJcblx0XHRcdHtzcmM6IFwiQW50Q2hvbXBlcnNEZWF0aC5wbmdcIiwgaWQ6IFwiQW50M1wifSxcclxuXHRcdFx0e3NyYzogXCJHcmVlayBMYW5kc2NhcGUgZmFsbC5wbmdcIiwgaWQ6IFwiRmFsbFwifSxcclxuXHRcdFx0e3NyYzogXCJHcmVlayBMYW5kc2NhcGUgc3ByaW5nLnBuZ1wiLCBpZDogXCJTcHJpbmdcIn0sXHJcblx0XHRcdHtzcmM6IFwiR3JlZWsgTGFuZHNjYXBlIHdpbnRlci5wbmdcIiwgaWQ6IFwiV2ludGVyXCJ9LFxyXG5cdFx0XHR7c3JjOiBcIkdyZWVrIExhbmRzY2FwZSBzdW1tZXIucG5nXCIsIGlkOiBcIlN1bW1lclwifSxcclxuXHRcdFx0e3NyYzogXCJncmlmZmluUGhhc2UxU21hbGwucG5nXCIsIGlkOiBcIkdyaWZmaW4xXCIgfSxcclxuXHRcdFx0e3NyYzogXCJncmlmZmluUGhhc2UyU21hbGwucG5nXCIsIGlkOiBcIkdyaWZmaW4yXCIgfSxcclxuXHRcdFx0e3NyYzogXCJncmlmZmluUGhhc2UzU21hbGwucG5nXCIsIGlkOiBcIkdyaWZmaW4zXCIgfSxcclxuXHRcdFx0eyBzcmM6IFwiZ3JpZmZpbkRlYXRoU21hbGwucG5nXCIsIGlkOiBcIkdyaWZmaW5EZWF0aFwiIH0sXHJcbiAgICAgICAgICAgIHsgc3JjOiBcImdyaWZmaW5EZWF0aFNtYWxsMi5wbmdcIiwgaWQ6IFwiR3JpZmZpbkRlYXRoMlwiIH0sXHJcbiAgICAgICAgICAgIHsgc3JjOiBcImdyaWZmaW5EZWF0aFNtYWxsMy5wbmdcIiwgaWQ6IFwiR3JpZmZpbkRlYXRoM1wiIH0sXHJcblx0XHRcdHsgc3JjOiBcIk1lZHVzYVNoZWV0LnBuZ1wiLCBpZDogXCJNZWR1c2ExXCIgfSxcclxuICAgICAgICAgICAgeyBzcmM6IFwiQ2VudGF1clNoZWV0LnBuZ1wiLCBpZDogXCJDZW50YXVyMVwiIH0sXHJcblx0XHRcdHtzcmM6IFwicGxhdGZvcm1fbGVmdC5wbmdcIiwgaWQ6IFwibGVmdF9wbGF0Zm9ybVwiIH0sXHJcblx0XHRcdHtzcmM6IFwicGxhdGZvcm1fbWlkZGxlLnBuZ1wiLCBpZDogXCJtaWRkbGVfcGxhdGZvcm1cIiB9LFxyXG5cdFx0XHR7c3JjOiBcInBsYXRmb3JtX3JpZ2h0LnBuZ1wiLCBpZDogXCJyaWdodF9wbGF0Zm9ybVwiIH0sXHJcblx0XHRcdHtzcmM6IFwiSHllbmFQaGFzZTMucG5nXCIsIGlkOiBcIkh5ZW5hU3ByaXRlXCIgfSxcclxuXHRcdFx0e3NyYzogXCJwbGF0Zm9ybV9zcGlrZXMucG5nXCIsIGlkOiBcInBsYXRmb3JtX3NwaWtlc1wiIH0sXHJcblx0XHRcdHtzcmM6IFwiSGVyby5wbmdcIiwgaWQ6IFwiSGVyb1wifSxcclxuXHRcdFx0e3NyYzogXCJIZXJvSGl0UmVkLnBuZ1wiLCBpZDogXCJIZXJvUlwifSxcclxuXHRcdFx0e3NyYzogXCJIZXJvSGl0V2hpdGUucG5nXCIsIGlkOiBcIkhlcm9XXCJ9LFxyXG5cdFx0XHR7c3JjOiBcIkhlcm9SZWQucG5nXCIsIGlkOiBcIkhlcm9SZWRcIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVyb1BpbmsucG5nXCIsIGlkOiBcIkhlcm9QaW5rXCJ9LFxyXG5cdFx0XHR7c3JjOiBcIkhlcm9CbHVlLnBuZ1wiLCBpZDogXCJIZXJvQmx1ZVwifSxcclxuXHRcdFx0e3NyYzogXCJIZXJvTFB1cnBsZS5wbmdcIiwgaWQ6IFwiSGVyb0xQdXJwbGVcIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVyb09yYW5nZS5wbmdcIiwgaWQ6IFwiSGVyb09yYW5nZVwifSxcclxuXHRcdFx0e3NyYzogXCJIZXJvTEIucG5nXCIsIGlkOiBcIkhlcm9MaWdodEJsdWVcIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVyb0xHLnBuZ1wiLCBpZDogXCJIZXJvTGlnaHRHcmVlblwifSxcclxuXHRcdFx0e3NyYzogXCJIZXJvR3JlZW4ucG5nXCIsIGlkOiBcIkhlcm9HcmVlblwifSxcclxuICAgICAgICAgICAge3NyYzogXCJwaXp6YS5wbmdcIiwgaWQ6IFwicGl6emFcIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVhZEdyZWVuLnBuZ1wiLCBpZDogXCJIZWFkR3JlZW5cIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVhZEJsdWUucG5nXCIsIGlkOiBcIkhlYWRCbHVlXCJ9LFxyXG5cdFx0XHR7c3JjOiBcIkhlYWRMaWdodEJsdWUucG5nXCIsIGlkOiBcIkhlYWRMaWdodEJsdWVcIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVhZE9yYW5nZS5wbmdcIiwgaWQ6IFwiSGVhZE9yYW5nZVwifSxcclxuXHRcdFx0e3NyYzogXCJIZWFkTGlnaHRHcmVlbi5wbmdcIiwgaWQ6IFwiSGVhZExpZ2h0R3JlZW5cIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVhZFB1cnBsZS5wbmdcIiwgaWQ6IFwiSGVhZFB1cnBsZVwifSxcclxuXHRcdFx0e3NyYzogXCJIZWFkUGluay5wbmdcIiwgaWQ6IFwiSGVhZFBpbmtcIn0sXHJcblx0XHRcdHtzcmM6IFwiSGVhZFJlZC5wbmdcIiwgaWQ6IFwiSGVhZFJlZFwifSxcclxuXHJcblx0XHRcdFxyXG5cdFx0XTsgXHJcblx0XHQvLyBUT0RPIG1ha2UgYWRkaW5nIHJlc291cmNlcyBlYXNpZXI/IEF1dG9tYXRpYyBsb2FkaW5nIFxyXG5cdFx0Ly8gb2YgZXZlcnl0aGluZyBmcm9tIGFzc2V0cywgYXV0b21hdGljIG5hbWVzIGV0Yy4/XHJcblxyXG5cdHRoaXMuc2hhcGVzID0ge307IC8vIG1heWJlIHRoaXMgYXJlbid0IG5lZWRlZFxyXG5cclxuXHR0aGlzLmJpdG1hcHMgPSB7fTtcclxuXHJcblx0dGhpcy5hbmltYXRpb25zID0ge307XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBc3NldE1vZGVsO1xyXG4iLCJ2YXIgRW50aXR5TW9kZWwgPSBmdW5jdGlvbigpe1x0XHJcblx0Ly8gYXNzb2NpYXRlcyB0eXBlIHdpdGggdGhlIEFJXHJcblx0dGhpcy50eXBlX3RvX0FJID0ge307XHJcblxyXG5cdHRoaXMuZm9yX2xvZ2ljX3VwZGF0ZSA9IHt9OyAvLyBrZXk6IHR5cGUsIHZhbHVlOiB0YWJsZSBvZiBvYmplY3RzIHdpdGggaWQgZm9yIGtleSwgb2JqZWN0IGZvciB2YWx1ZVxyXG5cdFxyXG5cdFxyXG5cdHRoaXMuaGVyb19zcGF3bmVkID0gZmFsc2U7XHJcblxyXG5cdC8vIGFzc2ljaWF0ZXMgcGxheWVyIG5ldHdvcmsgaWQgd2l0aCB0aGUgaGVybyBlbnRpdHkgaW5zdGFuY2VcclxuXHR0aGlzLmhlcm9lcyA9IHt9O1xyXG5cclxuXHQvLyBsYXN0IHZlbG9jaXR5IGZvciBteSBoZXJvXHJcblx0Ly8gdXNlZCB0byBjaGVjayBob3cgbXVjaCB2ZWxvY2l0eSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpY2tcclxuXHR0aGlzLmhlcm9fbGFzdF92ZWxvY2l0eSA9IHt4OiAwLCB5OiAwfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IEVudGl0eU1vZGVsO1xyXG5cclxuIiwidmFyIEdhbWVNb2RlbCA9IG5ldyBmdW5jdGlvbigpeyAvLyBtYWluIG1vZGVsXHJcbiAgICB0aGlzLnBhdXNlQ291bnRlciA9IDA7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVNb2RlbDtcclxuIiwidmFyIEdyYXBoaWNzTW9kZWwgPSBmdW5jdGlvbigpe1xyXG5cdHRoaXMuc3RhZ2U7IC8vIG1haW4gc3RhZ2UgdG8gd2hlcmUgZXZlcnl0aGluZyB3aWxsIGJlIGRyYXduXHJcblx0Ly8gbm90ZSB0aGF0IGV2ZXJ5IGdyYXBoaWNzIG9iamVjdCBtdXN0IGJlIGF1Z21lbnRlZCB3aXRoXHJcblx0Ly8gdGhlIHJlZmVyZW5jZSB0byB0aGUgY29ycmVzcG9uZGluZyBwaHlzaWNzIG9iamVjdCwgaWYgYW55XHJcblx0dGhpcy5vdGhlcl9wbGF5ZXJzID0gW107IC8vIGFycmF5IG9mIHBsYXllcnMgb3RoZXIgdGhlbiBoZXJvIGZvciBtdWx0aXBsYXllclxyXG5cclxuXHQvLyBhbGwgb2JqZWN0IHJlZ2lzdGVyZWQgZm9yIGNvbnRpbmlvdXMgdXBkYXRlIHRvIG1hdGNoIHRoZWlyIHBoeXNpY2FsIGJvZHlcclxuXHQvLyBwb3NpdGlvbiBcclxuXHR0aGlzLmFsbF9waHlzaWNhbCA9IHt9OyBcclxuXHR0aGlzLnNwZWNpYWxfcmVuZGVyID0ge307IC8vIG1hdGNoZXMgdHlwZSB3aXRoIGFycmF5IG9mIGFsbCBvYmplY3RzIG9mIHRoYXQgdHlwZSB0byBiZSByZW5kZXJlZFxyXG5cclxuXHQvLyBhbGwgc3ByaXRlc2hlZXQgZGVmaW5pdGlvbnMgKGFkZGVkIGF0IHRoZSBpbml0aWFsaXphdGlvbiBzdGFnZVxyXG5cdC8vIGJlY2F1c2UgdGhleSBuZWVkIGFzc2V0cyB0byBiZSBsb2FkZWQpXHJcblx0dGhpcy5zcHJpdGVzaGVldHMgPSB7fTsgXHJcblxyXG5cdHRoaXMuY2FtZXJhID0ge1xyXG5cdFx0Ly8gc2hvdWxkIGJlIGVhc2VsanMgb2JqZWN0IG9yIG51bGxcclxuXHRcdGZvbGxvd2luZzogbnVsbCxcclxuXHJcblx0XHQvLyBpbnRlcm5hbCBjYW1lcmEgaW1wbGVtZW50YXRpb24gdGhpbmcgdG8ga25vdyBob3cgZmFyIHRvIG9mZnNldCBmcm9tIHRoZVxyXG5cdFx0Ly8gaW5pdGlhbCBwb3NpdGlvblxyXG5cdFx0b2Zmc2V0OiB7eDogMCwgeTogMH0sXHJcblxyXG5cdFx0Ly8gdGhlIG9mZnNldCBvZiB0aGUgY2FtZXJhIGZyb20gdGhlIGZvbGxvd2VkIG9iamVjdFxyXG5cdFx0Ly8gZS5nLiBvZmZzZXQgb2Yge3g6IDEwMCwgeTogMTAwfSB3aWxsIGNlbnRlciBjYW1lcmFcclxuXHRcdC8vIDEwMCBwaXhlbHMgdG8gdGhlIHJpZ2h0IGFuZCAxMDAgcGl4ZWxzIGJlbG93IHRoZSBmb2xsb3dlZCBvYmplY3RcclxuXHRcdG9mZnNldF9mcm9tX2ZvbGxvd2VkOiB7IHg6IDQwMCwgeTogLTEwMCB9LFxyXG5cdFx0Ly9vZmZzZXRfZnJvbV9mb2xsb3dlZDoge3g6IDMzMCwgeTogLTIwNX0sIC8vRk9SIEdBTUUgUEFHRVxyXG5cdFx0Ly8gdGhpcyBpcyBjZW50ZXIgb2YgdGhlIHNjcmVlbiBpbiBwaXhlbHMuIGdldHMgZHluYW1pY2FsbHkgcmVjYWxjdWxhdGVkIFxyXG5cdFx0Ly8gZHVyaW5nIHRoZSBjYW1lcmEgdXBkYXRlIHNvIGlmIGl0J3MgZXZlciBjaGFuZ2VkLCBjYW1lcmEgc3RpbGwgd29ya3MgYXMgZXhwZWN0ZWRcclxuXHRcdGNlbnRlcjoge3g6IDAsIHk6IDB9XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgR3JhcGhpY3NNb2RlbDtcclxuXHJcbiIsIlxyXG52YXIgSWRlbnRpZmljYXRpb25Nb2RlbCA9IGZ1bmN0aW9uKCl7XHJcblx0XHJcblx0Ly8gbmV4dCB1bmlxdWUgaWQgdG8gYmUgZ2l2ZW4gaWYgbm90IGZyZWUgaWQncyByZW1haW5cclxuXHR0aGlzLm5leHRfaWQgPSAwO1xyXG5cclxuXHQvLyBhcnJheSBvZiBmcmVlIGlkJ3MuIHB1c2ggd2hlbiBmcmVlZCwgcG9wIHdoZW4gZnJlZSBpZCBpcyBuZWVkZWRcclxuXHQvLyBpZiBhcnJheSBpcyBlbXB0eSwgZ2V0IG5leHQgaWQgdXNpbmcgPm5leHRfaWQ8XHJcblx0dGhpcy5mcmVlX2lkcyA9IFtdO1xyXG5cclxuXHQvLyBhcnJheSBtYXRjaGVzIGlkcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdHNcclxuXHR0aGlzLmlkX21hdGNoaW5nID0gW107XHJcblxyXG5cdC8vIHJlZ2lzdHJ5IG9mIHR5cGVzIHRvIG1ha2Ugc3VyZSB0aGF0IG5vIHR5cGUgaXMgcmVnaXN0ZXJkIHR3aWNlXHJcblx0Ly8gYW5kIGVuYWJsZSBwZW9wbGUgdG8gZ2V0IHRoZSBtb2RlbCBieSB0eXBlIG5hbWVcclxuXHR0aGlzLnR5cGVzID0ge31cclxuXHJcblx0Ly9saXN0IG9mIGhlcm9lcyBhbmQgY29tcGFuaW9ucyBzcGF3bmVkXHJcblx0dGhpcy5oZXJvO1xyXG5cdHRoaXMuY29tcGFuaW9ucyA9IFtdO1xyXG5cclxuXHR0aGlzLnJlc2VydmVkID0gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBJZGVudGlmaWNhdGlvbk1vZGVsO1xyXG5cclxuXHJcbiIsInZhciBLZXlib2FyZE1vZGVsID0gZnVuY3Rpb24oKXtcclxuXHJcblx0Ly8gb3duIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZVxyXG5cdHRoaXMua2V5cyA9IHtcclxuXHR9O1xyXG5cclxuXHR0aGlzLnN0YXRlX2NoYW5nZWQgPSBmYWxzZTtcclxuXHJcblx0Ly8gdGFibGUgb2YgYWxsIGtleXMgdGhhdCBoYXZlXHJcblx0Ly8gY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aWNrXHJcblx0Ly8ga2V5IGlzIGtleWNvZGUsIHZhbHVlIGlzIGJvb2xlYW5cclxuXHQvLyBpbmRpY2F0aW5nIHdoZXRoZXIga2V5IHdhcyBwcmVzc2VkIG9yIHJlbGVhc2VkXHJcblx0Ly8gVE9ETzogaW1wbGVtZW50O1xyXG5cdC8vIGlkZWEgaXMgdGhhdCBvbmx5IGNvbW1hbmRzIGZvciByZWxldmFudCB0YWJsZXMgd2lsbCBiZSBzZW50XHJcblx0Ly8gb3ZlcnNlYXNcclxuXHR0aGlzLmNoYW5nZWRfa2V5cyA9IHt9O1xyXG5cclxuXHQvLyBvd24ga2V5cyB0aGF0IHdlcmUgYWN0aXZlIHByZXZpb3VzIHRpY2tcclxuXHQvL3RoaXMub2xkX2tleXMgPSB7XHJcblx0Ly99O1xyXG5cclxuXHQvLyB0YWJsZSBvZiBuZXR3b3JrIHBsYXllciBpZHMgYXNzb2NpYXRlZFxyXG5cdC8vIHdpdGggdGhlIGxhc3QgcmVnaXN0ZXJlZCBzdGF0ZSBvZiB0aGVpciBrZXlib3JhZHNcclxuXHR0aGlzLmFsbF9rZXlib2FyZF9zdGF0ZXMgPSB7XHJcblx0fVxyXG5cclxuXHR0aGlzLnRyYW5zbGF0aW9uX3RhYmxlcyA9IHtcclxuXHRcdGNvZGVfdG9fbmFtZToge1xyXG5cdFx0XHQ4OiAgIFwiYmFja3NwYWNlXCIsIC8vICBiYWNrc3BhY2VcclxuXHRcdFx0OTogICBcInRhYlwiLCAvLyAgdGFiXHJcblx0XHRcdDEzOiAgXCJlbnRlclwiLCAvLyAgZW50ZXJcclxuXHRcdFx0MTY6ICBcInNoaWZ0XCIsIC8vICBzaGlmdFxyXG5cdFx0XHQxNzogIFwiY3RybFwiLCAvLyAgY3RybFxyXG5cdFx0XHQxODogIFwiYWx0XCIsIC8vICBhbHRcclxuXHRcdFx0MTk6ICBcInBhdXNlL2JyZWFrXCIsIC8vICBwYXVzZS9icmVha1xyXG5cdFx0XHQyMDogIFwiY2FwcyBsb2NrXCIsIC8vICBjYXBzIGxvY2tcclxuXHRcdFx0Mjc6ICBcImVzY2FwZVwiLCAvLyAgZXNjYXBlXHJcblx0XHRcdDMzOiAgXCJwYWdlIHVwXCIsIC8vIHBhZ2UgdXAsIHRvIGF2b2lkIGRpc3BsYXlpbmcgYWx0ZXJuYXRlIGNoYXJhY3RlciBhbmQgY29uZnVzaW5nIHBlb3BsZVxyXG5cdFx0XHQzNDogIFwicGFnZSBkb3duXCIsIC8vIHBhZ2UgZG93blxyXG5cdFx0XHQzNTogIFwiZW5kXCIsIC8vIGVuZFxyXG5cdFx0XHQzNjogIFwiaG9tZVwiLCAvLyBob21lXHJcblx0XHRcdDM3OiAgXCJsZWZ0IGFycm93XCIsIC8vIGxlZnQgYXJyb3dcclxuXHRcdFx0Mzg6ICBcInVwIGFycm93XCIsIC8vIHVwIGFycm93XHJcblx0XHRcdDM5OiAgXCJyaWdodCBhcnJvd1wiLCAvLyByaWdodCBhcnJvd1xyXG5cdFx0XHQ0MDogIFwiZG93biBhcnJvd1wiLCAvLyBkb3duIGFycm93XHJcblx0XHRcdDQ1OiAgXCJpbnNlcnRcIiwgLy8gaW5zZXJ0XHJcblx0XHRcdDQ2OiAgXCJkZWxldGVcIiwgLy8gZGVsZXRlXHJcblx0XHRcdDQ4OiAgXCIwXCIsXHJcblx0XHRcdDQ5OiAgXCIxXCIsXHJcblx0XHRcdDUwOiAgXCIyXCIsXHJcblx0XHRcdDUxOiAgXCIzXCIsXHJcblx0XHRcdDUyOiAgXCI0XCIsXHJcblx0XHRcdDUzOiAgXCI1XCIsXHJcblx0XHRcdDU0OiAgXCI2XCIsXHJcblx0XHRcdDU1OiAgXCI3XCIsXHJcblx0XHRcdDU2OiAgXCI4XCIsXHJcblx0XHRcdDU3OiAgXCI5XCIsXHJcblx0XHRcdDY1OiAgXCJhXCIsXHJcblx0XHRcdDY2OiAgXCJiXCIsXHJcblx0XHRcdDY3OiAgXCJjXCIsXHJcblx0XHRcdDY4OiAgXCJkXCIsXHJcblx0XHRcdDY5OiAgXCJlXCIsXHJcblx0XHRcdDcwOiAgXCJmXCIsXHJcblx0XHRcdDcxOiAgXCJnXCIsXHJcblx0XHRcdDcyOiAgXCJoXCIsXHJcblx0XHRcdDczOiAgXCJpXCIsXHJcblx0XHRcdDc0OiAgXCJqXCIsXHJcblx0XHRcdDc1OiAgXCJrXCIsXHJcblx0XHRcdDc2OiAgXCJsXCIsXHJcblx0XHRcdDc3OiAgXCJtXCIsXHJcblx0XHRcdDc4OiAgXCJuXCIsXHJcblx0XHRcdDc5OiAgXCJvXCIsXHJcblx0XHRcdDgwOiAgXCJwXCIsXHJcblx0XHRcdDgxOiAgXCJxXCIsXHJcblx0XHRcdDgyOiAgXCJyXCIsXHJcblx0XHRcdDgzOiAgXCJzXCIsXHJcblx0XHRcdDg0OiAgXCJ0XCIsXHJcblx0XHRcdDg1OiAgXCJ1XCIsXHJcblx0XHRcdDg2OiAgXCJ2XCIsXHJcblx0XHRcdDg3OiAgXCJ3XCIsXHJcblx0XHRcdDg4OiAgXCJ4XCIsXHJcblx0XHRcdDg5OiAgXCJ5XCIsXHJcblx0XHRcdDkwOiAgXCJ6XCIsXHJcblx0XHRcdDkxOiAgXCJsZWZ0IHdpbmRvd1wiLCAvLyBsZWZ0IHdpbmRvd1xyXG5cdFx0XHQ5MjogIFwicmlnaHQgd2luZG93XCIsIC8vIHJpZ2h0IHdpbmRvd1xyXG5cdFx0XHQ5MzogIFwic2VsZWN0IGtleVwiLCAvLyBzZWxlY3Qga2V5XHJcblx0XHRcdDk2OiAgXCJudW1wYWQgMFwiLCAvLyBudW1wYWQgMFxyXG5cdFx0XHQ5NzogIFwibnVtcGFkIDFcIiwgLy8gbnVtcGFkIDFcclxuXHRcdFx0OTg6ICBcIm51bXBhZCAyXCIsIC8vIG51bXBhZCAyXHJcblx0XHRcdDk5OiAgXCJudW1wYWQgM1wiLCAvLyBudW1wYWQgM1xyXG5cdFx0XHQxMDA6IFwibnVtcGFkIDRcIiwgLy8gbnVtcGFkIDRcclxuXHRcdFx0MTAxOiBcIm51bXBhZCA1XCIsIC8vIG51bXBhZCA1XHJcblx0XHRcdDEwMjogXCJudW1wYWQgNlwiLCAvLyBudW1wYWQgNlxyXG5cdFx0XHQxMDM6IFwibnVtcGFkIDdcIiwgLy8gbnVtcGFkIDdcclxuXHRcdFx0MTA0OiBcIm51bXBhZCA4XCIsIC8vIG51bXBhZCA4XHJcblx0XHRcdDEwNTogXCJudW1wYWQgOVwiLCAvLyBudW1wYWQgOVxyXG5cdFx0XHQxMDY6IFwibXVsdGlwbHlcIiwgLy8gbXVsdGlwbHlcclxuXHRcdFx0MTA3OiBcImFkZFwiLCAvLyBhZGRcclxuXHRcdFx0MTA5OiBcInN1YnRyYWN0XCIsIC8vIHN1YnRyYWN0XHJcblx0XHRcdDExMDogXCJkZWNpbWFsIHBvaW50XCIsIC8vIGRlY2ltYWwgcG9pbnRcclxuXHRcdFx0MTExOiBcImRpdmlkZVwiLCAvLyBkaXZpZGVcclxuXHRcdFx0MTEyOiBcIkYxXCIsIC8vIEYxXHJcblx0XHRcdDExMzogXCJGMlwiLCAvLyBGMlxyXG5cdFx0XHQxMTQ6IFwiRjNcIiwgLy8gRjNcclxuXHRcdFx0MTE1OiBcIkY0XCIsIC8vIEY0XHJcblx0XHRcdDExNjogXCJGNVwiLCAvLyBGNVxyXG5cdFx0XHQxMTc6IFwiRjZcIiwgLy8gRjZcclxuXHRcdFx0MTE4OiBcIkY3XCIsIC8vIEY3XHJcblx0XHRcdDExOTogXCJGOFwiLCAvLyBGOFxyXG5cdFx0XHQxMjA6IFwiRjlcIiwgLy8gRjlcclxuXHRcdFx0MTIxOiBcIkYxMFwiLCAvLyBGMTBcclxuXHRcdFx0MTIyOiBcIkYxMVwiLCAvLyBGMTFcclxuXHRcdFx0MTIzOiBcIkYxMlwiLCAvLyBGMTJcclxuXHRcdFx0MTQ0OiBcIm51bSBsb2NrXCIsIC8vIG51bSBsb2NrXHJcblx0XHRcdDE0NTogXCJzY3JvbGwgbG9ja1wiLCAvLyBzY3JvbGwgbG9ja1xyXG5cdFx0XHQxODY6IFwiO1wiLCAvLyBzZW1pLWNvbG9uXHJcblx0XHRcdDE4NzogXCI9XCIsIC8vIGVxdWFsLXNpZ25cclxuXHRcdFx0MTg4OiBcIixcIiwgLy8gY29tbWFcclxuXHRcdFx0MTg5OiBcIi1cIiwgLy8gZGFzaFxyXG5cdFx0XHQxOTA6IFwiLlwiLCAvLyBwZXJpb2RcclxuXHRcdFx0MTkxOiBcIi9cIiwgLy8gZm9yd2FyZCBzbGFzaFxyXG5cdFx0XHQxOTI6IFwiYFwiLCAvLyBncmF2ZSBhY2NlbnRcclxuXHRcdFx0MjE5OiBcIltcIiwgLy8gb3BlbiBicmFja2V0XHJcblx0XHRcdDIyMDogXCJcXFxcXCIsIC8vIGJhY2sgc2xhc2hcclxuXHRcdFx0MjIxOiBcIl1cIiwgLy8gY2xvc2UgYnJhY2tldFxyXG5cdFx0XHQyMjI6IFwiJ1wiLCAvLyBzaW5nbGUgcXVvdGVcclxuXHRcdH0sXHJcblxyXG5cdFx0bW92ZW1lbnQ6IHtcclxuXHRcdFx0XCJsZWZ0IGFycm93XCI6IFwibGVmdFwiLFxyXG5cdFx0XHRcInVwIGFycm93XCI6IFwidXBcIixcclxuXHRcdFx0XCJkb3duIGFycm93XCI6IFwiZG93blwiLFxyXG5cdFx0XHRcInJpZ2h0IGFycm93XCI6IFwicmlnaHRcIixcclxuXHRcdH0sXHJcblxyXG5cdFx0cGF1c2U6IHtcclxuXHRcdCAgICBcInBcIjogXCJwYXVzZVwiLFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0ZGVidWc6IHtcclxuXHRcdFx0XCJhXCI6IFwic3Bhd25fYW50XCIsXHJcblx0XHRcdFwibVwiOiBcInNwYXduX21lZHVzYVwiLFxyXG4gICAgICAgICAgICBcInRcIjogXCJzcGF3bl9jZW50YXVyXCIsXHJcblx0XHRcdFwielwiOiBcInNlYXNvblwiLFxyXG5cdFx0XHRcImdcIjogXCJzcGF3bl9ncmlmZmluXCIsXHJcblx0XHRcdFwic1wiOiBcIm5ld19zbGljZVwiLFxyXG5cdFx0XHRcImhcIjogXCJzcGF3bl9oeWVuYVwiLFxyXG5cdFx0XHRcImNcIjogXCJjb25uZWN0XCIsXHJcblx0XHRcdFwidlwiOiBcInJlcXVlc3RfaGVyb1wiLFxyXG5cdFx0XHRcImlcIjogXCJzaG93X2lkc1wiLFxyXG4gICAgICAgICAgICBcImtcIjogXCJzcGF3bl9waXp6YVwiLFxyXG5cdFx0fSxcclxuXHJcblx0fVxyXG5cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBLZXlib2FyZE1vZGVsO1xyXG5cclxuIiwidmFyIE11bHRpcGxheWVyU3luY01vZGVsID0gZnVuY3Rpb24oKXtcclxuXHR0aGlzLmhlcm8gPSBudWxsO1xyXG5cclxuXHR0aGlzLm9wX3BhY2tldHNfdGFibGUgPSB7fTtcclxuXHRcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IE11bHRpcGxheWVyU3luY01vZGVsO1xyXG5cclxuXHJcbiIsInZhciBOZXR3b3JrTW9kZWwgPSBmdW5jdGlvbigpe1xyXG5cdHRoaXMuY29ubmVjdGVkID0gZmFsc2U7IC8vIGZsYWcgdG8gaW5kaWNhdGUgaWYgYWxyZWFkeSBjb25uZWN0ZWQgdG8gdGhlIG5ldHdvcmtcclxuXHJcblx0Ly8gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRvIGRpc2FsbG93IGNvbm5lY3Rpb25zLCB1c2VmdWwgdG8gcHJldmVudFxyXG5cdC8vIG1vcmUgYXR0ZW1wdHMgdG8gY29ubmVjdCB3aGVuIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBiZWluZyBlc3RhYmxpc2hlZFxyXG5cdHRoaXMuYmxvY2tfY29ubmVjdGlvbnM7IFxyXG5cclxuXHR0aGlzLm15X3BlZXIgPSBudWxsO1xyXG5cdHRoaXMubXlfaWQgPSBudWxsO1xyXG5cclxuXHR0aGlzLm1hc3Rlcl9pZCA9IG51bGw7IC8vIGlkIG9mIHRoZSBtYXN0ZXIgd2l0aCB3aG9tZSBldmVyeW9uZSBzeW5jZXNcclxuXHJcblx0Ly8gdGhpcyBpcyBmb3Igc3RhbmRhcnQgKG5vbi10ZXN0KSBtb2RlXHJcblx0Ly8gSSBwbGFuIHRvIG1ha2UgdGVzdCBtb2RlIHVzZSB0aGlzIHRvbywgZXZlbnR1YWxseVxyXG5cdHRoaXMucGVlcnNfdG9fY29ubmVjdCA9IG51bGw7XHJcblx0XHJcblxyXG5cdC8vIHBsYXllcl9pZCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbm5lY3Rpb24gb2JqZWN0XHJcblx0dGhpcy5jb25uZWN0aW9ucyA9IHt9O1xyXG5cclxuXHR0aGlzLnNlbmRfYXJyYXkgPSBudWxsO1xyXG5cdHRoaXMucmVjaWV2ZV9hcnJheSA9IG51bGw7XHJcblxyXG5cdHRoaXMub25lX3BhY2tldCA9IG51bGw7IC8vIHVzZWQgdG8gc3RvcmUgb25lIHBhY2tldCwgZm9yIG9uZSBwYWNrZXQgY29tbXVuaWNhdGlvblxyXG5cclxuXHR0aGlzLmlucHV0X2NlbGwgPSBudWxsO1xyXG5cdHRoaXMub3V0cHV0X2NlbGwgPSBudWxsO1xyXG5cdHRoaXMuY291bnRlciA9IDA7IC8vIHRlbXBcclxuXHJcblx0Ly8gbGlua2VkIGxpc3QgdG8gc3RvcmUgdGhlIGJhY2tsb2cgb2YgcGFja2V0cyBmb3IgdGhlIGNvbW11bmljYXRpb24gdGhhdCBuZWVkcyB0aGF0XHJcblx0dGhpcy5wYWNrYWdlX2JhY2tsb2cgPSB7SEVBRDogbnVsbCwgVEFJTDogbnVsbH0gXHJcblxyXG5cdHRoaXMud2FpdGluZ19mb3JfaW5pdGlhbF9zeW5jID0gW107IC8vIGxpc3Qgb2YgcGxheWVycyB3YWl0aW5nIHRvIHN5bmMgd2l0aCBtYXN0ZXJcclxuXHJcblx0Ly8gVElNRSBcclxuXHRcdHRoaXMuYmVnaW5fdGltZSA9IG51bGw7IC8vIHNlY29uZHNcclxuXHRcdHRoaXMudGltZW91dF9pZCA9IG51bGw7XHJcblx0Ly8gRU5EIFRJTUVcclxuXHRcclxuXHQvLyBURVNUSU5HIE1PREUgU1RVRkYuIFNIT1VMRCBCRSBNRVJHRUQgV0lUSCBHRU5FUkFMIFNUVUZGIElGIFBPU1NJQkxFXHJcblx0XHJcblx0dGhpcy5ub25fZnJlZV9pZHMgPSBbXHJcblx0XTtcclxuXHJcblx0dGhpcy5mcmVlX2lkcyA9IFtcclxuXHRdO1xyXG5cclxuXHQvLyBFTkQgVEVTVElORyBNT0RFIFNUVUZGXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgTmV0d29ya01vZGVsO1xyXG5cclxuXHJcbiIsIlxyXG52YXIgUGh5c2ljc01vZGVsID0gZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0dGhpcy5ncmF2aXR5O1xyXG5cdHRoaXMud29ybGQ7XHJcbiBcclxuXHQvLyBnZXR0aW5nIGNvbnRleHQgb2YgdGhlIGRlYnVnIGNhbnZhcywgZm9yIGJveDJkIHRvIGRyYXcgZGVidWdnaW4gYm94ZXNcclxuXHJcblx0Ly8gdGltZVRvQ292ZXIgaXMgdGhlIHRpbWUgdGhhdCBzaW11bGF0aW9uIG11c3QgY292ZXIgdG8gY2F0Y2ggdXAgdG8gdGhlIHJlYWwgd29ybGQgdGltZTtcclxuXHQvLyBzaW5jZSBjcmVhdGVqcyB0aWNrZXIgaXMgd2hhdCB3ZSB1c2UgZm9yIHRpbWluZywgYW5kIGJveDJkIHRpY2tzXHJcblx0Ly8gbXVzdCBiZSBvZiBjb25zdGFudCBsZW5ndGggYW5kIGluZGVwZW5kZW50IGZyb20gdGhlIGdyYXBoaWNzIGZyYW1lcmF0ZSxcclxuXHQvLyB3ZSBrZWVwIHRyYWNrIG9mIHRpbWUgdGhhdCBwYXNzZWQgc2luY2UgbGFzdCBib3gyZCBzdGVwIGJ5IGFkZGluZyB0aW1lIGRlbHRhc1xyXG5cdC8vIHRvIHRoZSB0aW1lVG9Db3Zlci4gVGhlbiwgd2hlbiB0aW1lVG9Db3ZlciBleGNlZWRzIGRlc2lyZWQgYm94MmQgc3RlcCBsZW5ndGgsXHJcblx0Ly8gd2UgcGVyZm9ybSB0aGUgc3RlcCBhbmQgc3VidHJhY3QgdGhlIGNvcnJlc3BvbmRpbmcgdGltZSBmcm9tIHRoZSB0aW1lVG9Db3ZlcjtcclxuXHQvLyBJZiBhbnl0aGluZyBpcyBzdGlsbCB1bmNsZWFyLCBhc2sgbWUgKEFLKTtcclxuXHRcdHRoaXMudGltZVRvQ292ZXIgPSAwOyBcclxuXHJcblx0dGhpcy5zdGVwX2Ftb3VudDtcclxuXHJcblx0dGhpcy5hd2FpdGluZ19jb250YWN0ID0ge1xyXG5cdFx0UHJlU29sdmU6IHt9LFxyXG5cdFx0UG9zdFNvbHZlOiB7fSxcclxuXHRcdEJlZ2luQ29udGFjdDoge30sXHJcblx0XHRFbmRDb250YWN0OiB7fSxcclxuXHR9O1xyXG5cclxufTsgXHJcblxyXG4vKlxyXG4gKiBQYXJhbWV0ZXJzIGZvciBiMmQgYm9keSBkZWZpbml0aW9uXHJcblx0YWN0aXZlOiB0cnVlXHJcblx0YWxsb3dTbGVlcDogdHJ1ZVxyXG5cdGFuZ2xlOiAwXHJcblx0YW5ndWxhckRhbXBpbmc6IDBcclxuXHRhbmd1bGFyVmVsb2NpdHk6IDBcclxuXHRhd2FrZTogdHJ1ZVxyXG5cdGJ1bGxldDogZmFsc2VcclxuXHRmaXhlZFJvdGF0aW9uOiBmYWxzZVxyXG5cdGluZXJ0aWFTY2FsZTogMVxyXG5cdGxpbmVhckRhbXBpbmc6IDBcclxuXHRsaW5lYXJWZWxvY2l0eTogYjJWZWMyXHJcblx0cG9zaXRpb246IGIyVmVjMlxyXG5cdHR5cGU6IDBcclxuXHR1c2VyRGF0YTogbnVsbFxyXG4qL1xyXG5cclxuLypcclxuICogRml4dHVyZSBkZWZpbml0aW9uIHBhcmFtZXRlcnM6XHJcblx0ZGVuc2l0eTogMFxyXG5cdGZpbHRlcjogYjJGaWx0ZXJEYXRhXHJcblx0ZnJpY3Rpb246IDAuMlxyXG5cdGlzU2Vuc29yOiBmYWxzZVxyXG5cdHJlc3RpdHV0aW9uOiAwXHJcblx0c2hhcGU6IG51bGxcclxuXHR1c2VyRGF0YTogbnVsbFxyXG4gKi9cclxuXHJcbi8vIHJlY3Rhbmd1bGFyXHJcblBoeXNpY3NNb2RlbC5wcm90b3R5cGUucl90ZW1wbGF0ZXMgPSByX3RlbXBsYXRlcyA9IHt9O1xyXG4vLyBjaXJjdWxhclxyXG5QaHlzaWNzTW9kZWwucHJvdG90eXBlLmNfdGVtcGxhdGVzID0gY190ZW1wbGF0ZXMgPSB7fTtcclxuLy8gcG9seWdvbmFsXHJcblBoeXNpY3NNb2RlbC5wcm90b3R5cGUucF90ZW1wbGF0ZXMgPSBwX3RlbXBsYXRlcyA9IHt9O1xyXG5cclxuXHJcblxyXG5yX3RlbXBsYXRlc1tcImRlZmF1bHRcIl0gPSB7XHJcblxyXG5cdC8vc2hhcGU6IFwicmVjdGFuZ2xlXCIsIC8vIGltcGxpZWQgZnJvbSB0aGUgdGVtcGxhdGUgdHlwZVxyXG5cdHg6IDMsXHJcblx0eTogMyxcclxuXHR2eDogMCxcclxuXHR2eTogMCxcclxuXHJcblx0d2lkdGg6IDUsXHJcblx0aGVpZ2h0OiA1LFxyXG5cdGRlbnNpdHk6IDIsXHJcblx0ZnJpY3Rpb246IDEsXHJcblx0cmVzdGl0dXRpb246IDAuMixcclxuXHRpc1NlbnNvcjogZmFsc2UsXHJcblxyXG5cclxuXHRhY3RpdmU6IHRydWUsXHJcblx0YWxsb3dTbGVlcDogdHJ1ZSxcclxuXHRhbmdsZTogMCxcclxuXHRhbmd1bGFyVmVsb2NpdHk6IDAsXHJcblx0YXdha2U6IHRydWUsXHJcblx0YnVsbGV0OiBmYWxzZSxcclxuXHRmaXhlZFJvdGF0aW9uOiBmYWxzZSxcclxuXHR0eXBlOiBcImR5bmFtaWNcIixcclxuXHJcbn07XHJcblxyXG5yX3RlbXBsYXRlcy5saXZpbmcgPSB7XHJcblx0Zml4ZWRSb3RhdGlvbjogdHJ1ZSxcclxuXHRhd2FrZTogdHJ1ZSxcclxuXHRpc1NlbnNvcjogZmFsc2UsXHJcblx0Ly9tb2JleHArK1xyXG59O1xyXG5cclxucl90ZW1wbGF0ZXMudGVycmFpbl9jZWxsID0ge1xyXG5cdHR5cGU6IFwic3RhdGljXCIsXHJcblx0d2lkdGg6IDEsXHJcblx0aGVpZ2h0OiAxLFxyXG5cdGZyaWN0aW9uOiAyLFxyXG5cdC8vbW9iZXhwKytcclxufTtcclxuXHJcbnJfdGVtcGxhdGVzLmhlcm8gPSB7XHJcblx0cGFyZW50OiByX3RlbXBsYXRlcy5saXZpbmcsXHJcblx0d2lkdGg6IDAuOSxcclxuXHRoZWlnaHQ6IDEuNyxcclxuXHRkZW5zaXR5OiA0LjUsXHJcblx0dHlwZTogXCJkeW5hbWljXCIsXHJcblx0Ly9tb2JleHArK1xyXG59O1xyXG5cclxucl90ZW1wbGF0ZXMuY29tcGFuaW9uID0ge1xyXG5cdHBhcmVudDogcl90ZW1wbGF0ZXMubGl2aW5nLFxyXG5cdHdpZHRoOiAxLjUsXHJcblx0aGVpZ2h0OiAyLjUsXHJcblx0dHlwZTogXCJkeW5hbWljXCIsXHJcblx0Ly9tb2JleHArK1xyXG59O1xyXG5cclxucl90ZW1wbGF0ZXMuYW50ID0ge1xyXG5cdHBhcmVudDogcl90ZW1wbGF0ZXMubGl2aW5nLFxyXG5cdHdpZHRoOiAxLFxyXG5cdGhlaWdodDogMC41LFxyXG5cdHR5cGU6IFwiZHluYW1pY1wiLFxyXG5cdHg6IDQwLFxyXG5cdHk6IDEwLFxyXG5cdC8vbW9iZXhwKytcclxufTtcclxuXHJcbnJfdGVtcGxhdGVzLkdyaWZmaW4gPSB7XHJcblx0cGFyZW50OiByX3RlbXBsYXRlcy5saXZpbmcsXHJcblx0d2lkdGg6IDIuOCxcclxuXHRoZWlnaHQ6IDIuNSxcclxuXHR0eXBlOiBcImR5bmFtaWNcIixcclxuXHR4OiA5NSxcclxuXHR5OiA1MCxcclxuXHQvL21vYmV4cCsrXHJcbn07XHJcblxyXG5yX3RlbXBsYXRlcy5IeWVuYSA9IHtcclxuXHRwYXJlbnQ6IHJfdGVtcGxhdGVzLmxpdmluZyxcclxuXHR3aWR0aDogMi4yNSxcclxuXHRoZWlnaHQ6IDEuNzUsXHJcblx0dHlwZTogXCJkeW5hbWljXCIsXHJcblx0eDogNjUsXHJcblx0eTogMTAsXHJcblx0Ly9tb2JleHArK1xyXG59O1xyXG5cclxucl90ZW1wbGF0ZXMuTWVkdXNhID0ge1xyXG4gICAgcGFyZW50OiByX3RlbXBsYXRlcy5saXZpbmcsXHJcbiAgICB3aWR0aDogMS40LFxyXG4gICAgaGVpZ2h0OiAyLjgsXHJcbiAgICB0eXBlOiBcImR5bmFtaWNcIixcclxuICAgIHg6IDY1LFxyXG4gICAgeTogMTAsXHJcbn07XHJcblxyXG5yX3RlbXBsYXRlcy5DZW50YXVyID0ge1xyXG4gICAgcGFyZW50OiByX3RlbXBsYXRlcy5saXZpbmcsXHJcbiAgICB3aWR0aDogMi4yLFxyXG4gICAgaGVpZ2h0OiAzLjQsXHJcbiAgICB0eXBlOiBcImR5bmFtaWNcIixcclxuICAgIHg6IDY1LFxyXG4gICAgeTogMTAsXHJcbn07XHJcblxyXG5yX3RlbXBsYXRlcy50ZXN0ID0ge1xyXG5cdHdpZHRoOiAxLFxyXG5cdGhlaWdodDogMixcclxuXHRmaXhlZFJvdGF0aW9uOiBmYWxzZSxcclxuXHQvL21vYmV4cCsrXHJcbn1cclxuXHJcbnJfdGVtcGxhdGVzLnBsYXRmb3JtID0ge1xyXG4gICAgeDogMTAsXHJcbiAgICB5OiAxMSxcclxuICAgIHdpZHRoOiAxMCxcclxuICAgIGhlaWdodDogLjUsXHJcbiAgICB0eXBlOiBcInN0YXRpY1wiLFxyXG59XHJcblxyXG5yX3RlbXBsYXRlcy5waXp6YSA9IHtcclxuICAgIGlzU2Vuc29yOiB0cnVlLFxyXG4gICAgdHlwZTogXCJzdGF0aWNcIixcclxuICAgIGhlaWdodDogLjUsXHJcbiAgICB3aWR0aDogLjUsXHJcbiAgICB4OiAxMCxcclxuICAgIHk6IDExLFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBQaHlzaWNzTW9kZWw7XHJcbiIsInZhciBSZWdpc3RlckFzTW9kZWwgPSBmdW5jdGlvbigpe1xyXG5cdFxyXG5cdC8vIHJlZ2lzdGVyIHN0dWZmIGZvciBvbmUgdGltZSBsb29rdXBcclxuXHQvLyB0aGUgb25lIHJlcXVlc3Rpbmcgc3R1ZmYgaXMgc3VwcG9zZWQgdG8gcG9wIHRoZSBlYWNoIGV4YW1pbmVkIGVsZW1lbnRcclxuXHQvLyB0aGVyZSBpcyBubyB0aW1lb3V0cyBvciBhdXRvbWF0aWMgY2xlYW51cFxyXG5cdHRoaXMuc2ltcGxlX29uZV90aW1lX2xvb2t1cCA9IHt9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgUmVnaXN0ZXJBc01vZGVsO1xyXG5cclxuIiwidmFyIFRlcnJhaW5Nb2RlbCA9IGZ1bmN0aW9uKCl7XHJcblx0Ly9UaGlzIGlzIHBoeXNpY3MsIGZvciBncmFwaGljcyBsb29rIGludG8gdGhlIEdyYXBoaWNzQ29udHJvbGxlci9Nb2RlbFxyXG5cdHRoaXMudGVycmFpbl9zbGljZXNfcXVldWUgPSBbXTtcclxuXHQvL3RoaXMubmV3X3NsaWNlcyA9IFtdO1xyXG5cdHRoaXMuc2VlZDtcclxuXHJcblx0Ly8gaG93IG1hbnkgaW5pdGlhbCAobm9uLXJhbmRvbSkgdGVycmFpbiBzbGljZXNcclxuXHQvLyB3ZXJlIGdlbmVyYXRlZCBhbHJlYWR5P1xyXG5cdHRoaXMuaW5pdGlhbF9nZW5lcmF0ZWQgPSAwO1xyXG5cclxuXHJcblx0Ly8gdXNlZCB0byBkZXRlcm1pbmUgeCBvZmZzZXQgb2YgdGhlIG5leHQgc2xpY2VcclxuXHQvLyBUT0RPOiB1cGRhdGUgdGhpcyB3aGVuIHRydWx5IGluZmluaXRlIHRlcnJhaW4gd2lsbCBiZSBpbXBsZW1lbnRlZFxyXG5cdHRoaXMuc2xpY2VfY291bnRlciA9IDA7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVGVycmFpbk1vZGVsO1xyXG4iLCJUZXJyYWluU2xpY2VDb25maWcgPSByZXF1aXJlIChcIi4uL0NvbmZpZy5qc1wiKS5UZXJyYWluU2xpY2U7XHJcblxyXG52YXIgVGVycmFpblNsaWNlTW9kZWwgPSBmdW5jdGlvbigpe1xyXG5cclxuXHR0aGlzLlNsaWNlID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qKlxyXG5cdFx0KiBzbGljZSBcIm1vZGVsXCIgdG8gYmUgaW5zdGFudGlhdGVkXHJcblx0XHQqL1xyXG5cdFx0XHJcblx0XHRcclxuXHRcdHRoaXMubnVtID0gVGVycmFpblNsaWNlQ29uZmlnLm5leHRfc2xpY2VfaWQrKzsgLy8gYXV0b21hdGljYWxsIGFzc2lnbiBpZCBhbmQgaW5jcmVtZW50IFxyXG5cclxuXHRcdHRoaXMuZ3JpZF9jb2x1bW5zID0gVGVycmFpblNsaWNlQ29uZmlnLmdyaWRfY29sdW1ucztcclxuXHRcdHRoaXMuZ3JpZF9yb3dzID0gVGVycmFpblNsaWNlQ29uZmlnLmdyaWRfcm93cztcclxuXHRcdHRoaXMuY2VsbF93ID0gVGVycmFpblNsaWNlQ29uZmlnLmNlbGxfdztcclxuXHRcdHRoaXMuY2VsbF9oID0gdGhpcy5jZWxsX3c7O1xyXG5cdFx0XHJcblx0XHQvLyBncmlkW2ldW2pdIGlzIHRoZSBlbGVtZW50IGluIHRoZSBpJ3MgY29sdW1uIGFuZCBqJ3Mgcm93XHJcblx0XHQvLyB0aGUgZ3JpZCBpcyBtYWlkIHRvIG1hdGNoIHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYW5kIHRoZSBjdXJyZW50IGJveDJkIGNvb3JkaW5hdGVzXHJcblx0XHQvLyBpLmUuIGdyaWRbMF1bMF0gaXMgdGhlIG9uZSBpbiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXJyYWluIHNsaWNlXHJcblx0XHQvLyBkbyB3ZSB3YW50IHRvIGNoYW5nZSBpdD8gd291bGQgaXQgYmUgZWFzaWVyIHRvIGdlbmVyYXRlIHRlcnJhaW4gaWYgd2Ugc3RhcnQgYXQgdGhlIGJvdHRvbT9cclxuXHRcdC8vIGlmIHllcywgdGhlbiB3aGF0IG1ha2VzIG1vcmUgc2Vuc2UsIGNoYW5naW5nIGNvb3JkaW5hdGUgc3lzdGVtcyBvciBqdXN0IHN3aXRjaGluZyBnZW5lcmF0aW9uXHJcblx0XHQvLyBsb29wcyBhcm91bmQ/IGRpc2N1c3NcclxuXHRcdC8vXHJcblx0XHQvLyBub3RpY2UgdGhhdCB0aGUgZ3JpZCBpcyBhIHRlcnJhaW4gZ2VuZXJhdGlvbiBkZXZpY2Ugb25seS4gb25jZSB0ZXJyYWluIHNsaWNlIGlzIGxvYWRlZCxcclxuXHRcdC8vIGJveDJkIHBoeXNpY3Mgc2ltdWxhdGlvbiBtYXkgKGFuZCB3aWxsKSBnbyBudXRzIG9uIGl0LCBjaGFuZ2luZyB3aGF0ZXZlciBpdCB3YW50cyxcclxuXHRcdC8vIGFuZCBjaGFuZ2VzIHdvbid0IGFueWhvdyBiZSByZWZsZWN0ZWQgaW4gdGhlIGdyaWQuIHRvIGtlZXAgdHJhY2sgb2YgYWxsIHRoZSBib2RpZXNcclxuXHRcdC8vIGluIHRoZSB0ZXJyYWluIHNsaWNlLCBpZiB0aGF0IHdpbGwgYmUgbmVlZGVkLCBvdGhlciBtZWNoYW5pc21zIHNob3VsZCBiZSB1c2VkLlxyXG5cdFx0Ly8gaWRlYTogaGF2ZSBhIGNvbGxlY3Rpb25zIG9mIGJvZGllcyBieSB0eXBlLCBhbmQgc2V0dXAgc2Vuc29yIGNvbGxpc2lvbiBiZWFtc1xyXG5cdFx0Ly8gYXQgdGhlIHRlcnJhaW4gc2xpY2VzJyBib3VuZGFyaWVzIHRvIGtlZXAgdHJhY2sgb2YgYm9kaWVzIGZseWluZyBvdmVyIGZyb20gb25lXHJcblx0XHQvLyB0ZXJyYWluIHNsaWNlIHRvIGFub3RoZXIuIEJ0dywgQWxpLCBJIGhhdGUgeW91IGZvciBtYWtpbmcgbWUgdG8gdHlwZSBcInRlcnJhaW4gc2xpY2VcIlxyXG5cdFx0Ly8gaW5zdGVhZCBvZiB0aGUgXCJjaHVua1wiIFxyXG5cdFx0dGhpcy5ncmlkID0gW107XHJcblx0XHRcclxuXHRcdHRoaXMub3JpZ2luID0ge3g6IG51bGwsIHk6IG51bGx9O1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLkNlbGwgPSBmdW5jdGlvbihraW5kKXtcclxuXHRcdHRoaXMua2luZCA9IGtpbmQ7XHJcblx0XHR0aGlzLmJvZHk7XHJcblx0fVxyXG5cclxuXHRcclxufTtcclxuXHJcblRlcnJhaW5TbGljZU1vZGVsLnByb3RvdHlwZS5sdmxfcHJvYiA9IFtcclxuXHRbNywgMiwgMV0sXHJcblx0WzAsIDcsIDNdLFxyXG5cdFswLCAxLCA5XVxyXG5dXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUZXJyYWluU2xpY2VNb2RlbDtcclxuIiwidmFyIFRlc3RNb2RlbCA9IGZ1bmN0aW9uKCl7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVGVzdE1vZGVsO1xyXG5cclxuIiwidmFyIFdvcmxkTW9kZWwgPSBmdW5jdGlvbigpe1xyXG5cdFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgV29ybGRNb2RlbDtcclxuXHJcbiIsInZhciBBbnRSZW5kZXJlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgc3ByaXRlc2hlZXRzID0ge307XHJcblx0dmFyIGFudF9hbmltYXRpb247XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIGlzIHJhbiBmcm9tIEdyYXBoaWNzQ29udHJvbGxlci5pbml0IG9uY2UgZHVyaW5nIGdhbWUgbG9hZGluZ1xyXG5cdFx0IFx0dXNlIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIHNwcml0ZXNoZWV0cyBhbmQgc3VjaFxyXG5cdFx0XHRsaWtlIHNwcml0ZXNoZWV0cy5maXJzdCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVzaGVldCguLi4pO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRpbmNsdWRlKCk7IC8vIHNhdGlzZnkgcmVxdWlyZW1lbnRzLCBHT0VTIEZJUlNUXHJcblx0XHR2YXIgZ2V0X2Fzc2V0ID0gQXNzZXRDb250cm9sbGVyLmdldF9hc3NldDtcclxuXHJcblx0XHRzcHJpdGVzaGVldHNbXCJhbnRcIl0gPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoe1xyXG5cdFx0XHRcImZyYW1lcmF0ZVwiOiAxLFxyXG5cdFx0XHRcImltYWdlc1wiOiBbZ2V0X2Fzc2V0KFwiQW50MVwiKSwgZ2V0X2Fzc2V0KFwiQW50MlwiKSwgZ2V0X2Fzc2V0KFwiQW50M1wiKV0sXHJcblx0XHRcdFwiZnJhbWVzXCI6IHsgXCJyZWdYXCI6IDMsIFwicmVnWVwiOiA2LCBcImhlaWdodFwiOiAyNSwgXCJ3aWR0aFwiOiA1MCwgXCJjb3VudFwiOiA2fSxcclxuXHRcdFx0XCJhbmltYXRpb25zXCI6IHtcclxuXHRcdFx0XHRcIndhbGtcIjogWzAsIDEsIFwid2Fsa1wiLCAwLjI1XSxcclxuXHRcdFx0XHRcInVwc2lkZV9kb3duXCI6IFsyLCAzLCBcInVwc2lkZV9kb3duXCJdLFxyXG5cdFx0XHRcdFwiZGVhdGhcIjogWzQsIDUsIFwiZGVhdGhcIl0sXHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblxyXG5cdH07XHJcblxyXG5cdHZhciByZWdpc3RlciA9IGZ1bmN0aW9uKGVudGl0eV9hbnQpe1xyXG5cdFx0LyogaXMgcmFuIGZvciBldmVyeSBlbnRpdHkgb2YgdGhpcyB0eXBlIHRoYXQgd2FzIGp1c3QgY3JlYXRlZCBhbmQgc2hvdWxkXHJcblx0XHRnZXQgZ3JhcGhpY3MgcmVwcmVzZW50YXRpb24uIFlvdSBhcmUgZ2l2ZW4gdGhlIGVudGl0eSBpbnN0YW5jZSBhbmQgaXMgc3VwcG9zZWRcclxuXHRcdHRvIGNyZXRlIGdyYXBoaWNzIGluc3RhbmNlLCBhbmQgR3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKGdyYXBoaWNzX2luc3RhbmNlLCBlbnRpdHlfaW5zdGFuY2UpOyBpdCBcclxuXHRcdCovXHJcblxyXG5cdFx0YW50X2FuaW1hdGlvbiA9IEdyYXBoaWNzQ29udHJvbGxlci5yZXF1ZXN0X2FuaW1hdGVkKHNwcml0ZXNoZWV0c1tcImFudFwiXSwgXCJ3YWxrXCIpO1xyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnNldF9yZWdfcG9zaXRpb24oYW50X2FuaW1hdGlvbiwgMCwgMCk7IC8vIGNoYW5nZSB0aGF0IHRvIGFkanVzdCBzcHJpdGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHlcclxuXHRcdEdyYXBoaWNzQ29udHJvbGxlci5yZWdfZm9yX3JlbmRlcihhbnRfYW5pbWF0aW9uLCBlbnRpdHlfYW50KTsgLy8gc2V0cyBhbnRfYW5pbWF0aW9uJ3MgcG9zaXRpb24gdG8gdHJhY2sgdGhlIGFudCdzIHBvc2l0aW9uICh1cGRhdGVzIGVhY2ggdGljaylcclxuXHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24oYW50KXtcclxuXHRcdC8qIFx0aXMgcmFuIGVhY2ggdGljayBmcm9tIEdyYXBoaWNzQ29udHJvbGxlciwgZm9yIGV2ZXJ5IHJlZ2lzdGVyZWQgb2JqZWN0IG9mIHRoaXMgdHlwZVxyXG5cdFx0XHRpcyBnaXZlbiA+Z3JhcGhpY3NfaW5zdGFuY2U8IHBhcmFtZXRlciwgd2hpY2ggaXMgYWxzbyBzdXBwb3NlZCB0byBjb250YWluXHJcblx0XHRcdHBoeXNpY2FsX2luc3RhbmNlIHByb3BlcnR5IGNvbnRhaW5pbmcgZW50aXR5X2luc3RhbmNlLCBpZiBpdCB3YXMgYXR0Y2hlZCBjb3JyZWN0bHlcclxuXHRcdCovXHJcblxyXG5cdFx0YW50X2FuaW1hdGUoYW50KTsgXHJcblx0fTtcclxuXHR2YXIgYW50X2FuaW1hdGUgPSBmdW5jdGlvbihhbnQpe1xyXG5cdFx0Ly9zZXQgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIGJhc2VkIG9uIHRoZSBhbmltYXRpb24gdmFyaWFibGUgZGV0ZXJtaW5lZCBieSB0aGUgQUlcclxuXHRcdC8vc2V0IGFuaW1hdGlvblxyXG5cdFx0aWYoYW50LnBoeXNpY2FsX2luc3RhbmNlLm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSl7XHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBhbnQucGh5c2ljYWxfaW5zdGFuY2UuYW5pbWF0aW9uO1xyXG5cdFx0XHRhbnQuZ290b0FuZFBsYXkoYW5pbWF0aW9uKVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL3NldCBkaXJlY3Rpb25cclxuXHRcdGlmIChhbnQucGh5c2ljYWxfaW5zdGFuY2UuZGlyZWN0aW9uKXsgLy9pZiBkaXJlY3Rpb24gPT0gcmlnaHQsIGZsaXAgcmlnaHRcclxuXHRcdFx0YW50LnNjYWxlWCA9IC0xO1xyXG5cdFx0fWVsc2V7IC8vZWxzZSBmbGlwIGxlZnRcclxuXHRcdFx0YW50LnNjYWxlWCA9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9zZXQgYWxwaGEgaWYgYmxpbmtpbmdcclxuXHRcdGlmKGFudC5waHlzaWNhbF9pbnN0YW5jZS5ibGlua2luZyAmJiBhbnQucGh5c2ljYWxfaW5zdGFuY2UuYmxpbmtfdGltZXIlMiA9PSAxKXtcclxuXHRcdFx0YW50LmFscGhhID0gMDtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRhbnQuYWxwaGEgPSAxO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0LypcclxuXHR2YXIgYW50X3NwZWNpYWxfcmVuZGVyX3RlbXAgPSBmdW5jdGlvbihhbnQpe1xyXG5cdFx0XHJcblxyXG5cdFx0XHJcblx0XHRpZihhbnQucGh5c2ljYWxfaW5zdGFuY2UuQUlfc3RhdGUgPT0gXCJkZWF0aFwiJiYgYW50LnBoeXNpY2FsX2luc3RhbmNlLmFsaXZlZmxhZyl7XHJcblx0XHRcdGFudC5nb3RvQW5kUGxheShcImRlYXRoXCIpO1xyXG5cdFx0XHRhbnQucGh5c2ljYWxfaW5zdGFuY2UuYWxpdmVmbGFnID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHJcblx0XHRpZihhbnQucGh5c2ljYWxfaW5zdGFuY2UuQUlfc3RhdGUgPT0gXCJ1cHNpZGVfZG93blwiICYmIGFudC5waHlzaWNhbF9pbnN0YW5jZS51bmh1cnRmbGFnKVxyXG5cdFx0e1xyXG5cdFx0XHRhbnQuZ290b0FuZFBsYXkoXCJ1cHNpZGVfZG93blwiKTtcclxuXHRcdFx0YW50LnBoeXNpY2FsX2luc3RhbmNlLnVuaHVydGZsYWcgPSBmYWxzZTtcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0aWYoYW50LnBoeXNpY2FsX2luc3RhbmNlLkFJX3N0YXRlID09IFwid2Fsa1wiICYmIGFudC5waHlzaWNhbF9pbnN0YW5jZS5zdGFydF93YWxraW5nKVxyXG5cdFx0e1xyXG5cdFx0XHRhbnQuZ290b0FuZFBsYXkoXCJ3YWxrXCIpO1xyXG5cdFx0XHQvL2FudC5waHlzaWNhbF9pbnN0YW5jZS5ocCArPSAxO1xyXG5cdFx0XHRhbnQucGh5c2ljYWxfaW5zdGFuY2Uuc3RhcnRfd2Fsa2luZyA9IGZhbHNlO1xyXG5cdFx0XHRcclxuXHRcdFx0XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblx0Ki9cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHJlZ2lzdGVyOiByZWdpc3RlcixcclxuXHRcdHJlbmRlcjogcmVuZGVyLFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFudFJlbmRlcmVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiQW50UmVuZGVyZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLlJFTkRFUkVSX1NQRUNJRklDXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuIiwidmFyIEJhY2tncm91bmRSZW5kZXJlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgc2Vhc29uX2FycmF5O1xyXG5cdHZhciBzZWFzb25faW1hZ2U7XHJcblx0dmFyIHNlYXNvbl90aHJlc2hvbGQ7XHJcblx0XHJcblx0dmFyIHNlYXNvbl9wcm9ncmVzcztcclxuXHR2YXIgc2Vhc29uX3Byb2dyZXNzX3RvX2xldmVsO1xyXG5cdHZhciBoZXJvX2N1cnJlbnRfbGV2ZWw7XHJcblx0XHRcclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRpbmNsdWRlKCk7IC8vc2V0cyB1cCBkZXBlbmRlbmNpZXMgTVVTVCBHTyBGSVJTVFxyXG5cdFx0XHJcblx0XHRzZWFzb25fYXJyYXkgPSBbXTsvL3N0b3JlcyBzZWFzb24gc3ByaXRlc1xyXG5cdFx0c2Vhc29uX2ltYWdlID0gW1wiV2ludGVyXCIsIFwiU3ByaW5nXCIsIFwiU3VtbWVyXCIsIFwiRmFsbFwiXTtcclxuXHRcdHNlYXNvbl90aHJlc2hvbGQgPSAyOyAvL1NvIHNlYXNvbnMgb25seSB1cGRhdGUgb25jZVxyXG5cdFx0XHJcblx0XHRzZWFzb25fcHJvZ3Jlc3MgPSAwO1xyXG5cdFx0c2Vhc29uX3Byb2dyZXNzX3RvX2xldmVsID0gMTk5Oy8vc2Vhc29uX2ltYWdlW2N5Y2xlXS53aWR0aCoyICsgQ29uZmlnLlNDUkVFTl9XLzI7XHJcblx0XHRoZXJvX2N1cnJlbnRfbGV2ZWwgPSBzZWFzb25fcHJvZ3Jlc3NfdG9fbGV2ZWw7XHJcblx0XHRcclxuXHRcdGdlbmVyYXRlX3NlYXNvbihcIldpbnRlclwiLCBHcmFwaGljc0NvbnRyb2xsZXIuZ2V0X3N0YWdlKCkuY2FudmFzLndpZHRoLCAwKTtcclxuXHR9O1xyXG5cdFxyXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbigpe1xyXG5cclxuXHRcdGlmKE1hdGgucm91bmQoV29ybGRDb250cm9sbGVyLmdldF9wcm9ncmVzcygpKSA+IGhlcm9fY3VycmVudF9sZXZlbCl7XHJcblx0XHRcdHNlYXNvbl9wcm9ncmVzcysrO1xyXG5cdFx0XHRoZXJvX2N1cnJlbnRfbGV2ZWwgKz0gc2Vhc29uX3Byb2dyZXNzX3RvX2xldmVsO1xyXG5cdFx0XHRXb3JsZENvbnRyb2xsZXIuaW5jcmVhc2Vfc2NvcmUoc2Vhc29uX3Byb2dyZXNzKjUwMCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vUG90ZW50aWFsbHkgY2hhbmdlIHNlYXNvbnMgYmFzZWQgb24gaGVybyBwcm9ncmVzc1xyXG5cdFx0Y2hhbmdlX3NlYXNvbnMoc2Vhc29uX3Byb2dyZXNzKTtcclxuXHRcdFxyXG5cdFx0Ly9wZXJmb3JtIHBhcmFsbGF4IGVmZmVjdCB3aXRoIGJhY2tncm91bmRcclxuXHRcdGJhY2tncm91bmRfbG9vcChXb3JsZENvbnRyb2xsZXIuZ2V0X3Byb2dyZXNzKCksc2Vhc29uX3Byb2dyZXNzKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vR2VuZXJhdGVzIHRpbGVkIGJhY2tncm91bmQgZm9yIHNlYXNvblxyXG5cdHZhciBnZW5lcmF0ZV9zZWFzb24gPSBmdW5jdGlvbihzZWFzb25faW1hZ2UsIGNhbnZhc193aWR0aCwgc3RhcnQpe1xyXG5cdFx0Zm9yKGk9MDsgaTwzOyBpKyspey8vY3JlYXRlIHRpbGVzIDMgYXQgYSB0aW1lXHJcblx0XHRcdHZhciBzZWFzb24gPSBHcmFwaGljc0NvbnRyb2xsZXIucmVxdWVzdF9iaXRtYXAoc2Vhc29uX2ltYWdlKTtcclxuXHRcdFx0c2Vhc29uLnJlZ1kgLT0gc2Vhc29uLmltYWdlLmhlaWdodC8yO1xyXG5cdFx0XHQvL2NyZWF0ZSBhIG5ldyB0aWxlIHdpdGggb2Zmc2V0XHJcblx0XHRcdHNlYXNvbi54ID0gc3RhcnQgKyBpKnNlYXNvbi5pbWFnZS53aWR0aDtcclxuXHRcdFx0R3JhcGhpY3NDb250cm9sbGVyLmdldF9zdGFnZSgpLmFkZENoaWxkQXQoc2Vhc29uLCAwKTtcclxuXHRcdFx0c2Vhc29uX2FycmF5LnB1c2goc2Vhc29uKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vY2hlY2tzIGZvciBhbmQgaGFuZGxlcyBwb3RlbnRpYWwgc2Vhc29uIGNoYW5nZVxyXG5cdHZhciBjaGFuZ2Vfc2Vhc29ucyA9IGZ1bmN0aW9uKHByb2dyZXNzKXtcclxuXHRcdHZhciBmbGFnID0gZmFsc2U7XHJcblx0XHRpZihwcm9ncmVzcyA9PSBzZWFzb25fdGhyZXNob2xkKXsgLy9zZWFzb25zIHdpbGwgY2hhbmdlIGV2ZXJ5IGV2ZW4gcHJvZ3Jlc3MgbnVtYmVyXHJcblx0XHRcdHNlYXNvbl90aHJlc2hvbGQgKz0gMjtcclxuXHRcdFx0ZmxhZyA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRpZihmbGFnKXtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJnZW5lcmF0aW5nIHNlYXNvblwiKTtcclxuXHRcdFx0ZGVsZXRlX2FsbF9zZWFzb24oKTtcclxuXHRcdFx0V29ybGRDb250cm9sbGVyLnNldF9zZWFzb24oKFdvcmxkQ29udHJvbGxlci5nZXRfc2Vhc29uKCkrMSklNCk7XHJcblx0XHRcdGdlbmVyYXRlX3NlYXNvbihzZWFzb25faW1hZ2VbV29ybGRDb250cm9sbGVyLmdldF9zZWFzb24oKV0sIEdyYXBoaWNzQ29udHJvbGxlci5nZXRfc3RhZ2UoKS5jYW52YXMud2lkdGgsIFdvcmxkQ29udHJvbGxlci5nZXRfbW92ZW1lbnRfZWRnZSgpIC8gMzApO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly9zY3JvbGxzIHRoZSBiYWNrZ3JvdW5kIGFsb25nIHdpdGggdGhlIHBsYXllclxyXG5cdHZhciBiYWNrZ3JvdW5kX2xvb3AgPSBmdW5jdGlvbihoZXJvX3gsIHByb2dyZXNzKXtcclxuXHRcdGZvcihpPTA7IGk8c2Vhc29uX2FycmF5Lmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0Ly9zZWFzb25fYXJyYXlbaV0ueCA9IChpICogNzk5KSArIEdyYXBoaWNzTW9kZWwuY2FtZXJhLm9mZnNldC54O1xyXG5cdFx0XHQvL3NlYXNvbl9hcnJheVtpXS55ID0gR3JhcGhpY3NNb2RlbC5jYW1lcmEub2Zmc2V0Lnk7XHJcblx0XHRcdHNlYXNvbl9hcnJheVtpXS54ID0gKChpICsgcHJvZ3Jlc3MpICogNzk5KSAtIChoZXJvX3ggKiA0KTtcclxuXHRcdFx0c2Vhc29uX2FycmF5W2ldLnkgPSBHcmFwaGljc0NvbnRyb2xsZXIuZ2V0X2NhbWVyYSgpLm9mZnNldC55O1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vZGVsZXRlcyBhbGwgYmFja2dyb3VuZCBvYmplY3RzXHJcblx0dmFyIGRlbGV0ZV9hbGxfc2Vhc29uID0gZnVuY3Rpb24oKXtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzZWFzb25fYXJyYXkubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRHcmFwaGljc0NvbnRyb2xsZXIuZ2V0X3N0YWdlKCkucmVtb3ZlQ2hpbGQoc2Vhc29uX2FycmF5W2ldKTtcclxuXHRcdH1cclxuXHRcdHNlYXNvbl9hcnJheSA9IFtdO1xyXG5cdH07XHJcblx0XHJcblx0dmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24oYmFja2dyb3VuZCl7XHJcblx0XHQvKiBpcyByYW4gZm9yIGV2ZXJ5IGVudGl0eSBvZiB0aGlzIHR5cGUgdGhhdCB3YXMganVzdCBjcmVhdGVkIGFuZCBzaG91bGRcclxuXHRcdGdldCBncmFwaGljcyByZXByZXNlbnRhdGlvbi4gWW91IGFyZSBnaXZlbiB0aGUgZW50aXR5IGluc3RhbmNlIGFuZCBpcyBzdXBwb3NlZFxyXG5cdFx0dG8gY3JldGUgZ3JhcGhpY3MgaW5zdGFuY2UsIGFuZCBHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoZ3JhcGhpY3NfaW5zdGFuY2UsIGVudGl0eV9pbnN0YW5jZSk7IGl0IFxyXG5cdFx0Ki9cclxuXHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxyXG5cdFx0cmVuZGVyOiByZW5kZXIsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZFJlbmRlcmVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiQmFja2dyb3VuZFJlbmRlcmVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUl9TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG5cclxuIiwidmFyIENlbnRhdXJSZW5kZXJlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgc3ByaXRlc2hlZXRzID0ge307XHJcblx0dmFyIENlbnRhdXJfYW5pbWF0aW9uO1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSBHcmFwaGljc0NvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmdcclxuXHRcdCBcdHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzcHJpdGVzaGVldHMgYW5kIHN1Y2hcclxuXHRcdFx0bGlrZSBzcHJpdGVzaGVldHMuZmlyc3QgPSBuZXcgY3JlYXRlanMuU3ByaXRlc2hlZXQoLi4uKTtcclxuXHRcdCovXHJcblxyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0dmFyIGdldF9hc3NldCA9IEFzc2V0Q29udHJvbGxlci5nZXRfYXNzZXQ7XHJcblxyXG5cdFx0c3ByaXRlc2hlZXRzW1wiQ2VudGF1clwiXSA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh7XHJcblx0XHRcdFwiZnJhbWVyYXRlXCI6IDEsXHJcblx0XHRcdFwiaW1hZ2VzXCI6IFtnZXRfYXNzZXQoXCJDZW50YXVyMVwiKSxdLCAvL0NlbnRhdXJTcHJpdGVTaGVldFxyXG5cdFx0XHRcImZyYW1lc1wiOiB7IFwicmVnWFwiOiAwLCBcInJlZ1lcIjogMCwgXCJoZWlnaHRcIjogMTA1LCBcIndpZHRoXCI6IDcwLjcsIFwiY291bnRcIjogNH0sXHJcblx0XHRcdFx0XCJhbmltYXRpb25zXCI6IHtcclxuXHRcdFx0XHRcIndhbGtcIjogWzAsIDMsIFwid2Fsa1wiLCAwLjFdLFxyXG5cdFx0XHRcdFwiaW5qdXJ5XCI6IHtcclxuXHRcdFx0XHQgICAgZnJhbWVzOiBbMywgNCwgLjI1XVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJkZWF0aFwiOiBbMywgNCwgXCJkZWF0aFwiLCAwLjZdLFxyXG4gICAgICAgICAgICAgICAgXHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblxyXG5cdH07XHJcblxyXG5cdHZhciByZWdpc3RlciA9IGZ1bmN0aW9uKGVudGl0eV9DZW50YXVyKXtcclxuXHRcdC8qIGlzIHJhbiBmb3IgZXZlcnkgZW50aXR5IG9mIHRoaXMgdHlwZSB0aGF0IHdhcyBqdXN0IGNyZWF0ZWQgYW5kIHNob3VsZFxyXG5cdFx0Z2V0IGdyYXBoaWNzIHJlcHJlc2VudGF0aW9uLiBZb3UgYXJlIGdpdmVuIHRoZSBlbnRpdHkgaW5zdGFuY2UgYW5kIGlzIHN1cHBvc2VkXHJcblx0XHR0byBjcmV0ZSBncmFwaGljcyBpbnN0YW5jZSwgYW5kIEdyYXBoaWNzQ29udHJvbGxlci5yZWdfZm9yX3JlbmRlcihncmFwaGljc19pbnN0YW5jZSwgZW50aXR5X2luc3RhbmNlKTsgaXQgXHJcblx0XHQqL1xyXG5cclxuXHRcdENlbnRhdXJfYW5pbWF0aW9uID0gR3JhcGhpY3NDb250cm9sbGVyLnJlcXVlc3RfYW5pbWF0ZWQoc3ByaXRlc2hlZXRzW1wiQ2VudGF1clwiXSwgXCJ3YWxrXCIpO1xyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnNldF9yZWdfcG9zaXRpb24oQ2VudGF1cl9hbmltYXRpb24sIDAsIDApOyAvLyBjaGFuZ2UgdGhhdCB0byBhZGp1c3Qgc3ByaXRlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBib2R5XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoQ2VudGF1cl9hbmltYXRpb24sIGVudGl0eV9DZW50YXVyKTsgLy8gc2V0cyBDZW50YXVyX2FuaW1hdGlvbidzIHBvc2l0aW9uIHRvIHRyYWNrIHRoZSBDZW50YXVyJ3MgcG9zaXRpb24gKHVwZGF0ZXMgZWFjaCB0aWNrKVxyXG5cclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbihDZW50YXVyKXtcclxuXHRcdC8qIFx0aXMgcmFuIGVhY2ggdGljayBmcm9tIEdyYXBoaWNzQ29udHJvbGxlciwgZm9yIGV2ZXJ5IHJlZ2lzdGVyZWQgb2JqZWN0IG9mIHRoaXMgdHlwZVxyXG5cdFx0XHRpcyBnaXZlbiA+Z3JhcGhpY3NfaW5zdGFuY2U8IHBhcmFtZXRlciwgd2hpY2ggaXMgYWxzbyBzdXBwb3NlZCB0byBjb250YWluXHJcblx0XHRcdHBoeXNpY2FsX2luc3RhbmNlIHByb3BlcnR5IGNvbnRhaW5pbmcgZW50aXR5X2luc3RhbmNlLCBpZiBpdCB3YXMgYXR0Y2hlZCBjb3JyZWN0bHlcclxuXHRcdCovXHJcblxyXG5cdFx0Q2VudGF1cl9zcGVjaWFsX3JlbmRlcl90ZW1wKENlbnRhdXIpOyBcclxuXHR9O1xyXG5cclxuXHR2YXIgQ2VudGF1cl9zcGVjaWFsX3JlbmRlcl90ZW1wID0gZnVuY3Rpb24oQ2VudGF1cil7XHJcblx0XHQvKiBob3cgdG8gaGFuZGxlIHNwZWNpYWwgcmVuZGVyPyBURU1QT1JBUlkgKi9cclxuXHJcblx0XHQvL3NldCBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gYmFzZWQgb24gdGhlIGFuaW1hdGlvbiB2YXJpYWJsZSBkZXRlcm1pbmVkIGJ5IHRoZSBBSVxyXG5cdFx0Ly9zZXQgYW5pbWF0aW9uXHJcblx0XHRpZihDZW50YXVyLnBoeXNpY2FsX2luc3RhbmNlLm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSl7XHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBDZW50YXVyLnBoeXNpY2FsX2luc3RhbmNlLmFuaW1hdGlvbjtcclxuXHRcdFx0Q2VudGF1ci5nb3RvQW5kUGxheShhbmltYXRpb24pXHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vc2V0IGRpcmVjdGlvblxyXG5cdFx0aWYgKENlbnRhdXIucGh5c2ljYWxfaW5zdGFuY2UuZGlyZWN0aW9uKXsgLy9pZiBkaXJlY3Rpb24gPT0gcmlnaHQsIGZsaXAgcmlnaHRcclxuXHRcdFx0Q2VudGF1ci5zY2FsZVggPSAtMTtcclxuXHRcdH1lbHNleyAvL2Vsc2UgZmxpcCBsZWZ0XHJcblx0XHRcdENlbnRhdXIuc2NhbGVYID0gMTtcclxuXHRcdH1cclxuXHJcblx0XHQvL3NldCBhbHBoYSBpZiBibGlua2luZ1xyXG5cdFx0aWYoQ2VudGF1ci5waHlzaWNhbF9pbnN0YW5jZS5ibGlua2luZyAmJiBDZW50YXVyLnBoeXNpY2FsX2luc3RhbmNlLmJsaW5rX3RpbWVyJTIgPT0gMSl7XHJcblx0XHRcdENlbnRhdXIuYWxwaGEgPSAwO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdENlbnRhdXIuYWxwaGEgPSAxO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXHJcblx0XHRyZW5kZXI6IHJlbmRlcixcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDZW50YXVyUmVuZGVyZXI7XHJcblxyXG52YXIgSW5jbHVkZXMgPSByZXF1aXJlKFwiLi4vSW5jbHVkZXMuanNcIik7IHZhciBpbmNsdWRlX2RhdGEgPSBJbmNsdWRlcy5nZXRfaW5jbHVkZV9kYXRhKHtcclxuXHRjdXJyZW50X21vZHVsZTogXCJDZW50YXVyUmVuZGVyZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLlJFTkRFUkVSX1NQRUNJRklDXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO30iLCJ2YXIgRXN0ZWVtZWRDb21wYW5pb25SZW5kZXJlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgc3ByaXRlc2hlZXRzID0ge307IC8vIHRvIHN0b3JlIHNwcml0ZXNoZWV0cyB1c2VkIGJ5IHRoaXMgZW50aXR5XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIGlzIHJhbiBmcm9tIEdyYXBoaWNzQ29udHJvbGxlci5pbml0IG9uY2UgZHVyaW5nIGdhbWUgbG9hZGluZ1xyXG5cdFx0XHR1c2UgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgc3ByaXRlc2hlZXRzIGFuZCBzdWNoXHJcblx0XHRcdGxpa2Ugc3ByaXRlc2hlZXRzLmZpcnN0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZXNoZWV0KC4uLik7XHJcblx0XHQqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdH07XHJcblxyXG5cdHZhciByZWdpc3RlciA9IGZ1bmN0aW9uKGVudGl0eV9jb21wYW5pb24pe1xyXG5cdFx0LyogaXMgcmFuIGZvciBldmVyeSBlbnRpdHkgb2YgdGhpcyB0eXBlIHRoYXQgd2FzIGp1c3QgY3JlYXRlZCBhbmQgc2hvdWxkXHJcblx0XHRnZXQgZ3JhcGhpY3MgcmVwcmVzZW50YXRpb24uIFlvdSBhcmUgZ2l2ZW4gdGhlIGVudGl0eSBpbnN0YW5jZSBhbmQgaXMgc3VwcG9zZWRcclxuXHRcdHRvIGNyZXRlIGdyYXBoaWNzIGluc3RhbmNlLCBhbmQgR3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKGdyYXBoaWNzX2luc3RhbmNlLCBlbnRpdHlfaW5zdGFuY2UpOyBpdCBcclxuXHRcdCovXHJcblxyXG5cdFx0dmFyIGNvbXBhbmlvbiA9IEdyYXBoaWNzQ29udHJvbGxlci5yZXF1ZXN0X2JpdG1hcChcImdyZWVrX3dhcnJpb3JcIik7XHJcblxyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnNldF9yZWdfcG9zaXRpb24oY29tcGFuaW9uLCAtMjAsICsxMCk7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoY29tcGFuaW9uLCBlbnRpdHlfY29tcGFuaW9uKTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHJlbmRlciA9IGZ1bmN0aW9uKGNvbXBhbmlvbil7XHJcblx0XHQvKiBcdGlzIHJhbiBlYWNoIHRpY2sgZnJvbSBHcmFwaGljc0NvbnRyb2xsZXIsIGZvciBldmVyeSByZWdpc3RlcmVkIG9iamVjdCBvZiB0aGlzIHR5cGVcclxuXHRcdFx0aXMgZ2l2ZW4gPmdyYXBoaWNzX2luc3RhbmNlPCBwYXJhbWV0ZXIsIHdoaWNoIGlzIGFsc28gc3VwcG9zZWQgdG8gY29udGFpblxyXG5cdFx0XHRwaHlzaWNhbF9pbnN0YW5jZSBwcm9wZXJ0eSBjb250YWluaW5nIGVudGl0eV9pbnN0YW5jZSwgaWYgaXQgd2FzIGF0dGNoZWQgY29ycmVjdGx5XHJcblx0XHQqL1xyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnVwZGF0ZV9oZWFsdGgoY29tcGFuaW9uLnBoeXNpY2FsX2luc3RhbmNlLmhwKTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxyXG5cdFx0cmVuZGVyOiByZW5kZXIsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXN0ZWVtZWRDb21wYW5pb25SZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkVzdGVlbWVkQ29tcGFuaW9uXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUl9TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcbiIsInZhciBHcmlmZmluUmVuZGVyZXIgPSAoZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHNwcml0ZXNoZWV0cyA9IHt9O1xyXG5cdHZhciBHcmlmZmluX2FuaW1hdGlvbjtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogaXMgcmFuIGZyb20gR3JhcGhpY3NDb250cm9sbGVyLmluaXQgb25jZSBkdXJpbmcgZ2FtZSBsb2FkaW5nXHJcblx0XHQgXHR1c2UgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgc3ByaXRlc2hlZXRzIGFuZCBzdWNoXHJcblx0XHRcdGxpa2Ugc3ByaXRlc2hlZXRzLmZpcnN0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZXNoZWV0KC4uLik7XHJcblx0XHQqL1xyXG5cclxuXHRcdGluY2x1ZGUoKTsgLy8gc2F0aXNmeSByZXF1aXJlbWVudHMsIEdPRVMgRklSU1RcclxuXHRcdHZhciBnZXRfYXNzZXQgPSBBc3NldENvbnRyb2xsZXIuZ2V0X2Fzc2V0O1xyXG5cclxuXHRcdHNwcml0ZXNoZWV0c1tcIkdyaWZmaW5cIl0gPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoe1xyXG5cdFx0XHRcImZyYW1lcmF0ZVwiOiAxLFxyXG5cdFx0XHRcImltYWdlc1wiOiBbZ2V0X2Fzc2V0KFwiR3JpZmZpbjFcIiksIGdldF9hc3NldChcIkdyaWZmaW4yXCIpLCBnZXRfYXNzZXQoXCJHcmlmZmluM1wiKSwgZ2V0X2Fzc2V0KFwiR3JpZmZpbkRlYXRoXCIpXSwgLy8sIGdldF9hc3NldChcIkdyaWZmaW5EZWF0aDJcIiksIGdldF9hc3NldChcIkdyaWZmaW5EZWF0aDNcIilcclxuXHRcdFx0XHRcImZyYW1lc1wiOiB7IFwicmVnWFwiOiA1LCBcInJlZ1lcIjogMTQsIFwiaGVpZ2h0XCI6IDIwNywgXCJ3aWR0aFwiOiAyMTAsIFwiY291bnRcIjogNn0sXHJcblx0XHRcdFx0XCJhbmltYXRpb25zXCI6IHtcclxuXHRcdFx0XHRcIndhbGtcIjogWzAsIDIsIFwid2Fsa1wiLCAwLjFdLFxyXG5cdFx0XHRcdFwiaW5qdXJ5XCI6IHtcclxuXHRcdFx0XHQgICAgZnJhbWVzOiBbMiwgNCwgLjI1XVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJkZWF0aFwiOiBbMywgNCwgXCJkZWF0aFwiLCAwLjZdLFxyXG4gICAgICAgICAgICAgICAgXCJmbHlcIjogWzEsIDIsIFwiZmx5XCIsIC40XSxcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24oZW50aXR5X0dyaWZmaW4pe1xyXG5cdFx0LyogaXMgcmFuIGZvciBldmVyeSBlbnRpdHkgb2YgdGhpcyB0eXBlIHRoYXQgd2FzIGp1c3QgY3JlYXRlZCBhbmQgc2hvdWxkXHJcblx0XHRnZXQgZ3JhcGhpY3MgcmVwcmVzZW50YXRpb24uIFlvdSBhcmUgZ2l2ZW4gdGhlIGVudGl0eSBpbnN0YW5jZSBhbmQgaXMgc3VwcG9zZWRcclxuXHRcdHRvIGNyZXRlIGdyYXBoaWNzIGluc3RhbmNlLCBhbmQgR3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKGdyYXBoaWNzX2luc3RhbmNlLCBlbnRpdHlfaW5zdGFuY2UpOyBpdCBcclxuXHRcdCovXHJcblxyXG5cdFx0R3JpZmZpbl9hbmltYXRpb24gPSBHcmFwaGljc0NvbnRyb2xsZXIucmVxdWVzdF9hbmltYXRlZChzcHJpdGVzaGVldHNbXCJHcmlmZmluXCJdLCBcIndhbGtcIik7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIuc2V0X3JlZ19wb3NpdGlvbihHcmlmZmluX2FuaW1hdGlvbiwgMCwgMCk7IC8vIGNoYW5nZSB0aGF0IHRvIGFkanVzdCBzcHJpdGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHlcclxuXHRcdEdyYXBoaWNzQ29udHJvbGxlci5yZWdfZm9yX3JlbmRlcihHcmlmZmluX2FuaW1hdGlvbiwgZW50aXR5X0dyaWZmaW4pOyAvLyBzZXRzIGdyaWZmaW5fYW5pbWF0aW9uJ3MgcG9zaXRpb24gdG8gdHJhY2sgdGhlIGdyaWZmaW4ncyBwb3NpdGlvbiAodXBkYXRlcyBlYWNoIHRpY2spXHJcblxyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIHJlbmRlciA9IGZ1bmN0aW9uKEdyaWZmaW4pe1xyXG5cdFx0LyogXHRpcyByYW4gZWFjaCB0aWNrIGZyb20gR3JhcGhpY3NDb250cm9sbGVyLCBmb3IgZXZlcnkgcmVnaXN0ZXJlZCBvYmplY3Qgb2YgdGhpcyB0eXBlXHJcblx0XHRcdGlzIGdpdmVuID5ncmFwaGljc19pbnN0YW5jZTwgcGFyYW1ldGVyLCB3aGljaCBpcyBhbHNvIHN1cHBvc2VkIHRvIGNvbnRhaW5cclxuXHRcdFx0cGh5c2ljYWxfaW5zdGFuY2UgcHJvcGVydHkgY29udGFpbmluZyBlbnRpdHlfaW5zdGFuY2UsIGlmIGl0IHdhcyBhdHRjaGVkIGNvcnJlY3RseVxyXG5cdFx0Ki9cclxuXHJcblx0XHRHcmlmZmluX3NwZWNpYWxfcmVuZGVyX3RlbXAoR3JpZmZpbik7IFxyXG5cdH07XHJcblxyXG5cdHZhciBHcmlmZmluX3NwZWNpYWxfcmVuZGVyX3RlbXAgPSBmdW5jdGlvbihHcmlmZmluKXtcclxuXHRcdC8qIGhvdyB0byBoYW5kbGUgc3BlY2lhbCByZW5kZXI/IFRFTVBPUkFSWSAqL1xyXG5cclxuXHRcdC8vc2V0IGdyYXBoaWNhbCByZXByZXNlbnRhdGlvbiBiYXNlZCBvbiB0aGUgYW5pbWF0aW9uIHZhcmlhYmxlIGRldGVybWluZWQgYnkgdGhlIEFJXHJcblx0XHQvL3NldCBhbmltYXRpb25cclxuXHRcdGlmKEdyaWZmaW4ucGh5c2ljYWxfaW5zdGFuY2UubmVlZHNfZ3JhcGhpY3NfdXBkYXRlKXtcclxuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IEdyaWZmaW4ucGh5c2ljYWxfaW5zdGFuY2UuYW5pbWF0aW9uO1xyXG5cdFx0XHRHcmlmZmluLmdvdG9BbmRQbGF5KGFuaW1hdGlvbilcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly9zZXQgZGlyZWN0aW9uXHJcblx0XHRpZiAoR3JpZmZpbi5waHlzaWNhbF9pbnN0YW5jZS5kaXJlY3Rpb24peyAvL2lmIGRpcmVjdGlvbiA9PSByaWdodCwgZmxpcCByaWdodFxyXG5cdFx0XHRHcmlmZmluLnNjYWxlWCA9IC0xO1xyXG5cdFx0fWVsc2V7IC8vZWxzZSBmbGlwIGxlZnRcclxuXHRcdFx0R3JpZmZpbi5zY2FsZVggPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vc2V0IGFscGhhIGlmIGJsaW5raW5nXHJcblx0XHRpZihHcmlmZmluLnBoeXNpY2FsX2luc3RhbmNlLmJsaW5raW5nICYmIEdyaWZmaW4ucGh5c2ljYWxfaW5zdGFuY2UuYmxpbmtfdGltZXIlMiA9PSAxKXtcclxuXHRcdFx0R3JpZmZpbi5hbHBoYSA9IDA7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0R3JpZmZpbi5hbHBoYSA9IDE7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHJlZ2lzdGVyOiByZWdpc3RlcixcclxuXHRcdHJlbmRlcjogcmVuZGVyLFxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWZmaW5SZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkdyaWZmaW5SZW5kZXJlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuUkVOREVSRVJfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG4iLCJ2YXIgSFVEUmVuZGVyZXIgPSAoZnVuY3Rpb24oKXtcclxuXHRcclxuXHR2YXIgc2NvcmU7XHJcblx0dmFyIGhlYWx0aF9iYXI7XHJcblx0dmFyIHNjb3JlX3RpdGxlO1xyXG5cdHZhciBoZWFsdGhfb3V0bGluZTtcclxuXHR2YXIgaGVhbHRoWDtcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHJcblx0XHRpbmNsdWRlKCk7XHJcblx0XHRoZWFsdGhYID0gMTAwO1xyXG5cdFx0Z2V0X2Fzc2V0ID0gQXNzZXRDb250cm9sbGVyLmdldF9hc3NldDsgLy8gZm9yIHF1aWNrZXIgYWNjZXNzXHJcblx0XHRzY29yZSA9IG5ldyBjcmVhdGVqcy5UZXh0KCk7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoc2NvcmUpO1xyXG5cdFx0aGVhbHRoX2JhciA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKGhlYWx0aF9iYXIpO1xyXG5cdFx0c2NvcmVfdGl0bGUgPSBuZXcgY3JlYXRlanMuVGV4dCgpO1xyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKHNjb3JlX3RpdGxlKTtcclxuXHRcdGhlYWx0aF9vdXRsaW5lID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoaGVhbHRoX291dGxpbmUpO1xyXG5cdFx0cGxheWVyX2hlYWQgPSBuZXcgY3JlYXRlanMuQml0bWFwKGdldF9hc3NldChcIkhlYWRSZWRcIikpO1xyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKHBsYXllcl9oZWFkKTtcclxuXHRcdFxyXG5cdFx0aGVhbHRoX291dGxpbmUueCA9IDMwO1xyXG5cdFx0aGVhbHRoX291dGxpbmUueSA9IDI1O1xyXG5cdFx0aGVhbHRoX291dGxpbmUuZ3JhcGhpY3MuYmVnaW5TdHJva2UoXCJyZWRcIikuc2V0U3Ryb2tlU3R5bGUoMSkuZHJhd1JlY3QoMzAsMjUsMTAwLDIwKTtcclxuXHRcdGhlYWx0aF9iYXIueCA9IDMwO1xyXG5cdFx0aGVhbHRoX2Jhci55ID0gMjU7XHJcblx0XHRoZWFsdGhfYmFyLmdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKTtcclxuXHRcdGhlYWx0aF9iYXIuZ3JhcGhpY3MuZHJhd1JlY3QoMzAsMjUsaGVhbHRoWCwgMjApO1xyXG5cdFx0XHJcblx0XHRwbGF5ZXJfaGVhZC54ID0gMTA7XHJcblx0XHRwbGF5ZXJfaGVhZC55ID0gMzU7XHJcblx0XHRzY29yZV90aXRsZS50ZXh0ID0gXCJTY29yZTogXCI7XHJcblx0XHRzY29yZV90aXRsZS54ID0gMTA7XHJcblx0XHRzY29yZV90aXRsZS55ID0gMTA7XHJcblx0XHRzY29yZS50ZXh0ID0gXCIwXCI7XHJcblx0XHRzY29yZS54ID0gODA7XHJcblx0XHRzY29yZS55ID0gMTA7XHJcblx0XHRzY29yZS5mb250ID0gXCIyMHB4IEFyaWFsXCI7XHJcblx0XHRzY29yZV90aXRsZS5mb250ID0gXCIyMHB4IEFyaWFsXCI7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24oKXtcclxuXHRcdHZhciBjYW1lcmEgPSBHcmFwaGljc0NvbnRyb2xsZXIuZ2V0X2NhbWVyYSgpO1xyXG5cdFx0dmFyIGhlcm8gPSBFbnRpdHlDb250cm9sbGVyLmdldF9teV9oZXJvKCk7XHJcblx0XHRcclxuXHRcdHVwZGF0ZV9zY29yZShXb3JsZENvbnRyb2xsZXIuZ2V0X3Njb3JlKCkpO1xyXG5cdFx0aWYoaGVybyl7XHJcblx0XHRcdHVwZGF0ZV9oZWFsdGgoaGVyby5ocCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9O1xyXG5cdFxyXG5cdHZhciB1cGRhdGVfc2NvcmUgPSBmdW5jdGlvbihuZXdfc2NvcmUpe1xyXG5cdFx0c2NvcmUudGV4dCA9IHBhcnNlSW50KG5ld19zY29yZSk7XHJcblx0fTtcclxuXHRcclxuXHR2YXIgdXBkYXRlX2hlYWx0aCA9IGZ1bmN0aW9uKG5ld19oZWFsdGgpe1xyXG5cdFx0aGVhbHRoWCA9IHBhcnNlSW50KG5ld19oZWFsdGgpO1xyXG5cdFx0aGVhbHRoX2Jhci5ncmFwaGljcy5jbGVhcigpO1xyXG5cdFx0aGVhbHRoX2Jhci5ncmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIik7XHJcblx0XHRoZWFsdGhfYmFyLmdyYXBoaWNzLmRyYXdSZWN0KDMwLDI1LGhlYWx0aFgsIDIwKTtcclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRyZW5kZXI6IHJlbmRlcixcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIVURSZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIkhVRFJlbmRlcmVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUl9TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJ2YXIgSGVyb1JlbmRlcmVyID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciBzcHJpdGVzaGVldHMgPSB7fTsgLy8gdG8gc3RvcmUgc3ByaXRlc2hlZXRzIHVzZWQgYnkgdGhpcyBlbnRpdHlcclxuXHJcblx0dmFyIGluaXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0LyogaXMgcmFuIGZyb20gR3JhcGhpY3NDb250cm9sbGVyLmluaXQgb25jZSBkdXJpbmcgZ2FtZSBsb2FkaW5nXHJcblx0XHRcdHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzcHJpdGVzaGVldHMgYW5kIHN1Y2hcclxuXHRcdFx0bGlrZSBzcHJpdGVzaGVldHMuZmlyc3QgPSBuZXcgY3JlYXRlanMuU3ByaXRlc2hlZXQoLi4uKTtcclxuXHRcdCovXHJcblx0XHRpbmNsdWRlKCk7IC8vIHNhdGlzZnkgcmVxdWlyZW1lbnRzLCBHT0VTIEZJUlNUXHJcblx0XHRcclxuXHRcdC8vU3ByaXRlU2hlZXRVdGlscy5hZGRGbGlwcGVkRnJhbWVzKHNwcml0ZVNoZWV0c1tcIkhlcm9cIl0sIHRydWUsIGZhbHNlLCBmYWxzZSk7XHJcblx0fTtcclxuXHJcblx0dmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24oZW50aXR5X2hlcm8pe1xyXG5cdFx0LyogaXMgcmFuIGZvciBldmVyeSBlbnRpdHkgb2YgdGhpcyB0eXBlIHRoYXQgd2FzIGp1c3QgY3JlYXRlZCBhbmQgc2hvdWxkXHJcblx0XHRnZXQgZ3JhcGhpY3MgcmVwcmVzZW50YXRpb24uIFlvdSBhcmUgZ2l2ZW4gdGhlIGVudGl0eSBpbnN0YW5jZSBhbmQgaXMgc3VwcG9zZWRcclxuXHRcdHRvIGNyZXRlIGdyYXBoaWNzIGluc3RhbmNlLCBhbmQgR3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKGdyYXBoaWNzX2luc3RhbmNlLCBlbnRpdHlfaW5zdGFuY2UpOyBpdCBcclxuXHRcdCovXHJcblx0XHR2YXIgZ2V0X2Fzc2V0ID0gQXNzZXRDb250cm9sbGVyLmdldF9hc3NldDtcclxuXHRcdHNwcml0ZXNoZWV0c1tcImhlcm9cIl0gPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoe1xyXG5cdFx0XHRcImZyYW1lcmF0ZVwiOiAxLFxyXG5cdFx0XHRcImltYWdlc1wiOiBbZ2V0X2Fzc2V0KFwiSGVyb1wiKV0sIC8vZ2V0X2Fzc2V0KFwiSGVyb1JcIiksIGdldF9hc3NldChcIkhlcm9XXCIpXHJcblx0XHRcdFwiZnJhbWVzXCI6IHsgXCJyZWdYXCI6IDI1LCBcInJlZ1lcIjogMjUsIFwiaGVpZ2h0XCI6IDUwLCBcIndpZHRoXCI6IDUwLCBcImNvdW50XCI6IDE2fSxcclxuXHRcdFx0XCJhbmltYXRpb25zXCI6IHtcclxuXHRcdFx0XHRcInN0YW5kXCI6IHtcclxuXHRcdFx0XHRmcmFtZXM6IFswXVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJmaW5pc2hcIjoge1xyXG5cdFx0XHRcdFx0ZnJhbWVzOiBbOF1cclxuXHRcdFx0XHR9LFx0XHRcdFx0XHJcblx0XHRcdFx0XCJ3YWxrXCI6IHtcclxuXHRcdFx0XHRcdCBmcmFtZXM6IFswLDEsIDJdLFxyXG5cdFx0XHRcdFx0IHNwZWVkOiAwLjJcclxuXHRcdFx0XHQgfSxcclxuXHRcdFx0XHRcImp1bXBcIjoge1xyXG5cdFx0XHRcdFx0ZnJhbWVzOiBbMywgNCwgNSwgNiwgNywgOF0sXHJcblx0XHRcdFx0XHRzcGVlZDogMC4yXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImRlYXRoXCI6IHtcclxuXHRcdFx0XHRcdGZyYW1lczogWzksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVdLFxyXG5cdFx0XHRcdFx0c3BlZWQ6IDAuMSxcclxuXHRcdFx0XHRcdG5leHQ6IFwiZGVhdGhcIlxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJkZWNheVwiOiB7XHJcblx0XHRcdFx0XHRmcmFtZXM6IFsxNV1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdFx0aGVyb19hbmltYXRpb24gPSBHcmFwaGljc0NvbnRyb2xsZXIucmVxdWVzdF9hbmltYXRlZChzcHJpdGVzaGVldHNbXCJoZXJvXCJdLCBcInN0YW5kXCIpO1xyXG5cdFx0aGVyb19hbmltYXRpb24uZ3JhcGhpY3NfaWQgPSBcImhlcm9cIjtcclxuXHRcdEdyYXBoaWNzQ29udHJvbGxlci5zZXRfcmVnX3Bvc2l0aW9uKGhlcm9fYW5pbWF0aW9uLCAtMjUsIC0yNSk7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoaGVyb19hbmltYXRpb24sIGVudGl0eV9oZXJvKTtcclxuXHRcdGlmKGVudGl0eV9oZXJvLnBsYXllcl9pZCA9PSBOZXR3b3JrQ29udHJvbGxlci5nZXRfbmV0d29ya19pZCgpKXtcclxuXHRcdFx0R3JhcGhpY3NDb250cm9sbGVyLmZvbGxvdyhlbnRpdHlfaGVyby5pZCk7XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblx0LypcclxuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24oaGVybyl7XHJcblxyXG5cdFx0aWYoaGVyby5waHlzaWNhbF9pbnN0YW5jZS5zdGF0ZT09XCJ3YWxrXCImJmhlcm8ucGh5c2ljYWxfaW5zdGFuY2UuaXNfd2FsayA9PSB0cnVlKXtcclxuXHRcdFx0aWYoaGVyby5waHlzaWNhbF9pbnN0YW5jZS53YWxrX3RpY2sgPT0xKXtcclxuXHRcdFx0XHRoZXJvLmdvdG9BbmRQbGF5KFwid2Fsa1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRoZXJvLnBoeXNpY2FsX2luc3RhbmNlLndhbGtfdGljaysrO1xyXG5cdFx0XHRpZihoZXJvLnBoeXNpY2FsX2luc3RhbmNlLndhbGtfdGljayA9PTEwKXtcclxuXHRcdFx0XHRoZXJvLnBoeXNpY2FsX2luc3RhbmNlLnN0YXRlPSBcInN0YW5kXCI7XHJcblx0XHRcdFx0aGVyby5waHlzaWNhbF9pbnN0YW5jZS5pc193YWxrID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYoaGVyby5waHlzaWNhbF9pbnN0YW5jZS5zdGF0ZT09XCJqdW1wXCIpe1xyXG5cdFx0XHRpZihoZXJvLnBoeXNpY2FsX2luc3RhbmNlLmp1bXBfdGljayA9PTEpe1xyXG5cdFx0XHRcdGhlcm8uZ290b0FuZFBsYXkoXCJqdW1wXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGhlcm8ucGh5c2ljYWxfaW5zdGFuY2UuanVtcF90aWNrKys7XHJcblx0XHRcdGlmKGhlcm8ucGh5c2ljYWxfaW5zdGFuY2UuanVtcF90aWNrID49IDIwKXtcclxuXHRcdFx0XHRoZXJvLmdvdG9BbmRQbGF5KFwiZmluaXNoXCIpO1xyXG5cdFx0XHRcdGlmKGhlcm8ucGh5c2ljYWxfaW5zdGFuY2UuanVtcHM9PTApe1xyXG5cdFx0XHRcdFx0aGVyby5waHlzaWNhbF9pbnN0YW5jZS5zdGF0ZT1cImZpbmlzaFwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZihoZXJvLnBoeXNpY2FsX2luc3RhbmNlLnN0YXRlPT1cImZpbmlzaFwiKXtcclxuXHRcdFx0aGVyby5nb3RvQW5kUGxheShcImZpbmlzaFwiKTtcclxuXHRcdH1cclxuXHRcdGlmKGhlcm8ucGh5c2ljYWxfaW5zdGFuY2Uuc3RhdGU9PVwiZGVhdGhGaW5hbFwiKXtcclxuXHRcdFx0aGVyby5nb3RvQW5kUGxheShcImRlYXRoRmluYWxcIik7XHJcblx0XHR9XHJcblx0XHRpZihoZXJvLnBoeXNpY2FsX2luc3RhbmNlLnN0YXRlPT1cInN0YW5kXCIpe1xyXG5cdFx0XHRoZXJvLmdvdG9BbmRQbGF5KFwic3RhbmRcIik7XHJcblx0XHR9XHJcblx0XHQvL2NvbnNvbGUubG9nKGhlcm8ucGh5c2ljYWxfaW5zdGFuY2Uuc3RhdGUpO1xyXG5cdFx0aWYgKGhlcm8ucGh5c2ljYWxfaW5zdGFuY2Uuc3RhdGUgPT0gXCJkZWF0aFwiKSB7XHJcblx0XHRcdC8vY29uc29sZS5sb2coaGVyby5waHlzaWNhbF9pbnN0YW5jZS5kZWF0aF90aWNrKTtcclxuXHRcdFx0aWYoaGVyby5waHlzaWNhbF9pbnN0YW5jZS5kZWF0aF90aWNrID09MSl7XHJcblx0XHRcdCAgICBoZXJvLmdvdG9BbmRQbGF5KFwiZGVhdGhcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZihoZXJvLnBoeXNpY2FsX2luc3RhbmNlLmRlYXRoX3RpY2sgPj0yMCl7XHJcblx0XHRcdFx0aGVyby5waHlzaWNhbF9pbnN0YW5jZS5zdGF0ZT1cImRlYXRoRmluYWxcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL3NldCBkaXJlY3Rpb25cclxuXHRcdGlmIChoZXJvLnBoeXNpY2FsX2luc3RhbmNlLmxlZnQpeyAvL2lmIGRpcmVjdGlvbiA9PSByaWdodCwgZmxpcCByaWdodFxyXG5cdFx0XHRoZXJvLnNjYWxlWCA9IC0xO1xyXG5cdFx0fWVsc2V7IC8vZWxzZSBmbGlwIGxlZnRcclxuXHRcdFx0aGVyby5zY2FsZVggPSAxO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0Ki9cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdC8vIGRlY2xhcmUgcHVibGljXHJcblx0XHRpbml0OiBpbml0LCBcclxuXHRcdHJlZ2lzdGVyOiByZWdpc3RlcixcclxuXHRcdC8vcmVuZGVyOiByZW5kZXIsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSGVyb1JlbmRlcmVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiSGVyb1JlbmRlcmVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUl9TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcbiIsInZhciBIeWVuYVJlbmRlcmVyID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciBzcHJpdGVzaGVldHMgPSB7fTtcclxuXHR2YXIgSHllbmFfYW5pbWF0aW9uO1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSBHcmFwaGljc0NvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmdcclxuXHRcdCBcdHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzcHJpdGVzaGVldHMgYW5kIHN1Y2hcclxuXHRcdFx0bGlrZSBzcHJpdGVzaGVldHMuZmlyc3QgPSBuZXcgY3JlYXRlanMuU3ByaXRlc2hlZXQoLi4uKTtcclxuXHRcdCovXHJcblxyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0dmFyIGdldF9hc3NldCA9IEFzc2V0Q29udHJvbGxlci5nZXRfYXNzZXQ7XHJcblxyXG5cdFx0c3ByaXRlc2hlZXRzW1wiSHllbmFcIl0gPSBuZXcgY3JlYXRlanMuU3ByaXRlU2hlZXQoe1xyXG5cdFx0XHRcImZyYW1lcmF0ZVwiOiAxLFxyXG5cdFx0XHRcImltYWdlc1wiOiBbZ2V0X2Fzc2V0KFwiSHllbmFTcHJpdGVcIildLFxyXG5cdFx0XHRcImZyYW1lc1wiOiB7IFwicmVnWFwiOiAwLCBcInJlZ1lcIjogOCwgXCJoZWlnaHRcIjogNjQsIFwid2lkdGhcIjogNjQsIFwiY291bnRcIjogMTd9LFxyXG5cdFx0XHRcImFuaW1hdGlvbnNcIjoge1xyXG5cdFx0XHRcdFwicnVuXCI6IFswLDMsIFwicnVuXCIsIDAuNV0sXHJcblx0XHRcdFx0XCJzdGFuZFwiOiBbNCw1LCBcInN0YW5kXCIsIDAuMjVdLFxyXG5cdFx0XHRcdFwid2Fsa1wiOiBbOCwxMSwgXCJ3YWxrXCIsIDAuMl0sXHJcblx0XHRcdFx0XCJsZWFwXCI6IFs2XSxcclxuXHRcdFx0XHRcImZhbGxcIjogWzddLFxyXG5cdFx0XHRcdFwiZGVhdGhcIjogWzEyLDE0LCBcImRlY2F5XCIsIDAuMjVdLFxyXG5cdFx0XHRcdFwiZGVjYXlcIjogWzE1LDE2LCBcImRlY2F5XCIsIDAuMjVdLFxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbihlbnRpdHlfaHllbmEpe1xyXG5cdFx0LyogaXMgcnVuIGZvciBldmVyeSBlbnRpdHkgb2YgdGhpcyB0eXBlIHRoYXQgd2FzIGp1c3QgY3JlYXRlZCBhbmQgc2hvdWxkXHJcblx0XHRnZXQgZ3JhcGhpY3MgcmVwcmVzZW50YXRpb24uIFlvdSBhcmUgZ2l2ZW4gdGhlIGVudGl0eSBpbnN0YW5jZSBhbmQgaXMgc3VwcG9zZWRcclxuXHRcdHRvIGNyZWF0ZSBncmFwaGljcyBpbnN0YW5jZSwgYW5kIEdyYXBoaWNzQ29udHJvbGxlci5yZWdfZm9yX3JlbmRlcihncmFwaGljc19pbnN0YW5jZSwgZW50aXR5X2luc3RhbmNlKTsgaXQgXHJcblx0XHQqL1xyXG5cclxuXHRcdGh5ZW5hX2FuaW1hdGlvbiA9IEdyYXBoaWNzQ29udHJvbGxlci5yZXF1ZXN0X2FuaW1hdGVkKHNwcml0ZXNoZWV0c1tcIkh5ZW5hXCJdLCBcIndhbGtcIik7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIuc2V0X3JlZ19wb3NpdGlvbihoeWVuYV9hbmltYXRpb24sIDAsIDApOyAvLyBjaGFuZ2UgdGhhdCB0byBhZGp1c3Qgc3ByaXRlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBib2R5XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoaHllbmFfYW5pbWF0aW9uLCBlbnRpdHlfaHllbmEpOyAvLyBzZXRzIGh5ZW5hX2FuaW1hdGlvbidzIHBvc2l0aW9uIHRvIHRyYWNrIHRoZSBoeWVuYSdzIHBvc2l0aW9uICh1cGRhdGVzIGVhY2ggdGljaylcclxuXHRcdC8qXHJcblx0XHRoeWVuYV9hbmltYXRpb24gaXMgdGhlIGVhc2VsanNfb2JqIHBhc3NlZCB0aHJvdWdoIGdyYXBoaWNzQ29udHJvbGxlclxyXG5cdFx0ZW50aXR5X2h5ZW5hIGlzIHRoZSBwaHlzaWNhbCBvYmplY3Qgc3Bhd25lZCBpbiBIeWVuYUxvZ2ljXHJcblx0XHRyZXF1ZXN0X2FuaW1hdGVkIHJldHVybnMgYW4gZWFzZWxqcyBvYmplY3Qgb2YgdHlwZSBTcHJpdGVcclxuXHRcdHRoaXMgU3ByaXRlIGlzIHRoZSBvYmplY3QgcGFzc2VkIHRvIHJlbmRlclxyXG5cdFx0Ki9cclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbihoeWVuYSl7XHJcblx0XHQvKiBcdGlzIHJ1biBlYWNoIHRpY2sgZnJvbSBHcmFwaGljc0NvbnRyb2xsZXIsIGZvciBldmVyeSByZWdpc3RlcmVkIG9iamVjdCBvZiB0aGlzIHR5cGVcclxuXHRcdFx0aXMgZ2l2ZW4gPmdyYXBoaWNzX2luc3RhbmNlPCBwYXJhbWV0ZXIsIHdoaWNoIGlzIGFsc28gc3VwcG9zZWQgdG8gY29udGFpblxyXG5cdFx0XHRwaHlzaWNhbF9pbnN0YW5jZSBwcm9wZXJ0eSBjb250YWluaW5nIGVudGl0eV9pbnN0YW5jZSwgaWYgaXQgd2FzIGF0dGFjaGVkIGNvcnJlY3RseVxyXG5cdFx0Ki9cclxuXHJcblx0XHRoeWVuYV9hbmltYXRlKGh5ZW5hKTsgXHJcblx0fTtcclxuXHJcblx0dmFyIGh5ZW5hX2FuaW1hdGUgPSBmdW5jdGlvbihoeWVuYSl7XHJcblx0XHQvL3NldCBncmFwaGljYWwgcmVwcmVzZW50YXRpb24gYmFzZWQgb24gdGhlIGFuaW1hdGlvbiB2YXJpYWJsZSBkZXRlcm1pbmVkIGJ5IHRoZSBBSVxyXG5cdFx0Ly9zZXQgYW5pbWF0aW9uXHJcblx0XHRpZihoeWVuYS5waHlzaWNhbF9pbnN0YW5jZS5uZWVkc19ncmFwaGljc191cGRhdGUpe1xyXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gaHllbmEucGh5c2ljYWxfaW5zdGFuY2UuYW5pbWF0aW9uO1xyXG5cdFx0XHRoeWVuYS5nb3RvQW5kUGxheShhbmltYXRpb24pXHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vc2V0IGRpcmVjdGlvblxyXG5cdFx0aWYgKGh5ZW5hLnBoeXNpY2FsX2luc3RhbmNlLmRpcmVjdGlvbil7IC8vaWYgZGlyZWN0aW9uID09IHJpZ2h0LCBmbGlwIHJpZ2h0XHJcblx0XHRcdGh5ZW5hLnNjYWxlWCA9IC0xO1xyXG5cdFx0fWVsc2V7IC8vZWxzZSBmbGlwIGxlZnRcclxuXHRcdFx0aHllbmEuc2NhbGVYID0gMTtcclxuXHRcdH1cclxuXHJcblx0XHQvL3NldCBhbHBoYSBpZiBibGlua2luZ1xyXG5cdFx0aWYoaHllbmEucGh5c2ljYWxfaW5zdGFuY2UuYmxpbmtpbmcgJiYgaHllbmEucGh5c2ljYWxfaW5zdGFuY2UuYmxpbmtfdGltZXIlMiA9PSAxKXtcclxuXHRcdFx0aHllbmEuYWxwaGEgPSAwO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdGh5ZW5hLmFscGhhID0gMTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXHJcblx0XHRyZW5kZXI6IHJlbmRlcixcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIeWVuYVJlbmRlcmVyO1xyXG5cclxudmFyIEluY2x1ZGVzID0gcmVxdWlyZShcIi4uL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0Y3VycmVudF9tb2R1bGU6IFwiSHllbmFSZW5kZXJlclwiLCBcclxuXHRpbmNsdWRlX29wdGlvbnM6IEluY2x1ZGVzLmNob2ljZXMuUkVOREVSRVJfU1BFQ0lGSUNcclxufSk7IGV2YWwoaW5jbHVkZV9kYXRhLm5hbWVfc3RhdGVtZW50cyk7IHZhciBpbmNsdWRlID0gZnVuY3Rpb24oKXtldmFsKGluY2x1ZGVfZGF0YS5tb2R1bGVfc3RhdGVtZW50cyk7fVxyXG4iLCJ2YXIgTWVkdXNhUmVuZGVyZXIgPSAoZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHNwcml0ZXNoZWV0cyA9IHt9O1xyXG5cdHZhciBNZWR1c2FfYW5pbWF0aW9uO1xyXG5cclxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHQvKiBpcyByYW4gZnJvbSBHcmFwaGljc0NvbnRyb2xsZXIuaW5pdCBvbmNlIGR1cmluZyBnYW1lIGxvYWRpbmdcclxuXHRcdCBcdHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNyZWF0ZSBzcHJpdGVzaGVldHMgYW5kIHN1Y2hcclxuXHRcdFx0bGlrZSBzcHJpdGVzaGVldHMuZmlyc3QgPSBuZXcgY3JlYXRlanMuU3ByaXRlc2hlZXQoLi4uKTtcclxuXHRcdCovXHJcblxyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cdFx0dmFyIGdldF9hc3NldCA9IEFzc2V0Q29udHJvbGxlci5nZXRfYXNzZXQ7XHJcblxyXG5cdFx0c3ByaXRlc2hlZXRzW1wiTWVkdXNhXCJdID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KHtcclxuXHRcdFx0XCJmcmFtZXJhdGVcIjogMSxcclxuXHRcdFx0XCJpbWFnZXNcIjogW2dldF9hc3NldChcIk1lZHVzYTFcIiksXSwgLy9NZWR1c2FTcHJpdGVTaGVldFxyXG5cdFx0XHRcImZyYW1lc1wiOiB7IFwicmVnWFwiOiAwLCBcInJlZ1lcIjogMCwgXCJoZWlnaHRcIjogODUsIFwid2lkdGhcIjogNDcuNSwgXCJjb3VudFwiOiAzfSxcclxuXHRcdFx0XHRcImFuaW1hdGlvbnNcIjoge1xyXG5cdFx0XHRcdFwid2Fsa1wiOiBbMCwgMiwgXCJ3YWxrXCIsIDAuMl0sXHJcblx0XHRcdFx0XCJpbmp1cnlcIjoge1xyXG5cdFx0XHRcdCAgICBmcmFtZXM6IFsyLCAzLCAuMjVdXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImRlYXRoXCI6IFsyLCAzLCBcImRlYXRoXCIsIDAuNl0sXHJcbiAgICAgICAgICAgICAgICBcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24oZW50aXR5X01lZHVzYSl7XHJcblx0XHQvKiBpcyByYW4gZm9yIGV2ZXJ5IGVudGl0eSBvZiB0aGlzIHR5cGUgdGhhdCB3YXMganVzdCBjcmVhdGVkIGFuZCBzaG91bGRcclxuXHRcdGdldCBncmFwaGljcyByZXByZXNlbnRhdGlvbi4gWW91IGFyZSBnaXZlbiB0aGUgZW50aXR5IGluc3RhbmNlIGFuZCBpcyBzdXBwb3NlZFxyXG5cdFx0dG8gY3JldGUgZ3JhcGhpY3MgaW5zdGFuY2UsIGFuZCBHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoZ3JhcGhpY3NfaW5zdGFuY2UsIGVudGl0eV9pbnN0YW5jZSk7IGl0IFxyXG5cdFx0Ki9cclxuXHJcblx0XHRNZWR1c2FfYW5pbWF0aW9uID0gR3JhcGhpY3NDb250cm9sbGVyLnJlcXVlc3RfYW5pbWF0ZWQoc3ByaXRlc2hlZXRzW1wiTWVkdXNhXCJdLCBcIndhbGtcIik7XHJcblx0XHRHcmFwaGljc0NvbnRyb2xsZXIuc2V0X3JlZ19wb3NpdGlvbihNZWR1c2FfYW5pbWF0aW9uLCAwLCAwKTsgLy8gY2hhbmdlIHRoYXQgdG8gYWRqdXN0IHNwcml0ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keVxyXG5cdFx0R3JhcGhpY3NDb250cm9sbGVyLnJlZ19mb3JfcmVuZGVyKE1lZHVzYV9hbmltYXRpb24sIGVudGl0eV9NZWR1c2EpOyAvLyBzZXRzIG1lZHVzYV9hbmltYXRpb24ncyBwb3NpdGlvbiB0byB0cmFjayB0aGUgbWVkdXNhJ3MgcG9zaXRpb24gKHVwZGF0ZXMgZWFjaCB0aWNrKVxyXG5cclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbihNZWR1c2Epe1xyXG5cdFx0LyogXHRpcyByYW4gZWFjaCB0aWNrIGZyb20gR3JhcGhpY3NDb250cm9sbGVyLCBmb3IgZXZlcnkgcmVnaXN0ZXJlZCBvYmplY3Qgb2YgdGhpcyB0eXBlXHJcblx0XHRcdGlzIGdpdmVuID5ncmFwaGljc19pbnN0YW5jZTwgcGFyYW1ldGVyLCB3aGljaCBpcyBhbHNvIHN1cHBvc2VkIHRvIGNvbnRhaW5cclxuXHRcdFx0cGh5c2ljYWxfaW5zdGFuY2UgcHJvcGVydHkgY29udGFpbmluZyBlbnRpdHlfaW5zdGFuY2UsIGlmIGl0IHdhcyBhdHRjaGVkIGNvcnJlY3RseVxyXG5cdFx0Ki9cclxuXHJcblx0XHRNZWR1c2Ffc3BlY2lhbF9yZW5kZXJfdGVtcChNZWR1c2EpOyBcclxuXHR9O1xyXG5cclxuXHR2YXIgTWVkdXNhX3NwZWNpYWxfcmVuZGVyX3RlbXAgPSBmdW5jdGlvbihNZWR1c2Epe1xyXG5cdFx0LyogaG93IHRvIGhhbmRsZSBzcGVjaWFsIHJlbmRlcj8gVEVNUE9SQVJZICovXHJcblxyXG5cdFx0Ly9zZXQgZ3JhcGhpY2FsIHJlcHJlc2VudGF0aW9uIGJhc2VkIG9uIHRoZSBhbmltYXRpb24gdmFyaWFibGUgZGV0ZXJtaW5lZCBieSB0aGUgQUlcclxuXHRcdC8vc2V0IGFuaW1hdGlvblxyXG5cdFx0aWYoTWVkdXNhLnBoeXNpY2FsX2luc3RhbmNlLm5lZWRzX2dyYXBoaWNzX3VwZGF0ZSl7XHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBNZWR1c2EucGh5c2ljYWxfaW5zdGFuY2UuYW5pbWF0aW9uO1xyXG5cdFx0XHRNZWR1c2EuZ290b0FuZFBsYXkoYW5pbWF0aW9uKVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL3NldCBkaXJlY3Rpb25cclxuXHRcdGlmIChNZWR1c2EucGh5c2ljYWxfaW5zdGFuY2UuZGlyZWN0aW9uKXsgLy9pZiBkaXJlY3Rpb24gPT0gcmlnaHQsIGZsaXAgcmlnaHRcclxuXHRcdFx0TWVkdXNhLnNjYWxlWCA9IC0xO1xyXG5cdFx0fWVsc2V7IC8vZWxzZSBmbGlwIGxlZnRcclxuXHRcdFx0TWVkdXNhLnNjYWxlWCA9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9zZXQgYWxwaGEgaWYgYmxpbmtpbmdcclxuXHRcdGlmKE1lZHVzYS5waHlzaWNhbF9pbnN0YW5jZS5ibGlua2luZyAmJiBNZWR1c2EucGh5c2ljYWxfaW5zdGFuY2UuYmxpbmtfdGltZXIlMiA9PSAxKXtcclxuXHRcdFx0TWVkdXNhLmFscGhhID0gMDtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRNZWR1c2EuYWxwaGEgPSAxO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXHJcblx0XHRyZW5kZXI6IHJlbmRlcixcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNZWR1c2FSZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIk1lZHVzYVJlbmRlcmVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUl9TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcbiIsInZhciBQaXp6YVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgc3ByaXRlc2hlZXRzID0ge307IC8vIHRvIHN0b3JlIHNwcml0ZXNoZWV0cyB1c2VkIGJ5IHRoaXMgZW50aXR5XHJcblxyXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG4gICAgICAgIHZhciBnZXRfYXNzZXQgPSBBc3NldENvbnRyb2xsZXIuZ2V0X2Fzc2V0O1xyXG4gICAgICAgIHNwcml0ZXNoZWV0c1tcInBpenphXCJdID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KHtcclxuICAgICAgICAgICAgXCJmcmFtZXJhdGVcIjogMSxcclxuICAgICAgICAgICAgXCJpbWFnZXNcIjogW2dldF9hc3NldChcInBpenphXCIpXSxcclxuICAgICAgICAgICAgXCJmcmFtZXNcIjogeyBcInJlZ1hcIjogMCwgXCJyZWdZXCI6IDAsIFwiaGVpZ2h0XCI6IDE1LCBcIndpZHRoXCI6IDE1LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgXCJhbmltYXRpb25zXCI6IHtcclxuICAgICAgICAgICAgICAgIFwibm9ybWFsXCI6IFsxLCBcIndhbGtcIl1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZWdpc3RlciA9IGZ1bmN0aW9uIChlbnRpdHlfcGl6emEpIHtcclxuICAgICAgICBwaXp6YV9hbmltYXRpb24gPSBHcmFwaGljc0NvbnRyb2xsZXIucmVxdWVzdF9hbmltYXRlZChzcHJpdGVzaGVldHNbXCJwaXp6YVwiXSwgXCJub3JtYWxcIik7XHJcbiAgICAgICAgR3JhcGhpY3NDb250cm9sbGVyLnNldF9yZWdfcG9zaXRpb24ocGl6emFfYW5pbWF0aW9uLCAwLCAwKTsgLy8gY2hhbmdlIHRoYXQgdG8gYWRqdXN0IHNwcml0ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keVxyXG4gICAgICAgIEdyYXBoaWNzQ29udHJvbGxlci5yZWdfZm9yX3JlbmRlcihwaXp6YV9hbmltYXRpb24sIGVudGl0eV9waXp6YSk7IC8vIHNldHMgYW50X2FuaW1hdGlvbidzIHBvc2l0aW9uIHRvIHRyYWNrIHRoZSBhbnQncyBwb3NpdGlvbiAodXBkYXRlcyBlYWNoIHRpY2spXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiAoY2VsbCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBkZWNsYXJlIHB1YmxpY1xyXG4gICAgICAgIGluaXQ6IGluaXQsXHJcbiAgICAgICAgcmVnaXN0ZXI6IHJlZ2lzdGVyLFxyXG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGl6emFSZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG4gICAgY3VycmVudF9tb2R1bGU6IFwiVGVycmFpbkNlbGxSZW5kZXJlclwiLFxyXG4gICAgaW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLlJFTkRFUkVSX1NQRUNJRklDXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uICgpIHsgZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpOyB9XHJcblxyXG4iLCJ2YXIgVGVycmFpbkNlbGxSZW5kZXJlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgc3ByaXRlc2hlZXRzID0ge307IC8vIHRvIHN0b3JlIHNwcml0ZXNoZWV0cyB1c2VkIGJ5IHRoaXMgZW50aXR5XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIGlzIHJhbiBmcm9tIEdyYXBoaWNzQ29udHJvbGxlci5pbml0IG9uY2UgZHVyaW5nIGdhbWUgbG9hZGluZ1xyXG5cdFx0XHR1c2UgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgc3ByaXRlc2hlZXRzIGFuZCBzdWNoXHJcblx0XHRcdGxpa2Ugc3ByaXRlc2hlZXRzLmZpcnN0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZXNoZWV0KC4uLik7XHJcblx0XHQqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbihlbnRpdHlfY2VsbCl7XHJcblx0XHQvKiBpcyByYW4gZm9yIGV2ZXJ5IGVudGl0eSBvZiB0aGlzIHR5cGUgdGhhdCB3YXMganVzdCBjcmVhdGVkIGFuZCBzaG91bGRcclxuXHRcdGdldCBncmFwaGljcyByZXByZXNlbnRhdGlvbi4gWW91IGFyZSBnaXZlbiB0aGUgZW50aXR5IGluc3RhbmNlIGFuZCBpcyBzdXBwb3NlZFxyXG5cdFx0dG8gY3JldGUgZ3JhcGhpY3MgaW5zdGFuY2UsIGFuZCBHcmFwaGljc0NvbnRyb2xsZXIucmVnX2Zvcl9yZW5kZXIoZ3JhcGhpY3NfaW5zdGFuY2UsIGVudGl0eV9pbnN0YW5jZSk7IGl0IFxyXG5cdFx0Ki9cclxuXHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24oY2VsbCl7XHJcblx0XHQvKiBcdGlzIHJhbiBlYWNoIHRpY2sgZnJvbSBHcmFwaGljc0NvbnRyb2xsZXIsIGZvciBldmVyeSByZWdpc3RlcmVkIG9iamVjdCBvZiB0aGlzIHR5cGVcclxuXHRcdFx0aXMgZ2l2ZW4gPmdyYXBoaWNzX2luc3RhbmNlPCBwYXJhbWV0ZXIsIHdoaWNoIGlzIGFsc28gc3VwcG9zZWQgdG8gY29udGFpblxyXG5cdFx0XHRwaHlzaWNhbF9pbnN0YW5jZSBwcm9wZXJ0eSBjb250YWluaW5nIGVudGl0eV9pbnN0YW5jZSwgaWYgaXQgd2FzIGF0dGNoZWQgY29ycmVjdGx5XHJcblx0XHQqL1xyXG5cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gZGVjbGFyZSBwdWJsaWNcclxuXHRcdGluaXQ6IGluaXQsIFxyXG5cdFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxyXG5cdFx0cmVuZGVyOiByZW5kZXIsXHJcblx0fTtcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVGVycmFpbkNlbGxSZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIlRlcnJhaW5DZWxsUmVuZGVyZXJcIiwgXHJcblx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLlJFTkRFUkVSX1NQRUNJRklDXHJcbn0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuXHJcbiIsInZhciBUZXJyYWluU2xpY2VSZW5kZXJlciA9IChmdW5jdGlvbigpe1xyXG5cclxuXHR2YXIgc3ByaXRlc2hlZXRzID0ge307IC8vIHRvIHN0b3JlIHNwcml0ZXNoZWV0cyB1c2VkIGJ5IHRoaXMgZW50aXR5XHJcblxyXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oKXtcclxuXHRcdC8qIGlzIHJhbiBmcm9tIEdyYXBoaWNzQ29udHJvbGxlci5pbml0IG9uY2UgZHVyaW5nIGdhbWUgbG9hZGluZ1xyXG5cdFx0XHR1c2UgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgc3ByaXRlc2hlZXRzIGFuZCBzdWNoXHJcblx0XHRcdGxpa2Ugc3ByaXRlc2hlZXRzLmZpcnN0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZXNoZWV0KC4uLik7XHJcblx0XHQqL1xyXG5cdFx0aW5jbHVkZSgpOyAvLyBzYXRpc2Z5IHJlcXVpcmVtZW50cywgR09FUyBGSVJTVFxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbihzbGljZSwgUHJpdmF0ZUdyYXBoaWNzKXtcclxuXHRcdC8qIGlzIHJhbiBmb3IgZXZlcnkgZW50aXR5IG9mIHRoaXMgdHlwZSB0aGF0IHdhcyBqdXN0IGNyZWF0ZWQgYW5kIHNob3VsZFxyXG5cdFx0Z2V0IGdyYXBoaWNzIHJlcHJlc2VudGF0aW9uLiBZb3UgYXJlIGdpdmVuIHRoZSBlbnRpdHkgaW5zdGFuY2UgYW5kIGlzIHN1cHBvc2VkXHJcblx0XHR0byBjcmV0ZSBncmFwaGljcyBpbnN0YW5jZSwgYW5kIEdyYXBoaWNzQ29udHJvbGxlci5yZWdfZm9yX3JlbmRlcihncmFwaGljc19pbnN0YW5jZSwgZW50aXR5X2luc3RhbmNlKTsgaXQgXHJcblx0XHQqL1xyXG5cclxuXHRcdC8vIFRPRE86IGNoYW5nZSB0aGF0IHByaXZhdGUgY3JhcCB0byBzbXRoIG1vcmUgdXNlZnVsXHJcblx0XHQvLyBsaWtlIG1ha2UgZ3JhcGhpY3MgY29udHJvbGxlciBzcGVjaWFsIGNhc2UgaW4gaW5jbHVkZXMsXHJcblx0XHQvLyBzbyB0aGF0IG9ubHkgaW50ZXJlc3RlZCBwZW9wbGUgY2FuIGdldCBpdFxyXG5cdFx0dmFyIHJlcXVlc3RfYW5pbWF0ZWQgPSBQcml2YXRlR3JhcGhpY3MucmVxdWVzdF9hbmltYXRlZDtcclxuXHRcdHZhciByZXF1ZXN0X2JpdG1hcCA9IFByaXZhdGVHcmFwaGljcy5yZXF1ZXN0X2JpdG1hcDtcclxuXHRcdHZhciB0cmFuc194eSA9IFByaXZhdGVHcmFwaGljcy50cmFuc194eTtcclxuXHRcdHZhciByZWdfZm9yX3JlbmRlciA9IFByaXZhdGVHcmFwaGljcy5yZWdfZm9yX3JlbmRlcjtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc2xpY2UuZ3JpZF9yb3dzOyBpKyspe1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBzbGljZS5ncmlkX2NvbHVtbnM7IGorKyl7XHJcblx0XHRcdFx0XHR2YXIga2luZCA9IHNsaWNlLmdyaWRbaV1bal0ua2luZDtcclxuXHRcdFx0XHRcdGlmKGtpbmQgIT0gMCl7XHJcblx0XHRcdFx0XHRcdC8vIFRPRE86IHNob3VsZCBtYWtlIHByb3BlciB0ZXJyYWluIGNvbGxlY3Rpb24gdGhpbmcgdG8gcHVsbCBmcm9tXHJcblx0XHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHRcdHZhciB0aWxlX3RleHR1cmUgPSBbXCJncmFzc1wiLCBcIm1pZGRsZV90ZXJyYWluXCIsIFwiYm90dG9tX3RlcnJhaW5cIl1ba2luZC0xXTtcclxuXHRcdFx0XHRcdFx0dmFyIHRpbGUgPSByZXF1ZXN0X2JpdG1hcCh0aWxlX3RleHR1cmUpO1xyXG5cdFx0XHRcdFx0XHQqL1xyXG5cdFx0XHRcdFx0XHR2YXIgc3VyZmFjZV90ZXh0dXJlcyA9IFtcImdyYXNzX3dpbnRlclwiLFwiZ3Jhc3Nfc3ByaW5nXCIsXCJncmFzc19zdW1tZXJcIixcImdyYXNzX2ZhbGxcIl07XHJcblx0XHRcdFx0XHRcdHZhciBwb3NpdGlvbiA9IHNsaWNlLmdyaWRbaV1bal0ucG9zaXRpb247XHJcblx0XHRcdFx0XHRcdGlmIChraW5kID09IDEpeyAvL2lmIHRpbGUgaXMgcGFydCBvZiB0aGUgZ3JvdW5kXHJcblx0XHRcdFx0XHRcdFx0c3dpdGNoIChwb3NpdGlvbil7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJzdXJmYWNlXCI6XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhXb3JsZENvbnRyb2xsZXIuZ2V0X3NlYXNvbigpKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdGlsZV90ZXh0dXJlID0gc3VyZmFjZV90ZXh0dXJlc1tXb3JsZENvbnRyb2xsZXIuZ2V0X3NlYXNvbigpXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwidW5kZXJncm91bmRcIjpcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRpbGVfdGV4dHVyZSA9IFwiYm90dG9tX3RlcnJhaW5cIjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmIChraW5kID09IDIpeyAvL2lmIHRpbGUgaXMgcGFydCBvZiBhIHBsYXRmb3JtXHJcblx0XHRcdFx0XHRcdFx0c3dpdGNoIChwb3NpdGlvbil7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibGVmdFwiOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdGlsZV90ZXh0dXJlID0gXCJsZWZ0X3BsYXRmb3JtXCI7O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJtaWRkbGVcIjpcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRpbGVfdGV4dHVyZSA9IFwibWlkZGxlX3BsYXRmb3JtXCI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInJpZ2h0XCI6XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciB0aWxlX3RleHR1cmUgPSBcInJpZ2h0X3BsYXRmb3JtXCI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAoa2luZCA9PSAzKXsvL2lmIHRpbGUgaXMgYWN0dWFsbHkganVzdCBzcGlrZXNcclxuXHRcdFx0XHRcdFx0XHR2YXIgdGlsZV90ZXh0dXJlID0gXCJwbGF0Zm9ybV9zcGlrZXNcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR2YXIgdGlsZSA9IHJlcXVlc3RfYml0bWFwKHRpbGVfdGV4dHVyZSk7XHJcblx0XHRcdFx0XHRcdHZhciBwaHlzaWNhbF9pbnN0YW5jZSA9IHNsaWNlLmdyaWRbaV1bal07XHJcblx0XHRcdFx0XHRcdHZhciBib2R5X3Bvc2l0aW9uID0gcGh5c2ljYWxfaW5zdGFuY2UuYm9keS5HZXRXb3JsZENlbnRlcigpO1xyXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNfcG9zID0gdHJhbnNfeHkoYm9keV9wb3NpdGlvbik7XHJcblx0XHRcdFx0XHRcdHRpbGUueCA9IHRyYW5zX3Bvcy54O1xyXG5cdFx0XHRcdFx0XHR0aWxlLnkgPSB0cmFuc19wb3MueTtcclxuXHRcdFx0XHRcdFx0cmVnX2Zvcl9yZW5kZXIodGlsZSwgcGh5c2ljYWxfaW5zdGFuY2UpO1xyXG5cdFx0XHRcdFx0fSAvLyBlbmQgdGlsZV90ZXh0dXJlIGFzc2lnbm1lbnRcclxuXHRcdFx0XHR9IC8vIGVuZCBmb3JcclxuXHRcdFx0fS8vZW5kIGZvclxyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0dmFyIHJlbmRlciA9IGZ1bmN0aW9uKHNsaWNlKXtcclxuXHRcdC8qIFx0aXMgcmFuIGVhY2ggdGljayBmcm9tIEdyYXBoaWNzQ29udHJvbGxlciwgZm9yIGV2ZXJ5IHJlZ2lzdGVyZWQgb2JqZWN0IG9mIHRoaXMgdHlwZVxyXG5cdFx0XHRpcyBnaXZlbiA+Z3JhcGhpY3NfaW5zdGFuY2U8IHBhcmFtZXRlciwgd2hpY2ggaXMgYWxzbyBzdXBwb3NlZCB0byBjb250YWluXHJcblx0XHRcdHBoeXNpY2FsX2luc3RhbmNlIHByb3BlcnR5IGNvbnRhaW5pbmcgZW50aXR5X2luc3RhbmNlLCBpZiBpdCB3YXMgYXR0Y2hlZCBjb3JyZWN0bHlcclxuXHRcdCovXHJcblxyXG5cdH07XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHQvLyBkZWNsYXJlIHB1YmxpY1xyXG5cdFx0aW5pdDogaW5pdCwgXHJcblx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXHJcblx0XHRyZW5kZXI6IHJlbmRlcixcclxuXHR9O1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXJyYWluU2xpY2VSZW5kZXJlcjtcclxuXHJcbnZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuLi9JbmNsdWRlcy5qc1wiKTsgdmFyIGluY2x1ZGVfZGF0YSA9IEluY2x1ZGVzLmdldF9pbmNsdWRlX2RhdGEoe1xyXG5cdGN1cnJlbnRfbW9kdWxlOiBcIlRlcnJhaW5TbGljZVJlbmRlcmVyXCIsIFxyXG5cdGluY2x1ZGVfb3B0aW9uczogSW5jbHVkZXMuY2hvaWNlcy5SRU5ERVJFUl9TUEVDSUZJQ1xyXG59KTsgZXZhbChpbmNsdWRlX2RhdGEubmFtZV9zdGF0ZW1lbnRzKTsgdmFyIGluY2x1ZGUgPSBmdW5jdGlvbigpe2V2YWwoaW5jbHVkZV9kYXRhLm1vZHVsZV9zdGF0ZW1lbnRzKTt9XHJcblxyXG4iLCJcclxuLypcclxuICogUnVsZXMgZm9yIHdvcmtpbmcgb24gdGhlIChjbGllbnQtc2lkZSkgZ2FtZSBjb2RlOlxyXG4gKlxyXG4gKiAxLiBJZiB5b3UgdGhpbmsgdGhhdCBvbmUgb2YgdGhlc2UgcnVsZXMgaXMgc3R1cGlkIG9yIHVzZWxlc3MsIHRlbGwgbWUsIGFsb25nIHdpdGggc29tZSBiZXR0ZXIgc3VnZ2VzdGlvbnMuXHJcbiAqXHJcbiAqIDIuIE1vZGVsIFtuYW1lXU1vZGVsIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIHRocm91Z2ggW25hbWVdQ29udHJvbGxlci4gSWYgeW91IG5lZWQgdG8gZG8gc29tZXRoaW5nIHRvIFxyXG4gKiBcdFx0Y2hhbmdlIFtuYW1lXU1vZGVsIGZyb20gW290aGVyX25hbWVdQ29udHJvbGxlciwgd3JpdGUgZnVuY3Rpb24gaW4gdGhlIFtuYW1lXUNvbnRyb2xsZXIgdGhhdCBkb2VzXHJcbiAqIFx0XHR3aGF0IHlvdSBuZWVkLCBhbmQgY2FsbCBpdCBmcm9tIHRoZSBbb3RoZXJfbmFtZV1Db250cm9sbGVyXHJcbiAqXHJcbiAqIDMuIENvbnRyb2xsZXJzIGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJpdmF0ZSBtZXRob2RzL2ZpZWxkcy4gTW9kZWxzIGFyZW4ndC4gXHJcbiAqXHJcbiAqIDQuIENvbnRyb2xsZXJzIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgcHVibGljIGRhdGEgZmllbGRzLiBcclxuICogXHRcdFRob3NlIGRhdGEgZmllbGRzIHRoYXQgYXJlIHByZXNlbnQgbXVzdCBub3QgcmVmbGVjdCBzdGF0ZSBvZiB0aGUgZ2FtZSwgdGhleSBtdXN0IGJlIHJlbGF0ZWQgdG9cclxuICogXHRcdHNvbWUgaW50ZXJuYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgY29udHJvbGxlclxyXG4gKlxyXG4gKiA1LiBJZiB5b3Ugd3JpdGUgc29tZSBmdW5jdGlvbiB0aGF0IGRvZXNuJ3QgbG9naWNhbGx5IGJlbG9uZyB0byBvbmUgb2YgdGhlIGNvbnRyb2xsZXJzLFxyXG4gKiBcdFx0cHV0IGl0IGluIHRoZSBVdGlsaXR5XHJcbiAqXHJcbiAqIDYuIFZhcmlhYmxlcyBhcmUgbmFtZWQgbGlrZSB0aGF0OiB2YXJpYWJsZV9uYW1lXHJcbiAqIFx0XHRFeGNlcHQgKHNpbmdsZXRvbiljbGFzcyBuYW1lcywgdGhhdCBhcmUgd3JpdHRlbiBsaWtlIHRoYXQ6IENsYXNzTmFtZVxyXG4gKlxyXG4gKiA3LiBBbmQgYWxsIHRoZSBvYnZpb3VzIHN0dWZmIHRoYXQgZXZlcnlvbmUga25vd3M6XHJcbiAqIFx0XHRmdW5jdGlvbiBtdXN0IGRvIG9uZSB0aGluZzsgZG9uJ3QgbWFrZSBmdW5jdGlvbiBwdWJsaWMgdW5sZXNzIGl0IG5lZWRzIHRvIGJlIHRoYXQ7IFxyXG4gKiBcdFx0Y29tbWVudCBhbWJpZ2lvdXMgY29kZSwgZm9yIGxhcmdlciBmdW5jdGlvbnMgaW5kaWNhdGUgdGhlaXIgcHVycG9zZSAodGhyb3VnaCBjb21tZW50aW5nKTtcclxuICovXHJcblxyXG5cclxuLy8gbWFpbiBuYW1lc3BhY2UgdGhhdCBpcyBleHBvc2VkIHRvIGdsb2JhbCBzY29wZSAod2luZG93IG9iamVjdClcclxud2luZG93LnNpZGVzY3JvbGxlcl9nYW1lID0gKGZ1bmN0aW9uIG5hbWVzcGFjZSgpe1xyXG5cclxuXHRcdHZhciBJbmNsdWRlcyA9IHJlcXVpcmUoXCIuL0luY2x1ZGVzLmpzXCIpOyB2YXIgaW5jbHVkZV9kYXRhID0gSW5jbHVkZXMuZ2V0X2luY2x1ZGVfZGF0YSh7XHJcblx0XHRjdXJyZW50X21vZHVsZTogXCJOb25lXCIsIFxyXG5cdFx0aW5jbHVkZV9vcHRpb25zOiBJbmNsdWRlcy5jaG9pY2VzLkFMTF9DT05UUk9MTEVSU1xyXG5cdH0pOyBldmFsKGluY2x1ZGVfZGF0YS5uYW1lX3N0YXRlbWVudHMpOyB2YXIgaW5jbHVkZSA9IGZ1bmN0aW9uKCl7ZXZhbChpbmNsdWRlX2RhdGEubW9kdWxlX3N0YXRlbWVudHMpO31cclxuXHJcblx0Ly8gR2FtZSBpbml0aWF0aW9uIHNlY3Rpb246ID4+PlxyXG5cdFx0XHJcblx0dmFyIGxvYWRfZ2FtZSA9IGZ1bmN0aW9uKG1vZGUsIHNlc3Npb25faWQsIHBsYXllcl9pZCwgcGxheWVyX2lkX2FycmF5KVxyXG5cdHtcclxuXHRcclxuXHRcdEluY2x1ZGVzLmluaXQoKTsgLy8gZmlyc3RcclxuXHRcdGluY2x1ZGUoKTsgLy8gc2Vjb25kXHJcblxyXG5cdFx0SW5pdENvbnRyb2xsZXIuaW5pdChtb2RlLCBzZXNzaW9uX2lkLCBwbGF5ZXJfaWQsIHBsYXllcl9pZF9hcnJheSk7IC8vIGluaXQgYWxsIHRoZSBzdHVmZlxyXG5cclxuXHRcdGlmKG1vZGUgPT0gXCJ0ZXN0XCIpe1xyXG5cdFx0XHRUZXN0Q29udHJvbGxlci50ZXN0KCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdHZhciBydW4gPSBmdW5jdGlvbihtb2RlLCBzZXNzaW9uX2lkLCBwbGF5ZXJfaWQsIHBsYXllcl9pZF9hcnJheSlcclxuXHR7XHJcblx0XHQvLyBkb25lIHRoaXMgd2F5IHRvIGVuc3VyZSB0aGF0IGxvYWRfZ2FtZSdzIGludGVybmFscyBhcmVuJ3QgYWNjZXNzaWJsZSB0byB0aGUgd29ybGQ6XHJcblx0XHRsb2FkX2dhbWUobW9kZSwgc2Vzc2lvbl9pZCwgcGxheWVyX2lkLCBwbGF5ZXJfaWRfYXJyYXkpO1xyXG5cdH07IFxyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHRydW46IHJ1blxyXG5cdH07IC8vIGV4cG9zZSBmdW5jdGlvbiBydW4gdG8gdGhlIHdvcmxkXHJcblxyXG59KSgpOyBcclxuXHJcbiIsIi8qXHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDcgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbVxyXG4qXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXHJcbiovXHJcblwidXNlIHN0cmljdFwiXHJcblxyXG52YXIgQm94MkQgPSB7fTtcclxuXHJcbihmdW5jdGlvbiAoYTJqLCB1bmRlZmluZWQpIHtcclxuICAgXHJcbiAgIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7fTtcclxuICAgYTJqLmluaGVyaXQgPSBmdW5jdGlvbihjbHMsIGJhc2UpIHtcclxuICAgICAgdmFyIHRtcEN0ciA9IGNscztcclxuICAgICAgZW1wdHlGbi5wcm90b3R5cGUgPSBiYXNlLnByb3RvdHlwZTtcclxuICAgICAgY2xzLnByb3RvdHlwZSA9IG5ldyBlbXB0eUZuO1xyXG4gICAgICBjbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdG1wQ3RyO1xyXG4gICB9O1xyXG4gICBcclxuICAgYTJqLmdlbmVyYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxiYWNrKGNvbnRleHQsIGNiKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgIGNiLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH07XHJcbiAgIH07XHJcbiAgIFxyXG4gICBhMmouTlZlY3RvciA9IGZ1bmN0aW9uIE5WZWN0b3IobGVuZ3RoKSB7XHJcbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgbGVuZ3RoID0gMDtcclxuICAgICAgdmFyIHRtcCA9IG5ldyBBcnJheShsZW5ndGggfHwgMCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpXHJcbiAgICAgIHRtcFtpXSA9IDA7XHJcbiAgICAgIHJldHVybiB0bXA7XHJcbiAgIH07XHJcbiAgIFxyXG4gICBhMmouaXMgPSBmdW5jdGlvbiBpcyhvMSwgbzIpIHtcclxuICAgICAgaWYgKG8xID09PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICgobzIgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgKG8xIGluc3RhbmNlb2YgbzIpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKChvMS5jb25zdHJ1Y3Rvci5fX2ltcGxlbWVudHMgIT0gdW5kZWZpbmVkKSAmJiAobzEuY29uc3RydWN0b3IuX19pbXBsZW1lbnRzW28yXSkpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgIH07XHJcbiAgIFxyXG4gICBhMmoucGFyc2VVSW50ID0gZnVuY3Rpb24odikge1xyXG4gICAgICByZXR1cm4gTWF0aC5hYnMocGFyc2VJbnQodikpO1xyXG4gICB9XHJcbiAgIFxyXG59KShCb3gyRCk7XHJcblxyXG4vLyNUT0RPIHJlbW92ZSBhc3NpZ25tZW50cyBmcm9tIGdsb2JhbCBuYW1lc3BhY2VcclxudmFyIFZlY3RvciA9IEFycmF5O1xyXG52YXIgVmVjdG9yX2Eyal9OdW1iZXIgPSBCb3gyRC5OVmVjdG9yO1xyXG4vL3BhY2thZ2Ugc3RydWN0dXJlXHJcbmlmICh0eXBlb2YoQm94MkQpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRCA9IHt9O1xyXG5pZiAodHlwZW9mKEJveDJELkNvbGxpc2lvbikgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkNvbGxpc2lvbiA9IHt9O1xyXG5pZiAodHlwZW9mKEJveDJELkNvbGxpc2lvbi5TaGFwZXMpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzID0ge307XHJcbmlmICh0eXBlb2YoQm94MkQuQ29tbW9uKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuQ29tbW9uID0ge307XHJcbmlmICh0eXBlb2YoQm94MkQuQ29tbW9uLk1hdGgpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5Db21tb24uTWF0aCA9IHt9O1xyXG5pZiAodHlwZW9mKEJveDJELkR5bmFtaWNzKSA9PT0gXCJ1bmRlZmluZWRcIikgQm94MkQuRHluYW1pY3MgPSB7fTtcclxuaWYgKHR5cGVvZihCb3gyRC5EeW5hbWljcy5Db250YWN0cykgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzID0ge307XHJcbmlmICh0eXBlb2YoQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMpID09PSBcInVuZGVmaW5lZFwiKSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycyA9IHt9O1xyXG5pZiAodHlwZW9mKEJveDJELkR5bmFtaWNzLkpvaW50cykgPT09IFwidW5kZWZpbmVkXCIpIEJveDJELkR5bmFtaWNzLkpvaW50cyA9IHt9O1xyXG4vL3ByZS1kZWZpbml0aW9uc1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICBCb3gyRC5Db2xsaXNpb24uSUJyb2FkUGhhc2UgPSAnQm94MkQuQ29sbGlzaW9uLklCcm9hZFBoYXNlJztcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQUFCQigpIHtcclxuICAgICAgYjJBQUJCLmIyQUFCQi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJBQUJCID0gYjJBQUJCO1xyXG5cclxuICAgZnVuY3Rpb24gYjJCb3VuZCgpIHtcclxuICAgICAgYjJCb3VuZC5iMkJvdW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMkJvdW5kID0gYjJCb3VuZDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQm91bmRWYWx1ZXMoKSB7XHJcbiAgICAgIGIyQm91bmRWYWx1ZXMuYjJCb3VuZFZhbHVlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJCb3VuZFZhbHVlcykgdGhpcy5iMkJvdW5kVmFsdWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMkJvdW5kVmFsdWVzID0gYjJCb3VuZFZhbHVlcztcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29sbGlzaW9uKCkge1xyXG4gICAgICBiMkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24gPSBiMkNvbGxpc2lvbjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdElEKCkge1xyXG4gICAgICBiMkNvbnRhY3RJRC5iMkNvbnRhY3RJRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0SUQpIHRoaXMuYjJDb250YWN0SUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElEID0gYjJDb250YWN0SUQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RQb2ludCgpIHtcclxuICAgICAgYjJDb250YWN0UG9pbnQuYjJDb250YWN0UG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdFBvaW50ID0gYjJDb250YWN0UG9pbnQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlKCkge1xyXG4gICAgICBiMkRpc3RhbmNlLmIyRGlzdGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UgPSBiMkRpc3RhbmNlO1xyXG5cclxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZUlucHV0KCkge1xyXG4gICAgICBiMkRpc3RhbmNlSW5wdXQuYjJEaXN0YW5jZUlucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlSW5wdXQgPSBiMkRpc3RhbmNlSW5wdXQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMkRpc3RhbmNlT3V0cHV0KCkge1xyXG4gICAgICBiMkRpc3RhbmNlT3V0cHV0LmIyRGlzdGFuY2VPdXRwdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VPdXRwdXQgPSBiMkRpc3RhbmNlT3V0cHV0O1xyXG5cclxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZVByb3h5KCkge1xyXG4gICAgICBiMkRpc3RhbmNlUHJveHkuYjJEaXN0YW5jZVByb3h5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHkgPSBiMkRpc3RhbmNlUHJveHk7XHJcblxyXG4gICBmdW5jdGlvbiBiMkR5bmFtaWNUcmVlKCkge1xyXG4gICAgICBiMkR5bmFtaWNUcmVlLmIyRHluYW1pY1RyZWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRHluYW1pY1RyZWUpIHRoaXMuYjJEeW5hbWljVHJlZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSA9IGIyRHluYW1pY1RyZWU7XHJcblxyXG4gICBmdW5jdGlvbiBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSgpIHtcclxuICAgICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVCcm9hZFBoYXNlID0gYjJEeW5hbWljVHJlZUJyb2FkUGhhc2U7XHJcblxyXG4gICBmdW5jdGlvbiBiMkR5bmFtaWNUcmVlTm9kZSgpIHtcclxuICAgICAgYjJEeW5hbWljVHJlZU5vZGUuYjJEeW5hbWljVHJlZU5vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlID0gYjJEeW5hbWljVHJlZU5vZGU7XHJcblxyXG4gICBmdW5jdGlvbiBiMkR5bmFtaWNUcmVlUGFpcigpIHtcclxuICAgICAgYjJEeW5hbWljVHJlZVBhaXIuYjJEeW5hbWljVHJlZVBhaXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVQYWlyID0gYjJEeW5hbWljVHJlZVBhaXI7XHJcblxyXG4gICBmdW5jdGlvbiBiMk1hbmlmb2xkKCkge1xyXG4gICAgICBiMk1hbmlmb2xkLmIyTWFuaWZvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTWFuaWZvbGQpIHRoaXMuYjJNYW5pZm9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZCA9IGIyTWFuaWZvbGQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMk1hbmlmb2xkUG9pbnQoKSB7XHJcbiAgICAgIGIyTWFuaWZvbGRQb2ludC5iMk1hbmlmb2xkUG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTWFuaWZvbGRQb2ludCkgdGhpcy5iMk1hbmlmb2xkUG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGRQb2ludCA9IGIyTWFuaWZvbGRQb2ludDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyUG9pbnQoKSB7XHJcbiAgICAgIGIyUG9pbnQuYjJQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJQb2ludCA9IGIyUG9pbnQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMlJheUNhc3RJbnB1dCgpIHtcclxuICAgICAgYjJSYXlDYXN0SW5wdXQuYjJSYXlDYXN0SW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUmF5Q2FzdElucHV0KSB0aGlzLmIyUmF5Q2FzdElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RJbnB1dCA9IGIyUmF5Q2FzdElucHV0O1xyXG5cclxuICAgZnVuY3Rpb24gYjJSYXlDYXN0T3V0cHV0KCkge1xyXG4gICAgICBiMlJheUNhc3RPdXRwdXQuYjJSYXlDYXN0T3V0cHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQgPSBiMlJheUNhc3RPdXRwdXQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMlNlZ21lbnQoKSB7XHJcbiAgICAgIGIyU2VnbWVudC5iMlNlZ21lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyU2VnbWVudCA9IGIyU2VnbWVudDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyU2VwYXJhdGlvbkZ1bmN0aW9uKCkge1xyXG4gICAgICBiMlNlcGFyYXRpb25GdW5jdGlvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24gPSBiMlNlcGFyYXRpb25GdW5jdGlvbjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyU2ltcGxleCgpIHtcclxuICAgICAgYjJTaW1wbGV4LmIyU2ltcGxleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJTaW1wbGV4KSB0aGlzLmIyU2ltcGxleC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4ID0gYjJTaW1wbGV4O1xyXG5cclxuICAgZnVuY3Rpb24gYjJTaW1wbGV4Q2FjaGUoKSB7XHJcbiAgICAgIGIyU2ltcGxleENhY2hlLmIyU2ltcGxleENhY2hlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhDYWNoZSA9IGIyU2ltcGxleENhY2hlO1xyXG5cclxuICAgZnVuY3Rpb24gYjJTaW1wbGV4VmVydGV4KCkge1xyXG4gICAgICBiMlNpbXBsZXhWZXJ0ZXguYjJTaW1wbGV4VmVydGV4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhWZXJ0ZXggPSBiMlNpbXBsZXhWZXJ0ZXg7XHJcblxyXG4gICBmdW5jdGlvbiBiMlRpbWVPZkltcGFjdCgpIHtcclxuICAgICAgYjJUaW1lT2ZJbXBhY3QuYjJUaW1lT2ZJbXBhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0ID0gYjJUaW1lT2ZJbXBhY3Q7XHJcblxyXG4gICBmdW5jdGlvbiBiMlRPSUlucHV0KCkge1xyXG4gICAgICBiMlRPSUlucHV0LmIyVE9JSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQgPSBiMlRPSUlucHV0O1xyXG5cclxuICAgZnVuY3Rpb24gYjJXb3JsZE1hbmlmb2xkKCkge1xyXG4gICAgICBiMldvcmxkTWFuaWZvbGQuYjJXb3JsZE1hbmlmb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMldvcmxkTWFuaWZvbGQpIHRoaXMuYjJXb3JsZE1hbmlmb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5iMldvcmxkTWFuaWZvbGQgPSBiMldvcmxkTWFuaWZvbGQ7XHJcblxyXG4gICBmdW5jdGlvbiBDbGlwVmVydGV4KCkge1xyXG4gICAgICBDbGlwVmVydGV4LkNsaXBWZXJ0ZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLkNsaXBWZXJ0ZXggPSBDbGlwVmVydGV4O1xyXG5cclxuICAgZnVuY3Rpb24gRmVhdHVyZXMoKSB7XHJcbiAgICAgIEZlYXR1cmVzLkZlYXR1cmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbGxpc2lvbi5GZWF0dXJlcyA9IEZlYXR1cmVzO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDaXJjbGVTaGFwZSgpIHtcclxuICAgICAgYjJDaXJjbGVTaGFwZS5iMkNpcmNsZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNpcmNsZVNoYXBlKSB0aGlzLmIyQ2lyY2xlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlID0gYjJDaXJjbGVTaGFwZTtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyRWRnZUNoYWluRGVmKCkge1xyXG4gICAgICBiMkVkZ2VDaGFpbkRlZi5iMkVkZ2VDaGFpbkRlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJFZGdlQ2hhaW5EZWYpIHRoaXMuYjJFZGdlQ2hhaW5EZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZiA9IGIyRWRnZUNoYWluRGVmO1xyXG5cclxuICAgZnVuY3Rpb24gYjJFZGdlU2hhcGUoKSB7XHJcbiAgICAgIGIyRWRnZVNoYXBlLmIyRWRnZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkVkZ2VTaGFwZSkgdGhpcy5iMkVkZ2VTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZVNoYXBlID0gYjJFZGdlU2hhcGU7XHJcblxyXG4gICBmdW5jdGlvbiBiMk1hc3NEYXRhKCkge1xyXG4gICAgICBiMk1hc3NEYXRhLmIyTWFzc0RhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhID0gYjJNYXNzRGF0YTtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyUG9seWdvblNoYXBlKCkge1xyXG4gICAgICBiMlBvbHlnb25TaGFwZS5iMlBvbHlnb25TaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJQb2x5Z29uU2hhcGUpIHRoaXMuYjJQb2x5Z29uU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZSA9IGIyUG9seWdvblNoYXBlO1xyXG5cclxuICAgZnVuY3Rpb24gYjJTaGFwZSgpIHtcclxuICAgICAgYjJTaGFwZS5iMlNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlNoYXBlKSB0aGlzLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlID0gYjJTaGFwZTtcclxuICAgQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwgPSAnQm94MkQuQ29tbW9uLmIyaW50ZXJuYWwnO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDb2xvcigpIHtcclxuICAgICAgYjJDb2xvci5iMkNvbG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkNvbG9yKSB0aGlzLmIyQ29sb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29tbW9uLmIyQ29sb3IgPSBiMkNvbG9yO1xyXG5cclxuICAgZnVuY3Rpb24gYjJTZXR0aW5ncygpIHtcclxuICAgICAgYjJTZXR0aW5ncy5iMlNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzID0gYjJTZXR0aW5ncztcclxuXHJcbiAgIGZ1bmN0aW9uIGIyTWF0MjIoKSB7XHJcbiAgICAgIGIyTWF0MjIuYjJNYXQyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJNYXQyMikgdGhpcy5iMk1hdDIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MjIgPSBiMk1hdDIyO1xyXG5cclxuICAgZnVuY3Rpb24gYjJNYXQzMygpIHtcclxuICAgICAgYjJNYXQzMy5iMk1hdDMzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMk1hdDMzKSB0aGlzLmIyTWF0MzMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyA9IGIyTWF0MzM7XHJcblxyXG4gICBmdW5jdGlvbiBiMk1hdGgoKSB7XHJcbiAgICAgIGIyTWF0aC5iMk1hdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoID0gYjJNYXRoO1xyXG5cclxuICAgZnVuY3Rpb24gYjJTd2VlcCgpIHtcclxuICAgICAgYjJTd2VlcC5iMlN3ZWVwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAgPSBiMlN3ZWVwO1xyXG5cclxuICAgZnVuY3Rpb24gYjJUcmFuc2Zvcm0oKSB7XHJcbiAgICAgIGIyVHJhbnNmb3JtLmIyVHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlRyYW5zZm9ybSkgdGhpcy5iMlRyYW5zZm9ybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSA9IGIyVHJhbnNmb3JtO1xyXG5cclxuICAgZnVuY3Rpb24gYjJWZWMyKCkge1xyXG4gICAgICBiMlZlYzIuYjJWZWMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlZlYzIpIHRoaXMuYjJWZWMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMiA9IGIyVmVjMjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyVmVjMygpIHtcclxuICAgICAgYjJWZWMzLmIyVmVjMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJWZWMzKSB0aGlzLmIyVmVjMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzMgPSBiMlZlYzM7XHJcblxyXG4gICBmdW5jdGlvbiBiMkJvZHkoKSB7XHJcbiAgICAgIGIyQm9keS5iMkJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQm9keSkgdGhpcy5iMkJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuYjJCb2R5ID0gYjJCb2R5O1xyXG5cclxuICAgZnVuY3Rpb24gYjJCb2R5RGVmKCkge1xyXG4gICAgICBiMkJvZHlEZWYuYjJCb2R5RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkJvZHlEZWYpIHRoaXMuYjJCb2R5RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLmIyQm9keURlZiA9IGIyQm9keURlZjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdEZpbHRlcigpIHtcclxuICAgICAgYjJDb250YWN0RmlsdGVyLmIyQ29udGFjdEZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RGaWx0ZXIgPSBiMkNvbnRhY3RGaWx0ZXI7XHJcblxyXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RJbXB1bHNlKCkge1xyXG4gICAgICBiMkNvbnRhY3RJbXB1bHNlLmIyQ29udGFjdEltcHVsc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuYjJDb250YWN0SW1wdWxzZSA9IGIyQ29udGFjdEltcHVsc2U7XHJcblxyXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RMaXN0ZW5lcigpIHtcclxuICAgICAgYjJDb250YWN0TGlzdGVuZXIuYjJDb250YWN0TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuYjJDb250YWN0TGlzdGVuZXIgPSBiMkNvbnRhY3RMaXN0ZW5lcjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdE1hbmFnZXIoKSB7XHJcbiAgICAgIGIyQ29udGFjdE1hbmFnZXIuYjJDb250YWN0TWFuYWdlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0TWFuYWdlcikgdGhpcy5iMkNvbnRhY3RNYW5hZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIgPSBiMkNvbnRhY3RNYW5hZ2VyO1xyXG5cclxuICAgZnVuY3Rpb24gYjJEZWJ1Z0RyYXcoKSB7XHJcbiAgICAgIGIyRGVidWdEcmF3LmIyRGVidWdEcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkRlYnVnRHJhdykgdGhpcy5iMkRlYnVnRHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyA9IGIyRGVidWdEcmF3O1xyXG5cclxuICAgZnVuY3Rpb24gYjJEZXN0cnVjdGlvbkxpc3RlbmVyKCkge1xyXG4gICAgICBiMkRlc3RydWN0aW9uTGlzdGVuZXIuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyRmlsdGVyRGF0YSgpIHtcclxuICAgICAgYjJGaWx0ZXJEYXRhLmIyRmlsdGVyRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5iMkZpbHRlckRhdGEgPSBiMkZpbHRlckRhdGE7XHJcblxyXG4gICBmdW5jdGlvbiBiMkZpeHR1cmUoKSB7XHJcbiAgICAgIGIyRml4dHVyZS5iMkZpeHR1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRml4dHVyZSkgdGhpcy5iMkZpeHR1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlID0gYjJGaXh0dXJlO1xyXG5cclxuICAgZnVuY3Rpb24gYjJGaXh0dXJlRGVmKCkge1xyXG4gICAgICBiMkZpeHR1cmVEZWYuYjJGaXh0dXJlRGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkZpeHR1cmVEZWYpIHRoaXMuYjJGaXh0dXJlRGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZiA9IGIyRml4dHVyZURlZjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIySXNsYW5kKCkge1xyXG4gICAgICBiMklzbGFuZC5iMklzbGFuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJJc2xhbmQpIHRoaXMuYjJJc2xhbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuYjJJc2xhbmQgPSBiMklzbGFuZDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyVGltZVN0ZXAoKSB7XHJcbiAgICAgIGIyVGltZVN0ZXAuYjJUaW1lU3RlcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5iMlRpbWVTdGVwID0gYjJUaW1lU3RlcDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyV29ybGQoKSB7XHJcbiAgICAgIGIyV29ybGQuYjJXb3JsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJXb3JsZCkgdGhpcy5iMldvcmxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQgPSBiMldvcmxkO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDaXJjbGVDb250YWN0KCkge1xyXG4gICAgICBiMkNpcmNsZUNvbnRhY3QuYjJDaXJjbGVDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ2lyY2xlQ29udGFjdCA9IGIyQ2lyY2xlQ29udGFjdDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdCgpIHtcclxuICAgICAgYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0KSB0aGlzLmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QgPSBiMkNvbnRhY3Q7XHJcblxyXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RDb25zdHJhaW50KCkge1xyXG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50LmIyQ29udGFjdENvbnN0cmFpbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ29udGFjdENvbnN0cmFpbnQpIHRoaXMuYjJDb250YWN0Q29uc3RyYWludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50ID0gYjJDb250YWN0Q29uc3RyYWludDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdENvbnN0cmFpbnRQb2ludCgpIHtcclxuICAgICAgYjJDb250YWN0Q29uc3RyYWludFBvaW50LmIyQ29udGFjdENvbnN0cmFpbnRQb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RFZGdlKCkge1xyXG4gICAgICBiMkNvbnRhY3RFZGdlLmIyQ29udGFjdEVkZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RWRnZSA9IGIyQ29udGFjdEVkZ2U7XHJcblxyXG4gICBmdW5jdGlvbiBiMkNvbnRhY3RGYWN0b3J5KCkge1xyXG4gICAgICBiMkNvbnRhY3RGYWN0b3J5LmIyQ29udGFjdEZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyQ29udGFjdEZhY3RvcnkpIHRoaXMuYjJDb250YWN0RmFjdG9yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RGYWN0b3J5ID0gYjJDb250YWN0RmFjdG9yeTtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdFJlZ2lzdGVyKCkge1xyXG4gICAgICBiMkNvbnRhY3RSZWdpc3Rlci5iMkNvbnRhY3RSZWdpc3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZWdpc3RlciA9IGIyQ29udGFjdFJlZ2lzdGVyO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDb250YWN0UmVzdWx0KCkge1xyXG4gICAgICBiMkNvbnRhY3RSZXN1bHQuYjJDb250YWN0UmVzdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCA9IGIyQ29udGFjdFJlc3VsdDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udGFjdFNvbHZlcigpIHtcclxuICAgICAgYjJDb250YWN0U29sdmVyLmIyQ29udGFjdFNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJDb250YWN0U29sdmVyKSB0aGlzLmIyQ29udGFjdFNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RTb2x2ZXIgPSBiMkNvbnRhY3RTb2x2ZXI7XHJcblxyXG4gICBmdW5jdGlvbiBiMkVkZ2VBbmRDaXJjbGVDb250YWN0KCkge1xyXG4gICAgICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0LmIyRWRnZUFuZENpcmNsZUNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCA9IGIyRWRnZUFuZENpcmNsZUNvbnRhY3Q7XHJcblxyXG4gICBmdW5jdGlvbiBiMk51bGxDb250YWN0KCkge1xyXG4gICAgICBiMk51bGxDb250YWN0LmIyTnVsbENvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTnVsbENvbnRhY3QpIHRoaXMuYjJOdWxsQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMk51bGxDb250YWN0ID0gYjJOdWxsQ29udGFjdDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyUG9seUFuZENpcmNsZUNvbnRhY3QoKSB7XHJcbiAgICAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gYjJQb2x5QW5kQ2lyY2xlQ29udGFjdDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyUG9seUFuZEVkZ2VDb250YWN0KCkge1xyXG4gICAgICBiMlBvbHlBbmRFZGdlQ29udGFjdC5iMlBvbHlBbmRFZGdlQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlBbmRFZGdlQ29udGFjdCA9IGIyUG9seUFuZEVkZ2VDb250YWN0O1xyXG5cclxuICAgZnVuY3Rpb24gYjJQb2x5Z29uQ29udGFjdCgpIHtcclxuICAgICAgYjJQb2x5Z29uQ29udGFjdC5iMlBvbHlnb25Db250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9seWdvbkNvbnRhY3QgPSBiMlBvbHlnb25Db250YWN0O1xyXG5cclxuICAgZnVuY3Rpb24gYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkKCkge1xyXG4gICAgICBiMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQpIHRoaXMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQnVveWFuY3lDb250cm9sbGVyKCkge1xyXG4gICAgICBiMkJ1b3lhbmN5Q29udHJvbGxlci5iMkJ1b3lhbmN5Q29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkJ1b3lhbmN5Q29udHJvbGxlciA9IGIyQnVveWFuY3lDb250cm9sbGVyO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDb25zdGFudEFjY2VsQ29udHJvbGxlcigpIHtcclxuICAgICAgYjJDb25zdGFudEFjY2VsQ29udHJvbGxlci5iMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIgPSBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDb25zdGFudEZvcmNlQ29udHJvbGxlcigpIHtcclxuICAgICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlci5iMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIgPSBiMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyO1xyXG5cclxuICAgZnVuY3Rpb24gYjJDb250cm9sbGVyKCkge1xyXG4gICAgICBiMkNvbnRyb2xsZXIuYjJDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlciA9IGIyQ29udHJvbGxlcjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyQ29udHJvbGxlckVkZ2UoKSB7XHJcbiAgICAgIGIyQ29udHJvbGxlckVkZ2UuYjJDb250cm9sbGVyRWRnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXJFZGdlID0gYjJDb250cm9sbGVyRWRnZTtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyR3Jhdml0eUNvbnRyb2xsZXIoKSB7XHJcbiAgICAgIGIyR3Jhdml0eUNvbnRyb2xsZXIuYjJHcmF2aXR5Q29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkdyYXZpdHlDb250cm9sbGVyID0gYjJHcmF2aXR5Q29udHJvbGxlcjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIoKSB7XHJcbiAgICAgIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIuYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMlRlbnNvckRhbXBpbmdDb250cm9sbGVyID0gYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlcjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyRGlzdGFuY2VKb2ludCgpIHtcclxuICAgICAgYjJEaXN0YW5jZUpvaW50LmIyRGlzdGFuY2VKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJEaXN0YW5jZUpvaW50KSB0aGlzLmIyRGlzdGFuY2VKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50ID0gYjJEaXN0YW5jZUpvaW50O1xyXG5cclxuICAgZnVuY3Rpb24gYjJEaXN0YW5jZUpvaW50RGVmKCkge1xyXG4gICAgICBiMkRpc3RhbmNlSm9pbnREZWYuYjJEaXN0YW5jZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkRpc3RhbmNlSm9pbnREZWYpIHRoaXMuYjJEaXN0YW5jZUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkRpc3RhbmNlSm9pbnREZWYgPSBiMkRpc3RhbmNlSm9pbnREZWY7XHJcblxyXG4gICBmdW5jdGlvbiBiMkZyaWN0aW9uSm9pbnQoKSB7XHJcbiAgICAgIGIyRnJpY3Rpb25Kb2ludC5iMkZyaWN0aW9uSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyRnJpY3Rpb25Kb2ludCkgdGhpcy5iMkZyaWN0aW9uSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyRnJpY3Rpb25Kb2ludCA9IGIyRnJpY3Rpb25Kb2ludDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyRnJpY3Rpb25Kb2ludERlZigpIHtcclxuICAgICAgYjJGcmljdGlvbkpvaW50RGVmLmIyRnJpY3Rpb25Kb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJGcmljdGlvbkpvaW50RGVmKSB0aGlzLmIyRnJpY3Rpb25Kb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJGcmljdGlvbkpvaW50RGVmID0gYjJGcmljdGlvbkpvaW50RGVmO1xyXG5cclxuICAgZnVuY3Rpb24gYjJHZWFySm9pbnQoKSB7XHJcbiAgICAgIGIyR2VhckpvaW50LmIyR2VhckpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkdlYXJKb2ludCkgdGhpcy5iMkdlYXJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJHZWFySm9pbnQgPSBiMkdlYXJKb2ludDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyR2VhckpvaW50RGVmKCkge1xyXG4gICAgICBiMkdlYXJKb2ludERlZi5iMkdlYXJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJHZWFySm9pbnREZWYpIHRoaXMuYjJHZWFySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyR2VhckpvaW50RGVmID0gYjJHZWFySm9pbnREZWY7XHJcblxyXG4gICBmdW5jdGlvbiBiMkphY29iaWFuKCkge1xyXG4gICAgICBiMkphY29iaWFuLmIySmFjb2JpYW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySmFjb2JpYW4gPSBiMkphY29iaWFuO1xyXG5cclxuICAgZnVuY3Rpb24gYjJKb2ludCgpIHtcclxuICAgICAgYjJKb2ludC5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkpvaW50KSB0aGlzLmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQgPSBiMkpvaW50O1xyXG5cclxuICAgZnVuY3Rpb24gYjJKb2ludERlZigpIHtcclxuICAgICAgYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkpvaW50RGVmKSB0aGlzLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYgPSBiMkpvaW50RGVmO1xyXG5cclxuICAgZnVuY3Rpb24gYjJKb2ludEVkZ2UoKSB7XHJcbiAgICAgIGIySm9pbnRFZGdlLmIySm9pbnRFZGdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RWRnZSA9IGIySm9pbnRFZGdlO1xyXG5cclxuICAgZnVuY3Rpb24gYjJMaW5lSm9pbnQoKSB7XHJcbiAgICAgIGIyTGluZUpvaW50LmIyTGluZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMkxpbmVKb2ludCkgdGhpcy5iMkxpbmVKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJMaW5lSm9pbnQgPSBiMkxpbmVKb2ludDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyTGluZUpvaW50RGVmKCkge1xyXG4gICAgICBiMkxpbmVKb2ludERlZi5iMkxpbmVKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJMaW5lSm9pbnREZWYpIHRoaXMuYjJMaW5lSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTGluZUpvaW50RGVmID0gYjJMaW5lSm9pbnREZWY7XHJcblxyXG4gICBmdW5jdGlvbiBiMk1vdXNlSm9pbnQoKSB7XHJcbiAgICAgIGIyTW91c2VKb2ludC5iMk1vdXNlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyTW91c2VKb2ludCkgdGhpcy5iMk1vdXNlSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTW91c2VKb2ludCA9IGIyTW91c2VKb2ludDtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyTW91c2VKb2ludERlZigpIHtcclxuICAgICAgYjJNb3VzZUpvaW50RGVmLmIyTW91c2VKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJNb3VzZUpvaW50RGVmKSB0aGlzLmIyTW91c2VKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJNb3VzZUpvaW50RGVmID0gYjJNb3VzZUpvaW50RGVmO1xyXG5cclxuICAgZnVuY3Rpb24gYjJQcmlzbWF0aWNKb2ludCgpIHtcclxuICAgICAgYjJQcmlzbWF0aWNKb2ludC5iMlByaXNtYXRpY0pvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlByaXNtYXRpY0pvaW50KSB0aGlzLmIyUHJpc21hdGljSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnQgPSBiMlByaXNtYXRpY0pvaW50O1xyXG5cclxuICAgZnVuY3Rpb24gYjJQcmlzbWF0aWNKb2ludERlZigpIHtcclxuICAgICAgYjJQcmlzbWF0aWNKb2ludERlZi5iMlByaXNtYXRpY0pvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlByaXNtYXRpY0pvaW50RGVmKSB0aGlzLmIyUHJpc21hdGljSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnREZWYgPSBiMlByaXNtYXRpY0pvaW50RGVmO1xyXG5cclxuICAgZnVuY3Rpb24gYjJQdWxsZXlKb2ludCgpIHtcclxuICAgICAgYjJQdWxsZXlKb2ludC5iMlB1bGxleUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlB1bGxleUpvaW50KSB0aGlzLmIyUHVsbGV5Sm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQgPSBiMlB1bGxleUpvaW50O1xyXG5cclxuICAgZnVuY3Rpb24gYjJQdWxsZXlKb2ludERlZigpIHtcclxuICAgICAgYjJQdWxsZXlKb2ludERlZi5iMlB1bGxleUpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlB1bGxleUpvaW50RGVmKSB0aGlzLmIyUHVsbGV5Sm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnREZWYgPSBiMlB1bGxleUpvaW50RGVmO1xyXG5cclxuICAgZnVuY3Rpb24gYjJSZXZvbHV0ZUpvaW50KCkge1xyXG4gICAgICBiMlJldm9sdXRlSm9pbnQuYjJSZXZvbHV0ZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBiMlJldm9sdXRlSm9pbnQpIHRoaXMuYjJSZXZvbHV0ZUpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlJldm9sdXRlSm9pbnQgPSBiMlJldm9sdXRlSm9pbnQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMlJldm9sdXRlSm9pbnREZWYoKSB7XHJcbiAgICAgIGIyUmV2b2x1dGVKb2ludERlZi5iMlJldm9sdXRlSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyUmV2b2x1dGVKb2ludERlZikgdGhpcy5iMlJldm9sdXRlSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludERlZiA9IGIyUmV2b2x1dGVKb2ludERlZjtcclxuXHJcbiAgIGZ1bmN0aW9uIGIyV2VsZEpvaW50KCkge1xyXG4gICAgICBiMldlbGRKb2ludC5iMldlbGRKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gYjJXZWxkSm9pbnQpIHRoaXMuYjJXZWxkSm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50ID0gYjJXZWxkSm9pbnQ7XHJcblxyXG4gICBmdW5jdGlvbiBiMldlbGRKb2ludERlZigpIHtcclxuICAgICAgYjJXZWxkSm9pbnREZWYuYjJXZWxkSm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IGIyV2VsZEpvaW50RGVmKSB0aGlzLmIyV2VsZEpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMldlbGRKb2ludERlZiA9IGIyV2VsZEpvaW50RGVmO1xyXG59KSgpOyAvL2RlZmluaXRpb25zXHJcbkJveDJELnBvc3REZWZzID0gW107XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgIHZhciBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxyXG4gICAgICBiMkVkZ2VDaGFpbkRlZiA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYsXHJcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcclxuICAgICAgYjJNYXNzRGF0YSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSxcclxuICAgICAgYjJQb2x5Z29uU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLFxyXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxyXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXHJcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcclxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxyXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcclxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXHJcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcclxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXHJcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXHJcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcclxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxyXG4gICAgICBiMkFBQkIgPSBCb3gyRC5Db2xsaXNpb24uYjJBQUJCLFxyXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXHJcbiAgICAgIGIyQm91bmRWYWx1ZXMgPSBCb3gyRC5Db2xsaXNpb24uYjJCb3VuZFZhbHVlcyxcclxuICAgICAgYjJDb2xsaXNpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24sXHJcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxyXG4gICAgICBiMkNvbnRhY3RQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RQb2ludCxcclxuICAgICAgYjJEaXN0YW5jZSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLFxyXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxyXG4gICAgICBiMkRpc3RhbmNlT3V0cHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VPdXRwdXQsXHJcbiAgICAgIGIyRGlzdGFuY2VQcm94eSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHksXHJcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcclxuICAgICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UsXHJcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlLFxyXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcclxuICAgICAgYjJNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkLFxyXG4gICAgICBiMk1hbmlmb2xkUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50LFxyXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXHJcbiAgICAgIGIyUmF5Q2FzdElucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyUmF5Q2FzdElucHV0LFxyXG4gICAgICBiMlJheUNhc3RPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0LFxyXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxyXG4gICAgICBiMlNlcGFyYXRpb25GdW5jdGlvbiA9IEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbixcclxuICAgICAgYjJTaW1wbGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCxcclxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXHJcbiAgICAgIGIyU2ltcGxleFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhWZXJ0ZXgsXHJcbiAgICAgIGIyVGltZU9mSW1wYWN0ID0gQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LFxyXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXHJcbiAgICAgIGIyV29ybGRNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMldvcmxkTWFuaWZvbGQsXHJcbiAgICAgIENsaXBWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCxcclxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXHJcbiAgICAgIElCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLklCcm9hZFBoYXNlO1xyXG5cclxuICAgYjJBQUJCLmIyQUFCQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5sb3dlckJvdW5kID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyQUFCQi5wcm90b3R5cGUuSXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRYID0gdGhpcy51cHBlckJvdW5kLnggLSB0aGlzLmxvd2VyQm91bmQueDtcclxuICAgICAgdmFyIGRZID0gdGhpcy51cHBlckJvdW5kLnkgLSB0aGlzLmxvd2VyQm91bmQueTtcclxuICAgICAgdmFyIHZhbGlkID0gZFggPj0gMC4wICYmIGRZID49IDAuMDtcclxuICAgICAgdmFsaWQgPSB2YWxpZCAmJiB0aGlzLmxvd2VyQm91bmQuSXNWYWxpZCgpICYmIHRoaXMudXBwZXJCb3VuZC5Jc1ZhbGlkKCk7XHJcbiAgICAgIHJldHVybiB2YWxpZDtcclxuICAgfVxyXG4gICBiMkFBQkIucHJvdG90eXBlLkdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoKHRoaXMubG93ZXJCb3VuZC54ICsgdGhpcy51cHBlckJvdW5kLngpIC8gMiwgKHRoaXMubG93ZXJCb3VuZC55ICsgdGhpcy51cHBlckJvdW5kLnkpIC8gMik7XHJcbiAgIH1cclxuICAgYjJBQUJCLnByb3RvdHlwZS5HZXRFeHRlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMigodGhpcy51cHBlckJvdW5kLnggLSB0aGlzLmxvd2VyQm91bmQueCkgLyAyLCAodGhpcy51cHBlckJvdW5kLnkgLSB0aGlzLmxvd2VyQm91bmQueSkgLyAyKTtcclxuICAgfVxyXG4gICBiMkFBQkIucHJvdG90eXBlLkNvbnRhaW5zID0gZnVuY3Rpb24gKGFhYmIpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiB0aGlzLmxvd2VyQm91bmQueCA8PSBhYWJiLmxvd2VyQm91bmQueDtcclxuICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMubG93ZXJCb3VuZC55IDw9IGFhYmIubG93ZXJCb3VuZC55O1xyXG4gICAgICByZXN1bHQgPSByZXN1bHQgJiYgYWFiYi51cHBlckJvdW5kLnggPD0gdGhpcy51cHBlckJvdW5kLng7XHJcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBhYWJiLnVwcGVyQm91bmQueSA8PSB0aGlzLnVwcGVyQm91bmQueTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgfVxyXG4gICBiMkFBQkIucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCkge1xyXG4gICAgICB2YXIgdG1pbiA9ICgtTnVtYmVyLk1BWF9WQUxVRSk7XHJcbiAgICAgIHZhciB0bWF4ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgdmFyIHBYID0gaW5wdXQucDEueDtcclxuICAgICAgdmFyIHBZID0gaW5wdXQucDEueTtcclxuICAgICAgdmFyIGRYID0gaW5wdXQucDIueCAtIGlucHV0LnAxLng7XHJcbiAgICAgIHZhciBkWSA9IGlucHV0LnAyLnkgLSBpbnB1dC5wMS55O1xyXG4gICAgICB2YXIgYWJzRFggPSBNYXRoLmFicyhkWCk7XHJcbiAgICAgIHZhciBhYnNEWSA9IE1hdGguYWJzKGRZKTtcclxuICAgICAgdmFyIG5vcm1hbCA9IG91dHB1dC5ub3JtYWw7XHJcbiAgICAgIHZhciBpbnZfZCA9IDA7XHJcbiAgICAgIHZhciB0MSA9IDA7XHJcbiAgICAgIHZhciB0MiA9IDA7XHJcbiAgICAgIHZhciB0MyA9IDA7XHJcbiAgICAgIHZhciBzID0gMDsge1xyXG4gICAgICAgICBpZiAoYWJzRFggPCBOdW1iZXIuTUlOX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgIGlmIChwWCA8IHRoaXMubG93ZXJCb3VuZC54IHx8IHRoaXMudXBwZXJCb3VuZC54IDwgcFgpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW52X2QgPSAxLjAgLyBkWDtcclxuICAgICAgICAgICAgdDEgPSAodGhpcy5sb3dlckJvdW5kLnggLSBwWCkgKiBpbnZfZDtcclxuICAgICAgICAgICAgdDIgPSAodGhpcy51cHBlckJvdW5kLnggLSBwWCkgKiBpbnZfZDtcclxuICAgICAgICAgICAgcyA9ICgtMS4wKTtcclxuICAgICAgICAgICAgaWYgKHQxID4gdDIpIHtcclxuICAgICAgICAgICAgICAgdDMgPSB0MTtcclxuICAgICAgICAgICAgICAgdDEgPSB0MjtcclxuICAgICAgICAgICAgICAgdDIgPSB0MztcclxuICAgICAgICAgICAgICAgcyA9IDEuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodDEgPiB0bWluKSB7XHJcbiAgICAgICAgICAgICAgIG5vcm1hbC54ID0gcztcclxuICAgICAgICAgICAgICAgbm9ybWFsLnkgPSAwO1xyXG4gICAgICAgICAgICAgICB0bWluID0gdDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIHQyKTtcclxuICAgICAgICAgICAgaWYgKHRtaW4gPiB0bWF4KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgIH1cclxuICAgICAgfSB7XHJcbiAgICAgICAgIGlmIChhYnNEWSA8IE51bWJlci5NSU5fVkFMVUUpIHtcclxuICAgICAgICAgICAgaWYgKHBZIDwgdGhpcy5sb3dlckJvdW5kLnkgfHwgdGhpcy51cHBlckJvdW5kLnkgPCBwWSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnZfZCA9IDEuMCAvIGRZO1xyXG4gICAgICAgICAgICB0MSA9ICh0aGlzLmxvd2VyQm91bmQueSAtIHBZKSAqIGludl9kO1xyXG4gICAgICAgICAgICB0MiA9ICh0aGlzLnVwcGVyQm91bmQueSAtIHBZKSAqIGludl9kO1xyXG4gICAgICAgICAgICBzID0gKC0xLjApO1xyXG4gICAgICAgICAgICBpZiAodDEgPiB0Mikge1xyXG4gICAgICAgICAgICAgICB0MyA9IHQxO1xyXG4gICAgICAgICAgICAgICB0MSA9IHQyO1xyXG4gICAgICAgICAgICAgICB0MiA9IHQzO1xyXG4gICAgICAgICAgICAgICBzID0gMS4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0MSA+IHRtaW4pIHtcclxuICAgICAgICAgICAgICAgbm9ybWFsLnkgPSBzO1xyXG4gICAgICAgICAgICAgICBub3JtYWwueCA9IDA7XHJcbiAgICAgICAgICAgICAgIHRtaW4gPSB0MTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgdDIpO1xyXG4gICAgICAgICAgICBpZiAodG1pbiA+IHRtYXgpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIG91dHB1dC5mcmFjdGlvbiA9IHRtaW47XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIGIyQUFCQi5wcm90b3R5cGUuVGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgdmFyIGQxWCA9IG90aGVyLmxvd2VyQm91bmQueCAtIHRoaXMudXBwZXJCb3VuZC54O1xyXG4gICAgICB2YXIgZDFZID0gb3RoZXIubG93ZXJCb3VuZC55IC0gdGhpcy51cHBlckJvdW5kLnk7XHJcbiAgICAgIHZhciBkMlggPSB0aGlzLmxvd2VyQm91bmQueCAtIG90aGVyLnVwcGVyQm91bmQueDtcclxuICAgICAgdmFyIGQyWSA9IHRoaXMubG93ZXJCb3VuZC55IC0gb3RoZXIudXBwZXJCb3VuZC55O1xyXG4gICAgICBpZiAoZDFYID4gMC4wIHx8IGQxWSA+IDAuMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoZDJYID4gMC4wIHx8IGQyWSA+IDAuMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgfVxyXG4gICBiMkFBQkIuQ29tYmluZSA9IGZ1bmN0aW9uIChhYWJiMSwgYWFiYjIpIHtcclxuICAgICAgdmFyIGFhYmIgPSBuZXcgYjJBQUJCKCk7XHJcbiAgICAgIGFhYmIuQ29tYmluZShhYWJiMSwgYWFiYjIpO1xyXG4gICAgICByZXR1cm4gYWFiYjtcclxuICAgfVxyXG4gICBiMkFBQkIucHJvdG90eXBlLkNvbWJpbmUgPSBmdW5jdGlvbiAoYWFiYjEsIGFhYmIyKSB7XHJcbiAgICAgIHRoaXMubG93ZXJCb3VuZC54ID0gTWF0aC5taW4oYWFiYjEubG93ZXJCb3VuZC54LCBhYWJiMi5sb3dlckJvdW5kLngpO1xyXG4gICAgICB0aGlzLmxvd2VyQm91bmQueSA9IE1hdGgubWluKGFhYmIxLmxvd2VyQm91bmQueSwgYWFiYjIubG93ZXJCb3VuZC55KTtcclxuICAgICAgdGhpcy51cHBlckJvdW5kLnggPSBNYXRoLm1heChhYWJiMS51cHBlckJvdW5kLngsIGFhYmIyLnVwcGVyQm91bmQueCk7XHJcbiAgICAgIHRoaXMudXBwZXJCb3VuZC55ID0gTWF0aC5tYXgoYWFiYjEudXBwZXJCb3VuZC55LCBhYWJiMi51cHBlckJvdW5kLnkpO1xyXG4gICB9XHJcbiAgIGIyQm91bmQuYjJCb3VuZCA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMkJvdW5kLnByb3RvdHlwZS5Jc0xvd2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiAxKSA9PSAwO1xyXG4gICB9XHJcbiAgIGIyQm91bmQucHJvdG90eXBlLklzVXBwZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09IDE7XHJcbiAgIH1cclxuICAgYjJCb3VuZC5wcm90b3R5cGUuU3dhcCA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciB0ZW1wVmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICB2YXIgdGVtcFByb3h5ID0gdGhpcy5wcm94eTtcclxuICAgICAgdmFyIHRlbXBTdGFiYmluZ0NvdW50ID0gdGhpcy5zdGFiYmluZ0NvdW50O1xyXG4gICAgICB0aGlzLnZhbHVlID0gYi52YWx1ZTtcclxuICAgICAgdGhpcy5wcm94eSA9IGIucHJveHk7XHJcbiAgICAgIHRoaXMuc3RhYmJpbmdDb3VudCA9IGIuc3RhYmJpbmdDb3VudDtcclxuICAgICAgYi52YWx1ZSA9IHRlbXBWYWx1ZTtcclxuICAgICAgYi5wcm94eSA9IHRlbXBQcm94eTtcclxuICAgICAgYi5zdGFiYmluZ0NvdW50ID0gdGVtcFN0YWJiaW5nQ291bnQ7XHJcbiAgIH1cclxuICAgYjJCb3VuZFZhbHVlcy5iMkJvdW5kVmFsdWVzID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyQm91bmRWYWx1ZXMucHJvdG90eXBlLmIyQm91bmRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubG93ZXJWYWx1ZXMgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoKTtcclxuICAgICAgdGhpcy5sb3dlclZhbHVlc1swXSA9IDAuMDtcclxuICAgICAgdGhpcy5sb3dlclZhbHVlc1sxXSA9IDAuMDtcclxuICAgICAgdGhpcy51cHBlclZhbHVlcyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigpO1xyXG4gICAgICB0aGlzLnVwcGVyVmFsdWVzWzBdID0gMC4wO1xyXG4gICAgICB0aGlzLnVwcGVyVmFsdWVzWzFdID0gMC4wO1xyXG4gICB9XHJcbiAgIGIyQ29sbGlzaW9uLmIyQ29sbGlzaW9uID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyQ29sbGlzaW9uLkNsaXBTZWdtZW50VG9MaW5lID0gZnVuY3Rpb24gKHZPdXQsIHZJbiwgbm9ybWFsLCBvZmZzZXQpIHtcclxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xyXG4gICAgICB2YXIgY3Y7XHJcbiAgICAgIHZhciBudW1PdXQgPSAwO1xyXG4gICAgICBjdiA9IHZJblswXTtcclxuICAgICAgdmFyIHZJbjAgPSBjdi52O1xyXG4gICAgICBjdiA9IHZJblsxXTtcclxuICAgICAgdmFyIHZJbjEgPSBjdi52O1xyXG4gICAgICB2YXIgZGlzdGFuY2UwID0gbm9ybWFsLnggKiB2SW4wLnggKyBub3JtYWwueSAqIHZJbjAueSAtIG9mZnNldDtcclxuICAgICAgdmFyIGRpc3RhbmNlMSA9IG5vcm1hbC54ICogdkluMS54ICsgbm9ybWFsLnkgKiB2SW4xLnkgLSBvZmZzZXQ7XHJcbiAgICAgIGlmIChkaXN0YW5jZTAgPD0gMC4wKSB2T3V0W251bU91dCsrXS5TZXQodkluWzBdKTtcclxuICAgICAgaWYgKGRpc3RhbmNlMSA8PSAwLjApIHZPdXRbbnVtT3V0KytdLlNldCh2SW5bMV0pO1xyXG4gICAgICBpZiAoZGlzdGFuY2UwICogZGlzdGFuY2UxIDwgMC4wKSB7XHJcbiAgICAgICAgIHZhciBpbnRlcnAgPSBkaXN0YW5jZTAgLyAoZGlzdGFuY2UwIC0gZGlzdGFuY2UxKTtcclxuICAgICAgICAgY3YgPSB2T3V0W251bU91dF07XHJcbiAgICAgICAgIHZhciB0VmVjID0gY3YudjtcclxuICAgICAgICAgdFZlYy54ID0gdkluMC54ICsgaW50ZXJwICogKHZJbjEueCAtIHZJbjAueCk7XHJcbiAgICAgICAgIHRWZWMueSA9IHZJbjAueSArIGludGVycCAqICh2SW4xLnkgLSB2SW4wLnkpO1xyXG4gICAgICAgICBjdiA9IHZPdXRbbnVtT3V0XTtcclxuICAgICAgICAgdmFyIGN2MjtcclxuICAgICAgICAgaWYgKGRpc3RhbmNlMCA+IDAuMCkge1xyXG4gICAgICAgICAgICBjdjIgPSB2SW5bMF07XHJcbiAgICAgICAgICAgIGN2LmlkID0gY3YyLmlkO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdjIgPSB2SW5bMV07XHJcbiAgICAgICAgICAgIGN2LmlkID0gY3YyLmlkO1xyXG4gICAgICAgICB9KytudW1PdXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bU91dDtcclxuICAgfVxyXG4gICBiMkNvbGxpc2lvbi5FZGdlU2VwYXJhdGlvbiA9IGZ1bmN0aW9uIChwb2x5MSwgeGYxLCBlZGdlMSwgcG9seTIsIHhmMikge1xyXG4gICAgICBpZiAoZWRnZTEgPT09IHVuZGVmaW5lZCkgZWRnZTEgPSAwO1xyXG4gICAgICB2YXIgY291bnQxID0gcGFyc2VJbnQocG9seTEubV92ZXJ0ZXhDb3VudCk7XHJcbiAgICAgIHZhciB2ZXJ0aWNlczEgPSBwb2x5MS5tX3ZlcnRpY2VzO1xyXG4gICAgICB2YXIgbm9ybWFsczEgPSBwb2x5MS5tX25vcm1hbHM7XHJcbiAgICAgIHZhciBjb3VudDIgPSBwYXJzZUludChwb2x5Mi5tX3ZlcnRleENvdW50KTtcclxuICAgICAgdmFyIHZlcnRpY2VzMiA9IHBvbHkyLm1fdmVydGljZXM7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgdFZlYztcclxuICAgICAgdE1hdCA9IHhmMS5SO1xyXG4gICAgICB0VmVjID0gbm9ybWFsczFbZWRnZTFdO1xyXG4gICAgICB2YXIgbm9ybWFsMVdvcmxkWCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgdmFyIG5vcm1hbDFXb3JsZFkgPSAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgIHRNYXQgPSB4ZjIuUjtcclxuICAgICAgdmFyIG5vcm1hbDFYID0gKHRNYXQuY29sMS54ICogbm9ybWFsMVdvcmxkWCArIHRNYXQuY29sMS55ICogbm9ybWFsMVdvcmxkWSk7XHJcbiAgICAgIHZhciBub3JtYWwxWSA9ICh0TWF0LmNvbDIueCAqIG5vcm1hbDFXb3JsZFggKyB0TWF0LmNvbDIueSAqIG5vcm1hbDFXb3JsZFkpO1xyXG4gICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICB2YXIgbWluRG90ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDI7ICsraSkge1xyXG4gICAgICAgICB0VmVjID0gdmVydGljZXMyW2ldO1xyXG4gICAgICAgICB2YXIgZG90ID0gdFZlYy54ICogbm9ybWFsMVggKyB0VmVjLnkgKiBub3JtYWwxWTtcclxuICAgICAgICAgaWYgKGRvdCA8IG1pbkRvdCkge1xyXG4gICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRWZWMgPSB2ZXJ0aWNlczFbZWRnZTFdO1xyXG4gICAgICB0TWF0ID0geGYxLlI7XHJcbiAgICAgIHZhciB2MVggPSB4ZjEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgdmFyIHYxWSA9IHhmMS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICB0VmVjID0gdmVydGljZXMyW2luZGV4XTtcclxuICAgICAgdE1hdCA9IHhmMi5SO1xyXG4gICAgICB2YXIgdjJYID0geGYyLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgIHZhciB2MlkgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdjJYIC09IHYxWDtcclxuICAgICAgdjJZIC09IHYxWTtcclxuICAgICAgdmFyIHNlcGFyYXRpb24gPSB2MlggKiBub3JtYWwxV29ybGRYICsgdjJZICogbm9ybWFsMVdvcmxkWTtcclxuICAgICAgcmV0dXJuIHNlcGFyYXRpb247XHJcbiAgIH1cclxuICAgYjJDb2xsaXNpb24uRmluZE1heFNlcGFyYXRpb24gPSBmdW5jdGlvbiAoZWRnZUluZGV4LCBwb2x5MSwgeGYxLCBwb2x5MiwgeGYyKSB7XHJcbiAgICAgIHZhciBjb3VudDEgPSBwYXJzZUludChwb2x5MS5tX3ZlcnRleENvdW50KTtcclxuICAgICAgdmFyIG5vcm1hbHMxID0gcG9seTEubV9ub3JtYWxzO1xyXG4gICAgICB2YXIgdFZlYztcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHRNYXQgPSB4ZjIuUjtcclxuICAgICAgdFZlYyA9IHBvbHkyLm1fY2VudHJvaWQ7XHJcbiAgICAgIHZhciBkWCA9IHhmMi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICB2YXIgZFkgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdE1hdCA9IHhmMS5SO1xyXG4gICAgICB0VmVjID0gcG9seTEubV9jZW50cm9pZDtcclxuICAgICAgZFggLT0geGYxLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgIGRZIC09IHhmMS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICB2YXIgZExvY2FsMVggPSAoZFggKiB4ZjEuUi5jb2wxLnggKyBkWSAqIHhmMS5SLmNvbDEueSk7XHJcbiAgICAgIHZhciBkTG9jYWwxWSA9IChkWCAqIHhmMS5SLmNvbDIueCArIGRZICogeGYxLlIuY29sMi55KTtcclxuICAgICAgdmFyIGVkZ2UgPSAwO1xyXG4gICAgICB2YXIgbWF4RG90ID0gKC1OdW1iZXIuTUFYX1ZBTFVFKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDE7ICsraSkge1xyXG4gICAgICAgICB0VmVjID0gbm9ybWFsczFbaV07XHJcbiAgICAgICAgIHZhciBkb3QgPSAodFZlYy54ICogZExvY2FsMVggKyB0VmVjLnkgKiBkTG9jYWwxWSk7XHJcbiAgICAgICAgIGlmIChkb3QgPiBtYXhEb3QpIHtcclxuICAgICAgICAgICAgbWF4RG90ID0gZG90O1xyXG4gICAgICAgICAgICBlZGdlID0gaTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBzID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgZWRnZSwgcG9seTIsIHhmMik7XHJcbiAgICAgIHZhciBwcmV2RWRnZSA9IHBhcnNlSW50KGVkZ2UgLSAxID49IDAgPyBlZGdlIC0gMSA6IGNvdW50MSAtIDEpO1xyXG4gICAgICB2YXIgc1ByZXYgPSBiMkNvbGxpc2lvbi5FZGdlU2VwYXJhdGlvbihwb2x5MSwgeGYxLCBwcmV2RWRnZSwgcG9seTIsIHhmMik7XHJcbiAgICAgIHZhciBuZXh0RWRnZSA9IHBhcnNlSW50KGVkZ2UgKyAxIDwgY291bnQxID8gZWRnZSArIDEgOiAwKTtcclxuICAgICAgdmFyIHNOZXh0ID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgbmV4dEVkZ2UsIHBvbHkyLCB4ZjIpO1xyXG4gICAgICB2YXIgYmVzdEVkZ2UgPSAwO1xyXG4gICAgICB2YXIgYmVzdFNlcGFyYXRpb24gPSAwO1xyXG4gICAgICB2YXIgaW5jcmVtZW50ID0gMDtcclxuICAgICAgaWYgKHNQcmV2ID4gcyAmJiBzUHJldiA+IHNOZXh0KSB7XHJcbiAgICAgICAgIGluY3JlbWVudCA9ICgtMSk7XHJcbiAgICAgICAgIGJlc3RFZGdlID0gcHJldkVkZ2U7XHJcbiAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gc1ByZXY7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoc05leHQgPiBzKSB7XHJcbiAgICAgICAgIGluY3JlbWVudCA9IDE7XHJcbiAgICAgICAgIGJlc3RFZGdlID0gbmV4dEVkZ2U7XHJcbiAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gc05leHQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIGVkZ2VJbmRleFswXSA9IGVkZ2U7XHJcbiAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgIGlmIChpbmNyZW1lbnQgPT0gKC0xKSkgZWRnZSA9IGJlc3RFZGdlIC0gMSA+PSAwID8gYmVzdEVkZ2UgLSAxIDogY291bnQxIC0gMTtcclxuICAgICAgICAgZWxzZSBlZGdlID0gYmVzdEVkZ2UgKyAxIDwgY291bnQxID8gYmVzdEVkZ2UgKyAxIDogMDtzID0gYjJDb2xsaXNpb24uRWRnZVNlcGFyYXRpb24ocG9seTEsIHhmMSwgZWRnZSwgcG9seTIsIHhmMik7XHJcbiAgICAgICAgIGlmIChzID4gYmVzdFNlcGFyYXRpb24pIHtcclxuICAgICAgICAgICAgYmVzdEVkZ2UgPSBlZGdlO1xyXG4gICAgICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWRnZUluZGV4WzBdID0gYmVzdEVkZ2U7XHJcbiAgICAgIHJldHVybiBiZXN0U2VwYXJhdGlvbjtcclxuICAgfVxyXG4gICBiMkNvbGxpc2lvbi5GaW5kSW5jaWRlbnRFZGdlID0gZnVuY3Rpb24gKGMsIHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKSB7XHJcbiAgICAgIGlmIChlZGdlMSA9PT0gdW5kZWZpbmVkKSBlZGdlMSA9IDA7XHJcbiAgICAgIHZhciBjb3VudDEgPSBwYXJzZUludChwb2x5MS5tX3ZlcnRleENvdW50KTtcclxuICAgICAgdmFyIG5vcm1hbHMxID0gcG9seTEubV9ub3JtYWxzO1xyXG4gICAgICB2YXIgY291bnQyID0gcGFyc2VJbnQocG9seTIubV92ZXJ0ZXhDb3VudCk7XHJcbiAgICAgIHZhciB2ZXJ0aWNlczIgPSBwb2x5Mi5tX3ZlcnRpY2VzO1xyXG4gICAgICB2YXIgbm9ybWFsczIgPSBwb2x5Mi5tX25vcm1hbHM7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgdFZlYztcclxuICAgICAgdE1hdCA9IHhmMS5SO1xyXG4gICAgICB0VmVjID0gbm9ybWFsczFbZWRnZTFdO1xyXG4gICAgICB2YXIgbm9ybWFsMVggPSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgIHZhciBub3JtYWwxWSA9ICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdE1hdCA9IHhmMi5SO1xyXG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiBub3JtYWwxWCArIHRNYXQuY29sMS55ICogbm9ybWFsMVkpO1xyXG4gICAgICBub3JtYWwxWSA9ICh0TWF0LmNvbDIueCAqIG5vcm1hbDFYICsgdE1hdC5jb2wyLnkgKiBub3JtYWwxWSk7XHJcbiAgICAgIG5vcm1hbDFYID0gdFg7XHJcbiAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgIHZhciBtaW5Eb3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50MjsgKytpKSB7XHJcbiAgICAgICAgIHRWZWMgPSBub3JtYWxzMltpXTtcclxuICAgICAgICAgdmFyIGRvdCA9IChub3JtYWwxWCAqIHRWZWMueCArIG5vcm1hbDFZICogdFZlYy55KTtcclxuICAgICAgICAgaWYgKGRvdCA8IG1pbkRvdCkge1xyXG4gICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciB0Q2xpcDtcclxuICAgICAgdmFyIGkxID0gcGFyc2VJbnQoaW5kZXgpO1xyXG4gICAgICB2YXIgaTIgPSBwYXJzZUludChpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwKTtcclxuICAgICAgdENsaXAgPSBjWzBdO1xyXG4gICAgICB0VmVjID0gdmVydGljZXMyW2kxXTtcclxuICAgICAgdE1hdCA9IHhmMi5SO1xyXG4gICAgICB0Q2xpcC52LnggPSB4ZjIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgdENsaXAudi55ID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLnJlZmVyZW5jZUVkZ2UgPSBlZGdlMTtcclxuICAgICAgdENsaXAuaWQuZmVhdHVyZXMuaW5jaWRlbnRFZGdlID0gaTE7XHJcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLmluY2lkZW50VmVydGV4ID0gMDtcclxuICAgICAgdENsaXAgPSBjWzFdO1xyXG4gICAgICB0VmVjID0gdmVydGljZXMyW2kyXTtcclxuICAgICAgdE1hdCA9IHhmMi5SO1xyXG4gICAgICB0Q2xpcC52LnggPSB4ZjIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgdENsaXAudi55ID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLnJlZmVyZW5jZUVkZ2UgPSBlZGdlMTtcclxuICAgICAgdENsaXAuaWQuZmVhdHVyZXMuaW5jaWRlbnRFZGdlID0gaTI7XHJcbiAgICAgIHRDbGlwLmlkLmZlYXR1cmVzLmluY2lkZW50VmVydGV4ID0gMTtcclxuICAgfVxyXG4gICBiMkNvbGxpc2lvbi5NYWtlQ2xpcFBvaW50VmVjdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgciA9IG5ldyBWZWN0b3IoMik7XHJcbiAgICAgIHJbMF0gPSBuZXcgQ2xpcFZlcnRleCgpO1xyXG4gICAgICByWzFdID0gbmV3IENsaXBWZXJ0ZXgoKTtcclxuICAgICAgcmV0dXJuIHI7XHJcbiAgIH1cclxuICAgYjJDb2xsaXNpb24uQ29sbGlkZVBvbHlnb25zID0gZnVuY3Rpb24gKG1hbmlmb2xkLCBwb2x5QSwgeGZBLCBwb2x5QiwgeGZCKSB7XHJcbiAgICAgIHZhciBjdjtcclxuICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcclxuICAgICAgdmFyIHRvdGFsUmFkaXVzID0gcG9seUEubV9yYWRpdXMgKyBwb2x5Qi5tX3JhZGl1cztcclxuICAgICAgdmFyIGVkZ2VBID0gMDtcclxuICAgICAgYjJDb2xsaXNpb24uc19lZGdlQU9bMF0gPSBlZGdlQTtcclxuICAgICAgdmFyIHNlcGFyYXRpb25BID0gYjJDb2xsaXNpb24uRmluZE1heFNlcGFyYXRpb24oYjJDb2xsaXNpb24uc19lZGdlQU8sIHBvbHlBLCB4ZkEsIHBvbHlCLCB4ZkIpO1xyXG4gICAgICBlZGdlQSA9IGIyQ29sbGlzaW9uLnNfZWRnZUFPWzBdO1xyXG4gICAgICBpZiAoc2VwYXJhdGlvbkEgPiB0b3RhbFJhZGl1cykgcmV0dXJuO1xyXG4gICAgICB2YXIgZWRnZUIgPSAwO1xyXG4gICAgICBiMkNvbGxpc2lvbi5zX2VkZ2VCT1swXSA9IGVkZ2VCO1xyXG4gICAgICB2YXIgc2VwYXJhdGlvbkIgPSBiMkNvbGxpc2lvbi5GaW5kTWF4U2VwYXJhdGlvbihiMkNvbGxpc2lvbi5zX2VkZ2VCTywgcG9seUIsIHhmQiwgcG9seUEsIHhmQSk7XHJcbiAgICAgIGVkZ2VCID0gYjJDb2xsaXNpb24uc19lZGdlQk9bMF07XHJcbiAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKSByZXR1cm47XHJcbiAgICAgIHZhciBwb2x5MTtcclxuICAgICAgdmFyIHBvbHkyO1xyXG4gICAgICB2YXIgeGYxO1xyXG4gICAgICB2YXIgeGYyO1xyXG4gICAgICB2YXIgZWRnZTEgPSAwO1xyXG4gICAgICB2YXIgZmxpcCA9IDA7XHJcbiAgICAgIHZhciBrX3JlbGF0aXZlVG9sID0gMC45ODtcclxuICAgICAgdmFyIGtfYWJzb2x1dGVUb2wgPSAwLjAwMTtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIGlmIChzZXBhcmF0aW9uQiA+IGtfcmVsYXRpdmVUb2wgKiBzZXBhcmF0aW9uQSArIGtfYWJzb2x1dGVUb2wpIHtcclxuICAgICAgICAgcG9seTEgPSBwb2x5QjtcclxuICAgICAgICAgcG9seTIgPSBwb2x5QTtcclxuICAgICAgICAgeGYxID0geGZCO1xyXG4gICAgICAgICB4ZjIgPSB4ZkE7XHJcbiAgICAgICAgIGVkZ2UxID0gZWRnZUI7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQjtcclxuICAgICAgICAgZmxpcCA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHBvbHkxID0gcG9seUE7XHJcbiAgICAgICAgIHBvbHkyID0gcG9seUI7XHJcbiAgICAgICAgIHhmMSA9IHhmQTtcclxuICAgICAgICAgeGYyID0geGZCO1xyXG4gICAgICAgICBlZGdlMSA9IGVkZ2VBO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XHJcbiAgICAgICAgIGZsaXAgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpbmNpZGVudEVkZ2UgPSBiMkNvbGxpc2lvbi5zX2luY2lkZW50RWRnZTtcclxuICAgICAgYjJDb2xsaXNpb24uRmluZEluY2lkZW50RWRnZShpbmNpZGVudEVkZ2UsIHBvbHkxLCB4ZjEsIGVkZ2UxLCBwb2x5MiwgeGYyKTtcclxuICAgICAgdmFyIGNvdW50MSA9IHBhcnNlSW50KHBvbHkxLm1fdmVydGV4Q291bnQpO1xyXG4gICAgICB2YXIgdmVydGljZXMxID0gcG9seTEubV92ZXJ0aWNlcztcclxuICAgICAgdmFyIGxvY2FsX3YxMSA9IHZlcnRpY2VzMVtlZGdlMV07XHJcbiAgICAgIHZhciBsb2NhbF92MTI7XHJcbiAgICAgIGlmIChlZGdlMSArIDEgPCBjb3VudDEpIHtcclxuICAgICAgICAgbG9jYWxfdjEyID0gdmVydGljZXMxW3BhcnNlSW50KGVkZ2UxICsgMSldO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICBsb2NhbF92MTIgPSB2ZXJ0aWNlczFbMF07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxvY2FsVGFuZ2VudCA9IGIyQ29sbGlzaW9uLnNfbG9jYWxUYW5nZW50O1xyXG4gICAgICBsb2NhbFRhbmdlbnQuU2V0KGxvY2FsX3YxMi54IC0gbG9jYWxfdjExLngsIGxvY2FsX3YxMi55IC0gbG9jYWxfdjExLnkpO1xyXG4gICAgICBsb2NhbFRhbmdlbnQuTm9ybWFsaXplKCk7XHJcbiAgICAgIHZhciBsb2NhbE5vcm1hbCA9IGIyQ29sbGlzaW9uLnNfbG9jYWxOb3JtYWw7XHJcbiAgICAgIGxvY2FsTm9ybWFsLnggPSBsb2NhbFRhbmdlbnQueTtcclxuICAgICAgbG9jYWxOb3JtYWwueSA9ICgtbG9jYWxUYW5nZW50LngpO1xyXG4gICAgICB2YXIgcGxhbmVQb2ludCA9IGIyQ29sbGlzaW9uLnNfcGxhbmVQb2ludDtcclxuICAgICAgcGxhbmVQb2ludC5TZXQoMC41ICogKGxvY2FsX3YxMS54ICsgbG9jYWxfdjEyLngpLCAwLjUgKiAobG9jYWxfdjExLnkgKyBsb2NhbF92MTIueSkpO1xyXG4gICAgICB2YXIgdGFuZ2VudCA9IGIyQ29sbGlzaW9uLnNfdGFuZ2VudDtcclxuICAgICAgdE1hdCA9IHhmMS5SO1xyXG4gICAgICB0YW5nZW50LnggPSAodE1hdC5jb2wxLnggKiBsb2NhbFRhbmdlbnQueCArIHRNYXQuY29sMi54ICogbG9jYWxUYW5nZW50LnkpO1xyXG4gICAgICB0YW5nZW50LnkgPSAodE1hdC5jb2wxLnkgKiBsb2NhbFRhbmdlbnQueCArIHRNYXQuY29sMi55ICogbG9jYWxUYW5nZW50LnkpO1xyXG4gICAgICB2YXIgdGFuZ2VudDIgPSBiMkNvbGxpc2lvbi5zX3RhbmdlbnQyO1xyXG4gICAgICB0YW5nZW50Mi54ID0gKC10YW5nZW50LngpO1xyXG4gICAgICB0YW5nZW50Mi55ID0gKC10YW5nZW50LnkpO1xyXG4gICAgICB2YXIgbm9ybWFsID0gYjJDb2xsaXNpb24uc19ub3JtYWw7XHJcbiAgICAgIG5vcm1hbC54ID0gdGFuZ2VudC55O1xyXG4gICAgICBub3JtYWwueSA9ICgtdGFuZ2VudC54KTtcclxuICAgICAgdmFyIHYxMSA9IGIyQ29sbGlzaW9uLnNfdjExO1xyXG4gICAgICB2YXIgdjEyID0gYjJDb2xsaXNpb24uc192MTI7XHJcbiAgICAgIHYxMS54ID0geGYxLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiBsb2NhbF92MTEueCArIHRNYXQuY29sMi54ICogbG9jYWxfdjExLnkpO1xyXG4gICAgICB2MTEueSA9IHhmMS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogbG9jYWxfdjExLnggKyB0TWF0LmNvbDIueSAqIGxvY2FsX3YxMS55KTtcclxuICAgICAgdjEyLnggPSB4ZjEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIGxvY2FsX3YxMi54ICsgdE1hdC5jb2wyLnggKiBsb2NhbF92MTIueSk7XHJcbiAgICAgIHYxMi55ID0geGYxLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiBsb2NhbF92MTIueCArIHRNYXQuY29sMi55ICogbG9jYWxfdjEyLnkpO1xyXG4gICAgICB2YXIgZnJvbnRPZmZzZXQgPSBub3JtYWwueCAqIHYxMS54ICsgbm9ybWFsLnkgKiB2MTEueTtcclxuICAgICAgdmFyIHNpZGVPZmZzZXQxID0gKC10YW5nZW50LnggKiB2MTEueCkgLSB0YW5nZW50LnkgKiB2MTEueSArIHRvdGFsUmFkaXVzO1xyXG4gICAgICB2YXIgc2lkZU9mZnNldDIgPSB0YW5nZW50LnggKiB2MTIueCArIHRhbmdlbnQueSAqIHYxMi55ICsgdG90YWxSYWRpdXM7XHJcbiAgICAgIHZhciBjbGlwUG9pbnRzMSA9IGIyQ29sbGlzaW9uLnNfY2xpcFBvaW50czE7XHJcbiAgICAgIHZhciBjbGlwUG9pbnRzMiA9IGIyQ29sbGlzaW9uLnNfY2xpcFBvaW50czI7XHJcbiAgICAgIHZhciBucCA9IDA7XHJcbiAgICAgIG5wID0gYjJDb2xsaXNpb24uQ2xpcFNlZ21lbnRUb0xpbmUoY2xpcFBvaW50czEsIGluY2lkZW50RWRnZSwgdGFuZ2VudDIsIHNpZGVPZmZzZXQxKTtcclxuICAgICAgaWYgKG5wIDwgMikgcmV0dXJuO1xyXG4gICAgICBucCA9IGIyQ29sbGlzaW9uLkNsaXBTZWdtZW50VG9MaW5lKGNsaXBQb2ludHMyLCBjbGlwUG9pbnRzMSwgdGFuZ2VudCwgc2lkZU9mZnNldDIpO1xyXG4gICAgICBpZiAobnAgPCAyKSByZXR1cm47XHJcbiAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRWKGxvY2FsTm9ybWFsKTtcclxuICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldFYocGxhbmVQb2ludCk7XHJcbiAgICAgIHZhciBwb2ludENvdW50ID0gMDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyArK2kpIHtcclxuICAgICAgICAgY3YgPSBjbGlwUG9pbnRzMltpXTtcclxuICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBub3JtYWwueCAqIGN2LnYueCArIG5vcm1hbC55ICogY3Yudi55IC0gZnJvbnRPZmZzZXQ7XHJcbiAgICAgICAgIGlmIChzZXBhcmF0aW9uIDw9IHRvdGFsUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG1hbmlmb2xkLm1fcG9pbnRzW3BvaW50Q291bnRdO1xyXG4gICAgICAgICAgICB0TWF0ID0geGYyLlI7XHJcbiAgICAgICAgICAgIHZhciB0WCA9IGN2LnYueCAtIHhmMi5wb3NpdGlvbi54O1xyXG4gICAgICAgICAgICB2YXIgdFkgPSBjdi52LnkgLSB4ZjIucG9zaXRpb24ueTtcclxuICAgICAgICAgICAgY3AubV9sb2NhbFBvaW50LnggPSAodFggKiB0TWF0LmNvbDEueCArIHRZICogdE1hdC5jb2wxLnkpO1xyXG4gICAgICAgICAgICBjcC5tX2xvY2FsUG9pbnQueSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XHJcbiAgICAgICAgICAgIGNwLm1faWQuU2V0KGN2LmlkKTtcclxuICAgICAgICAgICAgY3AubV9pZC5mZWF0dXJlcy5mbGlwID0gZmxpcDtcclxuICAgICAgICAgICAgKytwb2ludENvdW50O1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gcG9pbnRDb3VudDtcclxuICAgfVxyXG4gICBiMkNvbGxpc2lvbi5Db2xsaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgY2lyY2xlMSwgeGYxLCBjaXJjbGUyLCB4ZjIpIHtcclxuICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0VmVjO1xyXG4gICAgICB0TWF0ID0geGYxLlI7XHJcbiAgICAgIHRWZWMgPSBjaXJjbGUxLm1fcDtcclxuICAgICAgdmFyIHAxWCA9IHhmMS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICB2YXIgcDFZID0geGYxLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgIHRNYXQgPSB4ZjIuUjtcclxuICAgICAgdFZlYyA9IGNpcmNsZTIubV9wO1xyXG4gICAgICB2YXIgcDJYID0geGYyLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgIHZhciBwMlkgPSB4ZjIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdmFyIGRYID0gcDJYIC0gcDFYO1xyXG4gICAgICB2YXIgZFkgPSBwMlkgLSBwMVk7XHJcbiAgICAgIHZhciBkaXN0U3FyID0gZFggKiBkWCArIGRZICogZFk7XHJcbiAgICAgIHZhciByYWRpdXMgPSBjaXJjbGUxLm1fcmFkaXVzICsgY2lyY2xlMi5tX3JhZGl1cztcclxuICAgICAgaWYgKGRpc3RTcXIgPiByYWRpdXMgKiByYWRpdXMpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9jaXJjbGVzO1xyXG4gICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQuU2V0VihjaXJjbGUxLm1fcCk7XHJcbiAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRaZXJvKCk7XHJcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDE7XHJcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZTIubV9wKTtcclxuICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xyXG4gICB9XHJcbiAgIGIyQ29sbGlzaW9uLkNvbGxpZGVQb2x5Z29uQW5kQ2lyY2xlID0gZnVuY3Rpb24gKG1hbmlmb2xkLCBwb2x5Z29uLCB4ZjEsIGNpcmNsZSwgeGYyKSB7XHJcbiAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDA7XHJcbiAgICAgIHZhciB0UG9pbnQ7XHJcbiAgICAgIHZhciBkWCA9IDA7XHJcbiAgICAgIHZhciBkWSA9IDA7XHJcbiAgICAgIHZhciBwb3NpdGlvblggPSAwO1xyXG4gICAgICB2YXIgcG9zaXRpb25ZID0gMDtcclxuICAgICAgdmFyIHRWZWM7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB0TWF0ID0geGYyLlI7XHJcbiAgICAgIHRWZWMgPSBjaXJjbGUubV9wO1xyXG4gICAgICB2YXIgY1ggPSB4ZjIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgdmFyIGNZID0geGYyLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgIGRYID0gY1ggLSB4ZjEucG9zaXRpb24ueDtcclxuICAgICAgZFkgPSBjWSAtIHhmMS5wb3NpdGlvbi55O1xyXG4gICAgICB0TWF0ID0geGYxLlI7XHJcbiAgICAgIHZhciBjTG9jYWxYID0gKGRYICogdE1hdC5jb2wxLnggKyBkWSAqIHRNYXQuY29sMS55KTtcclxuICAgICAgdmFyIGNMb2NhbFkgPSAoZFggKiB0TWF0LmNvbDIueCArIGRZICogdE1hdC5jb2wyLnkpO1xyXG4gICAgICB2YXIgZGlzdCA9IDA7XHJcbiAgICAgIHZhciBub3JtYWxJbmRleCA9IDA7XHJcbiAgICAgIHZhciBzZXBhcmF0aW9uID0gKC1OdW1iZXIuTUFYX1ZBTFVFKTtcclxuICAgICAgdmFyIHJhZGl1cyA9IHBvbHlnb24ubV9yYWRpdXMgKyBjaXJjbGUubV9yYWRpdXM7XHJcbiAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IHBhcnNlSW50KHBvbHlnb24ubV92ZXJ0ZXhDb3VudCk7XHJcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHBvbHlnb24ubV92ZXJ0aWNlcztcclxuICAgICAgdmFyIG5vcm1hbHMgPSBwb2x5Z29uLm1fbm9ybWFscztcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHRWZWMgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgZFggPSBjTG9jYWxYIC0gdFZlYy54O1xyXG4gICAgICAgICBkWSA9IGNMb2NhbFkgLSB0VmVjLnk7XHJcbiAgICAgICAgIHRWZWMgPSBub3JtYWxzW2ldO1xyXG4gICAgICAgICB2YXIgcyA9IHRWZWMueCAqIGRYICsgdFZlYy55ICogZFk7XHJcbiAgICAgICAgIGlmIChzID4gcmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAocyA+IHNlcGFyYXRpb24pIHtcclxuICAgICAgICAgICAgc2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gaTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciB2ZXJ0SW5kZXgxID0gcGFyc2VJbnQobm9ybWFsSW5kZXgpO1xyXG4gICAgICB2YXIgdmVydEluZGV4MiA9IHBhcnNlSW50KHZlcnRJbmRleDEgKyAxIDwgdmVydGV4Q291bnQgPyB2ZXJ0SW5kZXgxICsgMSA6IDApO1xyXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1t2ZXJ0SW5kZXgxXTtcclxuICAgICAgdmFyIHYyID0gdmVydGljZXNbdmVydEluZGV4Ml07XHJcbiAgICAgIGlmIChzZXBhcmF0aW9uIDwgTnVtYmVyLk1JTl9WQUxVRSkge1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRWKG5vcm1hbHNbbm9ybWFsSW5kZXhdKTtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LnggPSAwLjUgKiAodjEueCArIHYyLngpO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQueSA9IDAuNSAqICh2MS55ICsgdjIueSk7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZS5tX3ApO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2lkLmtleSA9IDA7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdTEgPSAoY0xvY2FsWCAtIHYxLngpICogKHYyLnggLSB2MS54KSArIChjTG9jYWxZIC0gdjEueSkgKiAodjIueSAtIHYxLnkpO1xyXG4gICAgICB2YXIgdTIgPSAoY0xvY2FsWCAtIHYyLngpICogKHYxLnggLSB2Mi54KSArIChjTG9jYWxZIC0gdjIueSkgKiAodjEueSAtIHYyLnkpO1xyXG4gICAgICBpZiAodTEgPD0gMC4wKSB7XHJcbiAgICAgICAgIGlmICgoY0xvY2FsWCAtIHYxLngpICogKGNMb2NhbFggLSB2MS54KSArIChjTG9jYWxZIC0gdjEueSkgKiAoY0xvY2FsWSAtIHYxLnkpID4gcmFkaXVzICogcmFkaXVzKSByZXR1cm47XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fdHlwZSA9IGIyTWFuaWZvbGQuZV9mYWNlQTtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLnggPSBjTG9jYWxYIC0gdjEueDtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLnkgPSBjTG9jYWxZIC0gdjEueTtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUG9pbnQuU2V0Vih2MSk7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludC5TZXRWKGNpcmNsZS5tX3ApO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2lkLmtleSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAodTIgPD0gMCkge1xyXG4gICAgICAgICBpZiAoKGNMb2NhbFggLSB2Mi54KSAqIChjTG9jYWxYIC0gdjIueCkgKyAoY0xvY2FsWSAtIHYyLnkpICogKGNMb2NhbFkgLSB2Mi55KSA+IHJhZGl1cyAqIHJhZGl1cykgcmV0dXJuO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3R5cGUgPSBiMk1hbmlmb2xkLmVfZmFjZUE7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC54ID0gY0xvY2FsWCAtIHYyLng7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC55ID0gY0xvY2FsWSAtIHYyLnk7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldFYodjIpO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2xvY2FsUG9pbnQuU2V0VihjaXJjbGUubV9wKTtcclxuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB2YXIgZmFjZUNlbnRlclggPSAwLjUgKiAodjEueCArIHYyLngpO1xyXG4gICAgICAgICB2YXIgZmFjZUNlbnRlclkgPSAwLjUgKiAodjEueSArIHYyLnkpO1xyXG4gICAgICAgICBzZXBhcmF0aW9uID0gKGNMb2NhbFggLSBmYWNlQ2VudGVyWCkgKiBub3JtYWxzW3ZlcnRJbmRleDFdLnggKyAoY0xvY2FsWSAtIGZhY2VDZW50ZXJZKSAqIG5vcm1hbHNbdmVydEluZGV4MV0ueTtcclxuICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiByYWRpdXMpIHJldHVybjtcclxuICAgICAgICAgbWFuaWZvbGQubV9wb2ludENvdW50ID0gMTtcclxuICAgICAgICAgbWFuaWZvbGQubV90eXBlID0gYjJNYW5pZm9sZC5lX2ZhY2VBO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueCA9IG5vcm1hbHNbdmVydEluZGV4MV0ueDtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBsYW5lTm9ybWFsLnkgPSBub3JtYWxzW3ZlcnRJbmRleDFdLnk7XHJcbiAgICAgICAgIG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgbWFuaWZvbGQubV9sb2NhbFBvaW50LlNldChmYWNlQ2VudGVyWCwgZmFjZUNlbnRlclkpO1xyXG4gICAgICAgICBtYW5pZm9sZC5tX3BvaW50c1swXS5tX2xvY2FsUG9pbnQuU2V0VihjaXJjbGUubV9wKTtcclxuICAgICAgICAgbWFuaWZvbGQubV9wb2ludHNbMF0ubV9pZC5rZXkgPSAwO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJDb2xsaXNpb24uVGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICB2YXIgdDEgPSBiLmxvd2VyQm91bmQ7XHJcbiAgICAgIHZhciB0MiA9IGEudXBwZXJCb3VuZDtcclxuICAgICAgdmFyIGQxWCA9IHQxLnggLSB0Mi54O1xyXG4gICAgICB2YXIgZDFZID0gdDEueSAtIHQyLnk7XHJcbiAgICAgIHQxID0gYS5sb3dlckJvdW5kO1xyXG4gICAgICB0MiA9IGIudXBwZXJCb3VuZDtcclxuICAgICAgdmFyIGQyWCA9IHQxLnggLSB0Mi54O1xyXG4gICAgICB2YXIgZDJZID0gdDEueSAtIHQyLnk7XHJcbiAgICAgIGlmIChkMVggPiAwLjAgfHwgZDFZID4gMC4wKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChkMlggPiAwLjAgfHwgZDJZID4gMC4wKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19pbmNpZGVudEVkZ2UgPSBiMkNvbGxpc2lvbi5NYWtlQ2xpcFBvaW50VmVjdG9yKCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2NsaXBQb2ludHMxID0gYjJDb2xsaXNpb24uTWFrZUNsaXBQb2ludFZlY3RvcigpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19jbGlwUG9pbnRzMiA9IGIyQ29sbGlzaW9uLk1ha2VDbGlwUG9pbnRWZWN0b3IoKTtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfZWRnZUFPID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDEpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uc19lZGdlQk8gPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoMSk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX2xvY2FsVGFuZ2VudCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfbG9jYWxOb3JtYWwgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX3BsYW5lUG9pbnQgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX25vcm1hbCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfdGFuZ2VudCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfdGFuZ2VudDIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5zX3YxMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyQ29sbGlzaW9uLnNfdjEyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24uYjJDb2xsaWRlUG9seVRlbXBWZWMgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbi5iMl9udWxsRmVhdHVyZSA9IDB4MDAwMDAwZmY7XHJcbiAgIH0pO1xyXG4gICBiMkNvbnRhY3RJRC5iMkNvbnRhY3RJRCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBGZWF0dXJlcygpO1xyXG4gICB9O1xyXG4gICBiMkNvbnRhY3RJRC5wcm90b3R5cGUuYjJDb250YWN0SUQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuZmVhdHVyZXMuX21faWQgPSB0aGlzO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdElELnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgdGhpcy5rZXkgPSBpZC5fa2V5O1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdElELnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaWQgPSBuZXcgYjJDb250YWN0SUQoKTtcclxuICAgICAgaWQua2V5ID0gdGhpcy5rZXk7XHJcbiAgICAgIHJldHVybiBpZDtcclxuICAgfVxyXG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYjJDb250YWN0SUQucHJvdG90eXBlLCAna2V5Jywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcclxuICAgICAgfVxyXG4gICB9KTtcclxuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGIyQ29udGFjdElELnByb3RvdHlwZSwgJ2tleScsIHtcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gMDtcclxuICAgICAgICAgdGhpcy5fa2V5ID0gdmFsdWU7XHJcbiAgICAgICAgIHRoaXMuZmVhdHVyZXMuX3JlZmVyZW5jZUVkZ2UgPSB0aGlzLl9rZXkgJiAweDAwMDAwMGZmO1xyXG4gICAgICAgICB0aGlzLmZlYXR1cmVzLl9pbmNpZGVudEVkZ2UgPSAoKHRoaXMuX2tleSAmIDB4MDAwMGZmMDApID4+IDgpICYgMHgwMDAwMDBmZjtcclxuICAgICAgICAgdGhpcy5mZWF0dXJlcy5faW5jaWRlbnRWZXJ0ZXggPSAoKHRoaXMuX2tleSAmIDB4MDBmZjAwMDApID4+IDE2KSAmIDB4MDAwMDAwZmY7XHJcbiAgICAgICAgIHRoaXMuZmVhdHVyZXMuX2ZsaXAgPSAoKHRoaXMuX2tleSAmIDB4ZmYwMDAwMDApID4+IDI0KSAmIDB4MDAwMDAwZmY7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIGIyQ29udGFjdFBvaW50LmIyQ29udGFjdFBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5pZCA9IG5ldyBiMkNvbnRhY3RJRCgpO1xyXG4gICB9O1xyXG4gICBiMkRpc3RhbmNlLmIyRGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgYjJEaXN0YW5jZS5EaXN0YW5jZSA9IGZ1bmN0aW9uIChvdXRwdXQsIGNhY2hlLCBpbnB1dCkge1xyXG4gICAgICArK2IyRGlzdGFuY2UuYjJfZ2prQ2FsbHM7XHJcbiAgICAgIHZhciBwcm94eUEgPSBpbnB1dC5wcm94eUE7XHJcbiAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XHJcbiAgICAgIHZhciB0cmFuc2Zvcm1BID0gaW5wdXQudHJhbnNmb3JtQTtcclxuICAgICAgdmFyIHRyYW5zZm9ybUIgPSBpbnB1dC50cmFuc2Zvcm1CO1xyXG4gICAgICB2YXIgc2ltcGxleCA9IGIyRGlzdGFuY2Uuc19zaW1wbGV4O1xyXG4gICAgICBzaW1wbGV4LlJlYWRDYWNoZShjYWNoZSwgcHJveHlBLCB0cmFuc2Zvcm1BLCBwcm94eUIsIHRyYW5zZm9ybUIpO1xyXG4gICAgICB2YXIgdmVydGljZXMgPSBzaW1wbGV4Lm1fdmVydGljZXM7XHJcbiAgICAgIHZhciBrX21heEl0ZXJzID0gMjA7XHJcbiAgICAgIHZhciBzYXZlQSA9IGIyRGlzdGFuY2Uuc19zYXZlQTtcclxuICAgICAgdmFyIHNhdmVCID0gYjJEaXN0YW5jZS5zX3NhdmVCO1xyXG4gICAgICB2YXIgc2F2ZUNvdW50ID0gMDtcclxuICAgICAgdmFyIGNsb3Nlc3RQb2ludCA9IHNpbXBsZXguR2V0Q2xvc2VzdFBvaW50KCk7XHJcbiAgICAgIHZhciBkaXN0YW5jZVNxcjEgPSBjbG9zZXN0UG9pbnQuTGVuZ3RoU3F1YXJlZCgpO1xyXG4gICAgICB2YXIgZGlzdGFuY2VTcXIyID0gZGlzdGFuY2VTcXIxO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBwO1xyXG4gICAgICB2YXIgaXRlciA9IDA7XHJcbiAgICAgIHdoaWxlIChpdGVyIDwga19tYXhJdGVycykge1xyXG4gICAgICAgICBzYXZlQ291bnQgPSBzaW1wbGV4Lm1fY291bnQ7XHJcbiAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgIGkgPCBzYXZlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBzYXZlQVtpXSA9IHZlcnRpY2VzW2ldLmluZGV4QTtcclxuICAgICAgICAgICAgc2F2ZUJbaV0gPSB2ZXJ0aWNlc1tpXS5pbmRleEI7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgc3dpdGNoIChzaW1wbGV4Lm1fY291bnQpIHtcclxuICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBzaW1wbGV4LlNvbHZlMigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICBzaW1wbGV4LlNvbHZlMygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKHNpbXBsZXgubV9jb3VudCA9PSAzKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHAgPSBzaW1wbGV4LkdldENsb3Nlc3RQb2ludCgpO1xyXG4gICAgICAgICBkaXN0YW5jZVNxcjIgPSBwLkxlbmd0aFNxdWFyZWQoKTtcclxuICAgICAgICAgaWYgKGRpc3RhbmNlU3FyMiA+IGRpc3RhbmNlU3FyMSkge31cclxuICAgICAgICAgZGlzdGFuY2VTcXIxID0gZGlzdGFuY2VTcXIyO1xyXG4gICAgICAgICB2YXIgZCA9IHNpbXBsZXguR2V0U2VhcmNoRGlyZWN0aW9uKCk7XHJcbiAgICAgICAgIGlmIChkLkxlbmd0aFNxdWFyZWQoKSA8IE51bWJlci5NSU5fVkFMVUUgKiBOdW1iZXIuTUlOX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tzaW1wbGV4Lm1fY291bnRdO1xyXG4gICAgICAgICB2ZXJ0ZXguaW5kZXhBID0gcHJveHlBLkdldFN1cHBvcnQoYjJNYXRoLk11bFRNVih0cmFuc2Zvcm1BLlIsIGQuR2V0TmVnYXRpdmUoKSkpO1xyXG4gICAgICAgICB2ZXJ0ZXgud0EgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBwcm94eUEuR2V0VmVydGV4KHZlcnRleC5pbmRleEEpKTtcclxuICAgICAgICAgdmVydGV4LmluZGV4QiA9IHByb3h5Qi5HZXRTdXBwb3J0KGIyTWF0aC5NdWxUTVYodHJhbnNmb3JtQi5SLCBkKSk7XHJcbiAgICAgICAgIHZlcnRleC53QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIHByb3h5Qi5HZXRWZXJ0ZXgodmVydGV4LmluZGV4QikpO1xyXG4gICAgICAgICB2ZXJ0ZXgudyA9IGIyTWF0aC5TdWJ0cmFjdFZWKHZlcnRleC53QiwgdmVydGV4LndBKTtcclxuICAgICAgICAgKytpdGVyO1xyXG4gICAgICAgICArK2IyRGlzdGFuY2UuYjJfZ2prSXRlcnM7XHJcbiAgICAgICAgIHZhciBkdXBsaWNhdGUgPSBmYWxzZTtcclxuICAgICAgICAgZm9yIChpID0gMDtcclxuICAgICAgICAgaSA8IHNhdmVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXguaW5kZXhBID09IHNhdmVBW2ldICYmIHZlcnRleC5pbmRleEIgPT0gc2F2ZUJbaV0pIHtcclxuICAgICAgICAgICAgICAgZHVwbGljYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAoZHVwbGljYXRlKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICB9KytzaW1wbGV4Lm1fY291bnQ7XHJcbiAgICAgIH1cclxuICAgICAgYjJEaXN0YW5jZS5iMl9namtNYXhJdGVycyA9IGIyTWF0aC5NYXgoYjJEaXN0YW5jZS5iMl9namtNYXhJdGVycywgaXRlcik7XHJcbiAgICAgIHNpbXBsZXguR2V0V2l0bmVzc1BvaW50cyhvdXRwdXQucG9pbnRBLCBvdXRwdXQucG9pbnRCKTtcclxuICAgICAgb3V0cHV0LmRpc3RhbmNlID0gYjJNYXRoLlN1YnRyYWN0VlYob3V0cHV0LnBvaW50QSwgb3V0cHV0LnBvaW50QikuTGVuZ3RoKCk7XHJcbiAgICAgIG91dHB1dC5pdGVyYXRpb25zID0gaXRlcjtcclxuICAgICAgc2ltcGxleC5Xcml0ZUNhY2hlKGNhY2hlKTtcclxuICAgICAgaWYgKGlucHV0LnVzZVJhZGlpKSB7XHJcbiAgICAgICAgIHZhciByQSA9IHByb3h5QS5tX3JhZGl1cztcclxuICAgICAgICAgdmFyIHJCID0gcHJveHlCLm1fcmFkaXVzO1xyXG4gICAgICAgICBpZiAob3V0cHV0LmRpc3RhbmNlID4gckEgKyByQiAmJiBvdXRwdXQuZGlzdGFuY2UgPiBOdW1iZXIuTUlOX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5kaXN0YW5jZSAtPSByQSArIHJCO1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gYjJNYXRoLlN1YnRyYWN0VlYob3V0cHV0LnBvaW50Qiwgb3V0cHV0LnBvaW50QSk7XHJcbiAgICAgICAgICAgIG5vcm1hbC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgb3V0cHV0LnBvaW50QS54ICs9IHJBICogbm9ybWFsLng7XHJcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEEueSArPSByQSAqIG5vcm1hbC55O1xyXG4gICAgICAgICAgICBvdXRwdXQucG9pbnRCLnggLT0gckIgKiBub3JtYWwueDtcclxuICAgICAgICAgICAgb3V0cHV0LnBvaW50Qi55IC09IHJCICogbm9ybWFsLnk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgICAgICAgIHAueCA9IC41ICogKG91dHB1dC5wb2ludEEueCArIG91dHB1dC5wb2ludEIueCk7XHJcbiAgICAgICAgICAgIHAueSA9IC41ICogKG91dHB1dC5wb2ludEEueSArIG91dHB1dC5wb2ludEIueSk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wb2ludEEueCA9IG91dHB1dC5wb2ludEIueCA9IHAueDtcclxuICAgICAgICAgICAgb3V0cHV0LnBvaW50QS55ID0gb3V0cHV0LnBvaW50Qi55ID0gcC55O1xyXG4gICAgICAgICAgICBvdXRwdXQuZGlzdGFuY2UgPSAwLjA7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZS5zX3NpbXBsZXggPSBuZXcgYjJTaW1wbGV4KCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLnNfc2F2ZUEgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoMyk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLnNfc2F2ZUIgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoMyk7XHJcbiAgIH0pO1xyXG4gICBiMkRpc3RhbmNlSW5wdXQuYjJEaXN0YW5jZUlucHV0ID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyRGlzdGFuY2VPdXRwdXQuYjJEaXN0YW5jZU91dHB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wb2ludEEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMucG9pbnRCID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMkRpc3RhbmNlUHJveHkuYjJEaXN0YW5jZVByb3h5ID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKHNoYXBlKSB7XHJcbiAgICAgIHN3aXRjaCAoc2hhcGUuR2V0VHlwZSgpKSB7XHJcbiAgICAgIGNhc2UgYjJTaGFwZS5lX2NpcmNsZVNoYXBlOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSAoc2hhcGUgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gc2hhcGUgOiBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzID0gbmV3IFZlY3RvcigxLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzWzBdID0gY2lyY2xlLm1fcDtcclxuICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcclxuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IGNpcmNsZS5tX3JhZGl1cztcclxuICAgICAgICAgfVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBiMlNoYXBlLmVfcG9seWdvblNoYXBlOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gKHNoYXBlIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyBzaGFwZSA6IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMgPSBwb2x5Z29uLm1fdmVydGljZXM7XHJcbiAgICAgICAgICAgIHRoaXMubV9jb3VudCA9IHBvbHlnb24ubV92ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgICAgdGhpcy5tX3JhZGl1cyA9IHBvbHlnb24ubV9yYWRpdXM7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5HZXRTdXBwb3J0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XHJcbiAgICAgIHZhciBiZXN0VmFsdWUgPSB0aGlzLm1fdmVydGljZXNbMF0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1swXS55ICogZC55O1xyXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1tpXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzW2ldLnkgKiBkLnk7XHJcbiAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xyXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiZXN0SW5kZXg7XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZVByb3h5LnByb3RvdHlwZS5HZXRTdXBwb3J0VmVydGV4ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XHJcbiAgICAgIHZhciBiZXN0VmFsdWUgPSB0aGlzLm1fdmVydGljZXNbMF0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1swXS55ICogZC55O1xyXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV9jb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1tpXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzW2ldLnkgKiBkLnk7XHJcbiAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xyXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbYmVzdEluZGV4XTtcclxuICAgfVxyXG4gICBiMkRpc3RhbmNlUHJveHkucHJvdG90eXBlLkdldFZlcnRleENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2NvdW50O1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VQcm94eS5wcm90b3R5cGUuR2V0VmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSBpbmRleCA9IDA7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8PSBpbmRleCAmJiBpbmRleCA8IHRoaXMubV9jb3VudCk7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbaW5kZXhdO1xyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWUuYjJEeW5hbWljVHJlZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5iMkR5bmFtaWNUcmVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fcm9vdCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9mcmVlTGlzdCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9wYXRoID0gMDtcclxuICAgICAgdGhpcy5tX2luc2VydGlvbkNvdW50ID0gMDtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5DcmVhdGVQcm94eSA9IGZ1bmN0aW9uIChhYWJiLCB1c2VyRGF0YSkge1xyXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuQWxsb2NhdGVOb2RlKCk7XHJcbiAgICAgIHZhciBleHRlbmRYID0gYjJTZXR0aW5ncy5iMl9hYWJiRXh0ZW5zaW9uO1xyXG4gICAgICB2YXIgZXh0ZW5kWSA9IGIyU2V0dGluZ3MuYjJfYWFiYkV4dGVuc2lvbjtcclxuICAgICAgbm9kZS5hYWJiLmxvd2VyQm91bmQueCA9IGFhYmIubG93ZXJCb3VuZC54IC0gZXh0ZW5kWDtcclxuICAgICAgbm9kZS5hYWJiLmxvd2VyQm91bmQueSA9IGFhYmIubG93ZXJCb3VuZC55IC0gZXh0ZW5kWTtcclxuICAgICAgbm9kZS5hYWJiLnVwcGVyQm91bmQueCA9IGFhYmIudXBwZXJCb3VuZC54ICsgZXh0ZW5kWDtcclxuICAgICAgbm9kZS5hYWJiLnVwcGVyQm91bmQueSA9IGFhYmIudXBwZXJCb3VuZC55ICsgZXh0ZW5kWTtcclxuICAgICAgbm9kZS51c2VyRGF0YSA9IHVzZXJEYXRhO1xyXG4gICAgICB0aGlzLkluc2VydExlYWYobm9kZSk7XHJcbiAgICAgIHJldHVybiBub2RlO1xyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLkRlc3Ryb3lQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xyXG4gICAgICB0aGlzLlJlbW92ZUxlYWYocHJveHkpO1xyXG4gICAgICB0aGlzLkZyZWVOb2RlKHByb3h5KTtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5Nb3ZlUHJveHkgPSBmdW5jdGlvbiAocHJveHksIGFhYmIsIGRpc3BsYWNlbWVudCkge1xyXG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KHByb3h5LklzTGVhZigpKTtcclxuICAgICAgaWYgKHByb3h5LmFhYmIuQ29udGFpbnMoYWFiYikpIHtcclxuICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuUmVtb3ZlTGVhZihwcm94eSk7XHJcbiAgICAgIHZhciBleHRlbmRYID0gYjJTZXR0aW5ncy5iMl9hYWJiRXh0ZW5zaW9uICsgYjJTZXR0aW5ncy5iMl9hYWJiTXVsdGlwbGllciAqIChkaXNwbGFjZW1lbnQueCA+IDAgPyBkaXNwbGFjZW1lbnQueCA6ICgtZGlzcGxhY2VtZW50LngpKTtcclxuICAgICAgdmFyIGV4dGVuZFkgPSBiMlNldHRpbmdzLmIyX2FhYmJFeHRlbnNpb24gKyBiMlNldHRpbmdzLmIyX2FhYmJNdWx0aXBsaWVyICogKGRpc3BsYWNlbWVudC55ID4gMCA/IGRpc3BsYWNlbWVudC55IDogKC1kaXNwbGFjZW1lbnQueSkpO1xyXG4gICAgICBwcm94eS5hYWJiLmxvd2VyQm91bmQueCA9IGFhYmIubG93ZXJCb3VuZC54IC0gZXh0ZW5kWDtcclxuICAgICAgcHJveHkuYWFiYi5sb3dlckJvdW5kLnkgPSBhYWJiLmxvd2VyQm91bmQueSAtIGV4dGVuZFk7XHJcbiAgICAgIHByb3h5LmFhYmIudXBwZXJCb3VuZC54ID0gYWFiYi51cHBlckJvdW5kLnggKyBleHRlbmRYO1xyXG4gICAgICBwcm94eS5hYWJiLnVwcGVyQm91bmQueSA9IGFhYmIudXBwZXJCb3VuZC55ICsgZXh0ZW5kWTtcclxuICAgICAgdGhpcy5JbnNlcnRMZWFmKHByb3h5KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuUmViYWxhbmNlID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMpIHtcclxuICAgICAgaWYgKGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgaXRlcmF0aW9ucyA9IDA7XHJcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgIHZhciBub2RlID0gdGhpcy5tX3Jvb3Q7XHJcbiAgICAgICAgIHZhciBiaXQgPSAwO1xyXG4gICAgICAgICB3aGlsZSAobm9kZS5Jc0xlYWYoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBub2RlID0gKHRoaXMubV9wYXRoID4+IGJpdCkgJiAxID8gbm9kZS5jaGlsZDIgOiBub2RlLmNoaWxkMTtcclxuICAgICAgICAgICAgYml0ID0gKGJpdCArIDEpICYgMzE7XHJcbiAgICAgICAgIH0rK3RoaXMubV9wYXRoO1xyXG4gICAgICAgICB0aGlzLlJlbW92ZUxlYWYobm9kZSk7XHJcbiAgICAgICAgIHRoaXMuSW5zZXJ0TGVhZihub2RlKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLkdldEZhdEFBQkIgPSBmdW5jdGlvbiAocHJveHkpIHtcclxuICAgICAgcmV0dXJuIHByb3h5LmFhYmI7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuR2V0VXNlckRhdGEgPSBmdW5jdGlvbiAocHJveHkpIHtcclxuICAgICAgcmV0dXJuIHByb3h5LnVzZXJEYXRhO1xyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLlF1ZXJ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhYWJiKSB7XHJcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgIHZhciBzdGFjayA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgc3RhY2tbY291bnQrK10gPSB0aGlzLm1fcm9vdDtcclxuICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xyXG4gICAgICAgICB2YXIgbm9kZSA9IHN0YWNrWy0tY291bnRdO1xyXG4gICAgICAgICBpZiAobm9kZS5hYWJiLlRlc3RPdmVybGFwKGFhYmIpKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLklzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBwcm9jZWVkID0gY2FsbGJhY2sobm9kZSk7XHJcbiAgICAgICAgICAgICAgIGlmICghcHJvY2VlZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IG5vZGUuY2hpbGQxO1xyXG4gICAgICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IG5vZGUuY2hpbGQyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGlucHV0KSB7XHJcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgIHZhciBwMSA9IGlucHV0LnAxO1xyXG4gICAgICB2YXIgcDIgPSBpbnB1dC5wMjtcclxuICAgICAgdmFyIHIgPSBiMk1hdGguU3VidHJhY3RWVihwMSwgcDIpO1xyXG4gICAgICByLk5vcm1hbGl6ZSgpO1xyXG4gICAgICB2YXIgdiA9IGIyTWF0aC5Dcm9zc0ZWKDEuMCwgcik7XHJcbiAgICAgIHZhciBhYnNfdiA9IGIyTWF0aC5BYnNWKHYpO1xyXG4gICAgICB2YXIgbWF4RnJhY3Rpb24gPSBpbnB1dC5tYXhGcmFjdGlvbjtcclxuICAgICAgdmFyIHNlZ21lbnRBQUJCID0gbmV3IGIyQUFCQigpO1xyXG4gICAgICB2YXIgdFggPSAwO1xyXG4gICAgICB2YXIgdFkgPSAwOyB7XHJcbiAgICAgICAgIHRYID0gcDEueCArIG1heEZyYWN0aW9uICogKHAyLnggLSBwMS54KTtcclxuICAgICAgICAgdFkgPSBwMS55ICsgbWF4RnJhY3Rpb24gKiAocDIueSAtIHAxLnkpO1xyXG4gICAgICAgICBzZWdtZW50QUFCQi5sb3dlckJvdW5kLnggPSBNYXRoLm1pbihwMS54LCB0WCk7XHJcbiAgICAgICAgIHNlZ21lbnRBQUJCLmxvd2VyQm91bmQueSA9IE1hdGgubWluKHAxLnksIHRZKTtcclxuICAgICAgICAgc2VnbWVudEFBQkIudXBwZXJCb3VuZC54ID0gTWF0aC5tYXgocDEueCwgdFgpO1xyXG4gICAgICAgICBzZWdtZW50QUFCQi51cHBlckJvdW5kLnkgPSBNYXRoLm1heChwMS55LCB0WSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHN0YWNrID0gbmV3IFZlY3RvcigpO1xyXG4gICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICBzdGFja1tjb3VudCsrXSA9IHRoaXMubV9yb290O1xyXG4gICAgICB3aGlsZSAoY291bnQgPiAwKSB7XHJcbiAgICAgICAgIHZhciBub2RlID0gc3RhY2tbLS1jb3VudF07XHJcbiAgICAgICAgIGlmIChub2RlLmFhYmIuVGVzdE92ZXJsYXAoc2VnbWVudEFBQkIpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBjID0gbm9kZS5hYWJiLkdldENlbnRlcigpO1xyXG4gICAgICAgICB2YXIgaCA9IG5vZGUuYWFiYi5HZXRFeHRlbnRzKCk7XHJcbiAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gTWF0aC5hYnModi54ICogKHAxLnggLSBjLngpICsgdi55ICogKHAxLnkgLSBjLnkpKSAtIGFic192LnggKiBoLnggLSBhYnNfdi55ICogaC55O1xyXG4gICAgICAgICBpZiAoc2VwYXJhdGlvbiA+IDAuMCkgY29udGludWU7XHJcbiAgICAgICAgIGlmIChub2RlLklzTGVhZigpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJJbnB1dCA9IG5ldyBiMlJheUNhc3RJbnB1dCgpO1xyXG4gICAgICAgICAgICBzdWJJbnB1dC5wMSA9IGlucHV0LnAxO1xyXG4gICAgICAgICAgICBzdWJJbnB1dC5wMiA9IGlucHV0LnAyO1xyXG4gICAgICAgICAgICBzdWJJbnB1dC5tYXhGcmFjdGlvbiA9IGlucHV0Lm1heEZyYWN0aW9uO1xyXG4gICAgICAgICAgICBtYXhGcmFjdGlvbiA9IGNhbGxiYWNrKHN1YklucHV0LCBub2RlKTtcclxuICAgICAgICAgICAgaWYgKG1heEZyYWN0aW9uID09IDAuMCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAobWF4RnJhY3Rpb24gPiAwLjApIHtcclxuICAgICAgICAgICAgICAgdFggPSBwMS54ICsgbWF4RnJhY3Rpb24gKiAocDIueCAtIHAxLngpO1xyXG4gICAgICAgICAgICAgICB0WSA9IHAxLnkgKyBtYXhGcmFjdGlvbiAqIChwMi55IC0gcDEueSk7XHJcbiAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLmxvd2VyQm91bmQueCA9IE1hdGgubWluKHAxLngsIHRYKTtcclxuICAgICAgICAgICAgICAgc2VnbWVudEFBQkIubG93ZXJCb3VuZC55ID0gTWF0aC5taW4ocDEueSwgdFkpO1xyXG4gICAgICAgICAgICAgICBzZWdtZW50QUFCQi51cHBlckJvdW5kLnggPSBNYXRoLm1heChwMS54LCB0WCk7XHJcbiAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KHAxLnksIHRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IG5vZGUuY2hpbGQxO1xyXG4gICAgICAgICAgICBzdGFja1tjb3VudCsrXSA9IG5vZGUuY2hpbGQyO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5BbGxvY2F0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLm1fZnJlZUxpc3QpIHtcclxuICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm1fZnJlZUxpc3Q7XHJcbiAgICAgICAgIHRoaXMubV9mcmVlTGlzdCA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgIG5vZGUuY2hpbGQxID0gbnVsbDtcclxuICAgICAgICAgbm9kZS5jaGlsZDIgPSBudWxsO1xyXG4gICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IGIyRHluYW1pY1RyZWVOb2RlKCk7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuRnJlZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICBub2RlLnBhcmVudCA9IHRoaXMubV9mcmVlTGlzdDtcclxuICAgICAgdGhpcy5tX2ZyZWVMaXN0ID0gbm9kZTtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlLnByb3RvdHlwZS5JbnNlcnRMZWFmID0gZnVuY3Rpb24gKGxlYWYpIHtcclxuICAgICAgKyt0aGlzLm1faW5zZXJ0aW9uQ291bnQ7XHJcbiAgICAgIGlmICh0aGlzLm1fcm9vdCA9PSBudWxsKSB7XHJcbiAgICAgICAgIHRoaXMubV9yb290ID0gbGVhZjtcclxuICAgICAgICAgdGhpcy5tX3Jvb3QucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjZW50ZXIgPSBsZWFmLmFhYmIuR2V0Q2VudGVyKCk7XHJcbiAgICAgIHZhciBzaWJsaW5nID0gdGhpcy5tX3Jvb3Q7XHJcbiAgICAgIGlmIChzaWJsaW5nLklzTGVhZigpID09IGZhbHNlKSB7XHJcbiAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkMSA9IHNpYmxpbmcuY2hpbGQxO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQyID0gc2libGluZy5jaGlsZDI7XHJcbiAgICAgICAgICAgIHZhciBub3JtMSA9IE1hdGguYWJzKChjaGlsZDEuYWFiYi5sb3dlckJvdW5kLnggKyBjaGlsZDEuYWFiYi51cHBlckJvdW5kLngpIC8gMiAtIGNlbnRlci54KSArIE1hdGguYWJzKChjaGlsZDEuYWFiYi5sb3dlckJvdW5kLnkgKyBjaGlsZDEuYWFiYi51cHBlckJvdW5kLnkpIC8gMiAtIGNlbnRlci55KTtcclxuICAgICAgICAgICAgdmFyIG5vcm0yID0gTWF0aC5hYnMoKGNoaWxkMi5hYWJiLmxvd2VyQm91bmQueCArIGNoaWxkMi5hYWJiLnVwcGVyQm91bmQueCkgLyAyIC0gY2VudGVyLngpICsgTWF0aC5hYnMoKGNoaWxkMi5hYWJiLmxvd2VyQm91bmQueSArIGNoaWxkMi5hYWJiLnVwcGVyQm91bmQueSkgLyAyIC0gY2VudGVyLnkpO1xyXG4gICAgICAgICAgICBpZiAobm9ybTEgPCBub3JtMikge1xyXG4gICAgICAgICAgICAgICBzaWJsaW5nID0gY2hpbGQxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICBzaWJsaW5nID0gY2hpbGQyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgd2hpbGUgKHNpYmxpbmcuSXNMZWFmKCkgPT0gZmFsc2UpXHJcbiAgICAgIH1cclxuICAgICAgdmFyIG5vZGUxID0gc2libGluZy5wYXJlbnQ7XHJcbiAgICAgIHZhciBub2RlMiA9IHRoaXMuQWxsb2NhdGVOb2RlKCk7XHJcbiAgICAgIG5vZGUyLnBhcmVudCA9IG5vZGUxO1xyXG4gICAgICBub2RlMi51c2VyRGF0YSA9IG51bGw7XHJcbiAgICAgIG5vZGUyLmFhYmIuQ29tYmluZShsZWFmLmFhYmIsIHNpYmxpbmcuYWFiYik7XHJcbiAgICAgIGlmIChub2RlMSkge1xyXG4gICAgICAgICBpZiAoc2libGluZy5wYXJlbnQuY2hpbGQxID09IHNpYmxpbmcpIHtcclxuICAgICAgICAgICAgbm9kZTEuY2hpbGQxID0gbm9kZTI7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUxLmNoaWxkMiA9IG5vZGUyO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIG5vZGUyLmNoaWxkMSA9IHNpYmxpbmc7XHJcbiAgICAgICAgIG5vZGUyLmNoaWxkMiA9IGxlYWY7XHJcbiAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbm9kZTI7XHJcbiAgICAgICAgIGxlYWYucGFyZW50ID0gbm9kZTI7XHJcbiAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUxLmFhYmIuQ29udGFpbnMobm9kZTIuYWFiYikpIGJyZWFrO1xyXG4gICAgICAgICAgICBub2RlMS5hYWJiLkNvbWJpbmUobm9kZTEuY2hpbGQxLmFhYmIsIG5vZGUxLmNoaWxkMi5hYWJiKTtcclxuICAgICAgICAgICAgbm9kZTIgPSBub2RlMTtcclxuICAgICAgICAgICAgbm9kZTEgPSBub2RlMS5wYXJlbnQ7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgd2hpbGUgKG5vZGUxKVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICBub2RlMi5jaGlsZDEgPSBzaWJsaW5nO1xyXG4gICAgICAgICBub2RlMi5jaGlsZDIgPSBsZWFmO1xyXG4gICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG5vZGUyO1xyXG4gICAgICAgICBsZWFmLnBhcmVudCA9IG5vZGUyO1xyXG4gICAgICAgICB0aGlzLm1fcm9vdCA9IG5vZGUyO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZS5wcm90b3R5cGUuUmVtb3ZlTGVhZiA9IGZ1bmN0aW9uIChsZWFmKSB7XHJcbiAgICAgIGlmIChsZWFmID09IHRoaXMubV9yb290KSB7XHJcbiAgICAgICAgIHRoaXMubV9yb290ID0gbnVsbDtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBub2RlMiA9IGxlYWYucGFyZW50O1xyXG4gICAgICB2YXIgbm9kZTEgPSBub2RlMi5wYXJlbnQ7XHJcbiAgICAgIHZhciBzaWJsaW5nO1xyXG4gICAgICBpZiAobm9kZTIuY2hpbGQxID09IGxlYWYpIHtcclxuICAgICAgICAgc2libGluZyA9IG5vZGUyLmNoaWxkMjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgc2libGluZyA9IG5vZGUyLmNoaWxkMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobm9kZTEpIHtcclxuICAgICAgICAgaWYgKG5vZGUxLmNoaWxkMSA9PSBub2RlMikge1xyXG4gICAgICAgICAgICBub2RlMS5jaGlsZDEgPSBzaWJsaW5nO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlMS5jaGlsZDIgPSBzaWJsaW5nO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbm9kZTE7XHJcbiAgICAgICAgIHRoaXMuRnJlZU5vZGUobm9kZTIpO1xyXG4gICAgICAgICB3aGlsZSAobm9kZTEpIHtcclxuICAgICAgICAgICAgdmFyIG9sZEFBQkIgPSBub2RlMS5hYWJiO1xyXG4gICAgICAgICAgICBub2RlMS5hYWJiID0gYjJBQUJCLkNvbWJpbmUobm9kZTEuY2hpbGQxLmFhYmIsIG5vZGUxLmNoaWxkMi5hYWJiKTtcclxuICAgICAgICAgICAgaWYgKG9sZEFBQkIuQ29udGFpbnMobm9kZTEuYWFiYikpIGJyZWFrO1xyXG4gICAgICAgICAgICBub2RlMSA9IG5vZGUxLnBhcmVudDtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1fcm9vdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgdGhpcy5GcmVlTm9kZShub2RlMik7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX3RyZWUgPSBuZXcgYjJEeW5hbWljVHJlZSgpO1xyXG4gICAgICB0aGlzLm1fbW92ZUJ1ZmZlciA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgdGhpcy5tX3BhaXJCdWZmZXIgPSBuZXcgVmVjdG9yKCk7XHJcbiAgICAgIHRoaXMubV9wYWlyQ291bnQgPSAwO1xyXG4gICB9O1xyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuQ3JlYXRlUHJveHkgPSBmdW5jdGlvbiAoYWFiYiwgdXNlckRhdGEpIHtcclxuICAgICAgdmFyIHByb3h5ID0gdGhpcy5tX3RyZWUuQ3JlYXRlUHJveHkoYWFiYiwgdXNlckRhdGEpO1xyXG4gICAgICArK3RoaXMubV9wcm94eUNvdW50O1xyXG4gICAgICB0aGlzLkJ1ZmZlck1vdmUocHJveHkpO1xyXG4gICAgICByZXR1cm4gcHJveHk7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkRlc3Ryb3lQcm94eSA9IGZ1bmN0aW9uIChwcm94eSkge1xyXG4gICAgICB0aGlzLlVuQnVmZmVyTW92ZShwcm94eSk7XHJcbiAgICAgIC0tdGhpcy5tX3Byb3h5Q291bnQ7XHJcbiAgICAgIHRoaXMubV90cmVlLkRlc3Ryb3lQcm94eShwcm94eSk7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLk1vdmVQcm94eSA9IGZ1bmN0aW9uIChwcm94eSwgYWFiYiwgZGlzcGxhY2VtZW50KSB7XHJcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLm1fdHJlZS5Nb3ZlUHJveHkocHJveHksIGFhYmIsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgdGhpcy5CdWZmZXJNb3ZlKHByb3h5KTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5UZXN0T3ZlcmxhcCA9IGZ1bmN0aW9uIChwcm94eUEsIHByb3h5Qikge1xyXG4gICAgICB2YXIgYWFiYkEgPSB0aGlzLm1fdHJlZS5HZXRGYXRBQUJCKHByb3h5QSk7XHJcbiAgICAgIHZhciBhYWJiQiA9IHRoaXMubV90cmVlLkdldEZhdEFBQkIocHJveHlCKTtcclxuICAgICAgcmV0dXJuIGFhYmJBLlRlc3RPdmVybGFwKGFhYmJCKTtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuR2V0VXNlckRhdGEgPSBmdW5jdGlvbiAocHJveHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV90cmVlLkdldFVzZXJEYXRhKHByb3h5KTtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuR2V0RmF0QUFCQiA9IGZ1bmN0aW9uIChwcm94eSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3RyZWUuR2V0RmF0QUFCQihwcm94eSk7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkdldFByb3h5Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fcHJveHlDb3VudDtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuVXBkYXRlUGFpcnMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XHJcbiAgICAgIF9fdGhpcy5tX3BhaXJDb3VudCA9IDA7XHJcbiAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgcXVlcnlQcm94eTtcclxuICAgICAgIGZ1bmN0aW9uIFF1ZXJ5Q2FsbGJhY2socHJveHkpIHtcclxuICAgICAgICAgIGlmIChwcm94eSA9PSBxdWVyeVByb3h5KSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIGlmIChfX3RoaXMubV9wYWlyQ291bnQgPT0gX190aGlzLm1fcGFpckJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgIF9fdGhpcy5tX3BhaXJCdWZmZXJbX190aGlzLm1fcGFpckNvdW50XSA9IG5ldyBiMkR5bmFtaWNUcmVlUGFpcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIHBhaXIgPSBfX3RoaXMubV9wYWlyQnVmZmVyW19fdGhpcy5tX3BhaXJDb3VudF07XHJcbiAgICAgICAgICBwYWlyLnByb3h5QSA9IHByb3h5IDwgcXVlcnlQcm94eSA/IHByb3h5IDogcXVlcnlQcm94eTtcclxuICAgICAgICAgIHBhaXIucHJveHlCID0gcHJveHkgPj0gcXVlcnlQcm94eSA/IHByb3h5IDogcXVlcnlQcm94eTsrK19fdGhpcy5tX3BhaXJDb3VudDtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgfTtcclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IF9fdGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgcXVlcnlQcm94eSA9IF9fdGhpcy5tX21vdmVCdWZmZXJbaV07XHJcbiAgICAgICAgIHZhciBmYXRBQUJCID0gX190aGlzLm1fdHJlZS5HZXRGYXRBQUJCKHF1ZXJ5UHJveHkpO1xyXG4gICAgICAgICBfX3RoaXMubV90cmVlLlF1ZXJ5KFF1ZXJ5Q2FsbGJhY2ssIGZhdEFBQkIpO1xyXG4gICAgICB9XHJcbiAgICAgIF9fdGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfX3RoaXMubV9wYWlyQ291bnQ7KSB7XHJcbiAgICAgICAgIHZhciBwcmltYXJ5UGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbaV07XHJcbiAgICAgICAgIHZhciB1c2VyRGF0YUEgPSBfX3RoaXMubV90cmVlLkdldFVzZXJEYXRhKHByaW1hcnlQYWlyLnByb3h5QSk7XHJcbiAgICAgICAgIHZhciB1c2VyRGF0YUIgPSBfX3RoaXMubV90cmVlLkdldFVzZXJEYXRhKHByaW1hcnlQYWlyLnByb3h5Qik7XHJcbiAgICAgICAgIGNhbGxiYWNrKHVzZXJEYXRhQSwgdXNlckRhdGFCKTtcclxuICAgICAgICAgKytpO1xyXG4gICAgICAgICB3aGlsZSAoaSA8IF9fdGhpcy5tX3BhaXJDb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgcGFpciA9IF9fdGhpcy5tX3BhaXJCdWZmZXJbaV07XHJcbiAgICAgICAgICAgIGlmIChwYWlyLnByb3h5QSAhPSBwcmltYXJ5UGFpci5wcm94eUEgfHwgcGFpci5wcm94eUIgIT0gcHJpbWFyeVBhaXIucHJveHlCKSB7XHJcbiAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9KytpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuUXVlcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFhYmIpIHtcclxuICAgICAgdGhpcy5tX3RyZWUuUXVlcnkoY2FsbGJhY2ssIGFhYmIpO1xyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbnB1dCkge1xyXG4gICAgICB0aGlzLm1fdHJlZS5SYXlDYXN0KGNhbGxiYWNrLCBpbnB1dCk7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLlZhbGlkYXRlID0gZnVuY3Rpb24gKCkge31cclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLlJlYmFsYW5jZSA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XHJcbiAgICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAwO1xyXG4gICAgICB0aGlzLm1fdHJlZS5SZWJhbGFuY2UoaXRlcmF0aW9ucyk7XHJcbiAgIH1cclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UucHJvdG90eXBlLkJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHkpIHtcclxuICAgICAgdGhpcy5tX21vdmVCdWZmZXJbdGhpcy5tX21vdmVCdWZmZXIubGVuZ3RoXSA9IHByb3h5O1xyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWVCcm9hZFBoYXNlLnByb3RvdHlwZS5VbkJ1ZmZlck1vdmUgPSBmdW5jdGlvbiAocHJveHkpIHtcclxuICAgICAgdmFyIGkgPSBwYXJzZUludCh0aGlzLm1fbW92ZUJ1ZmZlci5pbmRleE9mKHByb3h5KSk7XHJcbiAgICAgIHRoaXMubV9tb3ZlQnVmZmVyLnNwbGljZShpLCAxKTtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5wcm90b3R5cGUuQ29tcGFyZVBhaXJzID0gZnVuY3Rpb24gKHBhaXIxLCBwYWlyMikge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgfVxyXG4gICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZS5fX2ltcGxlbWVudHMgPSB7fTtcclxuICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UuX19pbXBsZW1lbnRzW0lCcm9hZFBoYXNlXSA9IHRydWU7XHJcbiAgIGIyRHluYW1pY1RyZWVOb2RlLmIyRHluYW1pY1RyZWVOb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmFhYmIgPSBuZXcgYjJBQUJCKCk7XHJcbiAgIH07XHJcbiAgIGIyRHluYW1pY1RyZWVOb2RlLnByb3RvdHlwZS5Jc0xlYWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkMSA9PSBudWxsO1xyXG4gICB9XHJcbiAgIGIyRHluYW1pY1RyZWVQYWlyLmIyRHluYW1pY1RyZWVQYWlyID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyTWFuaWZvbGQuYjJNYW5pZm9sZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX3BvaW50Q291bnQgPSAwO1xyXG4gICB9O1xyXG4gICBiMk1hbmlmb2xkLnByb3RvdHlwZS5iMk1hbmlmb2xkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fcG9pbnRzID0gbmV3IFZlY3RvcihiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcclxuICAgICAgICAgdGhpcy5tX3BvaW50c1tpXSA9IG5ldyBiMk1hbmlmb2xkUG9pbnQoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fbG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2xvY2FsUG9pbnQgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH1cclxuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50czsgaSsrKSB7XHJcbiAgICAgICAgICgodGhpcy5tX3BvaW50c1tpXSBpbnN0YW5jZW9mIGIyTWFuaWZvbGRQb2ludCA/IHRoaXMubV9wb2ludHNbaV0gOiBudWxsKSkuUmVzZXQoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fbG9jYWxQbGFuZU5vcm1hbC5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFplcm8oKTtcclxuICAgICAgdGhpcy5tX3R5cGUgPSAwO1xyXG4gICAgICB0aGlzLm1fcG9pbnRDb3VudCA9IDA7XHJcbiAgIH1cclxuICAgYjJNYW5pZm9sZC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG0pIHtcclxuICAgICAgdGhpcy5tX3BvaW50Q291bnQgPSBtLm1fcG9pbnRDb3VudDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcclxuICAgICAgICAgKCh0aGlzLm1fcG9pbnRzW2ldIGluc3RhbmNlb2YgYjJNYW5pZm9sZFBvaW50ID8gdGhpcy5tX3BvaW50c1tpXSA6IG51bGwpKS5TZXQobS5tX3BvaW50c1tpXSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX2xvY2FsUGxhbmVOb3JtYWwuU2V0VihtLm1fbG9jYWxQbGFuZU5vcm1hbCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFYobS5tX2xvY2FsUG9pbnQpO1xyXG4gICAgICB0aGlzLm1fdHlwZSA9IG0ubV90eXBlO1xyXG4gICB9XHJcbiAgIGIyTWFuaWZvbGQucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBjb3B5ID0gbmV3IGIyTWFuaWZvbGQoKTtcclxuICAgICAgY29weS5TZXQodGhpcyk7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZC5lX2NpcmNsZXMgPSAweDAwMDE7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkLmVfZmFjZUEgPSAweDAwMDI7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkLmVfZmFjZUIgPSAweDAwMDQ7XHJcbiAgIH0pO1xyXG4gICBiMk1hbmlmb2xkUG9pbnQuYjJNYW5pZm9sZFBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fbG9jYWxQb2ludCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2lkID0gbmV3IGIyQ29udGFjdElEKCk7XHJcbiAgIH07XHJcbiAgIGIyTWFuaWZvbGRQb2ludC5wcm90b3R5cGUuYjJNYW5pZm9sZFBvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLlJlc2V0KCk7XHJcbiAgIH1cclxuICAgYjJNYW5pZm9sZFBvaW50LnByb3RvdHlwZS5SZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2xvY2FsUG9pbnQuU2V0WmVybygpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsSW1wdWxzZSA9IDAuMDtcclxuICAgICAgdGhpcy5tX3RhbmdlbnRJbXB1bHNlID0gMC4wO1xyXG4gICAgICB0aGlzLm1faWQua2V5ID0gMDtcclxuICAgfVxyXG4gICBiMk1hbmlmb2xkUG9pbnQucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgIHRoaXMubV9sb2NhbFBvaW50LlNldFYobS5tX2xvY2FsUG9pbnQpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsSW1wdWxzZSA9IG0ubV9ub3JtYWxJbXB1bHNlO1xyXG4gICAgICB0aGlzLm1fdGFuZ2VudEltcHVsc2UgPSBtLm1fdGFuZ2VudEltcHVsc2U7XHJcbiAgICAgIHRoaXMubV9pZC5TZXQobS5tX2lkKTtcclxuICAgfVxyXG4gICBiMlBvaW50LmIyUG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMucCA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJQb2ludC5wcm90b3R5cGUuU3VwcG9ydCA9IGZ1bmN0aW9uICh4ZiwgdlgsIHZZKSB7XHJcbiAgICAgIGlmICh2WCA9PT0gdW5kZWZpbmVkKSB2WCA9IDA7XHJcbiAgICAgIGlmICh2WSA9PT0gdW5kZWZpbmVkKSB2WSA9IDA7XHJcbiAgICAgIHJldHVybiB0aGlzLnA7XHJcbiAgIH1cclxuICAgYjJQb2ludC5wcm90b3R5cGUuR2V0Rmlyc3RWZXJ0ZXggPSBmdW5jdGlvbiAoeGYpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucDtcclxuICAgfVxyXG4gICBiMlJheUNhc3RJbnB1dC5iMlJheUNhc3RJbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5wMiA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJSYXlDYXN0SW5wdXQucHJvdG90eXBlLmIyUmF5Q2FzdElucHV0ID0gZnVuY3Rpb24gKHAxLCBwMiwgbWF4RnJhY3Rpb24pIHtcclxuICAgICAgaWYgKHAxID09PSB1bmRlZmluZWQpIHAxID0gbnVsbDtcclxuICAgICAgaWYgKHAyID09PSB1bmRlZmluZWQpIHAyID0gbnVsbDtcclxuICAgICAgaWYgKG1heEZyYWN0aW9uID09PSB1bmRlZmluZWQpIG1heEZyYWN0aW9uID0gMTtcclxuICAgICAgaWYgKHAxKSB0aGlzLnAxLlNldFYocDEpO1xyXG4gICAgICBpZiAocDIpIHRoaXMucDIuU2V0VihwMik7XHJcbiAgICAgIHRoaXMubWF4RnJhY3Rpb24gPSBtYXhGcmFjdGlvbjtcclxuICAgfVxyXG4gICBiMlJheUNhc3RPdXRwdXQuYjJSYXlDYXN0T3V0cHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJTZWdtZW50LmIyU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5wMiA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJTZWdtZW50LnByb3RvdHlwZS5UZXN0U2VnbWVudCA9IGZ1bmN0aW9uIChsYW1iZGEsIG5vcm1hbCwgc2VnbWVudCwgbWF4TGFtYmRhKSB7XHJcbiAgICAgIGlmIChtYXhMYW1iZGEgPT09IHVuZGVmaW5lZCkgbWF4TGFtYmRhID0gMDtcclxuICAgICAgdmFyIHMgPSBzZWdtZW50LnAxO1xyXG4gICAgICB2YXIgclggPSBzZWdtZW50LnAyLnggLSBzLng7XHJcbiAgICAgIHZhciByWSA9IHNlZ21lbnQucDIueSAtIHMueTtcclxuICAgICAgdmFyIGRYID0gdGhpcy5wMi54IC0gdGhpcy5wMS54O1xyXG4gICAgICB2YXIgZFkgPSB0aGlzLnAyLnkgLSB0aGlzLnAxLnk7XHJcbiAgICAgIHZhciBuWCA9IGRZO1xyXG4gICAgICB2YXIgblkgPSAoLWRYKTtcclxuICAgICAgdmFyIGtfc2xvcCA9IDEwMC4wICogTnVtYmVyLk1JTl9WQUxVRTtcclxuICAgICAgdmFyIGRlbm9tID0gKC0oclggKiBuWCArIHJZICogblkpKTtcclxuICAgICAgaWYgKGRlbm9tID4ga19zbG9wKSB7XHJcbiAgICAgICAgIHZhciBiWCA9IHMueCAtIHRoaXMucDEueDtcclxuICAgICAgICAgdmFyIGJZID0gcy55IC0gdGhpcy5wMS55O1xyXG4gICAgICAgICB2YXIgYSA9IChiWCAqIG5YICsgYlkgKiBuWSk7XHJcbiAgICAgICAgIGlmICgwLjAgPD0gYSAmJiBhIDw9IG1heExhbWJkYSAqIGRlbm9tKSB7XHJcbiAgICAgICAgICAgIHZhciBtdTIgPSAoLXJYICogYlkpICsgclkgKiBiWDtcclxuICAgICAgICAgICAgaWYgKCgta19zbG9wICogZGVub20pIDw9IG11MiAmJiBtdTIgPD0gZGVub20gKiAoMS4wICsga19zbG9wKSkge1xyXG4gICAgICAgICAgICAgICBhIC89IGRlbm9tO1xyXG4gICAgICAgICAgICAgICB2YXIgbkxlbiA9IE1hdGguc3FydChuWCAqIG5YICsgblkgKiBuWSk7XHJcbiAgICAgICAgICAgICAgIG5YIC89IG5MZW47XHJcbiAgICAgICAgICAgICAgIG5ZIC89IG5MZW47XHJcbiAgICAgICAgICAgICAgIGxhbWJkYVswXSA9IGE7XHJcbiAgICAgICAgICAgICAgIG5vcm1hbC5TZXQoblgsIG5ZKTtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgfVxyXG4gICBiMlNlZ21lbnQucHJvdG90eXBlLkV4dGVuZCA9IGZ1bmN0aW9uIChhYWJiKSB7XHJcbiAgICAgIHRoaXMuRXh0ZW5kRm9yd2FyZChhYWJiKTtcclxuICAgICAgdGhpcy5FeHRlbmRCYWNrd2FyZChhYWJiKTtcclxuICAgfVxyXG4gICBiMlNlZ21lbnQucHJvdG90eXBlLkV4dGVuZEZvcndhcmQgPSBmdW5jdGlvbiAoYWFiYikge1xyXG4gICAgICB2YXIgZFggPSB0aGlzLnAyLnggLSB0aGlzLnAxLng7XHJcbiAgICAgIHZhciBkWSA9IHRoaXMucDIueSAtIHRoaXMucDEueTtcclxuICAgICAgdmFyIGxhbWJkYSA9IE1hdGgubWluKGRYID4gMCA/IChhYWJiLnVwcGVyQm91bmQueCAtIHRoaXMucDEueCkgLyBkWCA6IGRYIDwgMCA/IChhYWJiLmxvd2VyQm91bmQueCAtIHRoaXMucDEueCkgLyBkWCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgICAgZFkgPiAwID8gKGFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5wMS55KSAvIGRZIDogZFkgPCAwID8gKGFhYmIubG93ZXJCb3VuZC55IC0gdGhpcy5wMS55KSAvIGRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgdGhpcy5wMi54ID0gdGhpcy5wMS54ICsgZFggKiBsYW1iZGE7XHJcbiAgICAgIHRoaXMucDIueSA9IHRoaXMucDEueSArIGRZICogbGFtYmRhO1xyXG4gICB9XHJcbiAgIGIyU2VnbWVudC5wcm90b3R5cGUuRXh0ZW5kQmFja3dhcmQgPSBmdW5jdGlvbiAoYWFiYikge1xyXG4gICAgICB2YXIgZFggPSAoLXRoaXMucDIueCkgKyB0aGlzLnAxLng7XHJcbiAgICAgIHZhciBkWSA9ICgtdGhpcy5wMi55KSArIHRoaXMucDEueTtcclxuICAgICAgdmFyIGxhbWJkYSA9IE1hdGgubWluKGRYID4gMCA/IChhYWJiLnVwcGVyQm91bmQueCAtIHRoaXMucDIueCkgLyBkWCA6IGRYIDwgMCA/IChhYWJiLmxvd2VyQm91bmQueCAtIHRoaXMucDIueCkgLyBkWCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcclxuICAgICAgZFkgPiAwID8gKGFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5wMi55KSAvIGRZIDogZFkgPCAwID8gKGFhYmIubG93ZXJCb3VuZC55IC0gdGhpcy5wMi55KSAvIGRZIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgdGhpcy5wMS54ID0gdGhpcy5wMi54ICsgZFggKiBsYW1iZGE7XHJcbiAgICAgIHRoaXMucDEueSA9IHRoaXMucDIueSArIGRZICogbGFtYmRhO1xyXG4gICB9XHJcbiAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fbG9jYWxQb2ludCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2F4aXMgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGNhY2hlLCBwcm94eUEsIHRyYW5zZm9ybUEsIHByb3h5QiwgdHJhbnNmb3JtQikge1xyXG4gICAgICB0aGlzLm1fcHJveHlBID0gcHJveHlBO1xyXG4gICAgICB0aGlzLm1fcHJveHlCID0gcHJveHlCO1xyXG4gICAgICB2YXIgY291bnQgPSBwYXJzZUludChjYWNoZS5jb3VudCk7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMCA8IGNvdW50ICYmIGNvdW50IDwgMyk7XHJcbiAgICAgIHZhciBsb2NhbFBvaW50QTtcclxuICAgICAgdmFyIGxvY2FsUG9pbnRBMTtcclxuICAgICAgdmFyIGxvY2FsUG9pbnRBMjtcclxuICAgICAgdmFyIGxvY2FsUG9pbnRCO1xyXG4gICAgICB2YXIgbG9jYWxQb2ludEIxO1xyXG4gICAgICB2YXIgbG9jYWxQb2ludEIyO1xyXG4gICAgICB2YXIgcG9pbnRBWCA9IDA7XHJcbiAgICAgIHZhciBwb2ludEFZID0gMDtcclxuICAgICAgdmFyIHBvaW50QlggPSAwO1xyXG4gICAgICB2YXIgcG9pbnRCWSA9IDA7XHJcbiAgICAgIHZhciBub3JtYWxYID0gMDtcclxuICAgICAgdmFyIG5vcm1hbFkgPSAwO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRWZWM7XHJcbiAgICAgIHZhciBzID0gMDtcclxuICAgICAgdmFyIHNnbiA9IDA7XHJcbiAgICAgIGlmIChjb3VudCA9PSAxKSB7XHJcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9wb2ludHM7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhBWzBdKTtcclxuICAgICAgICAgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLkdldFZlcnRleChjYWNoZS5pbmRleEJbMF0pO1xyXG4gICAgICAgICB0VmVjID0gbG9jYWxQb2ludEE7XHJcbiAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1BLlI7XHJcbiAgICAgICAgIHBvaW50QVggPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgICAgIHBvaW50QVkgPSB0cmFuc2Zvcm1BLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgICAgIHRWZWMgPSBsb2NhbFBvaW50QjtcclxuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcclxuICAgICAgICAgcG9pbnRCWCA9IHRyYW5zZm9ybUIucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgcG9pbnRCWSA9IHRyYW5zZm9ybUIucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgICAgdGhpcy5tX2F4aXMueCA9IHBvaW50QlggLSBwb2ludEFYO1xyXG4gICAgICAgICB0aGlzLm1fYXhpcy55ID0gcG9pbnRCWSAtIHBvaW50QVk7XHJcbiAgICAgICAgIHRoaXMubV9heGlzLk5vcm1hbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGNhY2hlLmluZGV4QlswXSA9PSBjYWNoZS5pbmRleEJbMV0pIHtcclxuICAgICAgICAgdGhpcy5tX3R5cGUgPSBiMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VBO1xyXG4gICAgICAgICBsb2NhbFBvaW50QTEgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMF0pO1xyXG4gICAgICAgICBsb2NhbFBvaW50QTIgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMV0pO1xyXG4gICAgICAgICBsb2NhbFBvaW50QiA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XHJcbiAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50LnggPSAwLjUgKiAobG9jYWxQb2ludEExLnggKyBsb2NhbFBvaW50QTIueCk7XHJcbiAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50LnkgPSAwLjUgKiAobG9jYWxQb2ludEExLnkgKyBsb2NhbFBvaW50QTIueSk7XHJcbiAgICAgICAgIHRoaXMubV9heGlzID0gYjJNYXRoLkNyb3NzVkYoYjJNYXRoLlN1YnRyYWN0VlYobG9jYWxQb2ludEEyLCBsb2NhbFBvaW50QTEpLCAxLjApO1xyXG4gICAgICAgICB0aGlzLm1fYXhpcy5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgdFZlYyA9IHRoaXMubV9heGlzO1xyXG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xyXG4gICAgICAgICBub3JtYWxYID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcclxuICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgIHRWZWMgPSB0aGlzLm1fbG9jYWxQb2ludDtcclxuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcclxuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgcG9pbnRBWSA9IHRyYW5zZm9ybUEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgICAgdFZlYyA9IGxvY2FsUG9pbnRCO1xyXG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xyXG4gICAgICAgICBwb2ludEJYID0gdHJhbnNmb3JtQi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICAgICBwb2ludEJZID0gdHJhbnNmb3JtQi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICAgICBzID0gKHBvaW50QlggLSBwb2ludEFYKSAqIG5vcm1hbFggKyAocG9pbnRCWSAtIHBvaW50QVkpICogbm9ybWFsWTtcclxuICAgICAgICAgaWYgKHMgPCAwLjApIHtcclxuICAgICAgICAgICAgdGhpcy5tX2F4aXMuTmVnYXRpdmVTZWxmKCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChjYWNoZS5pbmRleEFbMF0gPT0gY2FjaGUuaW5kZXhBWzBdKSB7XHJcbiAgICAgICAgIHRoaXMubV90eXBlID0gYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQjtcclxuICAgICAgICAgbG9jYWxQb2ludEIxID0gdGhpcy5tX3Byb3h5Qi5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzBdKTtcclxuICAgICAgICAgbG9jYWxQb2ludEIyID0gdGhpcy5tX3Byb3h5Qi5HZXRWZXJ0ZXgoY2FjaGUuaW5kZXhCWzFdKTtcclxuICAgICAgICAgbG9jYWxQb2ludEEgPSB0aGlzLm1fcHJveHlBLkdldFZlcnRleChjYWNoZS5pbmRleEFbMF0pO1xyXG4gICAgICAgICB0aGlzLm1fbG9jYWxQb2ludC54ID0gMC41ICogKGxvY2FsUG9pbnRCMS54ICsgbG9jYWxQb2ludEIyLngpO1xyXG4gICAgICAgICB0aGlzLm1fbG9jYWxQb2ludC55ID0gMC41ICogKGxvY2FsUG9pbnRCMS55ICsgbG9jYWxQb2ludEIyLnkpO1xyXG4gICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRCMiwgbG9jYWxQb2ludEIxKSwgMS4wKTtcclxuICAgICAgICAgdGhpcy5tX2F4aXMuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgIHRWZWMgPSB0aGlzLm1fYXhpcztcclxuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcclxuICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgIG5vcm1hbFkgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xyXG4gICAgICAgICB0VmVjID0gdGhpcy5tX2xvY2FsUG9pbnQ7XHJcbiAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1CLlI7XHJcbiAgICAgICAgIHBvaW50QlggPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgICAgIHRWZWMgPSBsb2NhbFBvaW50QTtcclxuICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcclxuICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgcG9pbnRBWSA9IHRyYW5zZm9ybUEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgICAgcyA9IChwb2ludEFYIC0gcG9pbnRCWCkgKiBub3JtYWxYICsgKHBvaW50QVkgLSBwb2ludEJZKSAqIG5vcm1hbFk7XHJcbiAgICAgICAgIGlmIChzIDwgMC4wKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9heGlzLk5lZ2F0aXZlU2VsZigpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRBMSA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVswXSk7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRBMiA9IHRoaXMubV9wcm94eUEuR2V0VmVydGV4KGNhY2hlLmluZGV4QVsxXSk7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRCMSA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlswXSk7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRCMiA9IHRoaXMubV9wcm94eUIuR2V0VmVydGV4KGNhY2hlLmluZGV4QlsxXSk7XHJcbiAgICAgICAgIHZhciBwQSA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUEsIGxvY2FsUG9pbnRBKTtcclxuICAgICAgICAgdmFyIGRBID0gYjJNYXRoLk11bE1WKHRyYW5zZm9ybUEuUiwgYjJNYXRoLlN1YnRyYWN0VlYobG9jYWxQb2ludEEyLCBsb2NhbFBvaW50QTEpKTtcclxuICAgICAgICAgdmFyIHBCID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQiwgbG9jYWxQb2ludEIpO1xyXG4gICAgICAgICB2YXIgZEIgPSBiMk1hdGguTXVsTVYodHJhbnNmb3JtQi5SLCBiMk1hdGguU3VidHJhY3RWVihsb2NhbFBvaW50QjIsIGxvY2FsUG9pbnRCMSkpO1xyXG4gICAgICAgICB2YXIgYSA9IGRBLnggKiBkQS54ICsgZEEueSAqIGRBLnk7XHJcbiAgICAgICAgIHZhciBlID0gZEIueCAqIGRCLnggKyBkQi55ICogZEIueTtcclxuICAgICAgICAgdmFyIHIgPSBiMk1hdGguU3VidHJhY3RWVihkQiwgZEEpO1xyXG4gICAgICAgICB2YXIgYyA9IGRBLnggKiByLnggKyBkQS55ICogci55O1xyXG4gICAgICAgICB2YXIgZiA9IGRCLnggKiByLnggKyBkQi55ICogci55O1xyXG4gICAgICAgICB2YXIgYiA9IGRBLnggKiBkQi54ICsgZEEueSAqIGRCLnk7XHJcbiAgICAgICAgIHZhciBkZW5vbSA9IGEgKiBlIC0gYiAqIGI7XHJcbiAgICAgICAgIHMgPSAwLjA7XHJcbiAgICAgICAgIGlmIChkZW5vbSAhPSAwLjApIHtcclxuICAgICAgICAgICAgcyA9IGIyTWF0aC5DbGFtcCgoYiAqIGYgLSBjICogZSkgLyBkZW5vbSwgMC4wLCAxLjApO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciB0ID0gKGIgKiBzICsgZikgLyBlO1xyXG4gICAgICAgICBpZiAodCA8IDAuMCkge1xyXG4gICAgICAgICAgICB0ID0gMC4wO1xyXG4gICAgICAgICAgICBzID0gYjJNYXRoLkNsYW1wKChiIC0gYykgLyBhLCAwLjAsIDEuMCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgbG9jYWxQb2ludEEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRBLnggPSBsb2NhbFBvaW50QTEueCArIHMgKiAobG9jYWxQb2ludEEyLnggLSBsb2NhbFBvaW50QTEueCk7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRBLnkgPSBsb2NhbFBvaW50QTEueSArIHMgKiAobG9jYWxQb2ludEEyLnkgLSBsb2NhbFBvaW50QTEueSk7XHJcbiAgICAgICAgIGxvY2FsUG9pbnRCID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICAgICBsb2NhbFBvaW50Qi54ID0gbG9jYWxQb2ludEIxLnggKyBzICogKGxvY2FsUG9pbnRCMi54IC0gbG9jYWxQb2ludEIxLngpO1xyXG4gICAgICAgICBsb2NhbFBvaW50Qi55ID0gbG9jYWxQb2ludEIxLnkgKyBzICogKGxvY2FsUG9pbnRCMi55IC0gbG9jYWxQb2ludEIxLnkpO1xyXG4gICAgICAgICBpZiAocyA9PSAwLjAgfHwgcyA9PSAxLjApIHtcclxuICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBiMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VCO1xyXG4gICAgICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRCMiwgbG9jYWxQb2ludEIxKSwgMS4wKTtcclxuICAgICAgICAgICAgdGhpcy5tX2F4aXMuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbFBvaW50ID0gbG9jYWxQb2ludEI7XHJcbiAgICAgICAgICAgIHRWZWMgPSB0aGlzLm1fYXhpcztcclxuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUIuUjtcclxuICAgICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIG5vcm1hbFkgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xyXG4gICAgICAgICAgICB0VmVjID0gdGhpcy5tX2xvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgIHRNYXQgPSB0cmFuc2Zvcm1CLlI7XHJcbiAgICAgICAgICAgIHBvaW50QlggPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgIHBvaW50QlkgPSB0cmFuc2Zvcm1CLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgIHRWZWMgPSBsb2NhbFBvaW50QTtcclxuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcclxuICAgICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgICAgcG9pbnRBWSA9IHRyYW5zZm9ybUEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgICAgICAgc2duID0gKHBvaW50QVggLSBwb2ludEJYKSAqIG5vcm1hbFggKyAocG9pbnRBWSAtIHBvaW50QlkpICogbm9ybWFsWTtcclxuICAgICAgICAgICAgaWYgKHMgPCAwLjApIHtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2F4aXMuTmVnYXRpdmVTZWxmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tX3R5cGUgPSBiMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VBO1xyXG4gICAgICAgICAgICB0aGlzLm1fYXhpcyA9IGIyTWF0aC5Dcm9zc1ZGKGIyTWF0aC5TdWJ0cmFjdFZWKGxvY2FsUG9pbnRBMiwgbG9jYWxQb2ludEExKSwgMS4wKTtcclxuICAgICAgICAgICAgdGhpcy5tX2xvY2FsUG9pbnQgPSBsb2NhbFBvaW50QTtcclxuICAgICAgICAgICAgdFZlYyA9IHRoaXMubV9heGlzO1xyXG4gICAgICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQS5SO1xyXG4gICAgICAgICAgICBub3JtYWxYID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcclxuICAgICAgICAgICAgbm9ybWFsWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIHRWZWMgPSB0aGlzLm1fbG9jYWxQb2ludDtcclxuICAgICAgICAgICAgdE1hdCA9IHRyYW5zZm9ybUEuUjtcclxuICAgICAgICAgICAgcG9pbnRBWCA9IHRyYW5zZm9ybUEucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgICAgcG9pbnRBWSA9IHRyYW5zZm9ybUEucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgICAgICAgdFZlYyA9IGxvY2FsUG9pbnRCO1xyXG4gICAgICAgICAgICB0TWF0ID0gdHJhbnNmb3JtQi5SO1xyXG4gICAgICAgICAgICBwb2ludEJYID0gdHJhbnNmb3JtQi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICAgICAgICBwb2ludEJZID0gdHJhbnNmb3JtQi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICAgICAgICBzZ24gPSAocG9pbnRCWCAtIHBvaW50QVgpICogbm9ybWFsWCArIChwb2ludEJZIC0gcG9pbnRBWSkgKiBub3JtYWxZO1xyXG4gICAgICAgICAgICBpZiAocyA8IDAuMCkge1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fYXhpcy5OZWdhdGl2ZVNlbGYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMlNlcGFyYXRpb25GdW5jdGlvbi5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAodHJhbnNmb3JtQSwgdHJhbnNmb3JtQikge1xyXG4gICAgICB2YXIgYXhpc0E7XHJcbiAgICAgIHZhciBheGlzQjtcclxuICAgICAgdmFyIGxvY2FsUG9pbnRBO1xyXG4gICAgICB2YXIgbG9jYWxQb2ludEI7XHJcbiAgICAgIHZhciBwb2ludEE7XHJcbiAgICAgIHZhciBwb2ludEI7XHJcbiAgICAgIHZhciBzZXBlcmF0aW9uID0gMDtcclxuICAgICAgdmFyIG5vcm1hbDtcclxuICAgICAgc3dpdGNoICh0aGlzLm1fdHlwZSkge1xyXG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfcG9pbnRzOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4aXNBID0gYjJNYXRoLk11bFRNVih0cmFuc2Zvcm1BLlIsIHRoaXMubV9heGlzKTtcclxuICAgICAgICAgICAgYXhpc0IgPSBiMk1hdGguTXVsVE1WKHRyYW5zZm9ybUIuUiwgdGhpcy5tX2F4aXMuR2V0TmVnYXRpdmUoKSk7XHJcbiAgICAgICAgICAgIGxvY2FsUG9pbnRBID0gdGhpcy5tX3Byb3h5QS5HZXRTdXBwb3J0VmVydGV4KGF4aXNBKTtcclxuICAgICAgICAgICAgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLkdldFN1cHBvcnRWZXJ0ZXgoYXhpc0IpO1xyXG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBsb2NhbFBvaW50QSk7XHJcbiAgICAgICAgICAgIHBvaW50QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIGxvY2FsUG9pbnRCKTtcclxuICAgICAgICAgICAgc2VwZXJhdGlvbiA9IChwb2ludEIueCAtIHBvaW50QS54KSAqIHRoaXMubV9heGlzLnggKyAocG9pbnRCLnkgLSBwb2ludEEueSkgKiB0aGlzLm1fYXhpcy55O1xyXG4gICAgICAgICAgICByZXR1cm4gc2VwZXJhdGlvbjtcclxuICAgICAgICAgfVxyXG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfZmFjZUE6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgbm9ybWFsID0gYjJNYXRoLk11bE1WKHRyYW5zZm9ybUEuUiwgdGhpcy5tX2F4aXMpO1xyXG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCB0aGlzLm1fbG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIGF4aXNCID0gYjJNYXRoLk11bFRNVih0cmFuc2Zvcm1CLlIsIG5vcm1hbC5HZXROZWdhdGl2ZSgpKTtcclxuICAgICAgICAgICAgbG9jYWxQb2ludEIgPSB0aGlzLm1fcHJveHlCLkdldFN1cHBvcnRWZXJ0ZXgoYXhpc0IpO1xyXG4gICAgICAgICAgICBwb2ludEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCBsb2NhbFBvaW50Qik7XHJcbiAgICAgICAgICAgIHNlcGVyYXRpb24gPSAocG9pbnRCLnggLSBwb2ludEEueCkgKiBub3JtYWwueCArIChwb2ludEIueSAtIHBvaW50QS55KSAqIG5vcm1hbC55O1xyXG4gICAgICAgICAgICByZXR1cm4gc2VwZXJhdGlvbjtcclxuICAgICAgICAgfVxyXG4gICAgICBjYXNlIGIyU2VwYXJhdGlvbkZ1bmN0aW9uLmVfZmFjZUI6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgbm9ybWFsID0gYjJNYXRoLk11bE1WKHRyYW5zZm9ybUIuUiwgdGhpcy5tX2F4aXMpO1xyXG4gICAgICAgICAgICBwb2ludEIgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCB0aGlzLm1fbG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIGF4aXNBID0gYjJNYXRoLk11bFRNVih0cmFuc2Zvcm1BLlIsIG5vcm1hbC5HZXROZWdhdGl2ZSgpKTtcclxuICAgICAgICAgICAgbG9jYWxQb2ludEEgPSB0aGlzLm1fcHJveHlBLkdldFN1cHBvcnRWZXJ0ZXgoYXhpc0EpO1xyXG4gICAgICAgICAgICBwb2ludEEgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCBsb2NhbFBvaW50QSk7XHJcbiAgICAgICAgICAgIHNlcGVyYXRpb24gPSAocG9pbnRBLnggLSBwb2ludEIueCkgKiBub3JtYWwueCArIChwb2ludEEueSAtIHBvaW50Qi55KSAqIG5vcm1hbC55O1xyXG4gICAgICAgICAgICByZXR1cm4gc2VwZXJhdGlvbjtcclxuICAgICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgcmV0dXJuIDAuMDtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9wb2ludHMgPSAweDAxO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJTZXBhcmF0aW9uRnVuY3Rpb24uZV9mYWNlQSA9IDB4MDI7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbi5lX2ZhY2VCID0gMHgwNDtcclxuICAgfSk7XHJcbiAgIGIyU2ltcGxleC5iMlNpbXBsZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV92MSA9IG5ldyBiMlNpbXBsZXhWZXJ0ZXgoKTtcclxuICAgICAgdGhpcy5tX3YyID0gbmV3IGIyU2ltcGxleFZlcnRleCgpO1xyXG4gICAgICB0aGlzLm1fdjMgPSBuZXcgYjJTaW1wbGV4VmVydGV4KCk7XHJcbiAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IG5ldyBWZWN0b3IoMyk7XHJcbiAgIH07XHJcbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuYjJTaW1wbGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0gPSB0aGlzLm1fdjE7XHJcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1sxXSA9IHRoaXMubV92MjtcclxuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzJdID0gdGhpcy5tX3YzO1xyXG4gICB9XHJcbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuUmVhZENhY2hlID0gZnVuY3Rpb24gKGNhY2hlLCBwcm94eUEsIHRyYW5zZm9ybUEsIHByb3h5QiwgdHJhbnNmb3JtQikge1xyXG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KDAgPD0gY2FjaGUuY291bnQgJiYgY2FjaGUuY291bnQgPD0gMyk7XHJcbiAgICAgIHZhciB3QUxvY2FsO1xyXG4gICAgICB2YXIgd0JMb2NhbDtcclxuICAgICAgdGhpcy5tX2NvdW50ID0gY2FjaGUuY291bnQ7XHJcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMubV92ZXJ0aWNlcztcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY291bnQ7IGkrKykge1xyXG4gICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICB2LmluZGV4QSA9IGNhY2hlLmluZGV4QVtpXTtcclxuICAgICAgICAgdi5pbmRleEIgPSBjYWNoZS5pbmRleEJbaV07XHJcbiAgICAgICAgIHdBTG9jYWwgPSBwcm94eUEuR2V0VmVydGV4KHYuaW5kZXhBKTtcclxuICAgICAgICAgd0JMb2NhbCA9IHByb3h5Qi5HZXRWZXJ0ZXgodi5pbmRleEIpO1xyXG4gICAgICAgICB2LndBID0gYjJNYXRoLk11bFgodHJhbnNmb3JtQSwgd0FMb2NhbCk7XHJcbiAgICAgICAgIHYud0IgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcclxuICAgICAgICAgdi53ID0gYjJNYXRoLlN1YnRyYWN0VlYodi53Qiwgdi53QSk7XHJcbiAgICAgICAgIHYuYSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9jb3VudCA+IDEpIHtcclxuICAgICAgICAgdmFyIG1ldHJpYzEgPSBjYWNoZS5tZXRyaWM7XHJcbiAgICAgICAgIHZhciBtZXRyaWMyID0gdGhpcy5HZXRNZXRyaWMoKTtcclxuICAgICAgICAgaWYgKG1ldHJpYzIgPCAuNSAqIG1ldHJpYzEgfHwgMi4wICogbWV0cmljMSA8IG1ldHJpYzIgfHwgbWV0cmljMiA8IE51bWJlci5NSU5fVkFMVUUpIHtcclxuICAgICAgICAgICAgdGhpcy5tX2NvdW50ID0gMDtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm1fY291bnQgPT0gMCkge1xyXG4gICAgICAgICB2ID0gdmVydGljZXNbMF07XHJcbiAgICAgICAgIHYuaW5kZXhBID0gMDtcclxuICAgICAgICAgdi5pbmRleEIgPSAwO1xyXG4gICAgICAgICB3QUxvY2FsID0gcHJveHlBLkdldFZlcnRleCgwKTtcclxuICAgICAgICAgd0JMb2NhbCA9IHByb3h5Qi5HZXRWZXJ0ZXgoMCk7XHJcbiAgICAgICAgIHYud0EgPSBiMk1hdGguTXVsWCh0cmFuc2Zvcm1BLCB3QUxvY2FsKTtcclxuICAgICAgICAgdi53QiA9IGIyTWF0aC5NdWxYKHRyYW5zZm9ybUIsIHdCTG9jYWwpO1xyXG4gICAgICAgICB2LncgPSBiMk1hdGguU3VidHJhY3RWVih2LndCLCB2LndBKTtcclxuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuV3JpdGVDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSkge1xyXG4gICAgICBjYWNoZS5tZXRyaWMgPSB0aGlzLkdldE1ldHJpYygpO1xyXG4gICAgICBjYWNoZS5jb3VudCA9IEJveDJELnBhcnNlVUludCh0aGlzLm1fY291bnQpO1xyXG4gICAgICB2YXIgdmVydGljZXMgPSB0aGlzLm1fdmVydGljZXM7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvdW50OyBpKyspIHtcclxuICAgICAgICAgY2FjaGUuaW5kZXhBW2ldID0gQm94MkQucGFyc2VVSW50KHZlcnRpY2VzW2ldLmluZGV4QSk7XHJcbiAgICAgICAgIGNhY2hlLmluZGV4QltpXSA9IEJveDJELnBhcnNlVUludCh2ZXJ0aWNlc1tpXS5pbmRleEIpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5HZXRTZWFyY2hEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICAgcmV0dXJuIHRoaXMubV92MS53LkdldE5lZ2F0aXZlKCk7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZTEyID0gYjJNYXRoLlN1YnRyYWN0VlYodGhpcy5tX3YyLncsIHRoaXMubV92MS53KTtcclxuICAgICAgICAgICAgdmFyIHNnbiA9IGIyTWF0aC5Dcm9zc1ZWKGUxMiwgdGhpcy5tX3YxLncuR2V0TmVnYXRpdmUoKSk7XHJcbiAgICAgICAgICAgIGlmIChzZ24gPiAwLjApIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIGIyTWF0aC5Dcm9zc0ZWKDEuMCwgZTEyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIGIyTWF0aC5Dcm9zc1ZGKGUxMiwgMS4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICByZXR1cm4gbmV3IGIyVmVjMigpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJTaW1wbGV4LnByb3RvdHlwZS5HZXRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgIHJldHVybiBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICAgcmV0dXJuIHRoaXMubV92MS53O1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgIHJldHVybiBuZXcgYjJWZWMyKHRoaXMubV92MS5hICogdGhpcy5tX3YxLncueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLncueCwgdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEudy55ICsgdGhpcy5tX3YyLmEgKiB0aGlzLm1fdjIudy55KTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgIHJldHVybiBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMlNpbXBsZXgucHJvdG90eXBlLkdldFdpdG5lc3NQb2ludHMgPSBmdW5jdGlvbiAocEEsIHBCKSB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5tX2NvdW50KSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgIHBBLlNldFYodGhpcy5tX3YxLndBKTtcclxuICAgICAgICAgcEIuU2V0Vih0aGlzLm1fdjEud0IpO1xyXG4gICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgICBwQS54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLng7XHJcbiAgICAgICAgIHBBLnkgPSB0aGlzLm1fdjEuYSAqIHRoaXMubV92MS53QS55ICsgdGhpcy5tX3YyLmEgKiB0aGlzLm1fdjIud0EueTtcclxuICAgICAgICAgcEIueCA9IHRoaXMubV92MS5hICogdGhpcy5tX3YxLndCLnggKyB0aGlzLm1fdjIuYSAqIHRoaXMubV92Mi53Qi54O1xyXG4gICAgICAgICBwQi55ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0IueSArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndCLnk7XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgIHBCLnggPSBwQS54ID0gdGhpcy5tX3YxLmEgKiB0aGlzLm1fdjEud0EueCArIHRoaXMubV92Mi5hICogdGhpcy5tX3YyLndBLnggKyB0aGlzLm1fdjMuYSAqIHRoaXMubV92My53QS54O1xyXG4gICAgICAgICBwQi55ID0gcEEueSA9IHRoaXMubV92MS5hICogdGhpcy5tX3YxLndBLnkgKyB0aGlzLm1fdjIuYSAqIHRoaXMubV92Mi53QS55ICsgdGhpcy5tX3YzLmEgKiB0aGlzLm1fdjMud0EueTtcclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuR2V0TWV0cmljID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBzd2l0Y2ggKHRoaXMubV9jb3VudCkge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICByZXR1cm4gMC4wO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgIHJldHVybiAwLjA7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICAgcmV0dXJuIGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92MS53LCB0aGlzLm1fdjIudykuTGVuZ3RoKCk7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICAgcmV0dXJuIGIyTWF0aC5Dcm9zc1ZWKGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92Mi53LCB0aGlzLm1fdjEudyksIGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV92My53LCB0aGlzLm1fdjEudykpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgcmV0dXJuIDAuMDtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuU29sdmUyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdzEgPSB0aGlzLm1fdjEudztcclxuICAgICAgdmFyIHcyID0gdGhpcy5tX3YyLnc7XHJcbiAgICAgIHZhciBlMTIgPSBiMk1hdGguU3VidHJhY3RWVih3MiwgdzEpO1xyXG4gICAgICB2YXIgZDEyXzIgPSAoLSh3MS54ICogZTEyLnggKyB3MS55ICogZTEyLnkpKTtcclxuICAgICAgaWYgKGQxMl8yIDw9IDAuMCkge1xyXG4gICAgICAgICB0aGlzLm1fdjEuYSA9IDEuMDtcclxuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMTtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBkMTJfMSA9ICh3Mi54ICogZTEyLnggKyB3Mi55ICogZTEyLnkpO1xyXG4gICAgICBpZiAoZDEyXzEgPD0gMC4wKSB7XHJcbiAgICAgICAgIHRoaXMubV92Mi5hID0gMS4wO1xyXG4gICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xyXG4gICAgICAgICB0aGlzLm1fdjEuU2V0KHRoaXMubV92Mik7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW52X2QxMiA9IDEuMCAvIChkMTJfMSArIGQxMl8yKTtcclxuICAgICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XHJcbiAgICAgIHRoaXMubV92Mi5hID0gZDEyXzIgKiBpbnZfZDEyO1xyXG4gICAgICB0aGlzLm1fY291bnQgPSAyO1xyXG4gICB9XHJcbiAgIGIyU2ltcGxleC5wcm90b3R5cGUuU29sdmUzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdzEgPSB0aGlzLm1fdjEudztcclxuICAgICAgdmFyIHcyID0gdGhpcy5tX3YyLnc7XHJcbiAgICAgIHZhciB3MyA9IHRoaXMubV92My53O1xyXG4gICAgICB2YXIgZTEyID0gYjJNYXRoLlN1YnRyYWN0VlYodzIsIHcxKTtcclxuICAgICAgdmFyIHcxZTEyID0gYjJNYXRoLkRvdCh3MSwgZTEyKTtcclxuICAgICAgdmFyIHcyZTEyID0gYjJNYXRoLkRvdCh3MiwgZTEyKTtcclxuICAgICAgdmFyIGQxMl8xID0gdzJlMTI7XHJcbiAgICAgIHZhciBkMTJfMiA9ICgtdzFlMTIpO1xyXG4gICAgICB2YXIgZTEzID0gYjJNYXRoLlN1YnRyYWN0VlYodzMsIHcxKTtcclxuICAgICAgdmFyIHcxZTEzID0gYjJNYXRoLkRvdCh3MSwgZTEzKTtcclxuICAgICAgdmFyIHczZTEzID0gYjJNYXRoLkRvdCh3MywgZTEzKTtcclxuICAgICAgdmFyIGQxM18xID0gdzNlMTM7XHJcbiAgICAgIHZhciBkMTNfMiA9ICgtdzFlMTMpO1xyXG4gICAgICB2YXIgZTIzID0gYjJNYXRoLlN1YnRyYWN0VlYodzMsIHcyKTtcclxuICAgICAgdmFyIHcyZTIzID0gYjJNYXRoLkRvdCh3MiwgZTIzKTtcclxuICAgICAgdmFyIHczZTIzID0gYjJNYXRoLkRvdCh3MywgZTIzKTtcclxuICAgICAgdmFyIGQyM18xID0gdzNlMjM7XHJcbiAgICAgIHZhciBkMjNfMiA9ICgtdzJlMjMpO1xyXG4gICAgICB2YXIgbjEyMyA9IGIyTWF0aC5Dcm9zc1ZWKGUxMiwgZTEzKTtcclxuICAgICAgdmFyIGQxMjNfMSA9IG4xMjMgKiBiMk1hdGguQ3Jvc3NWVih3MiwgdzMpO1xyXG4gICAgICB2YXIgZDEyM18yID0gbjEyMyAqIGIyTWF0aC5Dcm9zc1ZWKHczLCB3MSk7XHJcbiAgICAgIHZhciBkMTIzXzMgPSBuMTIzICogYjJNYXRoLkNyb3NzVlYodzEsIHcyKTtcclxuICAgICAgaWYgKGQxMl8yIDw9IDAuMCAmJiBkMTNfMiA8PSAwLjApIHtcclxuICAgICAgICAgdGhpcy5tX3YxLmEgPSAxLjA7XHJcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZDEyXzEgPiAwLjAgJiYgZDEyXzIgPiAwLjAgJiYgZDEyM18zIDw9IDAuMCkge1xyXG4gICAgICAgICB2YXIgaW52X2QxMiA9IDEuMCAvIChkMTJfMSArIGQxMl8yKTtcclxuICAgICAgICAgdGhpcy5tX3YxLmEgPSBkMTJfMSAqIGludl9kMTI7XHJcbiAgICAgICAgIHRoaXMubV92Mi5hID0gZDEyXzIgKiBpbnZfZDEyO1xyXG4gICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGQxM18xID4gMC4wICYmIGQxM18yID4gMC4wICYmIGQxMjNfMiA8PSAwLjApIHtcclxuICAgICAgICAgdmFyIGludl9kMTMgPSAxLjAgLyAoZDEzXzEgKyBkMTNfMik7XHJcbiAgICAgICAgIHRoaXMubV92MS5hID0gZDEzXzEgKiBpbnZfZDEzO1xyXG4gICAgICAgICB0aGlzLm1fdjMuYSA9IGQxM18yICogaW52X2QxMztcclxuICAgICAgICAgdGhpcy5tX2NvdW50ID0gMjtcclxuICAgICAgICAgdGhpcy5tX3YyLlNldCh0aGlzLm1fdjMpO1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGQxMl8xIDw9IDAuMCAmJiBkMjNfMiA8PSAwLjApIHtcclxuICAgICAgICAgdGhpcy5tX3YyLmEgPSAxLjA7XHJcbiAgICAgICAgIHRoaXMubV9jb3VudCA9IDE7XHJcbiAgICAgICAgIHRoaXMubV92MS5TZXQodGhpcy5tX3YyKTtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkMTNfMSA8PSAwLjAgJiYgZDIzXzEgPD0gMC4wKSB7XHJcbiAgICAgICAgIHRoaXMubV92My5hID0gMS4wO1xyXG4gICAgICAgICB0aGlzLm1fY291bnQgPSAxO1xyXG4gICAgICAgICB0aGlzLm1fdjEuU2V0KHRoaXMubV92Myk7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZDIzXzEgPiAwLjAgJiYgZDIzXzIgPiAwLjAgJiYgZDEyM18xIDw9IDAuMCkge1xyXG4gICAgICAgICB2YXIgaW52X2QyMyA9IDEuMCAvIChkMjNfMSArIGQyM18yKTtcclxuICAgICAgICAgdGhpcy5tX3YyLmEgPSBkMjNfMSAqIGludl9kMjM7XHJcbiAgICAgICAgIHRoaXMubV92My5hID0gZDIzXzIgKiBpbnZfZDIzO1xyXG4gICAgICAgICB0aGlzLm1fY291bnQgPSAyO1xyXG4gICAgICAgICB0aGlzLm1fdjEuU2V0KHRoaXMubV92Myk7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW52X2QxMjMgPSAxLjAgLyAoZDEyM18xICsgZDEyM18yICsgZDEyM18zKTtcclxuICAgICAgdGhpcy5tX3YxLmEgPSBkMTIzXzEgKiBpbnZfZDEyMztcclxuICAgICAgdGhpcy5tX3YyLmEgPSBkMTIzXzIgKiBpbnZfZDEyMztcclxuICAgICAgdGhpcy5tX3YzLmEgPSBkMTIzXzMgKiBpbnZfZDEyMztcclxuICAgICAgdGhpcy5tX2NvdW50ID0gMztcclxuICAgfVxyXG4gICBiMlNpbXBsZXhDYWNoZS5iMlNpbXBsZXhDYWNoZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5pbmRleEEgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoMyk7XHJcbiAgICAgIHRoaXMuaW5kZXhCID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKDMpO1xyXG4gICB9O1xyXG4gICBiMlNpbXBsZXhWZXJ0ZXguYjJTaW1wbGV4VmVydGV4ID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyU2ltcGxleFZlcnRleC5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgIHRoaXMud0EuU2V0VihvdGhlci53QSk7XHJcbiAgICAgIHRoaXMud0IuU2V0VihvdGhlci53Qik7XHJcbiAgICAgIHRoaXMudy5TZXRWKG90aGVyLncpO1xyXG4gICAgICB0aGlzLmEgPSBvdGhlci5hO1xyXG4gICAgICB0aGlzLmluZGV4QSA9IG90aGVyLmluZGV4QTtcclxuICAgICAgdGhpcy5pbmRleEIgPSBvdGhlci5pbmRleEI7XHJcbiAgIH1cclxuICAgYjJUaW1lT2ZJbXBhY3QuYjJUaW1lT2ZJbXBhY3QgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgYjJUaW1lT2ZJbXBhY3QuVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICsrYjJUaW1lT2ZJbXBhY3QuYjJfdG9pQ2FsbHM7XHJcbiAgICAgIHZhciBwcm94eUEgPSBpbnB1dC5wcm94eUE7XHJcbiAgICAgIHZhciBwcm94eUIgPSBpbnB1dC5wcm94eUI7XHJcbiAgICAgIHZhciBzd2VlcEEgPSBpbnB1dC5zd2VlcEE7XHJcbiAgICAgIHZhciBzd2VlcEIgPSBpbnB1dC5zd2VlcEI7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoc3dlZXBBLnQwID09IHN3ZWVwQi50MCk7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMS4wIC0gc3dlZXBBLnQwID4gTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgIHZhciByYWRpdXMgPSBwcm94eUEubV9yYWRpdXMgKyBwcm94eUIubV9yYWRpdXM7XHJcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBpbnB1dC50b2xlcmFuY2U7XHJcbiAgICAgIHZhciBhbHBoYSA9IDAuMDtcclxuICAgICAgdmFyIGtfbWF4SXRlcmF0aW9ucyA9IDEwMDA7XHJcbiAgICAgIHZhciBpdGVyID0gMDtcclxuICAgICAgdmFyIHRhcmdldCA9IDAuMDtcclxuICAgICAgYjJUaW1lT2ZJbXBhY3Quc19jYWNoZS5jb3VudCA9IDA7XHJcbiAgICAgIGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VJbnB1dC51c2VSYWRpaSA9IGZhbHNlO1xyXG4gICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgIHN3ZWVwQS5HZXRUcmFuc2Zvcm0oYjJUaW1lT2ZJbXBhY3Quc194ZkEsIGFscGhhKTtcclxuICAgICAgICAgc3dlZXBCLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQiwgYWxwaGEpO1xyXG4gICAgICAgICBiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlSW5wdXQucHJveHlBID0gcHJveHlBO1xyXG4gICAgICAgICBiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlSW5wdXQucHJveHlCID0gcHJveHlCO1xyXG4gICAgICAgICBiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlSW5wdXQudHJhbnNmb3JtQSA9IGIyVGltZU9mSW1wYWN0LnNfeGZBO1xyXG4gICAgICAgICBiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlSW5wdXQudHJhbnNmb3JtQiA9IGIyVGltZU9mSW1wYWN0LnNfeGZCO1xyXG4gICAgICAgICBiMkRpc3RhbmNlLkRpc3RhbmNlKGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VPdXRwdXQsIGIyVGltZU9mSW1wYWN0LnNfY2FjaGUsIGIyVGltZU9mSW1wYWN0LnNfZGlzdGFuY2VJbnB1dCk7XHJcbiAgICAgICAgIGlmIChiMlRpbWVPZkltcGFjdC5zX2Rpc3RhbmNlT3V0cHV0LmRpc3RhbmNlIDw9IDAuMCkge1xyXG4gICAgICAgICAgICBhbHBoYSA9IDEuMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYjJUaW1lT2ZJbXBhY3Quc19mY24uSW5pdGlhbGl6ZShiMlRpbWVPZkltcGFjdC5zX2NhY2hlLCBwcm94eUEsIGIyVGltZU9mSW1wYWN0LnNfeGZBLCBwcm94eUIsIGIyVGltZU9mSW1wYWN0LnNfeGZCKTtcclxuICAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBiMlRpbWVPZkltcGFjdC5zX2Zjbi5FdmFsdWF0ZShiMlRpbWVPZkltcGFjdC5zX3hmQSwgYjJUaW1lT2ZJbXBhY3Quc194ZkIpO1xyXG4gICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSAwLjApIHtcclxuICAgICAgICAgICAgYWxwaGEgPSAxLjA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGlmIChpdGVyID09IDApIHtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiByYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgdGFyZ2V0ID0gYjJNYXRoLk1heChyYWRpdXMgLSB0b2xlcmFuY2UsIDAuNzUgKiByYWRpdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0YXJnZXQgPSBiMk1hdGguTWF4KHNlcGFyYXRpb24gLSB0b2xlcmFuY2UsIDAuMDIgKiByYWRpdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKHNlcGFyYXRpb24gLSB0YXJnZXQgPCAwLjUgKiB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZXIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICBhbHBoYSA9IDEuMDtcclxuICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIG5ld0FscGhhID0gYWxwaGE7IHtcclxuICAgICAgICAgICAgdmFyIHgxID0gYWxwaGE7XHJcbiAgICAgICAgICAgIHZhciB4MiA9IDEuMDtcclxuICAgICAgICAgICAgdmFyIGYxID0gc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgc3dlZXBBLkdldFRyYW5zZm9ybShiMlRpbWVPZkltcGFjdC5zX3hmQSwgeDIpO1xyXG4gICAgICAgICAgICBzd2VlcEIuR2V0VHJhbnNmb3JtKGIyVGltZU9mSW1wYWN0LnNfeGZCLCB4Mik7XHJcbiAgICAgICAgICAgIHZhciBmMiA9IGIyVGltZU9mSW1wYWN0LnNfZmNuLkV2YWx1YXRlKGIyVGltZU9mSW1wYWN0LnNfeGZBLCBiMlRpbWVPZkltcGFjdC5zX3hmQik7XHJcbiAgICAgICAgICAgIGlmIChmMiA+PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgYWxwaGEgPSAxLjA7XHJcbiAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb290SXRlckNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ICYgMSkge1xyXG4gICAgICAgICAgICAgICAgICB4ID0geDEgKyAodGFyZ2V0IC0gZjEpICogKHgyIC0geDEpIC8gKGYyIC0gZjEpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICB4ID0gMC41ICogKHgxICsgeDIpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHN3ZWVwQS5HZXRUcmFuc2Zvcm0oYjJUaW1lT2ZJbXBhY3Quc194ZkEsIHgpO1xyXG4gICAgICAgICAgICAgICBzd2VlcEIuR2V0VHJhbnNmb3JtKGIyVGltZU9mSW1wYWN0LnNfeGZCLCB4KTtcclxuICAgICAgICAgICAgICAgdmFyIGYgPSBiMlRpbWVPZkltcGFjdC5zX2Zjbi5FdmFsdWF0ZShiMlRpbWVPZkltcGFjdC5zX3hmQSwgYjJUaW1lT2ZJbXBhY3Quc194ZkIpO1xyXG4gICAgICAgICAgICAgICBpZiAoYjJNYXRoLkFicyhmIC0gdGFyZ2V0KSA8IDAuMDI1ICogdG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0geDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYgKGYgPiB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgeDEgPSB4O1xyXG4gICAgICAgICAgICAgICAgICBmMSA9IGY7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHgyID0geDtcclxuICAgICAgICAgICAgICAgICAgZjIgPSBmO1xyXG4gICAgICAgICAgICAgICB9Kytyb290SXRlckNvdW50O1xyXG4gICAgICAgICAgICAgICArK2IyVGltZU9mSW1wYWN0LmIyX3RvaVJvb3RJdGVycztcclxuICAgICAgICAgICAgICAgaWYgKHJvb3RJdGVyQ291bnQgPT0gNTApIHtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiMlRpbWVPZkltcGFjdC5iMl90b2lNYXhSb290SXRlcnMgPSBiMk1hdGguTWF4KGIyVGltZU9mSW1wYWN0LmIyX3RvaU1heFJvb3RJdGVycywgcm9vdEl0ZXJDb3VudCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKG5ld0FscGhhIDwgKDEuMCArIDEwMC4wICogTnVtYmVyLk1JTl9WQUxVRSkgKiBhbHBoYSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgfVxyXG4gICAgICAgICBhbHBoYSA9IG5ld0FscGhhO1xyXG4gICAgICAgICBpdGVyKys7XHJcbiAgICAgICAgICsrYjJUaW1lT2ZJbXBhY3QuYjJfdG9pSXRlcnM7XHJcbiAgICAgICAgIGlmIChpdGVyID09IGtfbWF4SXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGIyVGltZU9mSW1wYWN0LmIyX3RvaU1heEl0ZXJzID0gYjJNYXRoLk1heChiMlRpbWVPZkltcGFjdC5iMl90b2lNYXhJdGVycywgaXRlcik7XHJcbiAgICAgIHJldHVybiBhbHBoYTtcclxuICAgfVxyXG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaUNhbGxzID0gMDtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaUl0ZXJzID0gMDtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaU1heEl0ZXJzID0gMDtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LmIyX3RvaVJvb3RJdGVycyA9IDA7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5iMl90b2lNYXhSb290SXRlcnMgPSAwO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc19jYWNoZSA9IG5ldyBiMlNpbXBsZXhDYWNoZSgpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZUlucHV0ID0gbmV3IGIyRGlzdGFuY2VJbnB1dCgpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc194ZkEgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LnNfeGZCID0gbmV3IGIyVHJhbnNmb3JtKCk7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5iMlRpbWVPZkltcGFjdC5zX2ZjbiA9IG5ldyBiMlNlcGFyYXRpb25GdW5jdGlvbigpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3Quc19kaXN0YW5jZU91dHB1dCA9IG5ldyBiMkRpc3RhbmNlT3V0cHV0KCk7XHJcbiAgIH0pO1xyXG4gICBiMlRPSUlucHV0LmIyVE9JSW5wdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMucHJveHlBID0gbmV3IGIyRGlzdGFuY2VQcm94eSgpO1xyXG4gICAgICB0aGlzLnByb3h5QiA9IG5ldyBiMkRpc3RhbmNlUHJveHkoKTtcclxuICAgICAgdGhpcy5zd2VlcEEgPSBuZXcgYjJTd2VlcCgpO1xyXG4gICAgICB0aGlzLnN3ZWVwQiA9IG5ldyBiMlN3ZWVwKCk7XHJcbiAgIH07XHJcbiAgIGIyV29ybGRNYW5pZm9sZC5iMldvcmxkTWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV9ub3JtYWwgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyV29ybGRNYW5pZm9sZC5wcm90b3R5cGUuYjJXb3JsZE1hbmlmb2xkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fcG9pbnRzID0gbmV3IFZlY3RvcihiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzOyBpKyspIHtcclxuICAgICAgICAgdGhpcy5tX3BvaW50c1tpXSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyV29ybGRNYW5pZm9sZC5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgeGZBLCByYWRpdXNBLCB4ZkIsIHJhZGl1c0IpIHtcclxuICAgICAgaWYgKHJhZGl1c0EgPT09IHVuZGVmaW5lZCkgcmFkaXVzQSA9IDA7XHJcbiAgICAgIGlmIChyYWRpdXNCID09PSB1bmRlZmluZWQpIHJhZGl1c0IgPSAwO1xyXG4gICAgICBpZiAobWFuaWZvbGQubV9wb2ludENvdW50ID09IDApIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIHRWZWM7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgbm9ybWFsWCA9IDA7XHJcbiAgICAgIHZhciBub3JtYWxZID0gMDtcclxuICAgICAgdmFyIHBsYW5lUG9pbnRYID0gMDtcclxuICAgICAgdmFyIHBsYW5lUG9pbnRZID0gMDtcclxuICAgICAgdmFyIGNsaXBQb2ludFggPSAwO1xyXG4gICAgICB2YXIgY2xpcFBvaW50WSA9IDA7XHJcbiAgICAgIHN3aXRjaCAobWFuaWZvbGQubV90eXBlKSB7XHJcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2NpcmNsZXM6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgdE1hdCA9IHhmQS5SO1xyXG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9sb2NhbFBvaW50O1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRBWCA9IHhmQS5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcclxuICAgICAgICAgICAgdmFyIHBvaW50QVkgPSB4ZkEucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIHRNYXQgPSB4ZkIuUjtcclxuICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fcG9pbnRzWzBdLm1fbG9jYWxQb2ludDtcclxuICAgICAgICAgICAgdmFyIHBvaW50QlggPSB4ZkIucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludEJZID0geGZCLnBvc2l0aW9uLnkgKyB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xyXG4gICAgICAgICAgICB2YXIgZFggPSBwb2ludEJYIC0gcG9pbnRBWDtcclxuICAgICAgICAgICAgdmFyIGRZID0gcG9pbnRCWSAtIHBvaW50QVk7XHJcbiAgICAgICAgICAgIHZhciBkMiA9IGRYICogZFggKyBkWSAqIGRZO1xyXG4gICAgICAgICAgICBpZiAoZDIgPiBOdW1iZXIuTUlOX1ZBTFVFICogTnVtYmVyLk1JTl9WQUxVRSkge1xyXG4gICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkMik7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9IGRYIC8gZDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gZFkgLyBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSAxO1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjQVggPSBwb2ludEFYICsgcmFkaXVzQSAqIHRoaXMubV9ub3JtYWwueDtcclxuICAgICAgICAgICAgdmFyIGNBWSA9IHBvaW50QVkgKyByYWRpdXNBICogdGhpcy5tX25vcm1hbC55O1xyXG4gICAgICAgICAgICB2YXIgY0JYID0gcG9pbnRCWCAtIHJhZGl1c0IgKiB0aGlzLm1fbm9ybWFsLng7XHJcbiAgICAgICAgICAgIHZhciBjQlkgPSBwb2ludEJZIC0gcmFkaXVzQiAqIHRoaXMubV9ub3JtYWwueTtcclxuICAgICAgICAgICAgdGhpcy5tX3BvaW50c1swXS54ID0gMC41ICogKGNBWCArIGNCWCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9wb2ludHNbMF0ueSA9IDAuNSAqIChjQVkgKyBjQlkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIyTWFuaWZvbGQuZV9mYWNlQTpcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICB0TWF0ID0geGZBLlI7XHJcbiAgICAgICAgICAgIHRWZWMgPSBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWw7XHJcbiAgICAgICAgICAgIG5vcm1hbFggPSB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xyXG4gICAgICAgICAgICBub3JtYWxZID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcclxuICAgICAgICAgICAgdE1hdCA9IHhmQS5SO1xyXG4gICAgICAgICAgICB0VmVjID0gbWFuaWZvbGQubV9sb2NhbFBvaW50O1xyXG4gICAgICAgICAgICBwbGFuZVBvaW50WCA9IHhmQS5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcclxuICAgICAgICAgICAgcGxhbmVQb2ludFkgPSB4ZkEucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9IG5vcm1hbFg7XHJcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IG5vcm1hbFk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgICAgIGkgPCBtYW5pZm9sZC5tX3BvaW50Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICB0TWF0ID0geGZCLlI7XHJcbiAgICAgICAgICAgICAgIHRWZWMgPSBtYW5pZm9sZC5tX3BvaW50c1tpXS5tX2xvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFggPSB4ZkIucG9zaXRpb24ueCArIHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFkgPSB4ZkIucG9zaXRpb24ueSArIHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9wb2ludHNbaV0ueCA9IGNsaXBQb2ludFggKyAwLjUgKiAocmFkaXVzQSAtIChjbGlwUG9pbnRYIC0gcGxhbmVQb2ludFgpICogbm9ybWFsWCAtIChjbGlwUG9pbnRZIC0gcGxhbmVQb2ludFkpICogbm9ybWFsWSAtIHJhZGl1c0IpICogbm9ybWFsWDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS55ID0gY2xpcFBvaW50WSArIDAuNSAqIChyYWRpdXNBIC0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiBub3JtYWxYIC0gKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiBub3JtYWxZIC0gcmFkaXVzQikgKiBub3JtYWxZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgYjJNYW5pZm9sZC5lX2ZhY2VCOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIHRNYXQgPSB4ZkIuUjtcclxuICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbDtcclxuICAgICAgICAgICAgbm9ybWFsWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIG5vcm1hbFkgPSB0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55O1xyXG4gICAgICAgICAgICB0TWF0ID0geGZCLlI7XHJcbiAgICAgICAgICAgIHRWZWMgPSBtYW5pZm9sZC5tX2xvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgIHBsYW5lUG9pbnRYID0geGZCLnBvc2l0aW9uLnggKyB0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55O1xyXG4gICAgICAgICAgICBwbGFuZVBvaW50WSA9IHhmQi5wb3NpdGlvbi55ICsgdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcclxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gKC1ub3JtYWxYKTtcclxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gKC1ub3JtYWxZKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDtcclxuICAgICAgICAgICAgaSA8IG1hbmlmb2xkLm1fcG9pbnRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgIHRNYXQgPSB4ZkEuUjtcclxuICAgICAgICAgICAgICAgdFZlYyA9IG1hbmlmb2xkLm1fcG9pbnRzW2ldLm1fbG9jYWxQb2ludDtcclxuICAgICAgICAgICAgICAgY2xpcFBvaW50WCA9IHhmQS5wb3NpdGlvbi54ICsgdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcclxuICAgICAgICAgICAgICAgY2xpcFBvaW50WSA9IHhmQS5wb3NpdGlvbi55ICsgdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcclxuICAgICAgICAgICAgICAgdGhpcy5tX3BvaW50c1tpXS54ID0gY2xpcFBvaW50WCArIDAuNSAqIChyYWRpdXNCIC0gKGNsaXBQb2ludFggLSBwbGFuZVBvaW50WCkgKiBub3JtYWxYIC0gKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiBub3JtYWxZIC0gcmFkaXVzQSkgKiBub3JtYWxYO1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLnkgPSBjbGlwUG9pbnRZICsgMC41ICogKHJhZGl1c0IgLSAoY2xpcFBvaW50WCAtIHBsYW5lUG9pbnRYKSAqIG5vcm1hbFggLSAoY2xpcFBvaW50WSAtIHBsYW5lUG9pbnRZKSAqIG5vcm1hbFkgLSByYWRpdXNBKSAqIG5vcm1hbFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIENsaXBWZXJ0ZXguQ2xpcFZlcnRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy52ID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLmlkID0gbmV3IGIyQ29udGFjdElEKCk7XHJcbiAgIH07XHJcbiAgIENsaXBWZXJ0ZXgucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICB0aGlzLnYuU2V0VihvdGhlci52KTtcclxuICAgICAgdGhpcy5pZC5TZXQob3RoZXIuaWQpO1xyXG4gICB9XHJcbiAgIEZlYXR1cmVzLkZlYXR1cmVzID0gZnVuY3Rpb24gKCkge307XHJcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWF0dXJlcy5wcm90b3R5cGUsICdyZWZlcmVuY2VFZGdlJywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmVyZW5jZUVkZ2U7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWF0dXJlcy5wcm90b3R5cGUsICdyZWZlcmVuY2VFZGdlJywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xyXG4gICAgICAgICB0aGlzLl9yZWZlcmVuY2VFZGdlID0gdmFsdWU7XHJcbiAgICAgICAgIHRoaXMuX21faWQuX2tleSA9ICh0aGlzLl9tX2lkLl9rZXkgJiAweGZmZmZmZjAwKSB8ICh0aGlzLl9yZWZlcmVuY2VFZGdlICYgMHgwMDAwMDBmZik7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWF0dXJlcy5wcm90b3R5cGUsICdpbmNpZGVudEVkZ2UnLCB7XHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICByZXR1cm4gdGhpcy5faW5jaWRlbnRFZGdlO1xyXG4gICAgICB9XHJcbiAgIH0pO1xyXG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAnaW5jaWRlbnRFZGdlJywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xyXG4gICAgICAgICB0aGlzLl9pbmNpZGVudEVkZ2UgPSB2YWx1ZTtcclxuICAgICAgICAgdGhpcy5fbV9pZC5fa2V5ID0gKHRoaXMuX21faWQuX2tleSAmIDB4ZmZmZjAwZmYpIHwgKCh0aGlzLl9pbmNpZGVudEVkZ2UgPDwgOCkgJiAweDAwMDBmZjAwKTtcclxuICAgICAgfVxyXG4gICB9KTtcclxuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZlYXR1cmVzLnByb3RvdHlwZSwgJ2luY2lkZW50VmVydGV4Jywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgcmV0dXJuIHRoaXMuX2luY2lkZW50VmVydGV4O1xyXG4gICAgICB9XHJcbiAgIH0pO1xyXG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVhdHVyZXMucHJvdG90eXBlLCAnaW5jaWRlbnRWZXJ0ZXgnLCB7XHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB2YWx1ZSA9IDA7XHJcbiAgICAgICAgIHRoaXMuX2luY2lkZW50VmVydGV4ID0gdmFsdWU7XHJcbiAgICAgICAgIHRoaXMuX21faWQuX2tleSA9ICh0aGlzLl9tX2lkLl9rZXkgJiAweGZmMDBmZmZmKSB8ICgodGhpcy5faW5jaWRlbnRWZXJ0ZXggPDwgMTYpICYgMHgwMGZmMDAwMCk7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWF0dXJlcy5wcm90b3R5cGUsICdmbGlwJywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgcmV0dXJuIHRoaXMuX2ZsaXA7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZWF0dXJlcy5wcm90b3R5cGUsICdmbGlwJywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSAwO1xyXG4gICAgICAgICB0aGlzLl9mbGlwID0gdmFsdWU7XHJcbiAgICAgICAgIHRoaXMuX21faWQuX2tleSA9ICh0aGlzLl9tX2lkLl9rZXkgJiAweDAwZmZmZmZmKSB8ICgodGhpcy5fZmxpcCA8PCAyNCkgJiAweGZmMDAwMDAwKTtcclxuICAgICAgfVxyXG4gICB9KTtcclxufSkoKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgdmFyIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcclxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxyXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXHJcbiAgICAgIGIyQ2lyY2xlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUsXHJcbiAgICAgIGIyRWRnZUNoYWluRGVmID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZixcclxuICAgICAgYjJFZGdlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZVNoYXBlLFxyXG4gICAgICBiMk1hc3NEYXRhID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhLFxyXG4gICAgICBiMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUsXHJcbiAgICAgIGIyU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUsXHJcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxyXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcclxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxyXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcclxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcclxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxyXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzMsXHJcbiAgICAgIGIyQm9keSA9IEJveDJELkR5bmFtaWNzLmIyQm9keSxcclxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxyXG4gICAgICBiMkNvbnRhY3RGaWx0ZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RGaWx0ZXIsXHJcbiAgICAgIGIyQ29udGFjdEltcHVsc2UgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlLFxyXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxyXG4gICAgICBiMkNvbnRhY3RNYW5hZ2VyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0TWFuYWdlcixcclxuICAgICAgYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyxcclxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxyXG4gICAgICBiMkZpbHRlckRhdGEgPSBCb3gyRC5EeW5hbWljcy5iMkZpbHRlckRhdGEsXHJcbiAgICAgIGIyRml4dHVyZSA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcclxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxyXG4gICAgICBiMklzbGFuZCA9IEJveDJELkR5bmFtaWNzLmIySXNsYW5kLFxyXG4gICAgICBiMlRpbWVTdGVwID0gQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCxcclxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQsXHJcbiAgICAgIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXHJcbiAgICAgIGIyQm91bmQgPSBCb3gyRC5Db2xsaXNpb24uYjJCb3VuZCxcclxuICAgICAgYjJCb3VuZFZhbHVlcyA9IEJveDJELkNvbGxpc2lvbi5iMkJvdW5kVmFsdWVzLFxyXG4gICAgICBiMkNvbGxpc2lvbiA9IEJveDJELkNvbGxpc2lvbi5iMkNvbGxpc2lvbixcclxuICAgICAgYjJDb250YWN0SUQgPSBCb3gyRC5Db2xsaXNpb24uYjJDb250YWN0SUQsXHJcbiAgICAgIGIyQ29udGFjdFBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdFBvaW50LFxyXG4gICAgICBiMkRpc3RhbmNlID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2UsXHJcbiAgICAgIGIyRGlzdGFuY2VJbnB1dCA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlSW5wdXQsXHJcbiAgICAgIGIyRGlzdGFuY2VPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZU91dHB1dCxcclxuICAgICAgYjJEaXN0YW5jZVByb3h5ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VQcm94eSxcclxuICAgICAgYjJEeW5hbWljVHJlZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlLFxyXG4gICAgICBiMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlQnJvYWRQaGFzZSxcclxuICAgICAgYjJEeW5hbWljVHJlZU5vZGUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZU5vZGUsXHJcbiAgICAgIGIyRHluYW1pY1RyZWVQYWlyID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVQYWlyLFxyXG4gICAgICBiMk1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyTWFuaWZvbGQsXHJcbiAgICAgIGIyTWFuaWZvbGRQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkUG9pbnQsXHJcbiAgICAgIGIyUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJQb2ludCxcclxuICAgICAgYjJSYXlDYXN0SW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0SW5wdXQsXHJcbiAgICAgIGIyUmF5Q2FzdE91dHB1dCA9IEJveDJELkNvbGxpc2lvbi5iMlJheUNhc3RPdXRwdXQsXHJcbiAgICAgIGIyU2VnbWVudCA9IEJveDJELkNvbGxpc2lvbi5iMlNlZ21lbnQsXHJcbiAgICAgIGIyU2VwYXJhdGlvbkZ1bmN0aW9uID0gQm94MkQuQ29sbGlzaW9uLmIyU2VwYXJhdGlvbkZ1bmN0aW9uLFxyXG4gICAgICBiMlNpbXBsZXggPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4LFxyXG4gICAgICBiMlNpbXBsZXhDYWNoZSA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhDYWNoZSxcclxuICAgICAgYjJTaW1wbGV4VmVydGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleFZlcnRleCxcclxuICAgICAgYjJUaW1lT2ZJbXBhY3QgPSBCb3gyRC5Db2xsaXNpb24uYjJUaW1lT2ZJbXBhY3QsXHJcbiAgICAgIGIyVE9JSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJUT0lJbnB1dCxcclxuICAgICAgYjJXb3JsZE1hbmlmb2xkID0gQm94MkQuQ29sbGlzaW9uLmIyV29ybGRNYW5pZm9sZCxcclxuICAgICAgQ2xpcFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5DbGlwVmVydGV4LFxyXG4gICAgICBGZWF0dXJlcyA9IEJveDJELkNvbGxpc2lvbi5GZWF0dXJlcyxcclxuICAgICAgSUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uSUJyb2FkUGhhc2U7XHJcblxyXG4gICBCb3gyRC5pbmhlcml0KGIyQ2lyY2xlU2hhcGUsIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZSk7XHJcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUucHJvdG90eXBlO1xyXG4gICBiMkNpcmNsZVNoYXBlLmIyQ2lyY2xlU2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5iMlNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMubV9wID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcyA9IG5ldyBiMkNpcmNsZVNoYXBlKCk7XHJcbiAgICAgIHMuU2V0KHRoaXMpO1xyXG4gICAgICByZXR1cm4gcztcclxuICAgfVxyXG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLlNldC5jYWxsKHRoaXMsIG90aGVyKTtcclxuICAgICAgaWYgKEJveDJELmlzKG90aGVyLCBiMkNpcmNsZVNoYXBlKSkge1xyXG4gICAgICAgICB2YXIgb3RoZXIyID0gKG90aGVyIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IG90aGVyIDogbnVsbCk7XHJcbiAgICAgICAgIHRoaXMubV9wLlNldFYob3RoZXIyLm1fcCk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtLCBwKSB7XHJcbiAgICAgIHZhciB0TWF0ID0gdHJhbnNmb3JtLlI7XHJcbiAgICAgIHZhciBkWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3AueCArIHRNYXQuY29sMi54ICogdGhpcy5tX3AueSk7XHJcbiAgICAgIHZhciBkWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3AueCArIHRNYXQuY29sMi55ICogdGhpcy5tX3AueSk7XHJcbiAgICAgIGRYID0gcC54IC0gZFg7XHJcbiAgICAgIGRZID0gcC55IC0gZFk7XHJcbiAgICAgIHJldHVybiAoZFggKiBkWCArIGRZICogZFkpIDw9IHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xyXG4gICB9XHJcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCwgdHJhbnNmb3JtKSB7XHJcbiAgICAgIHZhciB0TWF0ID0gdHJhbnNmb3JtLlI7XHJcbiAgICAgIHZhciBwb3NpdGlvblggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9wLnkpO1xyXG4gICAgICB2YXIgcG9zaXRpb25ZID0gdHJhbnNmb3JtLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0aGlzLm1fcC54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fcC55KTtcclxuICAgICAgdmFyIHNYID0gaW5wdXQucDEueCAtIHBvc2l0aW9uWDtcclxuICAgICAgdmFyIHNZID0gaW5wdXQucDEueSAtIHBvc2l0aW9uWTtcclxuICAgICAgdmFyIGIgPSAoc1ggKiBzWCArIHNZICogc1kpIC0gdGhpcy5tX3JhZGl1cyAqIHRoaXMubV9yYWRpdXM7XHJcbiAgICAgIHZhciByWCA9IGlucHV0LnAyLnggLSBpbnB1dC5wMS54O1xyXG4gICAgICB2YXIgclkgPSBpbnB1dC5wMi55IC0gaW5wdXQucDEueTtcclxuICAgICAgdmFyIGMgPSAoc1ggKiByWCArIHNZICogclkpO1xyXG4gICAgICB2YXIgcnIgPSAoclggKiByWCArIHJZICogclkpO1xyXG4gICAgICB2YXIgc2lnbWEgPSBjICogYyAtIHJyICogYjtcclxuICAgICAgaWYgKHNpZ21hIDwgMC4wIHx8IHJyIDwgTnVtYmVyLk1JTl9WQUxVRSkge1xyXG4gICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGEgPSAoLShjICsgTWF0aC5zcXJ0KHNpZ21hKSkpO1xyXG4gICAgICBpZiAoMC4wIDw9IGEgJiYgYSA8PSBpbnB1dC5tYXhGcmFjdGlvbiAqIHJyKSB7XHJcbiAgICAgICAgIGEgLz0gcnI7XHJcbiAgICAgICAgIG91dHB1dC5mcmFjdGlvbiA9IGE7XHJcbiAgICAgICAgIG91dHB1dC5ub3JtYWwueCA9IHNYICsgYSAqIHJYO1xyXG4gICAgICAgICBvdXRwdXQubm9ybWFsLnkgPSBzWSArIGEgKiByWTtcclxuICAgICAgICAgb3V0cHV0Lm5vcm1hbC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICB9XHJcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHRyYW5zZm9ybSkge1xyXG4gICAgICB2YXIgdE1hdCA9IHRyYW5zZm9ybS5SO1xyXG4gICAgICB2YXIgcFggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9wLnkpO1xyXG4gICAgICB2YXIgcFkgPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV9wLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV9wLnkpO1xyXG4gICAgICBhYWJiLmxvd2VyQm91bmQuU2V0KHBYIC0gdGhpcy5tX3JhZGl1cywgcFkgLSB0aGlzLm1fcmFkaXVzKTtcclxuICAgICAgYWFiYi51cHBlckJvdW5kLlNldChwWCArIHRoaXMubV9yYWRpdXMsIHBZICsgdGhpcy5tX3JhZGl1cyk7XHJcbiAgIH1cclxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuQ29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcclxuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XHJcbiAgICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogYjJTZXR0aW5ncy5iMl9waSAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzO1xyXG4gICAgICBtYXNzRGF0YS5jZW50ZXIuU2V0Vih0aGlzLm1fcCk7XHJcbiAgICAgIG1hc3NEYXRhLkkgPSBtYXNzRGF0YS5tYXNzICogKDAuNSAqIHRoaXMubV9yYWRpdXMgKiB0aGlzLm1fcmFkaXVzICsgKHRoaXMubV9wLnggKiB0aGlzLm1fcC54ICsgdGhpcy5tX3AueSAqIHRoaXMubV9wLnkpKTtcclxuICAgfVxyXG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5Db21wdXRlU3VibWVyZ2VkQXJlYSA9IGZ1bmN0aW9uIChub3JtYWwsIG9mZnNldCwgeGYsIGMpIHtcclxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSBvZmZzZXQgPSAwO1xyXG4gICAgICB2YXIgcCA9IGIyTWF0aC5NdWxYKHhmLCB0aGlzLm1fcCk7XHJcbiAgICAgIHZhciBsID0gKC0oYjJNYXRoLkRvdChub3JtYWwsIHApIC0gb2Zmc2V0KSk7XHJcbiAgICAgIGlmIChsIDwgKC10aGlzLm1fcmFkaXVzKSArIE51bWJlci5NSU5fVkFMVUUpIHtcclxuICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGwgPiB0aGlzLm1fcmFkaXVzKSB7XHJcbiAgICAgICAgIGMuU2V0VihwKTtcclxuICAgICAgICAgcmV0dXJuIE1hdGguUEkgKiB0aGlzLm1fcmFkaXVzICogdGhpcy5tX3JhZGl1cztcclxuICAgICAgfVxyXG4gICAgICB2YXIgcjIgPSB0aGlzLm1fcmFkaXVzICogdGhpcy5tX3JhZGl1cztcclxuICAgICAgdmFyIGwyID0gbCAqIGw7XHJcbiAgICAgIHZhciBhcmVhID0gcjIgKiAoTWF0aC5hc2luKGwgLyB0aGlzLm1fcmFkaXVzKSArIE1hdGguUEkgLyAyKSArIGwgKiBNYXRoLnNxcnQocjIgLSBsMik7XHJcbiAgICAgIHZhciBjb20gPSAoLTIgLyAzICogTWF0aC5wb3cocjIgLSBsMiwgMS41KSAvIGFyZWEpO1xyXG4gICAgICBjLnggPSBwLnggKyBub3JtYWwueCAqIGNvbTtcclxuICAgICAgYy55ID0gcC55ICsgbm9ybWFsLnkgKiBjb207XHJcbiAgICAgIHJldHVybiBhcmVhO1xyXG4gICB9XHJcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkdldExvY2FsUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fcDtcclxuICAgfVxyXG4gICBiMkNpcmNsZVNoYXBlLnByb3RvdHlwZS5TZXRMb2NhbFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgIHRoaXMubV9wLlNldFYocG9zaXRpb24pO1xyXG4gICB9XHJcbiAgIGIyQ2lyY2xlU2hhcGUucHJvdG90eXBlLkdldFJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9yYWRpdXM7XHJcbiAgIH1cclxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuU2V0UmFkaXVzID0gZnVuY3Rpb24gKHJhZGl1cykge1xyXG4gICAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHJhZGl1cyA9IDA7XHJcbiAgICAgIHRoaXMubV9yYWRpdXMgPSByYWRpdXM7XHJcbiAgIH1cclxuICAgYjJDaXJjbGVTaGFwZS5wcm90b3R5cGUuYjJDaXJjbGVTaGFwZSA9IGZ1bmN0aW9uIChyYWRpdXMpIHtcclxuICAgICAgaWYgKHJhZGl1cyA9PT0gdW5kZWZpbmVkKSByYWRpdXMgPSAwO1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJTaGFwZS5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9jaXJjbGVTaGFwZTtcclxuICAgICAgdGhpcy5tX3JhZGl1cyA9IHJhZGl1cztcclxuICAgfVxyXG4gICBiMkVkZ2VDaGFpbkRlZi5iMkVkZ2VDaGFpbkRlZiA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMkVkZ2VDaGFpbkRlZi5wcm90b3R5cGUuYjJFZGdlQ2hhaW5EZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLmlzQUxvb3AgPSB0cnVlO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gW107XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMkVkZ2VTaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUucHJvdG90eXBlO1xyXG4gICBiMkVkZ2VTaGFwZS5iMkVkZ2VTaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5zX3N1cHBvcnRWZWMgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV92MSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX3YyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fY29yZVYxID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fY29yZVYyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fZGlyZWN0aW9uID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fY29ybmVyRGlyMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2Nvcm5lckRpcjIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtLCBwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB0cmFuc2Zvcm0pIHtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciByWCA9IGlucHV0LnAyLnggLSBpbnB1dC5wMS54O1xyXG4gICAgICB2YXIgclkgPSBpbnB1dC5wMi55IC0gaW5wdXQucDEueTtcclxuICAgICAgdE1hdCA9IHRyYW5zZm9ybS5SO1xyXG4gICAgICB2YXIgdjFYID0gdHJhbnNmb3JtLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0aGlzLm1fdjEueCArIHRNYXQuY29sMi54ICogdGhpcy5tX3YxLnkpO1xyXG4gICAgICB2YXIgdjFZID0gdHJhbnNmb3JtLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0aGlzLm1fdjEueCArIHRNYXQuY29sMi55ICogdGhpcy5tX3YxLnkpO1xyXG4gICAgICB2YXIgblggPSB0cmFuc2Zvcm0ucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV92Mi54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fdjIueSkgLSB2MVk7XHJcbiAgICAgIHZhciBuWSA9ICgtKHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YyLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92Mi55KSAtIHYxWCkpO1xyXG4gICAgICB2YXIga19zbG9wID0gMTAwLjAgKiBOdW1iZXIuTUlOX1ZBTFVFO1xyXG4gICAgICB2YXIgZGVub20gPSAoLShyWCAqIG5YICsgclkgKiBuWSkpO1xyXG4gICAgICBpZiAoZGVub20gPiBrX3Nsb3ApIHtcclxuICAgICAgICAgdmFyIGJYID0gaW5wdXQucDEueCAtIHYxWDtcclxuICAgICAgICAgdmFyIGJZID0gaW5wdXQucDEueSAtIHYxWTtcclxuICAgICAgICAgdmFyIGEgPSAoYlggKiBuWCArIGJZICogblkpO1xyXG4gICAgICAgICBpZiAoMC4wIDw9IGEgJiYgYSA8PSBpbnB1dC5tYXhGcmFjdGlvbiAqIGRlbm9tKSB7XHJcbiAgICAgICAgICAgIHZhciBtdTIgPSAoLXJYICogYlkpICsgclkgKiBiWDtcclxuICAgICAgICAgICAgaWYgKCgta19zbG9wICogZGVub20pIDw9IG11MiAmJiBtdTIgPD0gZGVub20gKiAoMS4wICsga19zbG9wKSkge1xyXG4gICAgICAgICAgICAgICBhIC89IGRlbm9tO1xyXG4gICAgICAgICAgICAgICBvdXRwdXQuZnJhY3Rpb24gPSBhO1xyXG4gICAgICAgICAgICAgICB2YXIgbkxlbiA9IE1hdGguc3FydChuWCAqIG5YICsgblkgKiBuWSk7XHJcbiAgICAgICAgICAgICAgIG91dHB1dC5ub3JtYWwueCA9IG5YIC8gbkxlbjtcclxuICAgICAgICAgICAgICAgb3V0cHV0Lm5vcm1hbC55ID0gblkgLyBuTGVuO1xyXG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICB9XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5Db21wdXRlQUFCQiA9IGZ1bmN0aW9uIChhYWJiLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgdmFyIHRNYXQgPSB0cmFuc2Zvcm0uUjtcclxuICAgICAgdmFyIHYxWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YxLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92MS55KTtcclxuICAgICAgdmFyIHYxWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3YxLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV92MS55KTtcclxuICAgICAgdmFyIHYyWCA9IHRyYW5zZm9ybS5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdGhpcy5tX3YyLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV92Mi55KTtcclxuICAgICAgdmFyIHYyWSA9IHRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX3YyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV92Mi55KTtcclxuICAgICAgaWYgKHYxWCA8IHYyWCkge1xyXG4gICAgICAgICBhYWJiLmxvd2VyQm91bmQueCA9IHYxWDtcclxuICAgICAgICAgYWFiYi51cHBlckJvdW5kLnggPSB2Mlg7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gdjJYO1xyXG4gICAgICAgICBhYWJiLnVwcGVyQm91bmQueCA9IHYxWDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodjFZIDwgdjJZKSB7XHJcbiAgICAgICAgIGFhYmIubG93ZXJCb3VuZC55ID0gdjFZO1xyXG4gICAgICAgICBhYWJiLnVwcGVyQm91bmQueSA9IHYyWTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgYWFiYi5sb3dlckJvdW5kLnkgPSB2Mlk7XHJcbiAgICAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdjFZO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XHJcbiAgICAgIGlmIChkZW5zaXR5ID09PSB1bmRlZmluZWQpIGRlbnNpdHkgPSAwO1xyXG4gICAgICBtYXNzRGF0YS5tYXNzID0gMDtcclxuICAgICAgbWFzc0RhdGEuY2VudGVyLlNldFYodGhpcy5tX3YxKTtcclxuICAgICAgbWFzc0RhdGEuSSA9IDA7XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhID0gZnVuY3Rpb24gKG5vcm1hbCwgb2Zmc2V0LCB4ZiwgYykge1xyXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XHJcbiAgICAgIHZhciB2MCA9IG5ldyBiMlZlYzIobm9ybWFsLnggKiBvZmZzZXQsIG5vcm1hbC55ICogb2Zmc2V0KTtcclxuICAgICAgdmFyIHYxID0gYjJNYXRoLk11bFgoeGYsIHRoaXMubV92MSk7XHJcbiAgICAgIHZhciB2MiA9IGIyTWF0aC5NdWxYKHhmLCB0aGlzLm1fdjIpO1xyXG4gICAgICB2YXIgZDEgPSBiMk1hdGguRG90KG5vcm1hbCwgdjEpIC0gb2Zmc2V0O1xyXG4gICAgICB2YXIgZDIgPSBiMk1hdGguRG90KG5vcm1hbCwgdjIpIC0gb2Zmc2V0O1xyXG4gICAgICBpZiAoZDEgPiAwKSB7XHJcbiAgICAgICAgIGlmIChkMiA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHYxLnggPSAoLWQyIC8gKGQxIC0gZDIpICogdjEueCkgKyBkMSAvIChkMSAtIGQyKSAqIHYyLng7XHJcbiAgICAgICAgICAgIHYxLnkgPSAoLWQyIC8gKGQxIC0gZDIpICogdjEueSkgKyBkMSAvIChkMSAtIGQyKSAqIHYyLnk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgaWYgKGQyID4gMCkge1xyXG4gICAgICAgICAgICB2Mi54ID0gKC1kMiAvIChkMSAtIGQyKSAqIHYxLngpICsgZDEgLyAoZDEgLSBkMikgKiB2Mi54O1xyXG4gICAgICAgICAgICB2Mi55ID0gKC1kMiAvIChkMSAtIGQyKSAqIHYxLnkpICsgZDEgLyAoZDEgLSBkMikgKiB2Mi55O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge31cclxuICAgICAgfVxyXG4gICAgICBjLnggPSAodjAueCArIHYxLnggKyB2Mi54KSAvIDM7XHJcbiAgICAgIGMueSA9ICh2MC55ICsgdjEueSArIHYyLnkpIC8gMztcclxuICAgICAgcmV0dXJuIDAuNSAqICgodjEueCAtIHYwLngpICogKHYyLnkgLSB2MC55KSAtICh2MS55IC0gdjAueSkgKiAodjIueCAtIHYwLngpKTtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2xlbmd0aDtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0VmVydGV4MSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV92MTtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0VmVydGV4MiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV92MjtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0Q29yZVZlcnRleDEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fY29yZVYxO1xyXG4gICB9XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5HZXRDb3JlVmVydGV4MiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9jb3JlVjI7XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldE5vcm1hbFZlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ub3JtYWw7XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldERpcmVjdGlvblZlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9kaXJlY3Rpb247XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldENvcm5lcjFWZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fY29ybmVyRGlyMTtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuR2V0Q29ybmVyMlZlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9jb3JuZXJEaXIyO1xyXG4gICB9XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5Db3JuZXIxSXNDb252ZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fY29ybmVyQ29udmV4MTtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuQ29ybmVyMklzQ29udmV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2Nvcm5lckNvbnZleDI7XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldEZpcnN0VmVydGV4ID0gZnVuY3Rpb24gKHhmKSB7XHJcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoeGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9jb3JlVjEueCArIHRNYXQuY29sMi54ICogdGhpcy5tX2NvcmVWMS55KSwgeGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRoaXMubV9jb3JlVjEueCArIHRNYXQuY29sMi55ICogdGhpcy5tX2NvcmVWMS55KSk7XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLkdldE5leHRFZGdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX25leHRFZGdlO1xyXG4gICB9XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5HZXRQcmV2RWRnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9wcmV2RWRnZTtcclxuICAgfVxyXG4gICBiMkVkZ2VTaGFwZS5wcm90b3R5cGUuU3VwcG9ydCA9IGZ1bmN0aW9uICh4ZiwgZFgsIGRZKSB7XHJcbiAgICAgIGlmIChkWCA9PT0gdW5kZWZpbmVkKSBkWCA9IDA7XHJcbiAgICAgIGlmIChkWSA9PT0gdW5kZWZpbmVkKSBkWSA9IDA7XHJcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcclxuICAgICAgdmFyIHYxWCA9IHhmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0aGlzLm1fY29yZVYxLnggKyB0TWF0LmNvbDIueCAqIHRoaXMubV9jb3JlVjEueSk7XHJcbiAgICAgIHZhciB2MVkgPSB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdGhpcy5tX2NvcmVWMS54ICsgdE1hdC5jb2wyLnkgKiB0aGlzLm1fY29yZVYxLnkpO1xyXG4gICAgICB2YXIgdjJYID0geGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRoaXMubV9jb3JlVjIueCArIHRNYXQuY29sMi54ICogdGhpcy5tX2NvcmVWMi55KTtcclxuICAgICAgdmFyIHYyWSA9IHhmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0aGlzLm1fY29yZVYyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubV9jb3JlVjIueSk7XHJcbiAgICAgIGlmICgodjFYICogZFggKyB2MVkgKiBkWSkgPiAodjJYICogZFggKyB2MlkgKiBkWSkpIHtcclxuICAgICAgICAgdGhpcy5zX3N1cHBvcnRWZWMueCA9IHYxWDtcclxuICAgICAgICAgdGhpcy5zX3N1cHBvcnRWZWMueSA9IHYxWTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5zX3N1cHBvcnRWZWMueCA9IHYyWDtcclxuICAgICAgICAgdGhpcy5zX3N1cHBvcnRWZWMueSA9IHYyWTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5zX3N1cHBvcnRWZWM7XHJcbiAgIH1cclxuICAgYjJFZGdlU2hhcGUucHJvdG90eXBlLmIyRWRnZVNoYXBlID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJTaGFwZS5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV9lZGdlU2hhcGU7XHJcbiAgICAgIHRoaXMubV9wcmV2RWRnZSA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9uZXh0RWRnZSA9IG51bGw7XHJcbiAgICAgIHRoaXMubV92MSA9IHYxO1xyXG4gICAgICB0aGlzLm1fdjIgPSB2MjtcclxuICAgICAgdGhpcy5tX2RpcmVjdGlvbi5TZXQodGhpcy5tX3YyLnggLSB0aGlzLm1fdjEueCwgdGhpcy5tX3YyLnkgLSB0aGlzLm1fdjEueSk7XHJcbiAgICAgIHRoaXMubV9sZW5ndGggPSB0aGlzLm1fZGlyZWN0aW9uLk5vcm1hbGl6ZSgpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsLlNldCh0aGlzLm1fZGlyZWN0aW9uLnksICgtdGhpcy5tX2RpcmVjdGlvbi54KSk7XHJcbiAgICAgIHRoaXMubV9jb3JlVjEuU2V0KCgtYjJTZXR0aW5ncy5iMl90b2lTbG9wICogKHRoaXMubV9ub3JtYWwueCAtIHRoaXMubV9kaXJlY3Rpb24ueCkpICsgdGhpcy5tX3YxLngsICgtYjJTZXR0aW5ncy5iMl90b2lTbG9wICogKHRoaXMubV9ub3JtYWwueSAtIHRoaXMubV9kaXJlY3Rpb24ueSkpICsgdGhpcy5tX3YxLnkpO1xyXG4gICAgICB0aGlzLm1fY29yZVYyLlNldCgoLWIyU2V0dGluZ3MuYjJfdG9pU2xvcCAqICh0aGlzLm1fbm9ybWFsLnggKyB0aGlzLm1fZGlyZWN0aW9uLngpKSArIHRoaXMubV92Mi54LCAoLWIyU2V0dGluZ3MuYjJfdG9pU2xvcCAqICh0aGlzLm1fbm9ybWFsLnkgKyB0aGlzLm1fZGlyZWN0aW9uLnkpKSArIHRoaXMubV92Mi55KTtcclxuICAgICAgdGhpcy5tX2Nvcm5lckRpcjEgPSB0aGlzLm1fbm9ybWFsO1xyXG4gICAgICB0aGlzLm1fY29ybmVyRGlyMi5TZXQoKC10aGlzLm1fbm9ybWFsLngpLCAoLXRoaXMubV9ub3JtYWwueSkpO1xyXG4gICB9XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5TZXRQcmV2RWRnZSA9IGZ1bmN0aW9uIChlZGdlLCBjb3JlLCBjb3JuZXJEaXIsIGNvbnZleCkge1xyXG4gICAgICB0aGlzLm1fcHJldkVkZ2UgPSBlZGdlO1xyXG4gICAgICB0aGlzLm1fY29yZVYxID0gY29yZTtcclxuICAgICAgdGhpcy5tX2Nvcm5lckRpcjEgPSBjb3JuZXJEaXI7XHJcbiAgICAgIHRoaXMubV9jb3JuZXJDb252ZXgxID0gY29udmV4O1xyXG4gICB9XHJcbiAgIGIyRWRnZVNoYXBlLnByb3RvdHlwZS5TZXROZXh0RWRnZSA9IGZ1bmN0aW9uIChlZGdlLCBjb3JlLCBjb3JuZXJEaXIsIGNvbnZleCkge1xyXG4gICAgICB0aGlzLm1fbmV4dEVkZ2UgPSBlZGdlO1xyXG4gICAgICB0aGlzLm1fY29yZVYyID0gY29yZTtcclxuICAgICAgdGhpcy5tX2Nvcm5lckRpcjIgPSBjb3JuZXJEaXI7XHJcbiAgICAgIHRoaXMubV9jb3JuZXJDb252ZXgyID0gY29udmV4O1xyXG4gICB9XHJcbiAgIGIyTWFzc0RhdGEuYjJNYXNzRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tYXNzID0gMC4wO1xyXG4gICAgICB0aGlzLmNlbnRlciA9IG5ldyBiMlZlYzIoMCwgMCk7XHJcbiAgICAgIHRoaXMuSSA9IDAuMDtcclxuICAgfTtcclxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlnb25TaGFwZSwgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlKTtcclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUucHJvdG90eXBlO1xyXG4gICBiMlBvbHlnb25TaGFwZS5iMlBvbHlnb25TaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmIyU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XHJcbiAgICAgIHMuU2V0KHRoaXMpO1xyXG4gICAgICByZXR1cm4gcztcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgIHRoaXMuX19zdXBlci5TZXQuY2FsbCh0aGlzLCBvdGhlcik7XHJcbiAgICAgIGlmIChCb3gyRC5pcyhvdGhlciwgYjJQb2x5Z29uU2hhcGUpKSB7XHJcbiAgICAgICAgIHZhciBvdGhlcjIgPSAob3RoZXIgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IG90aGVyIDogbnVsbCk7XHJcbiAgICAgICAgIHRoaXMubV9jZW50cm9pZC5TZXRWKG90aGVyMi5tX2NlbnRyb2lkKTtcclxuICAgICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gb3RoZXIyLm1fdmVydGV4Q291bnQ7XHJcbiAgICAgICAgIHRoaXMuUmVzZXJ2ZSh0aGlzLm1fdmVydGV4Q291bnQpO1xyXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc1tpXS5TZXRWKG90aGVyMi5tX3ZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0uU2V0VihvdGhlcjIubV9ub3JtYWxzW2ldKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlNldEFzQXJyYXkgPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50KSB7XHJcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XHJcbiAgICAgIHZhciB2ID0gbmV3IFZlY3RvcigpO1xyXG4gICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgIHRWZWM7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCB2ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICB0VmVjID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgIHYucHVzaCh0VmVjKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLlNldEFzVmVjdG9yKHYsIHZlcnRleENvdW50KTtcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5Bc0FycmF5ID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xyXG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XHJcbiAgICAgIHBvbHlnb25TaGFwZS5TZXRBc0FycmF5KHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlNldEFzVmVjdG9yID0gZnVuY3Rpb24gKHZlcnRpY2VzLCB2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xyXG4gICAgICBpZiAodmVydGV4Q291bnQgPT0gMCkgdmVydGV4Q291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoMiA8PSB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgIHRoaXMubV92ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xyXG4gICAgICB0aGlzLlJlc2VydmUodmVydGV4Q291bnQpO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7IGkrKykge1xyXG4gICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0uU2V0Vih2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciBpMSA9IHBhcnNlSW50KGkpO1xyXG4gICAgICAgICB2YXIgaTIgPSBwYXJzZUludChpICsgMSA8IHRoaXMubV92ZXJ0ZXhDb3VudCA/IGkgKyAxIDogMCk7XHJcbiAgICAgICAgIHZhciBlZGdlID0gYjJNYXRoLlN1YnRyYWN0VlYodGhpcy5tX3ZlcnRpY2VzW2kyXSwgdGhpcy5tX3ZlcnRpY2VzW2kxXSk7XHJcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZWRnZS5MZW5ndGhTcXVhcmVkKCkgPiBOdW1iZXIuTUlOX1ZBTFVFKTtcclxuICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0uU2V0VihiMk1hdGguQ3Jvc3NWRihlZGdlLCAxLjApKTtcclxuICAgICAgICAgdGhpcy5tX25vcm1hbHNbaV0uTm9ybWFsaXplKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX2NlbnRyb2lkID0gYjJQb2x5Z29uU2hhcGUuQ29tcHV0ZUNlbnRyb2lkKHRoaXMubV92ZXJ0aWNlcywgdGhpcy5tX3ZlcnRleENvdW50KTtcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5Bc1ZlY3RvciA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGV4Q291bnQpIHtcclxuICAgICAgaWYgKHZlcnRleENvdW50ID09PSB1bmRlZmluZWQpIHZlcnRleENvdW50ID0gMDtcclxuICAgICAgdmFyIHBvbHlnb25TaGFwZSA9IG5ldyBiMlBvbHlnb25TaGFwZSgpO1xyXG4gICAgICBwb2x5Z29uU2hhcGUuU2V0QXNWZWN0b3IodmVydGljZXMsIHZlcnRleENvdW50KTtcclxuICAgICAgcmV0dXJuIHBvbHlnb25TaGFwZTtcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuU2V0QXNCb3ggPSBmdW5jdGlvbiAoaHgsIGh5KSB7XHJcbiAgICAgIGlmIChoeCA9PT0gdW5kZWZpbmVkKSBoeCA9IDA7XHJcbiAgICAgIGlmIChoeSA9PT0gdW5kZWZpbmVkKSBoeSA9IDA7XHJcbiAgICAgIHRoaXMubV92ZXJ0ZXhDb3VudCA9IDQ7XHJcbiAgICAgIHRoaXMuUmVzZXJ2ZSg0KTtcclxuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzBdLlNldCgoLWh4KSwgKC1oeSkpO1xyXG4gICAgICB0aGlzLm1fdmVydGljZXNbMV0uU2V0KGh4LCAoLWh5KSk7XHJcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1syXS5TZXQoaHgsIGh5KTtcclxuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzNdLlNldCgoLWh4KSwgaHkpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsc1swXS5TZXQoMC4wLCAoLTEuMCkpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsc1sxXS5TZXQoMS4wLCAwLjApO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsc1syXS5TZXQoMC4wLCAxLjApO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsc1szXS5TZXQoKC0xLjApLCAwLjApO1xyXG4gICAgICB0aGlzLm1fY2VudHJvaWQuU2V0WmVybygpO1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLkFzQm94ID0gZnVuY3Rpb24gKGh4LCBoeSkge1xyXG4gICAgICBpZiAoaHggPT09IHVuZGVmaW5lZCkgaHggPSAwO1xyXG4gICAgICBpZiAoaHkgPT09IHVuZGVmaW5lZCkgaHkgPSAwO1xyXG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XHJcbiAgICAgIHBvbHlnb25TaGFwZS5TZXRBc0JveChoeCwgaHkpO1xyXG4gICAgICByZXR1cm4gcG9seWdvblNoYXBlO1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5TZXRBc09yaWVudGVkQm94ID0gZnVuY3Rpb24gKGh4LCBoeSwgY2VudGVyLCBhbmdsZSkge1xyXG4gICAgICBpZiAoaHggPT09IHVuZGVmaW5lZCkgaHggPSAwO1xyXG4gICAgICBpZiAoaHkgPT09IHVuZGVmaW5lZCkgaHkgPSAwO1xyXG4gICAgICBpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIGNlbnRlciA9IG51bGw7XHJcbiAgICAgIGlmIChhbmdsZSA9PT0gdW5kZWZpbmVkKSBhbmdsZSA9IDAuMDtcclxuICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gNDtcclxuICAgICAgdGhpcy5SZXNlcnZlKDQpO1xyXG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0uU2V0KCgtaHgpLCAoLWh5KSk7XHJcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1sxXS5TZXQoaHgsICgtaHkpKTtcclxuICAgICAgdGhpcy5tX3ZlcnRpY2VzWzJdLlNldChoeCwgaHkpO1xyXG4gICAgICB0aGlzLm1fdmVydGljZXNbM10uU2V0KCgtaHgpLCBoeSk7XHJcbiAgICAgIHRoaXMubV9ub3JtYWxzWzBdLlNldCgwLjAsICgtMS4wKSk7XHJcbiAgICAgIHRoaXMubV9ub3JtYWxzWzFdLlNldCgxLjAsIDAuMCk7XHJcbiAgICAgIHRoaXMubV9ub3JtYWxzWzJdLlNldCgwLjAsIDEuMCk7XHJcbiAgICAgIHRoaXMubV9ub3JtYWxzWzNdLlNldCgoLTEuMCksIDAuMCk7XHJcbiAgICAgIHRoaXMubV9jZW50cm9pZCA9IGNlbnRlcjtcclxuICAgICAgdmFyIHhmID0gbmV3IGIyVHJhbnNmb3JtKCk7XHJcbiAgICAgIHhmLnBvc2l0aW9uID0gY2VudGVyO1xyXG4gICAgICB4Zi5SLlNldChhbmdsZSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcclxuICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW2ldID0gYjJNYXRoLk11bFgoeGYsIHRoaXMubV92ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgIHRoaXMubV9ub3JtYWxzW2ldID0gYjJNYXRoLk11bE1WKHhmLlIsIHRoaXMubV9ub3JtYWxzW2ldKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLkFzT3JpZW50ZWRCb3ggPSBmdW5jdGlvbiAoaHgsIGh5LCBjZW50ZXIsIGFuZ2xlKSB7XHJcbiAgICAgIGlmIChoeCA9PT0gdW5kZWZpbmVkKSBoeCA9IDA7XHJcbiAgICAgIGlmIChoeSA9PT0gdW5kZWZpbmVkKSBoeSA9IDA7XHJcbiAgICAgIGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgY2VudGVyID0gbnVsbDtcclxuICAgICAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIGFuZ2xlID0gMC4wO1xyXG4gICAgICB2YXIgcG9seWdvblNoYXBlID0gbmV3IGIyUG9seWdvblNoYXBlKCk7XHJcbiAgICAgIHBvbHlnb25TaGFwZS5TZXRBc09yaWVudGVkQm94KGh4LCBoeSwgY2VudGVyLCBhbmdsZSk7XHJcbiAgICAgIHJldHVybiBwb2x5Z29uU2hhcGU7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlNldEFzRWRnZSA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgICAgdGhpcy5tX3ZlcnRleENvdW50ID0gMjtcclxuICAgICAgdGhpcy5SZXNlcnZlKDIpO1xyXG4gICAgICB0aGlzLm1fdmVydGljZXNbMF0uU2V0Vih2MSk7XHJcbiAgICAgIHRoaXMubV92ZXJ0aWNlc1sxXS5TZXRWKHYyKTtcclxuICAgICAgdGhpcy5tX2NlbnRyb2lkLnggPSAwLjUgKiAodjEueCArIHYyLngpO1xyXG4gICAgICB0aGlzLm1fY2VudHJvaWQueSA9IDAuNSAqICh2MS55ICsgdjIueSk7XHJcbiAgICAgIHRoaXMubV9ub3JtYWxzWzBdID0gYjJNYXRoLkNyb3NzVkYoYjJNYXRoLlN1YnRyYWN0VlYodjIsIHYxKSwgMS4wKTtcclxuICAgICAgdGhpcy5tX25vcm1hbHNbMF0uTm9ybWFsaXplKCk7XHJcbiAgICAgIHRoaXMubV9ub3JtYWxzWzFdLnggPSAoLXRoaXMubV9ub3JtYWxzWzBdLngpO1xyXG4gICAgICB0aGlzLm1fbm9ybWFsc1sxXS55ID0gKC10aGlzLm1fbm9ybWFsc1swXS55KTtcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5Bc0VkZ2UgPSBmdW5jdGlvbiAodjEsIHYyKSB7XHJcbiAgICAgIHZhciBwb2x5Z29uU2hhcGUgPSBuZXcgYjJQb2x5Z29uU2hhcGUoKTtcclxuICAgICAgcG9seWdvblNoYXBlLlNldEFzRWRnZSh2MSwgdjIpO1xyXG4gICAgICByZXR1cm4gcG9seWdvblNoYXBlO1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5UZXN0UG9pbnQgPSBmdW5jdGlvbiAoeGYsIHApIHtcclxuICAgICAgdmFyIHRWZWM7XHJcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcclxuICAgICAgdmFyIHRYID0gcC54IC0geGYucG9zaXRpb24ueDtcclxuICAgICAgdmFyIHRZID0gcC55IC0geGYucG9zaXRpb24ueTtcclxuICAgICAgdmFyIHBMb2NhbFggPSAodFggKiB0TWF0LmNvbDEueCArIHRZICogdE1hdC5jb2wxLnkpO1xyXG4gICAgICB2YXIgcExvY2FsWSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcclxuICAgICAgICAgdFZlYyA9IHRoaXMubV92ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgdFggPSBwTG9jYWxYIC0gdFZlYy54O1xyXG4gICAgICAgICB0WSA9IHBMb2NhbFkgLSB0VmVjLnk7XHJcbiAgICAgICAgIHRWZWMgPSB0aGlzLm1fbm9ybWFsc1tpXTtcclxuICAgICAgICAgdmFyIGRvdCA9ICh0VmVjLnggKiB0WCArIHRWZWMueSAqIHRZKTtcclxuICAgICAgICAgaWYgKGRvdCA+IDAuMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuUmF5Q2FzdCA9IGZ1bmN0aW9uIChvdXRwdXQsIGlucHV0LCB0cmFuc2Zvcm0pIHtcclxuICAgICAgdmFyIGxvd2VyID0gMC4wO1xyXG4gICAgICB2YXIgdXBwZXIgPSBpbnB1dC5tYXhGcmFjdGlvbjtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIHRZID0gMDtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0VmVjO1xyXG4gICAgICB0WCA9IGlucHV0LnAxLnggLSB0cmFuc2Zvcm0ucG9zaXRpb24ueDtcclxuICAgICAgdFkgPSBpbnB1dC5wMS55IC0gdHJhbnNmb3JtLnBvc2l0aW9uLnk7XHJcbiAgICAgIHRNYXQgPSB0cmFuc2Zvcm0uUjtcclxuICAgICAgdmFyIHAxWCA9ICh0WCAqIHRNYXQuY29sMS54ICsgdFkgKiB0TWF0LmNvbDEueSk7XHJcbiAgICAgIHZhciBwMVkgPSAodFggKiB0TWF0LmNvbDIueCArIHRZICogdE1hdC5jb2wyLnkpO1xyXG4gICAgICB0WCA9IGlucHV0LnAyLnggLSB0cmFuc2Zvcm0ucG9zaXRpb24ueDtcclxuICAgICAgdFkgPSBpbnB1dC5wMi55IC0gdHJhbnNmb3JtLnBvc2l0aW9uLnk7XHJcbiAgICAgIHRNYXQgPSB0cmFuc2Zvcm0uUjtcclxuICAgICAgdmFyIHAyWCA9ICh0WCAqIHRNYXQuY29sMS54ICsgdFkgKiB0TWF0LmNvbDEueSk7XHJcbiAgICAgIHZhciBwMlkgPSAodFggKiB0TWF0LmNvbDIueCArIHRZICogdE1hdC5jb2wyLnkpO1xyXG4gICAgICB2YXIgZFggPSBwMlggLSBwMVg7XHJcbiAgICAgIHZhciBkWSA9IHAyWSAtIHAxWTtcclxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoKC0xKSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcclxuICAgICAgICAgdFZlYyA9IHRoaXMubV92ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgdFggPSB0VmVjLnggLSBwMVg7XHJcbiAgICAgICAgIHRZID0gdFZlYy55IC0gcDFZO1xyXG4gICAgICAgICB0VmVjID0gdGhpcy5tX25vcm1hbHNbaV07XHJcbiAgICAgICAgIHZhciBudW1lcmF0b3IgPSAodFZlYy54ICogdFggKyB0VmVjLnkgKiB0WSk7XHJcbiAgICAgICAgIHZhciBkZW5vbWluYXRvciA9ICh0VmVjLnggKiBkWCArIHRWZWMueSAqIGRZKTtcclxuICAgICAgICAgaWYgKGRlbm9taW5hdG9yID09IDAuMCkge1xyXG4gICAgICAgICAgICBpZiAobnVtZXJhdG9yIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZGVub21pbmF0b3IgPCAwLjAgJiYgbnVtZXJhdG9yIDwgbG93ZXIgKiBkZW5vbWluYXRvcikge1xyXG4gICAgICAgICAgICAgICBsb3dlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGVub21pbmF0b3IgPiAwLjAgJiYgbnVtZXJhdG9yIDwgdXBwZXIgKiBkZW5vbWluYXRvcikge1xyXG4gICAgICAgICAgICAgICB1cHBlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKHVwcGVyIDwgbG93ZXIgLSBOdW1iZXIuTUlOX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgIG91dHB1dC5mcmFjdGlvbiA9IGxvd2VyO1xyXG4gICAgICAgICB0TWF0ID0gdHJhbnNmb3JtLlI7XHJcbiAgICAgICAgIHRWZWMgPSB0aGlzLm1fbm9ybWFsc1tpbmRleF07XHJcbiAgICAgICAgIG91dHB1dC5ub3JtYWwueCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgb3V0cHV0Lm5vcm1hbC55ID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKGFhYmIsIHhmKSB7XHJcbiAgICAgIHZhciB0TWF0ID0geGYuUjtcclxuICAgICAgdmFyIHRWZWMgPSB0aGlzLm1fdmVydGljZXNbMF07XHJcbiAgICAgIHZhciBsb3dlclggPSB4Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICB2YXIgbG93ZXJZID0geGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdmFyIHVwcGVyWCA9IGxvd2VyWDtcclxuICAgICAgdmFyIHVwcGVyWSA9IGxvd2VyWTtcclxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xyXG4gICAgICAgICB0VmVjID0gdGhpcy5tX3ZlcnRpY2VzW2ldO1xyXG4gICAgICAgICB2YXIgdlggPSB4Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICAgICB2YXIgdlkgPSB4Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICAgICBsb3dlclggPSBsb3dlclggPCB2WCA/IGxvd2VyWCA6IHZYO1xyXG4gICAgICAgICBsb3dlclkgPSBsb3dlclkgPCB2WSA/IGxvd2VyWSA6IHZZO1xyXG4gICAgICAgICB1cHBlclggPSB1cHBlclggPiB2WCA/IHVwcGVyWCA6IHZYO1xyXG4gICAgICAgICB1cHBlclkgPSB1cHBlclkgPiB2WSA/IHVwcGVyWSA6IHZZO1xyXG4gICAgICB9XHJcbiAgICAgIGFhYmIubG93ZXJCb3VuZC54ID0gbG93ZXJYIC0gdGhpcy5tX3JhZGl1cztcclxuICAgICAgYWFiYi5sb3dlckJvdW5kLnkgPSBsb3dlclkgLSB0aGlzLm1fcmFkaXVzO1xyXG4gICAgICBhYWJiLnVwcGVyQm91bmQueCA9IHVwcGVyWCArIHRoaXMubV9yYWRpdXM7XHJcbiAgICAgIGFhYmIudXBwZXJCb3VuZC55ID0gdXBwZXJZICsgdGhpcy5tX3JhZGl1cztcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuQ29tcHV0ZU1hc3MgPSBmdW5jdGlvbiAobWFzc0RhdGEsIGRlbnNpdHkpIHtcclxuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XHJcbiAgICAgIGlmICh0aGlzLm1fdmVydGV4Q291bnQgPT0gMikge1xyXG4gICAgICAgICBtYXNzRGF0YS5jZW50ZXIueCA9IDAuNSAqICh0aGlzLm1fdmVydGljZXNbMF0ueCArIHRoaXMubV92ZXJ0aWNlc1sxXS54KTtcclxuICAgICAgICAgbWFzc0RhdGEuY2VudGVyLnkgPSAwLjUgKiAodGhpcy5tX3ZlcnRpY2VzWzBdLnkgKyB0aGlzLm1fdmVydGljZXNbMV0ueSk7XHJcbiAgICAgICAgIG1hc3NEYXRhLm1hc3MgPSAwLjA7XHJcbiAgICAgICAgIG1hc3NEYXRhLkkgPSAwLjA7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY2VudGVyWCA9IDAuMDtcclxuICAgICAgdmFyIGNlbnRlclkgPSAwLjA7XHJcbiAgICAgIHZhciBhcmVhID0gMC4wO1xyXG4gICAgICB2YXIgSSA9IDAuMDtcclxuICAgICAgdmFyIHAxWCA9IDAuMDtcclxuICAgICAgdmFyIHAxWSA9IDAuMDtcclxuICAgICAgdmFyIGtfaW52MyA9IDEuMCAvIDMuMDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fdmVydGV4Q291bnQ7ICsraSkge1xyXG4gICAgICAgICB2YXIgcDIgPSB0aGlzLm1fdmVydGljZXNbaV07XHJcbiAgICAgICAgIHZhciBwMyA9IGkgKyAxIDwgdGhpcy5tX3ZlcnRleENvdW50ID8gdGhpcy5tX3ZlcnRpY2VzW3BhcnNlSW50KGkgKyAxKV0gOiB0aGlzLm1fdmVydGljZXNbMF07XHJcbiAgICAgICAgIHZhciBlMVggPSBwMi54IC0gcDFYO1xyXG4gICAgICAgICB2YXIgZTFZID0gcDIueSAtIHAxWTtcclxuICAgICAgICAgdmFyIGUyWCA9IHAzLnggLSBwMVg7XHJcbiAgICAgICAgIHZhciBlMlkgPSBwMy55IC0gcDFZO1xyXG4gICAgICAgICB2YXIgRCA9IGUxWCAqIGUyWSAtIGUxWSAqIGUyWDtcclxuICAgICAgICAgdmFyIHRyaWFuZ2xlQXJlYSA9IDAuNSAqIEQ7YXJlYSArPSB0cmlhbmdsZUFyZWE7XHJcbiAgICAgICAgIGNlbnRlclggKz0gdHJpYW5nbGVBcmVhICoga19pbnYzICogKHAxWCArIHAyLnggKyBwMy54KTtcclxuICAgICAgICAgY2VudGVyWSArPSB0cmlhbmdsZUFyZWEgKiBrX2ludjMgKiAocDFZICsgcDIueSArIHAzLnkpO1xyXG4gICAgICAgICB2YXIgcHggPSBwMVg7XHJcbiAgICAgICAgIHZhciBweSA9IHAxWTtcclxuICAgICAgICAgdmFyIGV4MSA9IGUxWDtcclxuICAgICAgICAgdmFyIGV5MSA9IGUxWTtcclxuICAgICAgICAgdmFyIGV4MiA9IGUyWDtcclxuICAgICAgICAgdmFyIGV5MiA9IGUyWTtcclxuICAgICAgICAgdmFyIGludHgyID0ga19pbnYzICogKDAuMjUgKiAoZXgxICogZXgxICsgZXgyICogZXgxICsgZXgyICogZXgyKSArIChweCAqIGV4MSArIHB4ICogZXgyKSkgKyAwLjUgKiBweCAqIHB4O1xyXG4gICAgICAgICB2YXIgaW50eTIgPSBrX2ludjMgKiAoMC4yNSAqIChleTEgKiBleTEgKyBleTIgKiBleTEgKyBleTIgKiBleTIpICsgKHB5ICogZXkxICsgcHkgKiBleTIpKSArIDAuNSAqIHB5ICogcHk7SSArPSBEICogKGludHgyICsgaW50eTIpO1xyXG4gICAgICB9XHJcbiAgICAgIG1hc3NEYXRhLm1hc3MgPSBkZW5zaXR5ICogYXJlYTtcclxuICAgICAgY2VudGVyWCAqPSAxLjAgLyBhcmVhO1xyXG4gICAgICBjZW50ZXJZICo9IDEuMCAvIGFyZWE7XHJcbiAgICAgIG1hc3NEYXRhLmNlbnRlci5TZXQoY2VudGVyWCwgY2VudGVyWSk7XHJcbiAgICAgIG1hc3NEYXRhLkkgPSBkZW5zaXR5ICogSTtcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEgPSBmdW5jdGlvbiAobm9ybWFsLCBvZmZzZXQsIHhmLCBjKSB7XHJcbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgb2Zmc2V0ID0gMDtcclxuICAgICAgdmFyIG5vcm1hbEwgPSBiMk1hdGguTXVsVE1WKHhmLlIsIG5vcm1hbCk7XHJcbiAgICAgIHZhciBvZmZzZXRMID0gb2Zmc2V0IC0gYjJNYXRoLkRvdChub3JtYWwsIHhmLnBvc2l0aW9uKTtcclxuICAgICAgdmFyIGRlcHRocyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcigpO1xyXG4gICAgICB2YXIgZGl2ZUNvdW50ID0gMDtcclxuICAgICAgdmFyIGludG9JbmRleCA9IHBhcnNlSW50KCgtMSkpO1xyXG4gICAgICB2YXIgb3V0b0luZGV4ID0gcGFyc2VJbnQoKC0xKSk7XHJcbiAgICAgIHZhciBsYXN0U3VibWVyZ2VkID0gZmFsc2U7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIGRlcHRoc1tpXSA9IGIyTWF0aC5Eb3Qobm9ybWFsTCwgdGhpcy5tX3ZlcnRpY2VzW2ldKSAtIG9mZnNldEw7XHJcbiAgICAgICAgIHZhciBpc1N1Ym1lcmdlZCA9IGRlcHRoc1tpXSA8ICgtTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdWJtZXJnZWQpIHtcclxuICAgICAgICAgICAgICAgaWYgKCFsYXN0U3VibWVyZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGludG9JbmRleCA9IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICBkaXZlQ291bnQrKztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICBpZiAobGFzdFN1Ym1lcmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICBvdXRvSW5kZXggPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgZGl2ZUNvdW50Kys7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGxhc3RTdWJtZXJnZWQgPSBpc1N1Ym1lcmdlZDtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKGRpdmVDb3VudCkge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgICAgIGlmIChsYXN0U3VibWVyZ2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBtZCA9IG5ldyBiMk1hc3NEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuQ29tcHV0ZU1hc3MobWQsIDEpO1xyXG4gICAgICAgICAgICBjLlNldFYoYjJNYXRoLk11bFgoeGYsIG1kLmNlbnRlcikpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWQubWFzcztcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICAgaWYgKGludG9JbmRleCA9PSAoLTEpKSB7XHJcbiAgICAgICAgICAgIGludG9JbmRleCA9IHRoaXMubV92ZXJ0ZXhDb3VudCAtIDE7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dG9JbmRleCA9IHRoaXMubV92ZXJ0ZXhDb3VudCAtIDE7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGludG9JbmRleDIgPSBwYXJzZUludCgoaW50b0luZGV4ICsgMSkgJSB0aGlzLm1fdmVydGV4Q291bnQpO1xyXG4gICAgICB2YXIgb3V0b0luZGV4MiA9IHBhcnNlSW50KChvdXRvSW5kZXggKyAxKSAlIHRoaXMubV92ZXJ0ZXhDb3VudCk7XHJcbiAgICAgIHZhciBpbnRvTGFtZGRhID0gKDAgLSBkZXB0aHNbaW50b0luZGV4XSkgLyAoZGVwdGhzW2ludG9JbmRleDJdIC0gZGVwdGhzW2ludG9JbmRleF0pO1xyXG4gICAgICB2YXIgb3V0b0xhbWRkYSA9ICgwIC0gZGVwdGhzW291dG9JbmRleF0pIC8gKGRlcHRoc1tvdXRvSW5kZXgyXSAtIGRlcHRoc1tvdXRvSW5kZXhdKTtcclxuICAgICAgdmFyIGludG9WZWMgPSBuZXcgYjJWZWMyKHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXhdLnggKiAoMSAtIGludG9MYW1kZGEpICsgdGhpcy5tX3ZlcnRpY2VzW2ludG9JbmRleDJdLnggKiBpbnRvTGFtZGRhLCB0aGlzLm1fdmVydGljZXNbaW50b0luZGV4XS55ICogKDEgLSBpbnRvTGFtZGRhKSArIHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXgyXS55ICogaW50b0xhbWRkYSk7XHJcbiAgICAgIHZhciBvdXRvVmVjID0gbmV3IGIyVmVjMih0aGlzLm1fdmVydGljZXNbb3V0b0luZGV4XS54ICogKDEgLSBvdXRvTGFtZGRhKSArIHRoaXMubV92ZXJ0aWNlc1tvdXRvSW5kZXgyXS54ICogb3V0b0xhbWRkYSwgdGhpcy5tX3ZlcnRpY2VzW291dG9JbmRleF0ueSAqICgxIC0gb3V0b0xhbWRkYSkgKyB0aGlzLm1fdmVydGljZXNbb3V0b0luZGV4Ml0ueSAqIG91dG9MYW1kZGEpO1xyXG4gICAgICB2YXIgYXJlYSA9IDA7XHJcbiAgICAgIHZhciBjZW50ZXIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHZhciBwMiA9IHRoaXMubV92ZXJ0aWNlc1tpbnRvSW5kZXgyXTtcclxuICAgICAgdmFyIHAzO1xyXG4gICAgICBpID0gaW50b0luZGV4MjtcclxuICAgICAgd2hpbGUgKGkgIT0gb3V0b0luZGV4Mikge1xyXG4gICAgICAgICBpID0gKGkgKyAxKSAlIHRoaXMubV92ZXJ0ZXhDb3VudDtcclxuICAgICAgICAgaWYgKGkgPT0gb3V0b0luZGV4MikgcDMgPSBvdXRvVmVjO1xyXG4gICAgICAgICBlbHNlIHAzID0gdGhpcy5tX3ZlcnRpY2VzW2ldO1xyXG4gICAgICAgICB2YXIgdHJpYW5nbGVBcmVhID0gMC41ICogKChwMi54IC0gaW50b1ZlYy54KSAqIChwMy55IC0gaW50b1ZlYy55KSAtIChwMi55IC0gaW50b1ZlYy55KSAqIChwMy54IC0gaW50b1ZlYy54KSk7XHJcbiAgICAgICAgIGFyZWEgKz0gdHJpYW5nbGVBcmVhO1xyXG4gICAgICAgICBjZW50ZXIueCArPSB0cmlhbmdsZUFyZWEgKiAoaW50b1ZlYy54ICsgcDIueCArIHAzLngpIC8gMztcclxuICAgICAgICAgY2VudGVyLnkgKz0gdHJpYW5nbGVBcmVhICogKGludG9WZWMueSArIHAyLnkgKyBwMy55KSAvIDM7XHJcbiAgICAgICAgIHAyID0gcDM7XHJcbiAgICAgIH1cclxuICAgICAgY2VudGVyLk11bHRpcGx5KDEgLyBhcmVhKTtcclxuICAgICAgYy5TZXRWKGIyTWF0aC5NdWxYKHhmLCBjZW50ZXIpKTtcclxuICAgICAgcmV0dXJuIGFyZWE7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkdldFZlcnRleENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3ZlcnRleENvdW50O1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5HZXRWZXJ0aWNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlcztcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5wcm90b3R5cGUuR2V0Tm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ub3JtYWxzO1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5HZXRTdXBwb3J0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgdmFyIGJlc3RJbmRleCA9IDA7XHJcbiAgICAgIHZhciBiZXN0VmFsdWUgPSB0aGlzLm1fdmVydGljZXNbMF0ueCAqIGQueCArIHRoaXMubV92ZXJ0aWNlc1swXS55ICogZC55O1xyXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubV92ZXJ0ZXhDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1tpXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzW2ldLnkgKiBkLnk7XHJcbiAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSkge1xyXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiZXN0SW5kZXg7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLkdldFN1cHBvcnRWZXJ0ZXggPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICB2YXIgYmVzdEluZGV4ID0gMDtcclxuICAgICAgdmFyIGJlc3RWYWx1ZSA9IHRoaXMubV92ZXJ0aWNlc1swXS54ICogZC54ICsgdGhpcy5tX3ZlcnRpY2VzWzBdLnkgKiBkLnk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5tX3ZlcnRleENvdW50OyArK2kpIHtcclxuICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tX3ZlcnRpY2VzW2ldLnggKiBkLnggKyB0aGlzLm1fdmVydGljZXNbaV0ueSAqIGQueTtcclxuICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMubV92ZXJ0aWNlc1tiZXN0SW5kZXhdO1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5WYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICB9XHJcbiAgIGIyUG9seWdvblNoYXBlLnByb3RvdHlwZS5iMlBvbHlnb25TaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIyU2hhcGUuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy5tX3R5cGUgPSBiMlNoYXBlLmVfcG9seWdvblNoYXBlO1xyXG4gICAgICB0aGlzLm1fY2VudHJvaWQgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV92ZXJ0aWNlcyA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgdGhpcy5tX25vcm1hbHMgPSBuZXcgVmVjdG9yKCk7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUucHJvdG90eXBlLlJlc2VydmUgPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIGNvdW50ID0gMDtcclxuICAgICAgZm9yICh2YXIgaSA9IHBhcnNlSW50KHRoaXMubV92ZXJ0aWNlcy5sZW5ndGgpOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICB0aGlzLm1fdmVydGljZXNbaV0gPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgICAgIHRoaXMubV9ub3JtYWxzW2ldID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uU2hhcGUuQ29tcHV0ZUNlbnRyb2lkID0gZnVuY3Rpb24gKHZzLCBjb3VudCkge1xyXG4gICAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgY291bnQgPSAwO1xyXG4gICAgICB2YXIgYyA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdmFyIGFyZWEgPSAwLjA7XHJcbiAgICAgIHZhciBwMVggPSAwLjA7XHJcbiAgICAgIHZhciBwMVkgPSAwLjA7XHJcbiAgICAgIHZhciBpbnYzID0gMS4wIC8gMy4wO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgdmFyIHAyID0gdnNbaV07XHJcbiAgICAgICAgIHZhciBwMyA9IGkgKyAxIDwgY291bnQgPyB2c1twYXJzZUludChpICsgMSldIDogdnNbMF07XHJcbiAgICAgICAgIHZhciBlMVggPSBwMi54IC0gcDFYO1xyXG4gICAgICAgICB2YXIgZTFZID0gcDIueSAtIHAxWTtcclxuICAgICAgICAgdmFyIGUyWCA9IHAzLnggLSBwMVg7XHJcbiAgICAgICAgIHZhciBlMlkgPSBwMy55IC0gcDFZO1xyXG4gICAgICAgICB2YXIgRCA9IChlMVggKiBlMlkgLSBlMVkgKiBlMlgpO1xyXG4gICAgICAgICB2YXIgdHJpYW5nbGVBcmVhID0gMC41ICogRDthcmVhICs9IHRyaWFuZ2xlQXJlYTtcclxuICAgICAgICAgYy54ICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDFYICsgcDIueCArIHAzLngpO1xyXG4gICAgICAgICBjLnkgKz0gdHJpYW5nbGVBcmVhICogaW52MyAqIChwMVkgKyBwMi55ICsgcDMueSk7XHJcbiAgICAgIH1cclxuICAgICAgYy54ICo9IDEuMCAvIGFyZWE7XHJcbiAgICAgIGMueSAqPSAxLjAgLyBhcmVhO1xyXG4gICAgICByZXR1cm4gYztcclxuICAgfVxyXG4gICBiMlBvbHlnb25TaGFwZS5Db21wdXRlT0JCID0gZnVuY3Rpb24gKG9iYiwgdnMsIGNvdW50KSB7XHJcbiAgICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSBjb3VudCA9IDA7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIHAgPSBuZXcgVmVjdG9yKGNvdW50ICsgMSk7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHBbaV0gPSB2c1tpXTtcclxuICAgICAgfVxyXG4gICAgICBwW2NvdW50XSA9IHBbMF07XHJcbiAgICAgIHZhciBtaW5BcmVhID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgZm9yIChpID0gMTtcclxuICAgICAgaSA8PSBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciByb290ID0gcFtwYXJzZUludChpIC0gMSldO1xyXG4gICAgICAgICB2YXIgdXhYID0gcFtpXS54IC0gcm9vdC54O1xyXG4gICAgICAgICB2YXIgdXhZID0gcFtpXS55IC0gcm9vdC55O1xyXG4gICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KHV4WCAqIHV4WCArIHV4WSAqIHV4WSk7XHJcbiAgICAgICAgIHV4WCAvPSBsZW5ndGg7XHJcbiAgICAgICAgIHV4WSAvPSBsZW5ndGg7XHJcbiAgICAgICAgIHZhciB1eVggPSAoLXV4WSk7XHJcbiAgICAgICAgIHZhciB1eVkgPSB1eFg7XHJcbiAgICAgICAgIHZhciBsb3dlclggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICB2YXIgbG93ZXJZID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgdmFyIHVwcGVyWCA9ICgtTnVtYmVyLk1BWF9WQUxVRSk7XHJcbiAgICAgICAgIHZhciB1cHBlclkgPSAoLU51bWJlci5NQVhfVkFMVUUpO1xyXG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyArK2opIHtcclxuICAgICAgICAgICAgdmFyIGRYID0gcFtqXS54IC0gcm9vdC54O1xyXG4gICAgICAgICAgICB2YXIgZFkgPSBwW2pdLnkgLSByb290Lnk7XHJcbiAgICAgICAgICAgIHZhciByWCA9ICh1eFggKiBkWCArIHV4WSAqIGRZKTtcclxuICAgICAgICAgICAgdmFyIHJZID0gKHV5WCAqIGRYICsgdXlZICogZFkpO1xyXG4gICAgICAgICAgICBpZiAoclggPCBsb3dlclgpIGxvd2VyWCA9IHJYO1xyXG4gICAgICAgICAgICBpZiAoclkgPCBsb3dlclkpIGxvd2VyWSA9IHJZO1xyXG4gICAgICAgICAgICBpZiAoclggPiB1cHBlclgpIHVwcGVyWCA9IHJYO1xyXG4gICAgICAgICAgICBpZiAoclkgPiB1cHBlclkpIHVwcGVyWSA9IHJZO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBhcmVhID0gKHVwcGVyWCAtIGxvd2VyWCkgKiAodXBwZXJZIC0gbG93ZXJZKTtcclxuICAgICAgICAgaWYgKGFyZWEgPCAwLjk1ICogbWluQXJlYSkge1xyXG4gICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcclxuICAgICAgICAgICAgb2JiLlIuY29sMS54ID0gdXhYO1xyXG4gICAgICAgICAgICBvYmIuUi5jb2wxLnkgPSB1eFk7XHJcbiAgICAgICAgICAgIG9iYi5SLmNvbDIueCA9IHV5WDtcclxuICAgICAgICAgICAgb2JiLlIuY29sMi55ID0gdXlZO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyWCA9IDAuNSAqIChsb3dlclggKyB1cHBlclgpO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyWSA9IDAuNSAqIChsb3dlclkgKyB1cHBlclkpO1xyXG4gICAgICAgICAgICB2YXIgdE1hdCA9IG9iYi5SO1xyXG4gICAgICAgICAgICBvYmIuY2VudGVyLnggPSByb290LnggKyAodE1hdC5jb2wxLnggKiBjZW50ZXJYICsgdE1hdC5jb2wyLnggKiBjZW50ZXJZKTtcclxuICAgICAgICAgICAgb2JiLmNlbnRlci55ID0gcm9vdC55ICsgKHRNYXQuY29sMS55ICogY2VudGVyWCArIHRNYXQuY29sMi55ICogY2VudGVyWSk7XHJcbiAgICAgICAgICAgIG9iYi5leHRlbnRzLnggPSAwLjUgKiAodXBwZXJYIC0gbG93ZXJYKTtcclxuICAgICAgICAgICAgb2JiLmV4dGVudHMueSA9IDAuNSAqICh1cHBlclkgLSBsb3dlclkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlBvbHlnb25TaGFwZS5zX21hdCA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgIH0pO1xyXG4gICBiMlNoYXBlLmIyU2hhcGUgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgYjJTaGFwZS5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgIH1cclxuICAgYjJTaGFwZS5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgIHRoaXMubV9yYWRpdXMgPSBvdGhlci5tX3JhZGl1cztcclxuICAgfVxyXG4gICBiMlNoYXBlLnByb3RvdHlwZS5HZXRUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3R5cGU7XHJcbiAgIH1cclxuICAgYjJTaGFwZS5wcm90b3R5cGUuVGVzdFBvaW50ID0gZnVuY3Rpb24gKHhmLCBwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgfVxyXG4gICBiMlNoYXBlLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKG91dHB1dCwgaW5wdXQsIHRyYW5zZm9ybSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgIH1cclxuICAgYjJTaGFwZS5wcm90b3R5cGUuQ29tcHV0ZUFBQkIgPSBmdW5jdGlvbiAoYWFiYiwgeGYpIHt9XHJcbiAgIGIyU2hhcGUucHJvdG90eXBlLkNvbXB1dGVNYXNzID0gZnVuY3Rpb24gKG1hc3NEYXRhLCBkZW5zaXR5KSB7XHJcbiAgICAgIGlmIChkZW5zaXR5ID09PSB1bmRlZmluZWQpIGRlbnNpdHkgPSAwO1xyXG4gICB9XHJcbiAgIGIyU2hhcGUucHJvdG90eXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhID0gZnVuY3Rpb24gKG5vcm1hbCwgb2Zmc2V0LCB4ZiwgYykge1xyXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIG9mZnNldCA9IDA7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICB9XHJcbiAgIGIyU2hhcGUuVGVzdE92ZXJsYXAgPSBmdW5jdGlvbiAoc2hhcGUxLCB0cmFuc2Zvcm0xLCBzaGFwZTIsIHRyYW5zZm9ybTIpIHtcclxuICAgICAgdmFyIGlucHV0ID0gbmV3IGIyRGlzdGFuY2VJbnB1dCgpO1xyXG4gICAgICBpbnB1dC5wcm94eUEgPSBuZXcgYjJEaXN0YW5jZVByb3h5KCk7XHJcbiAgICAgIGlucHV0LnByb3h5QS5TZXQoc2hhcGUxKTtcclxuICAgICAgaW5wdXQucHJveHlCID0gbmV3IGIyRGlzdGFuY2VQcm94eSgpO1xyXG4gICAgICBpbnB1dC5wcm94eUIuU2V0KHNoYXBlMik7XHJcbiAgICAgIGlucHV0LnRyYW5zZm9ybUEgPSB0cmFuc2Zvcm0xO1xyXG4gICAgICBpbnB1dC50cmFuc2Zvcm1CID0gdHJhbnNmb3JtMjtcclxuICAgICAgaW5wdXQudXNlUmFkaWkgPSB0cnVlO1xyXG4gICAgICB2YXIgc2ltcGxleENhY2hlID0gbmV3IGIyU2ltcGxleENhY2hlKCk7XHJcbiAgICAgIHNpbXBsZXhDYWNoZS5jb3VudCA9IDA7XHJcbiAgICAgIHZhciBvdXRwdXQgPSBuZXcgYjJEaXN0YW5jZU91dHB1dCgpO1xyXG4gICAgICBiMkRpc3RhbmNlLkRpc3RhbmNlKG91dHB1dCwgc2ltcGxleENhY2hlLCBpbnB1dCk7XHJcbiAgICAgIHJldHVybiBvdXRwdXQuZGlzdGFuY2UgPCAxMC4wICogTnVtYmVyLk1JTl9WQUxVRTtcclxuICAgfVxyXG4gICBiMlNoYXBlLnByb3RvdHlwZS5iMlNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fdHlwZSA9IGIyU2hhcGUuZV91bmtub3duU2hhcGU7XHJcbiAgICAgIHRoaXMubV9yYWRpdXMgPSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XHJcbiAgIH1cclxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3Vua25vd25TaGFwZSA9IHBhcnNlSW50KCgtMSkpO1xyXG4gICAgICBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUuZV9jaXJjbGVTaGFwZSA9IDA7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3BvbHlnb25TaGFwZSA9IDE7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX2VkZ2VTaGFwZSA9IDI7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX3NoYXBlVHlwZUNvdW50ID0gMztcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmVfaGl0Q29sbGlkZSA9IDE7XHJcbiAgICAgIEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJTaGFwZS5lX21pc3NDb2xsaWRlID0gMDtcclxuICAgICAgQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLmVfc3RhcnRzSW5zaWRlQ29sbGlkZSA9IHBhcnNlSW50KCgtMSkpO1xyXG4gICB9KTtcclxufSkoKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgdmFyIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcclxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxyXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXHJcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxyXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcclxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxyXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcclxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcclxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxyXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzM7XHJcblxyXG4gICBiMkNvbG9yLmIyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuX3IgPSAwO1xyXG4gICAgICB0aGlzLl9nID0gMDtcclxuICAgICAgdGhpcy5fYiA9IDA7XHJcbiAgIH07XHJcbiAgIGIyQ29sb3IucHJvdG90eXBlLmIyQ29sb3IgPSBmdW5jdGlvbiAocnIsIGdnLCBiYikge1xyXG4gICAgICBpZiAocnIgPT09IHVuZGVmaW5lZCkgcnIgPSAwO1xyXG4gICAgICBpZiAoZ2cgPT09IHVuZGVmaW5lZCkgZ2cgPSAwO1xyXG4gICAgICBpZiAoYmIgPT09IHVuZGVmaW5lZCkgYmIgPSAwO1xyXG4gICAgICB0aGlzLl9yID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChyciwgMC4wLCAxLjApKTtcclxuICAgICAgdGhpcy5fZyA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoZ2csIDAuMCwgMS4wKSk7XHJcbiAgICAgIHRoaXMuX2IgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKGJiLCAwLjAsIDEuMCkpO1xyXG4gICB9XHJcbiAgIGIyQ29sb3IucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChyciwgZ2csIGJiKSB7XHJcbiAgICAgIGlmIChyciA9PT0gdW5kZWZpbmVkKSByciA9IDA7XHJcbiAgICAgIGlmIChnZyA9PT0gdW5kZWZpbmVkKSBnZyA9IDA7XHJcbiAgICAgIGlmIChiYiA9PT0gdW5kZWZpbmVkKSBiYiA9IDA7XHJcbiAgICAgIHRoaXMuX3IgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKHJyLCAwLjAsIDEuMCkpO1xyXG4gICAgICB0aGlzLl9nID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChnZywgMC4wLCAxLjApKTtcclxuICAgICAgdGhpcy5fYiA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAoYmIsIDAuMCwgMS4wKSk7XHJcbiAgIH1cclxuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGIyQ29sb3IucHJvdG90eXBlLCAncicsIHtcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiAocnIpIHtcclxuICAgICAgICAgaWYgKHJyID09PSB1bmRlZmluZWQpIHJyID0gMDtcclxuICAgICAgICAgdGhpcy5fciA9IEJveDJELnBhcnNlVUludCgyNTUgKiBiMk1hdGguQ2xhbXAocnIsIDAuMCwgMS4wKSk7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiMkNvbG9yLnByb3RvdHlwZSwgJ2cnLCB7XHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIHNldDogZnVuY3Rpb24gKGdnKSB7XHJcbiAgICAgICAgIGlmIChnZyA9PT0gdW5kZWZpbmVkKSBnZyA9IDA7XHJcbiAgICAgICAgIHRoaXMuX2cgPSBCb3gyRC5wYXJzZVVJbnQoMjU1ICogYjJNYXRoLkNsYW1wKGdnLCAwLjAsIDEuMCkpO1xyXG4gICAgICB9XHJcbiAgIH0pO1xyXG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYjJDb2xvci5wcm90b3R5cGUsICdiJywge1xyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChiYikge1xyXG4gICAgICAgICBpZiAoYmIgPT09IHVuZGVmaW5lZCkgYmIgPSAwO1xyXG4gICAgICAgICB0aGlzLl9iID0gQm94MkQucGFyc2VVSW50KDI1NSAqIGIyTWF0aC5DbGFtcChiYiwgMC4wLCAxLjApKTtcclxuICAgICAgfVxyXG4gICB9KTtcclxuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGIyQ29sb3IucHJvdG90eXBlLCAnY29sb3InLCB7XHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICByZXR1cm4gKHRoaXMuX3IgPDwgMTYpIHwgKHRoaXMuX2cgPDwgOCkgfCAodGhpcy5fYik7XHJcbiAgICAgIH1cclxuICAgfSk7XHJcbiAgIGIyU2V0dGluZ3MuYjJTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMlNldHRpbmdzLmIyTWl4RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24xLCBmcmljdGlvbjIpIHtcclxuICAgICAgaWYgKGZyaWN0aW9uMSA9PT0gdW5kZWZpbmVkKSBmcmljdGlvbjEgPSAwO1xyXG4gICAgICBpZiAoZnJpY3Rpb24yID09PSB1bmRlZmluZWQpIGZyaWN0aW9uMiA9IDA7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZnJpY3Rpb24xICogZnJpY3Rpb24yKTtcclxuICAgfVxyXG4gICBiMlNldHRpbmdzLmIyTWl4UmVzdGl0dXRpb24gPSBmdW5jdGlvbiAocmVzdGl0dXRpb24xLCByZXN0aXR1dGlvbjIpIHtcclxuICAgICAgaWYgKHJlc3RpdHV0aW9uMSA9PT0gdW5kZWZpbmVkKSByZXN0aXR1dGlvbjEgPSAwO1xyXG4gICAgICBpZiAocmVzdGl0dXRpb24yID09PSB1bmRlZmluZWQpIHJlc3RpdHV0aW9uMiA9IDA7XHJcbiAgICAgIHJldHVybiByZXN0aXR1dGlvbjEgPiByZXN0aXR1dGlvbjIgPyByZXN0aXR1dGlvbjEgOiByZXN0aXR1dGlvbjI7XHJcbiAgIH1cclxuICAgYjJTZXR0aW5ncy5iMkFzc2VydCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgIGlmICghYSkge1xyXG4gICAgICAgICB0aHJvdyBcIkFzc2VydGlvbiBGYWlsZWRcIjtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5WRVJTSU9OID0gXCIyLjFhbHBoYVwiO1xyXG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5VU0hSVF9NQVggPSAweDAwMDBmZmZmO1xyXG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9waSA9IE1hdGguUEk7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzID0gMjtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYWFiYkV4dGVuc2lvbiA9IDAuMTtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYWFiYk11bHRpcGxpZXIgPSAyLjA7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX3BvbHlnb25SYWRpdXMgPSAyLjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX2xpbmVhclNsb3AgPSAwLjAwNTtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3AgPSAyLjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX3RvaVNsb3AgPSA4LjAgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRPSUNvbnRhY3RzUGVySXNsYW5kID0gMzI7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRPSUpvaW50c1BlcklzbGFuZCA9IDMyO1xyXG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl92ZWxvY2l0eVRocmVzaG9sZCA9IDEuMDtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiA9IDAuMjtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4QW5ndWxhckNvcnJlY3Rpb24gPSA4LjAgLyAxODAuMCAqIGIyU2V0dGluZ3MuYjJfcGk7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uID0gMi4wO1xyXG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvblNxdWFyZWQgPSBiMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uICogYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvbjtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gPSAwLjUgKiBiMlNldHRpbmdzLmIyX3BpO1xyXG4gICAgICBCb3gyRC5Db21tb24uYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvblNxdWFyZWQgPSBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uICogYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvbjtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfY29udGFjdEJhdW1nYXJ0ZSA9IDAuMjtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfdGltZVRvU2xlZXAgPSAwLjU7XHJcbiAgICAgIEJveDJELkNvbW1vbi5iMlNldHRpbmdzLmIyX2xpbmVhclNsZWVwVG9sZXJhbmNlID0gMC4wMTtcclxuICAgICAgQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MuYjJfYW5ndWxhclNsZWVwVG9sZXJhbmNlID0gMi4wIC8gMTgwLjAgKiBiMlNldHRpbmdzLmIyX3BpO1xyXG4gICB9KTtcclxufSkoKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgdmFyIGIyQUFCQiA9IEJveDJELkNvbGxpc2lvbi5iMkFBQkIsXHJcbiAgICAgIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcclxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxyXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXHJcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxyXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcclxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxyXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcclxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcclxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxyXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzM7XHJcblxyXG4gICBiMk1hdDIyLmIyTWF0MjIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuY29sMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5jb2wyID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMk1hdDIyLnByb3RvdHlwZS5iMk1hdDIyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLlNldElkZW50aXR5KCk7XHJcbiAgIH1cclxuICAgYjJNYXQyMi5Gcm9tQW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgICAgaWYgKGFuZ2xlID09PSB1bmRlZmluZWQpIGFuZ2xlID0gMDtcclxuICAgICAgdmFyIG1hdCA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgICAgIG1hdC5TZXQoYW5nbGUpO1xyXG4gICAgICByZXR1cm4gbWF0O1xyXG4gICB9XHJcbiAgIGIyTWF0MjIuRnJvbVZWID0gZnVuY3Rpb24gKGMxLCBjMikge1xyXG4gICAgICB2YXIgbWF0ID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgbWF0LlNldFZWKGMxLCBjMik7XHJcbiAgICAgIHJldHVybiBtYXQ7XHJcbiAgIH1cclxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0ID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgIGlmIChhbmdsZSA9PT0gdW5kZWZpbmVkKSBhbmdsZSA9IDA7XHJcbiAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgdGhpcy5jb2wxLnggPSBjO1xyXG4gICAgICB0aGlzLmNvbDIueCA9ICgtcyk7XHJcbiAgICAgIHRoaXMuY29sMS55ID0gcztcclxuICAgICAgdGhpcy5jb2wyLnkgPSBjO1xyXG4gICB9XHJcbiAgIGIyTWF0MjIucHJvdG90eXBlLlNldFZWID0gZnVuY3Rpb24gKGMxLCBjMikge1xyXG4gICAgICB0aGlzLmNvbDEuU2V0VihjMSk7XHJcbiAgICAgIHRoaXMuY29sMi5TZXRWKGMyKTtcclxuICAgfVxyXG4gICBiMk1hdDIyLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbWF0ID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgbWF0LlNldE0odGhpcyk7XHJcbiAgICAgIHJldHVybiBtYXQ7XHJcbiAgIH1cclxuICAgYjJNYXQyMi5wcm90b3R5cGUuU2V0TSA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgIHRoaXMuY29sMS5TZXRWKG0uY29sMSk7XHJcbiAgICAgIHRoaXMuY29sMi5TZXRWKG0uY29sMik7XHJcbiAgIH1cclxuICAgYjJNYXQyMi5wcm90b3R5cGUuQWRkTSA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgIHRoaXMuY29sMS54ICs9IG0uY29sMS54O1xyXG4gICAgICB0aGlzLmNvbDEueSArPSBtLmNvbDEueTtcclxuICAgICAgdGhpcy5jb2wyLnggKz0gbS5jb2wyLng7XHJcbiAgICAgIHRoaXMuY29sMi55ICs9IG0uY29sMi55O1xyXG4gICB9XHJcbiAgIGIyTWF0MjIucHJvdG90eXBlLlNldElkZW50aXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmNvbDEueCA9IDEuMDtcclxuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMS55ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDIueSA9IDEuMDtcclxuICAgfVxyXG4gICBiMk1hdDIyLnByb3RvdHlwZS5TZXRaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmNvbDEueCA9IDAuMDtcclxuICAgICAgdGhpcy5jb2wyLnggPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMS55ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDIueSA9IDAuMDtcclxuICAgfVxyXG4gICBiMk1hdDIyLnByb3RvdHlwZS5HZXRBbmdsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5jb2wxLnksIHRoaXMuY29sMS54KTtcclxuICAgfVxyXG4gICBiMk1hdDIyLnByb3RvdHlwZS5HZXRJbnZlcnNlID0gZnVuY3Rpb24gKG91dCkge1xyXG4gICAgICB2YXIgYSA9IHRoaXMuY29sMS54O1xyXG4gICAgICB2YXIgYiA9IHRoaXMuY29sMi54O1xyXG4gICAgICB2YXIgYyA9IHRoaXMuY29sMS55O1xyXG4gICAgICB2YXIgZCA9IHRoaXMuY29sMi55O1xyXG4gICAgICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcclxuICAgICAgaWYgKGRldCAhPSAwLjApIHtcclxuICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xyXG4gICAgICB9XHJcbiAgICAgIG91dC5jb2wxLnggPSBkZXQgKiBkO1xyXG4gICAgICBvdXQuY29sMi54ID0gKC1kZXQgKiBiKTtcclxuICAgICAgb3V0LmNvbDEueSA9ICgtZGV0ICogYyk7XHJcbiAgICAgIG91dC5jb2wyLnkgPSBkZXQgKiBhO1xyXG4gICAgICByZXR1cm4gb3V0O1xyXG4gICB9XHJcbiAgIGIyTWF0MjIucHJvdG90eXBlLlNvbHZlID0gZnVuY3Rpb24gKG91dCwgYlgsIGJZKSB7XHJcbiAgICAgIGlmIChiWCA9PT0gdW5kZWZpbmVkKSBiWCA9IDA7XHJcbiAgICAgIGlmIChiWSA9PT0gdW5kZWZpbmVkKSBiWSA9IDA7XHJcbiAgICAgIHZhciBhMTEgPSB0aGlzLmNvbDEueDtcclxuICAgICAgdmFyIGExMiA9IHRoaXMuY29sMi54O1xyXG4gICAgICB2YXIgYTIxID0gdGhpcy5jb2wxLnk7XHJcbiAgICAgIHZhciBhMjIgPSB0aGlzLmNvbDIueTtcclxuICAgICAgdmFyIGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcclxuICAgICAgaWYgKGRldCAhPSAwLjApIHtcclxuICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xyXG4gICAgICB9XHJcbiAgICAgIG91dC54ID0gZGV0ICogKGEyMiAqIGJYIC0gYTEyICogYlkpO1xyXG4gICAgICBvdXQueSA9IGRldCAqIChhMTEgKiBiWSAtIGEyMSAqIGJYKTtcclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgfVxyXG4gICBiMk1hdDIyLnByb3RvdHlwZS5BYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuY29sMS5BYnMoKTtcclxuICAgICAgdGhpcy5jb2wyLkFicygpO1xyXG4gICB9XHJcbiAgIGIyTWF0MzMuYjJNYXQzMyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5jb2wxID0gbmV3IGIyVmVjMygpO1xyXG4gICAgICB0aGlzLmNvbDIgPSBuZXcgYjJWZWMzKCk7XHJcbiAgICAgIHRoaXMuY29sMyA9IG5ldyBiMlZlYzMoKTtcclxuICAgfTtcclxuICAgYjJNYXQzMy5wcm90b3R5cGUuYjJNYXQzMyA9IGZ1bmN0aW9uIChjMSwgYzIsIGMzKSB7XHJcbiAgICAgIGlmIChjMSA9PT0gdW5kZWZpbmVkKSBjMSA9IG51bGw7XHJcbiAgICAgIGlmIChjMiA9PT0gdW5kZWZpbmVkKSBjMiA9IG51bGw7XHJcbiAgICAgIGlmIChjMyA9PT0gdW5kZWZpbmVkKSBjMyA9IG51bGw7XHJcbiAgICAgIGlmICghYzEgJiYgIWMyICYmICFjMykge1xyXG4gICAgICAgICB0aGlzLmNvbDEuU2V0WmVybygpO1xyXG4gICAgICAgICB0aGlzLmNvbDIuU2V0WmVybygpO1xyXG4gICAgICAgICB0aGlzLmNvbDMuU2V0WmVybygpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLmNvbDEuU2V0VihjMSk7XHJcbiAgICAgICAgIHRoaXMuY29sMi5TZXRWKGMyKTtcclxuICAgICAgICAgdGhpcy5jb2wzLlNldFYoYzMpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0VlZWID0gZnVuY3Rpb24gKGMxLCBjMiwgYzMpIHtcclxuICAgICAgdGhpcy5jb2wxLlNldFYoYzEpO1xyXG4gICAgICB0aGlzLmNvbDIuU2V0VihjMik7XHJcbiAgICAgIHRoaXMuY29sMy5TZXRWKGMzKTtcclxuICAgfVxyXG4gICBiMk1hdDMzLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbmV3IGIyTWF0MzModGhpcy5jb2wxLCB0aGlzLmNvbDIsIHRoaXMuY29sMyk7XHJcbiAgIH1cclxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0TSA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgIHRoaXMuY29sMS5TZXRWKG0uY29sMSk7XHJcbiAgICAgIHRoaXMuY29sMi5TZXRWKG0uY29sMik7XHJcbiAgICAgIHRoaXMuY29sMy5TZXRWKG0uY29sMyk7XHJcbiAgIH1cclxuICAgYjJNYXQzMy5wcm90b3R5cGUuQWRkTSA9IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgIHRoaXMuY29sMS54ICs9IG0uY29sMS54O1xyXG4gICAgICB0aGlzLmNvbDEueSArPSBtLmNvbDEueTtcclxuICAgICAgdGhpcy5jb2wxLnogKz0gbS5jb2wxLno7XHJcbiAgICAgIHRoaXMuY29sMi54ICs9IG0uY29sMi54O1xyXG4gICAgICB0aGlzLmNvbDIueSArPSBtLmNvbDIueTtcclxuICAgICAgdGhpcy5jb2wyLnogKz0gbS5jb2wyLno7XHJcbiAgICAgIHRoaXMuY29sMy54ICs9IG0uY29sMy54O1xyXG4gICAgICB0aGlzLmNvbDMueSArPSBtLmNvbDMueTtcclxuICAgICAgdGhpcy5jb2wzLnogKz0gbS5jb2wzLno7XHJcbiAgIH1cclxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0SWRlbnRpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuY29sMS54ID0gMS4wO1xyXG4gICAgICB0aGlzLmNvbDIueCA9IDAuMDtcclxuICAgICAgdGhpcy5jb2wzLnggPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMS55ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDIueSA9IDEuMDtcclxuICAgICAgdGhpcy5jb2wzLnkgPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMS56ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDIueiA9IDAuMDtcclxuICAgICAgdGhpcy5jb2wzLnogPSAxLjA7XHJcbiAgIH1cclxuICAgYjJNYXQzMy5wcm90b3R5cGUuU2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5jb2wxLnggPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMi54ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDMueCA9IDAuMDtcclxuICAgICAgdGhpcy5jb2wxLnkgPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMi55ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDMueSA9IDAuMDtcclxuICAgICAgdGhpcy5jb2wxLnogPSAwLjA7XHJcbiAgICAgIHRoaXMuY29sMi56ID0gMC4wO1xyXG4gICAgICB0aGlzLmNvbDMueiA9IDAuMDtcclxuICAgfVxyXG4gICBiMk1hdDMzLnByb3RvdHlwZS5Tb2x2ZTIyID0gZnVuY3Rpb24gKG91dCwgYlgsIGJZKSB7XHJcbiAgICAgIGlmIChiWCA9PT0gdW5kZWZpbmVkKSBiWCA9IDA7XHJcbiAgICAgIGlmIChiWSA9PT0gdW5kZWZpbmVkKSBiWSA9IDA7XHJcbiAgICAgIHZhciBhMTEgPSB0aGlzLmNvbDEueDtcclxuICAgICAgdmFyIGExMiA9IHRoaXMuY29sMi54O1xyXG4gICAgICB2YXIgYTIxID0gdGhpcy5jb2wxLnk7XHJcbiAgICAgIHZhciBhMjIgPSB0aGlzLmNvbDIueTtcclxuICAgICAgdmFyIGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcclxuICAgICAgaWYgKGRldCAhPSAwLjApIHtcclxuICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xyXG4gICAgICB9XHJcbiAgICAgIG91dC54ID0gZGV0ICogKGEyMiAqIGJYIC0gYTEyICogYlkpO1xyXG4gICAgICBvdXQueSA9IGRldCAqIChhMTEgKiBiWSAtIGEyMSAqIGJYKTtcclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgfVxyXG4gICBiMk1hdDMzLnByb3RvdHlwZS5Tb2x2ZTMzID0gZnVuY3Rpb24gKG91dCwgYlgsIGJZLCBiWikge1xyXG4gICAgICBpZiAoYlggPT09IHVuZGVmaW5lZCkgYlggPSAwO1xyXG4gICAgICBpZiAoYlkgPT09IHVuZGVmaW5lZCkgYlkgPSAwO1xyXG4gICAgICBpZiAoYlogPT09IHVuZGVmaW5lZCkgYlogPSAwO1xyXG4gICAgICB2YXIgYTExID0gdGhpcy5jb2wxLng7XHJcbiAgICAgIHZhciBhMjEgPSB0aGlzLmNvbDEueTtcclxuICAgICAgdmFyIGEzMSA9IHRoaXMuY29sMS56O1xyXG4gICAgICB2YXIgYTEyID0gdGhpcy5jb2wyLng7XHJcbiAgICAgIHZhciBhMjIgPSB0aGlzLmNvbDIueTtcclxuICAgICAgdmFyIGEzMiA9IHRoaXMuY29sMi56O1xyXG4gICAgICB2YXIgYTEzID0gdGhpcy5jb2wzLng7XHJcbiAgICAgIHZhciBhMjMgPSB0aGlzLmNvbDMueTtcclxuICAgICAgdmFyIGEzMyA9IHRoaXMuY29sMy56O1xyXG4gICAgICB2YXIgZGV0ID0gYTExICogKGEyMiAqIGEzMyAtIGEzMiAqIGEyMykgKyBhMjEgKiAoYTMyICogYTEzIC0gYTEyICogYTMzKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMjIgKiBhMTMpO1xyXG4gICAgICBpZiAoZGV0ICE9IDAuMCkge1xyXG4gICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XHJcbiAgICAgIH1cclxuICAgICAgb3V0LnggPSBkZXQgKiAoYlggKiAoYTIyICogYTMzIC0gYTMyICogYTIzKSArIGJZICogKGEzMiAqIGExMyAtIGExMiAqIGEzMykgKyBiWiAqIChhMTIgKiBhMjMgLSBhMjIgKiBhMTMpKTtcclxuICAgICAgb3V0LnkgPSBkZXQgKiAoYTExICogKGJZICogYTMzIC0gYlogKiBhMjMpICsgYTIxICogKGJaICogYTEzIC0gYlggKiBhMzMpICsgYTMxICogKGJYICogYTIzIC0gYlkgKiBhMTMpKTtcclxuICAgICAgb3V0LnogPSBkZXQgKiAoYTExICogKGEyMiAqIGJaIC0gYTMyICogYlkpICsgYTIxICogKGEzMiAqIGJYIC0gYTEyICogYlopICsgYTMxICogKGExMiAqIGJZIC0gYTIyICogYlgpKTtcclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgfVxyXG4gICBiMk1hdGguYjJNYXRoID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyTWF0aC5Jc1ZhbGlkID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IDA7XHJcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh4KTtcclxuICAgfVxyXG4gICBiMk1hdGguRG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueTtcclxuICAgfVxyXG4gICBiMk1hdGguQ3Jvc3NWViA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XHJcbiAgIH1cclxuICAgYjJNYXRoLkNyb3NzVkYgPSBmdW5jdGlvbiAoYSwgcykge1xyXG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMDtcclxuICAgICAgdmFyIHYgPSBuZXcgYjJWZWMyKHMgKiBhLnksICgtcyAqIGEueCkpO1xyXG4gICAgICByZXR1cm4gdjtcclxuICAgfVxyXG4gICBiMk1hdGguQ3Jvc3NGViA9IGZ1bmN0aW9uIChzLCBhKSB7XHJcbiAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAwO1xyXG4gICAgICB2YXIgdiA9IG5ldyBiMlZlYzIoKC1zICogYS55KSwgcyAqIGEueCk7XHJcbiAgICAgIHJldHVybiB2O1xyXG4gICB9XHJcbiAgIGIyTWF0aC5NdWxNViA9IGZ1bmN0aW9uIChBLCB2KSB7XHJcbiAgICAgIHZhciB1ID0gbmV3IGIyVmVjMihBLmNvbDEueCAqIHYueCArIEEuY29sMi54ICogdi55LCBBLmNvbDEueSAqIHYueCArIEEuY29sMi55ICogdi55KTtcclxuICAgICAgcmV0dXJuIHU7XHJcbiAgIH1cclxuICAgYjJNYXRoLk11bFRNViA9IGZ1bmN0aW9uIChBLCB2KSB7XHJcbiAgICAgIHZhciB1ID0gbmV3IGIyVmVjMihiMk1hdGguRG90KHYsIEEuY29sMSksIGIyTWF0aC5Eb3QodiwgQS5jb2wyKSk7XHJcbiAgICAgIHJldHVybiB1O1xyXG4gICB9XHJcbiAgIGIyTWF0aC5NdWxYID0gZnVuY3Rpb24gKFQsIHYpIHtcclxuICAgICAgdmFyIGEgPSBiMk1hdGguTXVsTVYoVC5SLCB2KTtcclxuICAgICAgYS54ICs9IFQucG9zaXRpb24ueDtcclxuICAgICAgYS55ICs9IFQucG9zaXRpb24ueTtcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgIH1cclxuICAgYjJNYXRoLk11bFhUID0gZnVuY3Rpb24gKFQsIHYpIHtcclxuICAgICAgdmFyIGEgPSBiMk1hdGguU3VidHJhY3RWVih2LCBULnBvc2l0aW9uKTtcclxuICAgICAgdmFyIHRYID0gKGEueCAqIFQuUi5jb2wxLnggKyBhLnkgKiBULlIuY29sMS55KTtcclxuICAgICAgYS55ID0gKGEueCAqIFQuUi5jb2wyLnggKyBhLnkgKiBULlIuY29sMi55KTtcclxuICAgICAgYS54ID0gdFg7XHJcbiAgICAgIHJldHVybiBhO1xyXG4gICB9XHJcbiAgIGIyTWF0aC5BZGRWViA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHZhciB2ID0gbmV3IGIyVmVjMihhLnggKyBiLngsIGEueSArIGIueSk7XHJcbiAgICAgIHJldHVybiB2O1xyXG4gICB9XHJcbiAgIGIyTWF0aC5TdWJ0cmFjdFZWID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgdmFyIHYgPSBuZXcgYjJWZWMyKGEueCAtIGIueCwgYS55IC0gYi55KTtcclxuICAgICAgcmV0dXJuIHY7XHJcbiAgIH1cclxuICAgYjJNYXRoLkRpc3RhbmNlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgdmFyIGNYID0gYS54IC0gYi54O1xyXG4gICAgICB2YXIgY1kgPSBhLnkgLSBiLnk7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoY1ggKiBjWCArIGNZICogY1kpO1xyXG4gICB9XHJcbiAgIGIyTWF0aC5EaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICB2YXIgY1ggPSBhLnggLSBiLng7XHJcbiAgICAgIHZhciBjWSA9IGEueSAtIGIueTtcclxuICAgICAgcmV0dXJuIChjWCAqIGNYICsgY1kgKiBjWSk7XHJcbiAgIH1cclxuICAgYjJNYXRoLk11bEZWID0gZnVuY3Rpb24gKHMsIGEpIHtcclxuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDA7XHJcbiAgICAgIHZhciB2ID0gbmV3IGIyVmVjMihzICogYS54LCBzICogYS55KTtcclxuICAgICAgcmV0dXJuIHY7XHJcbiAgIH1cclxuICAgYjJNYXRoLkFkZE1NID0gZnVuY3Rpb24gKEEsIEIpIHtcclxuICAgICAgdmFyIEMgPSBiMk1hdDIyLkZyb21WVihiMk1hdGguQWRkVlYoQS5jb2wxLCBCLmNvbDEpLCBiMk1hdGguQWRkVlYoQS5jb2wyLCBCLmNvbDIpKTtcclxuICAgICAgcmV0dXJuIEM7XHJcbiAgIH1cclxuICAgYjJNYXRoLk11bE1NID0gZnVuY3Rpb24gKEEsIEIpIHtcclxuICAgICAgdmFyIEMgPSBiMk1hdDIyLkZyb21WVihiMk1hdGguTXVsTVYoQSwgQi5jb2wxKSwgYjJNYXRoLk11bE1WKEEsIEIuY29sMikpO1xyXG4gICAgICByZXR1cm4gQztcclxuICAgfVxyXG4gICBiMk1hdGguTXVsVE1NID0gZnVuY3Rpb24gKEEsIEIpIHtcclxuICAgICAgdmFyIGMxID0gbmV3IGIyVmVjMihiMk1hdGguRG90KEEuY29sMSwgQi5jb2wxKSwgYjJNYXRoLkRvdChBLmNvbDIsIEIuY29sMSkpO1xyXG4gICAgICB2YXIgYzIgPSBuZXcgYjJWZWMyKGIyTWF0aC5Eb3QoQS5jb2wxLCBCLmNvbDIpLCBiMk1hdGguRG90KEEuY29sMiwgQi5jb2wyKSk7XHJcbiAgICAgIHZhciBDID0gYjJNYXQyMi5Gcm9tVlYoYzEsIGMyKTtcclxuICAgICAgcmV0dXJuIEM7XHJcbiAgIH1cclxuICAgYjJNYXRoLkFicyA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQpIGEgPSAwO1xyXG4gICAgICByZXR1cm4gYSA+IDAuMCA/IGEgOiAoLWEpO1xyXG4gICB9XHJcbiAgIGIyTWF0aC5BYnNWID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgdmFyIGIgPSBuZXcgYjJWZWMyKGIyTWF0aC5BYnMoYS54KSwgYjJNYXRoLkFicyhhLnkpKTtcclxuICAgICAgcmV0dXJuIGI7XHJcbiAgIH1cclxuICAgYjJNYXRoLkFic00gPSBmdW5jdGlvbiAoQSkge1xyXG4gICAgICB2YXIgQiA9IGIyTWF0MjIuRnJvbVZWKGIyTWF0aC5BYnNWKEEuY29sMSksIGIyTWF0aC5BYnNWKEEuY29sMikpO1xyXG4gICAgICByZXR1cm4gQjtcclxuICAgfVxyXG4gICBiMk1hdGguTWluID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XHJcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAwO1xyXG4gICAgICByZXR1cm4gYSA8IGIgPyBhIDogYjtcclxuICAgfVxyXG4gICBiMk1hdGguTWluViA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHZhciBjID0gbmV3IGIyVmVjMihiMk1hdGguTWluKGEueCwgYi54KSwgYjJNYXRoLk1pbihhLnksIGIueSkpO1xyXG4gICAgICByZXR1cm4gYztcclxuICAgfVxyXG4gICBiMk1hdGguTWF4ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XHJcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIGIgPSAwO1xyXG4gICAgICByZXR1cm4gYSA+IGIgPyBhIDogYjtcclxuICAgfVxyXG4gICBiMk1hdGguTWF4ViA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHZhciBjID0gbmV3IGIyVmVjMihiMk1hdGguTWF4KGEueCwgYi54KSwgYjJNYXRoLk1heChhLnksIGIueSkpO1xyXG4gICAgICByZXR1cm4gYztcclxuICAgfVxyXG4gICBiMk1hdGguQ2xhbXAgPSBmdW5jdGlvbiAoYSwgbG93LCBoaWdoKSB7XHJcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQpIGEgPSAwO1xyXG4gICAgICBpZiAobG93ID09PSB1bmRlZmluZWQpIGxvdyA9IDA7XHJcbiAgICAgIGlmIChoaWdoID09PSB1bmRlZmluZWQpIGhpZ2ggPSAwO1xyXG4gICAgICByZXR1cm4gYSA8IGxvdyA/IGxvdyA6IGEgPiBoaWdoID8gaGlnaCA6IGE7XHJcbiAgIH1cclxuICAgYjJNYXRoLkNsYW1wViA9IGZ1bmN0aW9uIChhLCBsb3csIGhpZ2gpIHtcclxuICAgICAgcmV0dXJuIGIyTWF0aC5NYXhWKGxvdywgYjJNYXRoLk1pblYoYSwgaGlnaCkpO1xyXG4gICB9XHJcbiAgIGIyTWF0aC5Td2FwID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgdmFyIHRtcCA9IGFbMF07XHJcbiAgICAgIGFbMF0gPSBiWzBdO1xyXG4gICAgICBiWzBdID0gdG1wO1xyXG4gICB9XHJcbiAgIGIyTWF0aC5SYW5kb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogMiAtIDE7XHJcbiAgIH1cclxuICAgYjJNYXRoLlJhbmRvbVJhbmdlID0gZnVuY3Rpb24gKGxvLCBoaSkge1xyXG4gICAgICBpZiAobG8gPT09IHVuZGVmaW5lZCkgbG8gPSAwO1xyXG4gICAgICBpZiAoaGkgPT09IHVuZGVmaW5lZCkgaGkgPSAwO1xyXG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgIHIgPSAoaGkgLSBsbykgKiByICsgbG87XHJcbiAgICAgIHJldHVybiByO1xyXG4gICB9XHJcbiAgIGIyTWF0aC5OZXh0UG93ZXJPZlR3byA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHggPSAwO1xyXG4gICAgICB4IHw9ICh4ID4+IDEpICYgMHg3RkZGRkZGRjtcclxuICAgICAgeCB8PSAoeCA+PiAyKSAmIDB4M0ZGRkZGRkY7XHJcbiAgICAgIHggfD0gKHggPj4gNCkgJiAweDBGRkZGRkZGO1xyXG4gICAgICB4IHw9ICh4ID4+IDgpICYgMHgwMEZGRkZGRjtcclxuICAgICAgeCB8PSAoeCA+PiAxNikgJiAweDAwMDBGRkZGO1xyXG4gICAgICByZXR1cm4geCArIDE7XHJcbiAgIH1cclxuICAgYjJNYXRoLklzUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHggPSAwO1xyXG4gICAgICB2YXIgcmVzdWx0ID0geCA+IDAgJiYgKHggJiAoeCAtIDEpKSA9PSAwO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGguYjJWZWMyX3plcm8gPSBuZXcgYjJWZWMyKDAuMCwgMC4wKTtcclxuICAgICAgQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLmIyTWF0MjJfaWRlbnRpdHkgPSBiMk1hdDIyLkZyb21WVihuZXcgYjJWZWMyKDEuMCwgMC4wKSwgbmV3IGIyVmVjMigwLjAsIDEuMCkpO1xyXG4gICAgICBCb3gyRC5Db21tb24uTWF0aC5iMk1hdGguYjJUcmFuc2Zvcm1faWRlbnRpdHkgPSBuZXcgYjJUcmFuc2Zvcm0oYjJNYXRoLmIyVmVjMl96ZXJvLCBiMk1hdGguYjJNYXQyMl9pZGVudGl0eSk7XHJcbiAgIH0pO1xyXG4gICBiMlN3ZWVwLmIyU3dlZXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubG9jYWxDZW50ZXIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMuYzAgPSBuZXcgYjJWZWMyO1xyXG4gICAgICB0aGlzLmMgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyU3dlZXAucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICB0aGlzLmxvY2FsQ2VudGVyLlNldFYob3RoZXIubG9jYWxDZW50ZXIpO1xyXG4gICAgICB0aGlzLmMwLlNldFYob3RoZXIuYzApO1xyXG4gICAgICB0aGlzLmMuU2V0VihvdGhlci5jKTtcclxuICAgICAgdGhpcy5hMCA9IG90aGVyLmEwO1xyXG4gICAgICB0aGlzLmEgPSBvdGhlci5hO1xyXG4gICAgICB0aGlzLnQwID0gb3RoZXIudDA7XHJcbiAgIH1cclxuICAgYjJTd2VlcC5wcm90b3R5cGUuQ29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGNvcHkgPSBuZXcgYjJTd2VlcCgpO1xyXG4gICAgICBjb3B5LmxvY2FsQ2VudGVyLlNldFYodGhpcy5sb2NhbENlbnRlcik7XHJcbiAgICAgIGNvcHkuYzAuU2V0Vih0aGlzLmMwKTtcclxuICAgICAgY29weS5jLlNldFYodGhpcy5jKTtcclxuICAgICAgY29weS5hMCA9IHRoaXMuYTA7XHJcbiAgICAgIGNvcHkuYSA9IHRoaXMuYTtcclxuICAgICAgY29weS50MCA9IHRoaXMudDA7XHJcbiAgICAgIHJldHVybiBjb3B5O1xyXG4gICB9XHJcbiAgIGIyU3dlZXAucHJvdG90eXBlLkdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh4ZiwgYWxwaGEpIHtcclxuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcclxuICAgICAgeGYucG9zaXRpb24ueCA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmMwLnggKyBhbHBoYSAqIHRoaXMuYy54O1xyXG4gICAgICB4Zi5wb3NpdGlvbi55ID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYzAueSArIGFscGhhICogdGhpcy5jLnk7XHJcbiAgICAgIHZhciBhbmdsZSA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmEwICsgYWxwaGEgKiB0aGlzLmE7XHJcbiAgICAgIHhmLlIuU2V0KGFuZ2xlKTtcclxuICAgICAgdmFyIHRNYXQgPSB4Zi5SO1xyXG4gICAgICB4Zi5wb3NpdGlvbi54IC09ICh0TWF0LmNvbDEueCAqIHRoaXMubG9jYWxDZW50ZXIueCArIHRNYXQuY29sMi54ICogdGhpcy5sb2NhbENlbnRlci55KTtcclxuICAgICAgeGYucG9zaXRpb24ueSAtPSAodE1hdC5jb2wxLnkgKiB0aGlzLmxvY2FsQ2VudGVyLnggKyB0TWF0LmNvbDIueSAqIHRoaXMubG9jYWxDZW50ZXIueSk7XHJcbiAgIH1cclxuICAgYjJTd2VlcC5wcm90b3R5cGUuQWR2YW5jZSA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHQgPSAwO1xyXG4gICAgICBpZiAodGhpcy50MCA8IHQgJiYgMS4wIC0gdGhpcy50MCA+IE51bWJlci5NSU5fVkFMVUUpIHtcclxuICAgICAgICAgdmFyIGFscGhhID0gKHQgLSB0aGlzLnQwKSAvICgxLjAgLSB0aGlzLnQwKTtcclxuICAgICAgICAgdGhpcy5jMC54ID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYzAueCArIGFscGhhICogdGhpcy5jLng7XHJcbiAgICAgICAgIHRoaXMuYzAueSA9ICgxLjAgLSBhbHBoYSkgKiB0aGlzLmMwLnkgKyBhbHBoYSAqIHRoaXMuYy55O1xyXG4gICAgICAgICB0aGlzLmEwID0gKDEuMCAtIGFscGhhKSAqIHRoaXMuYTAgKyBhbHBoYSAqIHRoaXMuYTtcclxuICAgICAgICAgdGhpcy50MCA9IHQ7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMlRyYW5zZm9ybS5iMlRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBiMlZlYzI7XHJcbiAgICAgIHRoaXMuUiA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgIH07XHJcbiAgIGIyVHJhbnNmb3JtLnByb3RvdHlwZS5iMlRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwb3MsIHIpIHtcclxuICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSBwb3MgPSBudWxsO1xyXG4gICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByID0gbnVsbDtcclxuICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICB0aGlzLnBvc2l0aW9uLlNldFYocG9zKTtcclxuICAgICAgICAgdGhpcy5SLlNldE0ocik7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMlRyYW5zZm9ybS5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChwb3MsIHIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi5TZXRWKHBvcyk7XHJcbiAgICAgIHRoaXMuUi5TZXRNKHIpO1xyXG4gICB9XHJcbiAgIGIyVHJhbnNmb3JtLnByb3RvdHlwZS5TZXRJZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMuUi5TZXRJZGVudGl0eSgpO1xyXG4gICB9XHJcbiAgIGIyVHJhbnNmb3JtLnByb3RvdHlwZS5TZXQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLlNldFYoeC5wb3NpdGlvbik7XHJcbiAgICAgIHRoaXMuUi5TZXRNKHguUik7XHJcbiAgIH1cclxuICAgYjJUcmFuc2Zvcm0ucHJvdG90eXBlLkdldEFuZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLlIuY29sMS55LCB0aGlzLlIuY29sMS54KTtcclxuICAgfVxyXG4gICBiMlZlYzIuYjJWZWMyID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuYjJWZWMyID0gZnVuY3Rpb24gKHhfLCB5Xykge1xyXG4gICAgICBpZiAoeF8gPT09IHVuZGVmaW5lZCkgeF8gPSAwO1xyXG4gICAgICBpZiAoeV8gPT09IHVuZGVmaW5lZCkgeV8gPSAwO1xyXG4gICAgICB0aGlzLnggPSB4XztcclxuICAgICAgdGhpcy55ID0geV87XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5TZXRaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnggPSAwLjA7XHJcbiAgICAgIHRoaXMueSA9IDAuMDtcclxuICAgfVxyXG4gICBiMlZlYzIucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4XywgeV8pIHtcclxuICAgICAgaWYgKHhfID09PSB1bmRlZmluZWQpIHhfID0gMDtcclxuICAgICAgaWYgKHlfID09PSB1bmRlZmluZWQpIHlfID0gMDtcclxuICAgICAgdGhpcy54ID0geF87XHJcbiAgICAgIHRoaXMueSA9IHlfO1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuU2V0ViA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIHRoaXMueCA9IHYueDtcclxuICAgICAgdGhpcy55ID0gdi55O1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuR2V0TmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKCgtdGhpcy54KSwgKC10aGlzLnkpKTtcclxuICAgfVxyXG4gICBiMlZlYzIucHJvdG90eXBlLk5lZ2F0aXZlU2VsZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy54ID0gKC10aGlzLngpO1xyXG4gICAgICB0aGlzLnkgPSAoLXRoaXMueSk7XHJcbiAgIH1cclxuICAgYjJWZWMyLk1ha2UgPSBmdW5jdGlvbiAoeF8sIHlfKSB7XHJcbiAgICAgIGlmICh4XyA9PT0gdW5kZWZpbmVkKSB4XyA9IDA7XHJcbiAgICAgIGlmICh5XyA9PT0gdW5kZWZpbmVkKSB5XyA9IDA7XHJcbiAgICAgIHJldHVybiBuZXcgYjJWZWMyKHhfLCB5Xyk7XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih0aGlzLngsIHRoaXMueSk7XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5BZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuU3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICB0aGlzLnggLT0gdi54O1xyXG4gICAgICB0aGlzLnkgLT0gdi55O1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuTXVsdGlwbHkgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMDtcclxuICAgICAgdGhpcy54ICo9IGE7XHJcbiAgICAgIHRoaXMueSAqPSBhO1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuTXVsTSA9IGZ1bmN0aW9uIChBKSB7XHJcbiAgICAgIHZhciB0WCA9IHRoaXMueDtcclxuICAgICAgdGhpcy54ID0gQS5jb2wxLnggKiB0WCArIEEuY29sMi54ICogdGhpcy55O1xyXG4gICAgICB0aGlzLnkgPSBBLmNvbDEueSAqIHRYICsgQS5jb2wyLnkgKiB0aGlzLnk7XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5NdWxUTSA9IGZ1bmN0aW9uIChBKSB7XHJcbiAgICAgIHZhciB0WCA9IGIyTWF0aC5Eb3QodGhpcywgQS5jb2wxKTtcclxuICAgICAgdGhpcy55ID0gYjJNYXRoLkRvdCh0aGlzLCBBLmNvbDIpO1xyXG4gICAgICB0aGlzLnggPSB0WDtcclxuICAgfVxyXG4gICBiMlZlYzIucHJvdG90eXBlLkNyb3NzVkYgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMDtcclxuICAgICAgdmFyIHRYID0gdGhpcy54O1xyXG4gICAgICB0aGlzLnggPSBzICogdGhpcy55O1xyXG4gICAgICB0aGlzLnkgPSAoLXMgKiB0WCk7XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5Dcm9zc0ZWID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDA7XHJcbiAgICAgIHZhciB0WCA9IHRoaXMueDtcclxuICAgICAgdGhpcy54ID0gKC1zICogdGhpcy55KTtcclxuICAgICAgdGhpcy55ID0gcyAqIHRYO1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuTWluViA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHRoaXMueCA9IHRoaXMueCA8IGIueCA/IHRoaXMueCA6IGIueDtcclxuICAgICAgdGhpcy55ID0gdGhpcy55IDwgYi55ID8gdGhpcy55IDogYi55O1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuTWF4ViA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHRoaXMueCA9IHRoaXMueCA+IGIueCA/IHRoaXMueCA6IGIueDtcclxuICAgICAgdGhpcy55ID0gdGhpcy55ID4gYi55ID8gdGhpcy55IDogYi55O1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuQWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy54IDwgMCkgdGhpcy54ID0gKC10aGlzLngpO1xyXG4gICAgICBpZiAodGhpcy55IDwgMCkgdGhpcy55ID0gKC10aGlzLnkpO1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5MZW5ndGhTcXVhcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XHJcbiAgIH1cclxuICAgYjJWZWMyLnByb3RvdHlwZS5Ob3JtYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcclxuICAgICAgaWYgKGxlbmd0aCA8IE51bWJlci5NSU5fVkFMVUUpIHtcclxuICAgICAgICAgcmV0dXJuIDAuMDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW52TGVuZ3RoID0gMS4wIC8gbGVuZ3RoO1xyXG4gICAgICB0aGlzLnggKj0gaW52TGVuZ3RoO1xyXG4gICAgICB0aGlzLnkgKj0gaW52TGVuZ3RoO1xyXG4gICAgICByZXR1cm4gbGVuZ3RoO1xyXG4gICB9XHJcbiAgIGIyVmVjMi5wcm90b3R5cGUuSXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGIyTWF0aC5Jc1ZhbGlkKHRoaXMueCkgJiYgYjJNYXRoLklzVmFsaWQodGhpcy55KTtcclxuICAgfVxyXG4gICBiMlZlYzMuYjJWZWMzID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyVmVjMy5wcm90b3R5cGUuYjJWZWMzID0gZnVuY3Rpb24gKHgsIHksIHopIHtcclxuICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IDA7XHJcbiAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHkgPSAwO1xyXG4gICAgICBpZiAoeiA9PT0gdW5kZWZpbmVkKSB6ID0gMDtcclxuICAgICAgdGhpcy54ID0geDtcclxuICAgICAgdGhpcy55ID0geTtcclxuICAgICAgdGhpcy56ID0gejtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLlNldFplcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDAuMDtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XHJcbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHggPSAwO1xyXG4gICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB5ID0gMDtcclxuICAgICAgaWYgKHogPT09IHVuZGVmaW5lZCkgeiA9IDA7XHJcbiAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgIHRoaXMueiA9IHo7XHJcbiAgIH1cclxuICAgYjJWZWMzLnByb3RvdHlwZS5TZXRWID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICB0aGlzLnkgPSB2Lnk7XHJcbiAgICAgIHRoaXMueiA9IHYuejtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLkdldE5lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMygoLXRoaXMueCksICgtdGhpcy55KSwgKC10aGlzLnopKTtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLk5lZ2F0aXZlU2VsZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy54ID0gKC10aGlzLngpO1xyXG4gICAgICB0aGlzLnkgPSAoLXRoaXMueSk7XHJcbiAgICAgIHRoaXMueiA9ICgtdGhpcy56KTtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLkNvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgYjJWZWMzKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xyXG4gICB9XHJcbiAgIGIyVmVjMy5wcm90b3R5cGUuQWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgdGhpcy54ICs9IHYueDtcclxuICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgdGhpcy56ICs9IHYuejtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLlN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgdGhpcy55IC09IHYueTtcclxuICAgICAgdGhpcy56IC09IHYuejtcclxuICAgfVxyXG4gICBiMlZlYzMucHJvdG90eXBlLk11bHRpcGx5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkgYSA9IDA7XHJcbiAgICAgIHRoaXMueCAqPSBhO1xyXG4gICAgICB0aGlzLnkgKj0gYTtcclxuICAgICAgdGhpcy56ICo9IGE7XHJcbiAgIH1cclxufSkoKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgdmFyIGIyQ29udHJvbGxlckVkZ2UgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXJFZGdlLFxyXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcclxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXHJcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcclxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXHJcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXHJcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcclxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxyXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXHJcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcclxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxyXG4gICAgICBiMkFBQkIgPSBCb3gyRC5Db2xsaXNpb24uYjJBQUJCLFxyXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXHJcbiAgICAgIGIyQm91bmRWYWx1ZXMgPSBCb3gyRC5Db2xsaXNpb24uYjJCb3VuZFZhbHVlcyxcclxuICAgICAgYjJDb2xsaXNpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24sXHJcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxyXG4gICAgICBiMkNvbnRhY3RQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RQb2ludCxcclxuICAgICAgYjJEaXN0YW5jZSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLFxyXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxyXG4gICAgICBiMkRpc3RhbmNlT3V0cHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VPdXRwdXQsXHJcbiAgICAgIGIyRGlzdGFuY2VQcm94eSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHksXHJcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcclxuICAgICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UsXHJcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlLFxyXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcclxuICAgICAgYjJNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkLFxyXG4gICAgICBiMk1hbmlmb2xkUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50LFxyXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXHJcbiAgICAgIGIyUmF5Q2FzdElucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyUmF5Q2FzdElucHV0LFxyXG4gICAgICBiMlJheUNhc3RPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0LFxyXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxyXG4gICAgICBiMlNlcGFyYXRpb25GdW5jdGlvbiA9IEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbixcclxuICAgICAgYjJTaW1wbGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCxcclxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXHJcbiAgICAgIGIyU2ltcGxleFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhWZXJ0ZXgsXHJcbiAgICAgIGIyVGltZU9mSW1wYWN0ID0gQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LFxyXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXHJcbiAgICAgIGIyV29ybGRNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMldvcmxkTWFuaWZvbGQsXHJcbiAgICAgIENsaXBWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCxcclxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXHJcbiAgICAgIElCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLklCcm9hZFBoYXNlLFxyXG4gICAgICBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxyXG4gICAgICBiMkVkZ2VDaGFpbkRlZiA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYsXHJcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcclxuICAgICAgYjJNYXNzRGF0YSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSxcclxuICAgICAgYjJQb2x5Z29uU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLFxyXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxyXG4gICAgICBiMkJvZHkgPSBCb3gyRC5EeW5hbWljcy5iMkJvZHksXHJcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcclxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxyXG4gICAgICBiMkNvbnRhY3RJbXB1bHNlID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0SW1wdWxzZSxcclxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcclxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXHJcbiAgICAgIGIyRGVidWdEcmF3ID0gQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcsXHJcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcclxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxyXG4gICAgICBiMkZpeHR1cmUgPSBCb3gyRC5EeW5hbWljcy5iMkZpeHR1cmUsXHJcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcclxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcclxuICAgICAgYjJUaW1lU3RlcCA9IEJveDJELkR5bmFtaWNzLmIyVGltZVN0ZXAsXHJcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxyXG4gICAgICBiMkNpcmNsZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNpcmNsZUNvbnRhY3QsXHJcbiAgICAgIGIyQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCxcclxuICAgICAgYjJDb250YWN0Q29uc3RyYWludCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnQsXHJcbiAgICAgIGIyQ29udGFjdENvbnN0cmFpbnRQb2ludCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdENvbnN0cmFpbnRQb2ludCxcclxuICAgICAgYjJDb250YWN0RWRnZSA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdEVkZ2UsXHJcbiAgICAgIGIyQ29udGFjdEZhY3RvcnkgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RGYWN0b3J5LFxyXG4gICAgICBiMkNvbnRhY3RSZWdpc3RlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlZ2lzdGVyLFxyXG4gICAgICBiMkNvbnRhY3RSZXN1bHQgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RSZXN1bHQsXHJcbiAgICAgIGIyQ29udGFjdFNvbHZlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFNvbHZlcixcclxuICAgICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyRWRnZUFuZENpcmNsZUNvbnRhY3QsXHJcbiAgICAgIGIyTnVsbENvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMk51bGxDb250YWN0LFxyXG4gICAgICBiMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5QW5kQ2lyY2xlQ29udGFjdCxcclxuICAgICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlBbmRFZGdlQ29udGFjdCxcclxuICAgICAgYjJQb2x5Z29uQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9seWdvbkNvbnRhY3QsXHJcbiAgICAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZCxcclxuICAgICAgYjJDb250cm9sbGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLFxyXG4gICAgICBiMkRpc3RhbmNlSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50LFxyXG4gICAgICBiMkRpc3RhbmNlSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJEaXN0YW5jZUpvaW50RGVmLFxyXG4gICAgICBiMkZyaWN0aW9uSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJGcmljdGlvbkpvaW50LFxyXG4gICAgICBiMkZyaWN0aW9uSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJGcmljdGlvbkpvaW50RGVmLFxyXG4gICAgICBiMkdlYXJKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludCxcclxuICAgICAgYjJHZWFySm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJHZWFySm9pbnREZWYsXHJcbiAgICAgIGIySmFjb2JpYW4gPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKYWNvYmlhbixcclxuICAgICAgYjJKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LFxyXG4gICAgICBiMkpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYsXHJcbiAgICAgIGIySm9pbnRFZGdlID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnRFZGdlLFxyXG4gICAgICBiMkxpbmVKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludCxcclxuICAgICAgYjJMaW5lSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJMaW5lSm9pbnREZWYsXHJcbiAgICAgIGIyTW91c2VKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnQsXHJcbiAgICAgIGIyTW91c2VKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMk1vdXNlSm9pbnREZWYsXHJcbiAgICAgIGIyUHJpc21hdGljSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQcmlzbWF0aWNKb2ludCxcclxuICAgICAgYjJQcmlzbWF0aWNKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50RGVmLFxyXG4gICAgICBiMlB1bGxleUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQsXHJcbiAgICAgIGIyUHVsbGV5Sm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQdWxsZXlKb2ludERlZixcclxuICAgICAgYjJSZXZvbHV0ZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludCxcclxuICAgICAgYjJSZXZvbHV0ZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUmV2b2x1dGVKb2ludERlZixcclxuICAgICAgYjJXZWxkSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJXZWxkSm9pbnQsXHJcbiAgICAgIGIyV2VsZEpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyV2VsZEpvaW50RGVmO1xyXG5cclxuICAgYjJCb2R5LmIyQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX3hmID0gbmV3IGIyVHJhbnNmb3JtKCk7XHJcbiAgICAgIHRoaXMubV9zd2VlcCA9IG5ldyBiMlN3ZWVwKCk7XHJcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2ZvcmNlID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMkJvZHkucHJvdG90eXBlLmNvbm5lY3RFZGdlcyA9IGZ1bmN0aW9uIChzMSwgczIsIGFuZ2xlMSkge1xyXG4gICAgICBpZiAoYW5nbGUxID09PSB1bmRlZmluZWQpIGFuZ2xlMSA9IDA7XHJcbiAgICAgIHZhciBhbmdsZTIgPSBNYXRoLmF0YW4yKHMyLkdldERpcmVjdGlvblZlY3RvcigpLnksIHMyLkdldERpcmVjdGlvblZlY3RvcigpLngpO1xyXG4gICAgICB2YXIgY29yZU9mZnNldCA9IE1hdGgudGFuKChhbmdsZTIgLSBhbmdsZTEpICogMC41KTtcclxuICAgICAgdmFyIGNvcmUgPSBiMk1hdGguTXVsRlYoY29yZU9mZnNldCwgczIuR2V0RGlyZWN0aW9uVmVjdG9yKCkpO1xyXG4gICAgICBjb3JlID0gYjJNYXRoLlN1YnRyYWN0VlYoY29yZSwgczIuR2V0Tm9ybWFsVmVjdG9yKCkpO1xyXG4gICAgICBjb3JlID0gYjJNYXRoLk11bEZWKGIyU2V0dGluZ3MuYjJfdG9pU2xvcCwgY29yZSk7XHJcbiAgICAgIGNvcmUgPSBiMk1hdGguQWRkVlYoY29yZSwgczIuR2V0VmVydGV4MSgpKTtcclxuICAgICAgdmFyIGNvcm5lckRpciA9IGIyTWF0aC5BZGRWVihzMS5HZXREaXJlY3Rpb25WZWN0b3IoKSwgczIuR2V0RGlyZWN0aW9uVmVjdG9yKCkpO1xyXG4gICAgICBjb3JuZXJEaXIuTm9ybWFsaXplKCk7XHJcbiAgICAgIHZhciBjb252ZXggPSBiMk1hdGguRG90KHMxLkdldERpcmVjdGlvblZlY3RvcigpLCBzMi5HZXROb3JtYWxWZWN0b3IoKSkgPiAwLjA7XHJcbiAgICAgIHMxLlNldE5leHRFZGdlKHMyLCBjb3JlLCBjb3JuZXJEaXIsIGNvbnZleCk7XHJcbiAgICAgIHMyLlNldFByZXZFZGdlKHMxLCBjb3JlLCBjb3JuZXJEaXIsIGNvbnZleCk7XHJcbiAgICAgIHJldHVybiBhbmdsZTI7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5DcmVhdGVGaXh0dXJlID0gZnVuY3Rpb24gKGRlZikge1xyXG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZml4dHVyZSA9IG5ldyBiMkZpeHR1cmUoKTtcclxuICAgICAgZml4dHVyZS5DcmVhdGUodGhpcywgdGhpcy5tX3hmLCBkZWYpO1xyXG4gICAgICBpZiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYWN0aXZlRmxhZykge1xyXG4gICAgICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcclxuICAgICAgICAgZml4dHVyZS5DcmVhdGVQcm94eShicm9hZFBoYXNlLCB0aGlzLm1feGYpO1xyXG4gICAgICB9XHJcbiAgICAgIGZpeHR1cmUubV9uZXh0ID0gdGhpcy5tX2ZpeHR1cmVMaXN0O1xyXG4gICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBmaXh0dXJlO1xyXG4gICAgICArK3RoaXMubV9maXh0dXJlQ291bnQ7XHJcbiAgICAgIGZpeHR1cmUubV9ib2R5ID0gdGhpcztcclxuICAgICAgaWYgKGZpeHR1cmUubV9kZW5zaXR5ID4gMC4wKSB7XHJcbiAgICAgICAgIHRoaXMuUmVzZXRNYXNzRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV93b3JsZC5tX2ZsYWdzIHw9IGIyV29ybGQuZV9uZXdGaXh0dXJlO1xyXG4gICAgICByZXR1cm4gZml4dHVyZTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkNyZWF0ZUZpeHR1cmUyID0gZnVuY3Rpb24gKHNoYXBlLCBkZW5zaXR5KSB7XHJcbiAgICAgIGlmIChkZW5zaXR5ID09PSB1bmRlZmluZWQpIGRlbnNpdHkgPSAwLjA7XHJcbiAgICAgIHZhciBkZWYgPSBuZXcgYjJGaXh0dXJlRGVmKCk7XHJcbiAgICAgIGRlZi5zaGFwZSA9IHNoYXBlO1xyXG4gICAgICBkZWYuZGVuc2l0eSA9IGRlbnNpdHk7XHJcbiAgICAgIHJldHVybiB0aGlzLkNyZWF0ZUZpeHR1cmUoZGVmKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkRlc3Ryb3lGaXh0dXJlID0gZnVuY3Rpb24gKGZpeHR1cmUpIHtcclxuICAgICAgaWYgKHRoaXMubV93b3JsZC5Jc0xvY2tlZCgpID09IHRydWUpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBub2RlID0gdGhpcy5tX2ZpeHR1cmVMaXN0O1xyXG4gICAgICB2YXIgcHBGID0gbnVsbDtcclxuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAgaWYgKG5vZGUgPT0gZml4dHVyZSkge1xyXG4gICAgICAgICAgICBpZiAocHBGKSBwcEYubV9uZXh0ID0gZml4dHVyZS5tX25leHQ7XHJcbiAgICAgICAgICAgIGVsc2UgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZml4dHVyZS5tX25leHQ7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgcHBGID0gbm9kZTtcclxuICAgICAgICAgbm9kZSA9IG5vZGUubV9uZXh0O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBlZGdlID0gdGhpcy5tX2NvbnRhY3RMaXN0O1xyXG4gICAgICB3aGlsZSAoZWRnZSkge1xyXG4gICAgICAgICB2YXIgYyA9IGVkZ2UuY29udGFjdDtcclxuICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcclxuICAgICAgICAgdmFyIGZpeHR1cmVBID0gYy5HZXRGaXh0dXJlQSgpO1xyXG4gICAgICAgICB2YXIgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XHJcbiAgICAgICAgIGlmIChmaXh0dXJlID09IGZpeHR1cmVBIHx8IGZpeHR1cmUgPT0gZml4dHVyZUIpIHtcclxuICAgICAgICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIuRGVzdHJveShjKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9hY3RpdmVGbGFnKSB7XHJcbiAgICAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xyXG4gICAgICAgICBmaXh0dXJlLkRlc3Ryb3lQcm94eShicm9hZFBoYXNlKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHt9XHJcbiAgICAgIGZpeHR1cmUuRGVzdHJveSgpO1xyXG4gICAgICBmaXh0dXJlLm1fYm9keSA9IG51bGw7XHJcbiAgICAgIGZpeHR1cmUubV9uZXh0ID0gbnVsbDtcclxuICAgICAgLS10aGlzLm1fZml4dHVyZUNvdW50O1xyXG4gICAgICB0aGlzLlJlc2V0TWFzc0RhdGEoKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldFBvc2l0aW9uQW5kQW5nbGUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGFuZ2xlKSB7XHJcbiAgICAgIGlmIChhbmdsZSA9PT0gdW5kZWZpbmVkKSBhbmdsZSA9IDA7XHJcbiAgICAgIHZhciBmO1xyXG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX3hmLlIuU2V0KGFuZ2xlKTtcclxuICAgICAgdGhpcy5tX3hmLnBvc2l0aW9uLlNldFYocG9zaXRpb24pO1xyXG4gICAgICB2YXIgdE1hdCA9IHRoaXMubV94Zi5SO1xyXG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMueCA9ICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMueSA9ICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMueCArPSB0aGlzLm1feGYucG9zaXRpb24ueDtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMwLlNldFYodGhpcy5tX3N3ZWVwLmMpO1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYTAgPSB0aGlzLm1fc3dlZXAuYSA9IGFuZ2xlO1xyXG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcclxuICAgICAgZm9yIChmID0gdGhpcy5tX2ZpeHR1cmVMaXN0O1xyXG4gICAgICBmOyBmID0gZi5tX25leHQpIHtcclxuICAgICAgICAgZi5TeW5jaHJvbml6ZShicm9hZFBoYXNlLCB0aGlzLm1feGYsIHRoaXMubV94Zik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoeGYpIHtcclxuICAgICAgdGhpcy5TZXRQb3NpdGlvbkFuZEFuZ2xlKHhmLnBvc2l0aW9uLCB4Zi5HZXRBbmdsZSgpKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV94ZjtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3hmLnBvc2l0aW9uO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgdGhpcy5TZXRQb3NpdGlvbkFuZEFuZ2xlKHBvc2l0aW9uLCB0aGlzLkdldEFuZ2xlKCkpO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0QW5nbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fc3dlZXAuYTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldEFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgIGlmIChhbmdsZSA9PT0gdW5kZWZpbmVkKSBhbmdsZSA9IDA7XHJcbiAgICAgIHRoaXMuU2V0UG9zaXRpb25BbmRBbmdsZSh0aGlzLkdldFBvc2l0aW9uKCksIGFuZ2xlKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkQ2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3N3ZWVwLmM7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMb2NhbENlbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkuU2V0Vih2KTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldExpbmVhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gKG9tZWdhKSB7XHJcbiAgICAgIGlmIChvbWVnYSA9PT0gdW5kZWZpbmVkKSBvbWVnYSA9IDA7XHJcbiAgICAgIGlmICh0aGlzLm1fdHlwZSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IG9tZWdhO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldERlZmluaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiZCA9IG5ldyBiMkJvZHlEZWYoKTtcclxuICAgICAgYmQudHlwZSA9IHRoaXMuR2V0VHlwZSgpO1xyXG4gICAgICBiZC5hbGxvd1NsZWVwID0gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2FsbG93U2xlZXBGbGFnKSA9PSBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZztcclxuICAgICAgYmQuYW5nbGUgPSB0aGlzLkdldEFuZ2xlKCk7XHJcbiAgICAgIGJkLmFuZ3VsYXJEYW1waW5nID0gdGhpcy5tX2FuZ3VsYXJEYW1waW5nO1xyXG4gICAgICBiZC5hbmd1bGFyVmVsb2NpdHkgPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICBiZC5maXhlZFJvdGF0aW9uID0gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnKSA9PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcclxuICAgICAgYmQuYnVsbGV0ID0gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2J1bGxldEZsYWcpID09IGIyQm9keS5lX2J1bGxldEZsYWc7XHJcbiAgICAgIGJkLmF3YWtlID0gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2F3YWtlRmxhZykgPT0gYjJCb2R5LmVfYXdha2VGbGFnO1xyXG4gICAgICBiZC5saW5lYXJEYW1waW5nID0gdGhpcy5tX2xpbmVhckRhbXBpbmc7XHJcbiAgICAgIGJkLmxpbmVhclZlbG9jaXR5LlNldFYodGhpcy5HZXRMaW5lYXJWZWxvY2l0eSgpKTtcclxuICAgICAgYmQucG9zaXRpb24gPSB0aGlzLkdldFBvc2l0aW9uKCk7XHJcbiAgICAgIGJkLnVzZXJEYXRhID0gdGhpcy5HZXRVc2VyRGF0YSgpO1xyXG4gICAgICByZXR1cm4gYmQ7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5BcHBseUZvcmNlID0gZnVuY3Rpb24gKGZvcmNlLCBwb2ludCkge1xyXG4gICAgICBpZiAodGhpcy5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5Jc0F3YWtlKCkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgdGhpcy5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fZm9yY2UueCArPSBmb3JjZS54O1xyXG4gICAgICB0aGlzLm1fZm9yY2UueSArPSBmb3JjZS55O1xyXG4gICAgICB0aGlzLm1fdG9ycXVlICs9ICgocG9pbnQueCAtIHRoaXMubV9zd2VlcC5jLngpICogZm9yY2UueSAtIChwb2ludC55IC0gdGhpcy5tX3N3ZWVwLmMueSkgKiBmb3JjZS54KTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkFwcGx5VG9ycXVlID0gZnVuY3Rpb24gKHRvcnF1ZSkge1xyXG4gICAgICBpZiAodG9ycXVlID09PSB1bmRlZmluZWQpIHRvcnF1ZSA9IDA7XHJcbiAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLklzQXdha2UoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICB0aGlzLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV90b3JxdWUgKz0gdG9ycXVlO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuQXBwbHlJbXB1bHNlID0gZnVuY3Rpb24gKGltcHVsc2UsIHBvaW50KSB7XHJcbiAgICAgIGlmICh0aGlzLm1fdHlwZSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLklzQXdha2UoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICB0aGlzLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS54ICs9IHRoaXMubV9pbnZNYXNzICogaW1wdWxzZS54O1xyXG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1faW52TWFzcyAqIGltcHVsc2UueTtcclxuICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLm1faW52SSAqICgocG9pbnQueCAtIHRoaXMubV9zd2VlcC5jLngpICogaW1wdWxzZS55IC0gKHBvaW50LnkgLSB0aGlzLm1fc3dlZXAuYy55KSAqIGltcHVsc2UueCk7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5TcGxpdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICB2YXIgbGluZWFyVmVsb2NpdHkgPSB0aGlzLkdldExpbmVhclZlbG9jaXR5KCkuQ29weSgpO1xyXG4gICAgICB2YXIgYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5HZXRBbmd1bGFyVmVsb2NpdHkoKTtcclxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuR2V0V29ybGRDZW50ZXIoKTtcclxuICAgICAgdmFyIGJvZHkxID0gdGhpcztcclxuICAgICAgdmFyIGJvZHkyID0gdGhpcy5tX3dvcmxkLkNyZWF0ZUJvZHkodGhpcy5HZXREZWZpbml0aW9uKCkpO1xyXG4gICAgICB2YXIgcHJldjtcclxuICAgICAgZm9yICh2YXIgZiA9IGJvZHkxLm1fZml4dHVyZUxpc3Q7IGY7KSB7XHJcbiAgICAgICAgIGlmIChjYWxsYmFjayhmKSkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGYubV9uZXh0O1xyXG4gICAgICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICAgICBwcmV2Lm1fbmV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGJvZHkxLm1fZml4dHVyZUxpc3QgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvZHkxLm1fZml4dHVyZUNvdW50LS07XHJcbiAgICAgICAgICAgIGYubV9uZXh0ID0gYm9keTIubV9maXh0dXJlTGlzdDtcclxuICAgICAgICAgICAgYm9keTIubV9maXh0dXJlTGlzdCA9IGY7XHJcbiAgICAgICAgICAgIGJvZHkyLm1fZml4dHVyZUNvdW50Kys7XHJcbiAgICAgICAgICAgIGYubV9ib2R5ID0gYm9keTI7XHJcbiAgICAgICAgICAgIGYgPSBuZXh0O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2ID0gZjtcclxuICAgICAgICAgICAgZiA9IGYubV9uZXh0O1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYm9keTEuUmVzZXRNYXNzRGF0YSgpO1xyXG4gICAgICBib2R5Mi5SZXNldE1hc3NEYXRhKCk7XHJcbiAgICAgIHZhciBjZW50ZXIxID0gYm9keTEuR2V0V29ybGRDZW50ZXIoKTtcclxuICAgICAgdmFyIGNlbnRlcjIgPSBib2R5Mi5HZXRXb3JsZENlbnRlcigpO1xyXG4gICAgICB2YXIgdmVsb2NpdHkxID0gYjJNYXRoLkFkZFZWKGxpbmVhclZlbG9jaXR5LCBiMk1hdGguQ3Jvc3NGVihhbmd1bGFyVmVsb2NpdHksIGIyTWF0aC5TdWJ0cmFjdFZWKGNlbnRlcjEsIGNlbnRlcikpKTtcclxuICAgICAgdmFyIHZlbG9jaXR5MiA9IGIyTWF0aC5BZGRWVihsaW5lYXJWZWxvY2l0eSwgYjJNYXRoLkNyb3NzRlYoYW5ndWxhclZlbG9jaXR5LCBiMk1hdGguU3VidHJhY3RWVihjZW50ZXIyLCBjZW50ZXIpKSk7XHJcbiAgICAgIGJvZHkxLlNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5MSk7XHJcbiAgICAgIGJvZHkyLlNldExpbmVhclZlbG9jaXR5KHZlbG9jaXR5Mik7XHJcbiAgICAgIGJvZHkxLlNldEFuZ3VsYXJWZWxvY2l0eShhbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgICBib2R5Mi5TZXRBbmd1bGFyVmVsb2NpdHkoYW5ndWxhclZlbG9jaXR5KTtcclxuICAgICAgYm9keTEuU3luY2hyb25pemVGaXh0dXJlcygpO1xyXG4gICAgICBib2R5Mi5TeW5jaHJvbml6ZUZpeHR1cmVzKCk7XHJcbiAgICAgIHJldHVybiBib2R5MjtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLk1lcmdlID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgIHZhciBmO1xyXG4gICAgICBmb3IgKGYgPSBvdGhlci5tX2ZpeHR1cmVMaXN0O1xyXG4gICAgICBmOykge1xyXG4gICAgICAgICB2YXIgbmV4dCA9IGYubV9uZXh0O1xyXG4gICAgICAgICBvdGhlci5tX2ZpeHR1cmVDb3VudC0tO1xyXG4gICAgICAgICBmLm1fbmV4dCA9IHRoaXMubV9maXh0dXJlTGlzdDtcclxuICAgICAgICAgdGhpcy5tX2ZpeHR1cmVMaXN0ID0gZjtcclxuICAgICAgICAgdGhpcy5tX2ZpeHR1cmVDb3VudCsrO1xyXG4gICAgICAgICBmLm1fYm9keSA9IGJvZHkyO1xyXG4gICAgICAgICBmID0gbmV4dDtcclxuICAgICAgfVxyXG4gICAgICBib2R5MS5tX2ZpeHR1cmVDb3VudCA9IDA7XHJcbiAgICAgIHZhciBib2R5MSA9IHRoaXM7XHJcbiAgICAgIHZhciBib2R5MiA9IG90aGVyO1xyXG4gICAgICB2YXIgY2VudGVyMSA9IGJvZHkxLkdldFdvcmxkQ2VudGVyKCk7XHJcbiAgICAgIHZhciBjZW50ZXIyID0gYm9keTIuR2V0V29ybGRDZW50ZXIoKTtcclxuICAgICAgdmFyIHZlbG9jaXR5MSA9IGJvZHkxLkdldExpbmVhclZlbG9jaXR5KCkuQ29weSgpO1xyXG4gICAgICB2YXIgdmVsb2NpdHkyID0gYm9keTIuR2V0TGluZWFyVmVsb2NpdHkoKS5Db3B5KCk7XHJcbiAgICAgIHZhciBhbmd1bGFyMSA9IGJvZHkxLkdldEFuZ3VsYXJWZWxvY2l0eSgpO1xyXG4gICAgICB2YXIgYW5ndWxhciA9IGJvZHkyLkdldEFuZ3VsYXJWZWxvY2l0eSgpO1xyXG4gICAgICBib2R5MS5SZXNldE1hc3NEYXRhKCk7XHJcbiAgICAgIHRoaXMuU3luY2hyb25pemVGaXh0dXJlcygpO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TWFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9tYXNzO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0SW5lcnRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9JO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICBkYXRhLm1hc3MgPSB0aGlzLm1fbWFzcztcclxuICAgICAgZGF0YS5JID0gdGhpcy5tX0k7XHJcbiAgICAgIGRhdGEuY2VudGVyLlNldFYodGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldE1hc3NEYXRhID0gZnVuY3Rpb24gKG1hc3NEYXRhKSB7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gZmFsc2UpO1xyXG4gICAgICBpZiAodGhpcy5tX3dvcmxkLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV90eXBlICE9IGIyQm9keS5iMl9keW5hbWljQm9keSkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX2ludk1hc3MgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9JID0gMC4wO1xyXG4gICAgICB0aGlzLm1faW52SSA9IDAuMDtcclxuICAgICAgdGhpcy5tX21hc3MgPSBtYXNzRGF0YS5tYXNzO1xyXG4gICAgICBpZiAodGhpcy5tX21hc3MgPD0gMC4wKSB7XHJcbiAgICAgICAgIHRoaXMubV9tYXNzID0gMS4wO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9pbnZNYXNzID0gMS4wIC8gdGhpcy5tX21hc3M7XHJcbiAgICAgIGlmIChtYXNzRGF0YS5JID4gMC4wICYmICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZykgPT0gMCkge1xyXG4gICAgICAgICB0aGlzLm1fSSA9IG1hc3NEYXRhLkkgLSB0aGlzLm1fbWFzcyAqIChtYXNzRGF0YS5jZW50ZXIueCAqIG1hc3NEYXRhLmNlbnRlci54ICsgbWFzc0RhdGEuY2VudGVyLnkgKiBtYXNzRGF0YS5jZW50ZXIueSk7XHJcbiAgICAgICAgIHRoaXMubV9pbnZJID0gMS4wIC8gdGhpcy5tX0k7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG9sZENlbnRlciA9IHRoaXMubV9zd2VlcC5jLkNvcHkoKTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyLlNldFYobWFzc0RhdGEuY2VudGVyKTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMwLlNldFYoYjJNYXRoLk11bFgodGhpcy5tX3hmLCB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIpKTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMuU2V0Vih0aGlzLm1fc3dlZXAuYzApO1xyXG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueCArPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKC0odGhpcy5tX3N3ZWVwLmMueSAtIG9sZENlbnRlci55KSk7XHJcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS55ICs9IHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAoKyh0aGlzLm1fc3dlZXAuYy54IC0gb2xkQ2VudGVyLngpKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlJlc2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV9tYXNzID0gMC4wO1xyXG4gICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcclxuICAgICAgdGhpcy5tX0kgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9pbnZJID0gMC4wO1xyXG4gICAgICB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIuU2V0WmVybygpO1xyXG4gICAgICBpZiAodGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkgfHwgdGhpcy5tX3R5cGUgPT0gYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjZW50ZXIgPSBiMlZlYzIuTWFrZSgwLCAwKTtcclxuICAgICAgZm9yICh2YXIgZiA9IHRoaXMubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XHJcbiAgICAgICAgIGlmIChmLm1fZGVuc2l0eSA9PSAwLjApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIG1hc3NEYXRhID0gZi5HZXRNYXNzRGF0YSgpO1xyXG4gICAgICAgICB0aGlzLm1fbWFzcyArPSBtYXNzRGF0YS5tYXNzO1xyXG4gICAgICAgICBjZW50ZXIueCArPSBtYXNzRGF0YS5jZW50ZXIueCAqIG1hc3NEYXRhLm1hc3M7XHJcbiAgICAgICAgIGNlbnRlci55ICs9IG1hc3NEYXRhLmNlbnRlci55ICogbWFzc0RhdGEubWFzcztcclxuICAgICAgICAgdGhpcy5tX0kgKz0gbWFzc0RhdGEuSTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5tX21hc3MgPiAwLjApIHtcclxuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjAgLyB0aGlzLm1fbWFzcztcclxuICAgICAgICAgY2VudGVyLnggKj0gdGhpcy5tX2ludk1hc3M7XHJcbiAgICAgICAgIGNlbnRlci55ICo9IHRoaXMubV9pbnZNYXNzO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcclxuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9JID4gMC4wICYmICh0aGlzLm1fZmxhZ3MgJiBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZykgPT0gMCkge1xyXG4gICAgICAgICB0aGlzLm1fSSAtPSB0aGlzLm1fbWFzcyAqIChjZW50ZXIueCAqIGNlbnRlci54ICsgY2VudGVyLnkgKiBjZW50ZXIueSk7XHJcbiAgICAgICAgIHRoaXMubV9JICo9IHRoaXMubV9pbmVydGlhU2NhbGU7XHJcbiAgICAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQodGhpcy5tX0kgPiAwKTtcclxuICAgICAgICAgdGhpcy5tX2ludkkgPSAxLjAgLyB0aGlzLm1fSTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX0kgPSAwLjA7XHJcbiAgICAgICAgIHRoaXMubV9pbnZJID0gMC4wO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBvbGRDZW50ZXIgPSB0aGlzLm1fc3dlZXAuYy5Db3B5KCk7XHJcbiAgICAgIHRoaXMubV9zd2VlcC5sb2NhbENlbnRlci5TZXRWKGNlbnRlcik7XHJcbiAgICAgIHRoaXMubV9zd2VlcC5jMC5TZXRWKGIyTWF0aC5NdWxYKHRoaXMubV94ZiwgdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyKSk7XHJcbiAgICAgIHRoaXMubV9zd2VlcC5jLlNldFYodGhpcy5tX3N3ZWVwLmMwKTtcclxuICAgICAgdGhpcy5tX2xpbmVhclZlbG9jaXR5LnggKz0gdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSAqICgtKHRoaXMubV9zd2VlcC5jLnkgLSBvbGRDZW50ZXIueSkpO1xyXG4gICAgICB0aGlzLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKCsodGhpcy5tX3N3ZWVwLmMueCAtIG9sZENlbnRlci54KSk7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRXb3JsZFBvaW50ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgdmFyIEEgPSB0aGlzLm1feGYuUjtcclxuICAgICAgdmFyIHUgPSBuZXcgYjJWZWMyKEEuY29sMS54ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnggKiBsb2NhbFBvaW50LnksIEEuY29sMS55ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnkgKiBsb2NhbFBvaW50LnkpO1xyXG4gICAgICB1LnggKz0gdGhpcy5tX3hmLnBvc2l0aW9uLng7XHJcbiAgICAgIHUueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcclxuICAgICAgcmV0dXJuIHU7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRXb3JsZFZlY3RvciA9IGZ1bmN0aW9uIChsb2NhbFZlY3Rvcikge1xyXG4gICAgICByZXR1cm4gYjJNYXRoLk11bE1WKHRoaXMubV94Zi5SLCBsb2NhbFZlY3Rvcik7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMb2NhbFBvaW50ID0gZnVuY3Rpb24gKHdvcmxkUG9pbnQpIHtcclxuICAgICAgcmV0dXJuIGIyTWF0aC5NdWxYVCh0aGlzLm1feGYsIHdvcmxkUG9pbnQpO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TG9jYWxWZWN0b3IgPSBmdW5jdGlvbiAod29ybGRWZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIGIyTWF0aC5NdWxUTVYodGhpcy5tX3hmLlIsIHdvcmxkVmVjdG9yKTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldExpbmVhclZlbG9jaXR5RnJvbVdvcmxkUG9pbnQgPSBmdW5jdGlvbiAod29ybGRQb2ludCkge1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMih0aGlzLm1fbGluZWFyVmVsb2NpdHkueCAtIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAod29ybGRQb2ludC55IC0gdGhpcy5tX3N3ZWVwLmMueSksIHRoaXMubV9saW5lYXJWZWxvY2l0eS55ICsgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSAqICh3b3JsZFBvaW50LnggLSB0aGlzLm1fc3dlZXAuYy54KSk7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRMaW5lYXJWZWxvY2l0eUZyb21Mb2NhbFBvaW50ID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQpIHtcclxuICAgICAgdmFyIEEgPSB0aGlzLm1feGYuUjtcclxuICAgICAgdmFyIHdvcmxkUG9pbnQgPSBuZXcgYjJWZWMyKEEuY29sMS54ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnggKiBsb2NhbFBvaW50LnksIEEuY29sMS55ICogbG9jYWxQb2ludC54ICsgQS5jb2wyLnkgKiBsb2NhbFBvaW50LnkpO1xyXG4gICAgICB3b3JsZFBvaW50LnggKz0gdGhpcy5tX3hmLnBvc2l0aW9uLng7XHJcbiAgICAgIHdvcmxkUG9pbnQueSArPSB0aGlzLm1feGYucG9zaXRpb24ueTtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIodGhpcy5tX2xpbmVhclZlbG9jaXR5LnggLSB0aGlzLm1fYW5ndWxhclZlbG9jaXR5ICogKHdvcmxkUG9pbnQueSAtIHRoaXMubV9zd2VlcC5jLnkpLCB0aGlzLm1fbGluZWFyVmVsb2NpdHkueSArIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgKiAod29ybGRQb2ludC54IC0gdGhpcy5tX3N3ZWVwLmMueCkpO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9saW5lYXJEYW1waW5nO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0TGluZWFyRGFtcGluZyA9IGZ1bmN0aW9uIChsaW5lYXJEYW1waW5nKSB7XHJcbiAgICAgIGlmIChsaW5lYXJEYW1waW5nID09PSB1bmRlZmluZWQpIGxpbmVhckRhbXBpbmcgPSAwO1xyXG4gICAgICB0aGlzLm1fbGluZWFyRGFtcGluZyA9IGxpbmVhckRhbXBpbmc7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRBbmd1bGFyRGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9hbmd1bGFyRGFtcGluZztcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldEFuZ3VsYXJEYW1waW5nID0gZnVuY3Rpb24gKGFuZ3VsYXJEYW1waW5nKSB7XHJcbiAgICAgIGlmIChhbmd1bGFyRGFtcGluZyA9PT0gdW5kZWZpbmVkKSBhbmd1bGFyRGFtcGluZyA9IDA7XHJcbiAgICAgIHRoaXMubV9hbmd1bGFyRGFtcGluZyA9IGFuZ3VsYXJEYW1waW5nO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHR5cGUgPSAwO1xyXG4gICAgICBpZiAodGhpcy5tX3R5cGUgPT0gdHlwZSkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX3R5cGUgPSB0eXBlO1xyXG4gICAgICB0aGlzLlJlc2V0TWFzc0RhdGEoKTtcclxuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XHJcbiAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRaZXJvKCk7XHJcbiAgICAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2ZvcmNlLlNldFplcm8oKTtcclxuICAgICAgdGhpcy5tX3RvcnF1ZSA9IDAuMDtcclxuICAgICAgZm9yICh2YXIgY2UgPSB0aGlzLm1fY29udGFjdExpc3Q7IGNlOyBjZSA9IGNlLm5leHQpIHtcclxuICAgICAgICAgY2UuY29udGFjdC5GbGFnRm9yRmlsdGVyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fdHlwZTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldEJ1bGxldCA9IGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgIGlmIChmbGFnKSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9idWxsZXRGbGFnO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2J1bGxldEZsYWc7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLklzQnVsbGV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2J1bGxldEZsYWcpID09IGIyQm9keS5lX2J1bGxldEZsYWc7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRTbGVlcGluZ0FsbG93ZWQgPSBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICBpZiAoZmxhZykge1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XHJcbiAgICAgICAgIHRoaXMuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldEF3YWtlID0gZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgaWYgKGZsYWcpIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQm9keS5lX2F3YWtlRmxhZztcclxuICAgICAgICAgdGhpcy5tX3NsZWVwVGltZSA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9hd2FrZUZsYWc7XHJcbiAgICAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XHJcbiAgICAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRaZXJvKCk7XHJcbiAgICAgICAgIHRoaXMubV9hbmd1bGFyVmVsb2NpdHkgPSAwLjA7XHJcbiAgICAgICAgIHRoaXMubV9mb3JjZS5TZXRaZXJvKCk7XHJcbiAgICAgICAgIHRoaXMubV90b3JxdWUgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLklzQXdha2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYXdha2VGbGFnKSA9PSBiMkJvZHkuZV9hd2FrZUZsYWc7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5TZXRGaXhlZFJvdGF0aW9uID0gZnVuY3Rpb24gKGZpeGVkKSB7XHJcbiAgICAgIGlmIChmaXhlZCkge1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5SZXNldE1hc3NEYXRhKCk7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5Jc0ZpeGVkUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWcpID09IGIyQm9keS5lX2ZpeGVkUm90YXRpb25GbGFnO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuU2V0QWN0aXZlID0gZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgaWYgKGZsYWcgPT0gdGhpcy5Jc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYnJvYWRQaGFzZTtcclxuICAgICAgdmFyIGY7XHJcbiAgICAgIGlmIChmbGFnKSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9hY3RpdmVGbGFnO1xyXG4gICAgICAgICBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xyXG4gICAgICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XHJcbiAgICAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xyXG4gICAgICAgICAgICBmLkNyZWF0ZVByb3h5KGJyb2FkUGhhc2UsIHRoaXMubV94Zik7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkJvZHkuZV9hY3RpdmVGbGFnO1xyXG4gICAgICAgICBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xyXG4gICAgICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XHJcbiAgICAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xyXG4gICAgICAgICAgICBmLkRlc3Ryb3lQcm94eShicm9hZFBoYXNlKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgY2UgPSB0aGlzLm1fY29udGFjdExpc3Q7XHJcbiAgICAgICAgIHdoaWxlIChjZSkge1xyXG4gICAgICAgICAgICB2YXIgY2UwID0gY2U7XHJcbiAgICAgICAgICAgIGNlID0gY2UubmV4dDtcclxuICAgICAgICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIuRGVzdHJveShjZTAuY29udGFjdCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuSXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJCb2R5LmVfYWN0aXZlRmxhZykgPT0gYjJCb2R5LmVfYWN0aXZlRmxhZztcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLklzU2xlZXBpbmdBbGxvd2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMubV9mbGFncyAmIGIyQm9keS5lX2FsbG93U2xlZXBGbGFnKSA9PSBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZztcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldEZpeHR1cmVMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2ZpeHR1cmVMaXN0O1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0Sm9pbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2pvaW50TGlzdDtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldENvbnRyb2xsZXJMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2NvbnRyb2xsZXJMaXN0O1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuR2V0Q29udGFjdExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdExpc3Q7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XHJcbiAgIH1cclxuICAgYjJCb2R5LnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV91c2VyRGF0YTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgdGhpcy5tX3VzZXJEYXRhID0gZGF0YTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLkdldFdvcmxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3dvcmxkO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuYjJCb2R5ID0gZnVuY3Rpb24gKGJkLCB3b3JsZCkge1xyXG4gICAgICB0aGlzLm1fZmxhZ3MgPSAwO1xyXG4gICAgICBpZiAoYmQuYnVsbGV0KSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9idWxsZXRGbGFnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChiZC5maXhlZFJvdGF0aW9uKSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9maXhlZFJvdGF0aW9uRmxhZztcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmQuYWxsb3dTbGVlcCkge1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWxsb3dTbGVlcEZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJkLmF3YWtlKSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkJvZHkuZV9hd2FrZUZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJkLmFjdGl2ZSkge1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJCb2R5LmVfYWN0aXZlRmxhZztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fd29ybGQgPSB3b3JsZDtcclxuICAgICAgdGhpcy5tX3hmLnBvc2l0aW9uLlNldFYoYmQucG9zaXRpb24pO1xyXG4gICAgICB0aGlzLm1feGYuUi5TZXQoYmQuYW5nbGUpO1xyXG4gICAgICB0aGlzLm1fc3dlZXAubG9jYWxDZW50ZXIuU2V0WmVybygpO1xyXG4gICAgICB0aGlzLm1fc3dlZXAudDAgPSAxLjA7XHJcbiAgICAgIHRoaXMubV9zd2VlcC5hMCA9IHRoaXMubV9zd2VlcC5hID0gYmQuYW5nbGU7XHJcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX3hmLlI7XHJcbiAgICAgIHZhciB0VmVjID0gdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYy54ID0gKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYy55ID0gKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYy54ICs9IHRoaXMubV94Zi5wb3NpdGlvbi54O1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYy55ICs9IHRoaXMubV94Zi5wb3NpdGlvbi55O1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYzAuU2V0Vih0aGlzLm1fc3dlZXAuYyk7XHJcbiAgICAgIHRoaXMubV9qb2ludExpc3QgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fY29udGFjdExpc3QgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50ID0gMDtcclxuICAgICAgdGhpcy5tX3ByZXYgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9saW5lYXJWZWxvY2l0eS5TZXRWKGJkLmxpbmVhclZlbG9jaXR5KTtcclxuICAgICAgdGhpcy5tX2FuZ3VsYXJWZWxvY2l0eSA9IGJkLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdGhpcy5tX2xpbmVhckRhbXBpbmcgPSBiZC5saW5lYXJEYW1waW5nO1xyXG4gICAgICB0aGlzLm1fYW5ndWxhckRhbXBpbmcgPSBiZC5hbmd1bGFyRGFtcGluZztcclxuICAgICAgdGhpcy5tX2ZvcmNlLlNldCgwLjAsIDAuMCk7XHJcbiAgICAgIHRoaXMubV90b3JxdWUgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9zbGVlcFRpbWUgPSAwLjA7XHJcbiAgICAgIHRoaXMubV90eXBlID0gYmQudHlwZTtcclxuICAgICAgaWYgKHRoaXMubV90eXBlID09IGIyQm9keS5iMl9keW5hbWljQm9keSkge1xyXG4gICAgICAgICB0aGlzLm1fbWFzcyA9IDEuMDtcclxuICAgICAgICAgdGhpcy5tX2ludk1hc3MgPSAxLjA7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9tYXNzID0gMC4wO1xyXG4gICAgICAgICB0aGlzLm1faW52TWFzcyA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fSSA9IDAuMDtcclxuICAgICAgdGhpcy5tX2ludkkgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9pbmVydGlhU2NhbGUgPSBiZC5pbmVydGlhU2NhbGU7XHJcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IGJkLnVzZXJEYXRhO1xyXG4gICAgICB0aGlzLm1fZml4dHVyZUxpc3QgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fZml4dHVyZUNvdW50ID0gMDtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlN5bmNocm9uaXplRml4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ZjEgPSBiMkJvZHkuc194ZjE7XHJcbiAgICAgIHhmMS5SLlNldCh0aGlzLm1fc3dlZXAuYTApO1xyXG4gICAgICB2YXIgdE1hdCA9IHhmMS5SO1xyXG4gICAgICB2YXIgdFZlYyA9IHRoaXMubV9zd2VlcC5sb2NhbENlbnRlcjtcclxuICAgICAgeGYxLnBvc2l0aW9uLnggPSB0aGlzLm1fc3dlZXAuYzAueCAtICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgeGYxLnBvc2l0aW9uLnkgPSB0aGlzLm1fc3dlZXAuYzAueSAtICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgdmFyIGY7XHJcbiAgICAgIHZhciBicm9hZFBoYXNlID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xyXG4gICAgICBmb3IgKGYgPSB0aGlzLm1fZml4dHVyZUxpc3Q7XHJcbiAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xyXG4gICAgICAgICBmLlN5bmNocm9uaXplKGJyb2FkUGhhc2UsIHhmMSwgdGhpcy5tX3hmKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuU3luY2hyb25pemVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV94Zi5SLlNldCh0aGlzLm1fc3dlZXAuYSk7XHJcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX3hmLlI7XHJcbiAgICAgIHZhciB0VmVjID0gdGhpcy5tX3N3ZWVwLmxvY2FsQ2VudGVyO1xyXG4gICAgICB0aGlzLm1feGYucG9zaXRpb24ueCA9IHRoaXMubV9zd2VlcC5jLnggLSAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgIHRoaXMubV94Zi5wb3NpdGlvbi55ID0gdGhpcy5tX3N3ZWVwLmMueSAtICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgfVxyXG4gICBiMkJvZHkucHJvdG90eXBlLlNob3VsZENvbGxpZGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgaWYgKHRoaXMubV90eXBlICE9IGIyQm9keS5iMl9keW5hbWljQm9keSAmJiBvdGhlci5tX3R5cGUgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XHJcbiAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBqbiA9IHRoaXMubV9qb2ludExpc3Q7IGpuOyBqbiA9IGpuLm5leHQpIHtcclxuICAgICAgICAgaWYgKGpuLm90aGVyID09IG90aGVyKSBpZiAoam4uam9pbnQubV9jb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIGIyQm9keS5wcm90b3R5cGUuQWR2YW5jZSA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHQgPSAwO1xyXG4gICAgICB0aGlzLm1fc3dlZXAuQWR2YW5jZSh0KTtcclxuICAgICAgdGhpcy5tX3N3ZWVwLmMuU2V0Vih0aGlzLm1fc3dlZXAuYzApO1xyXG4gICAgICB0aGlzLm1fc3dlZXAuYSA9IHRoaXMubV9zd2VlcC5hMDtcclxuICAgICAgdGhpcy5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuc194ZjEgPSBuZXcgYjJUcmFuc2Zvcm0oKTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJCb2R5LmVfaXNsYW5kRmxhZyA9IDB4MDAwMTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJCb2R5LmVfYXdha2VGbGFnID0gMHgwMDAyO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuZV9hbGxvd1NsZWVwRmxhZyA9IDB4MDAwNDtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJCb2R5LmVfYnVsbGV0RmxhZyA9IDB4MDAwODtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJCb2R5LmVfZml4ZWRSb3RhdGlvbkZsYWcgPSAweDAwMTA7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5lX2FjdGl2ZUZsYWcgPSAweDAwMjA7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQm9keS5iMl9zdGF0aWNCb2R5ID0gMDtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkgPSAxO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkJvZHkuYjJfZHluYW1pY0JvZHkgPSAyO1xyXG4gICB9KTtcclxuICAgYjJCb2R5RGVmLmIyQm9keURlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5saW5lYXJWZWxvY2l0eSA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJCb2R5RGVmLnByb3RvdHlwZS5iMkJvZHlEZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMudXNlckRhdGEgPSBudWxsO1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLlNldCgwLjAsIDAuMCk7XHJcbiAgICAgIHRoaXMuYW5nbGUgPSAwLjA7XHJcbiAgICAgIHRoaXMubGluZWFyVmVsb2NpdHkuU2V0KDAsIDApO1xyXG4gICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDAuMDtcclxuICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gMC4wO1xyXG4gICAgICB0aGlzLmFuZ3VsYXJEYW1waW5nID0gMC4wO1xyXG4gICAgICB0aGlzLmFsbG93U2xlZXAgPSB0cnVlO1xyXG4gICAgICB0aGlzLmF3YWtlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5maXhlZFJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuYnVsbGV0ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudHlwZSA9IGIyQm9keS5iMl9zdGF0aWNCb2R5O1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgIHRoaXMuaW5lcnRpYVNjYWxlID0gMS4wO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdEZpbHRlci5iMkNvbnRhY3RGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgYjJDb250YWN0RmlsdGVyLnByb3RvdHlwZS5TaG91bGRDb2xsaWRlID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xyXG4gICAgICB2YXIgZmlsdGVyMSA9IGZpeHR1cmVBLkdldEZpbHRlckRhdGEoKTtcclxuICAgICAgdmFyIGZpbHRlcjIgPSBmaXh0dXJlQi5HZXRGaWx0ZXJEYXRhKCk7XHJcbiAgICAgIGlmIChmaWx0ZXIxLmdyb3VwSW5kZXggPT0gZmlsdGVyMi5ncm91cEluZGV4ICYmIGZpbHRlcjEuZ3JvdXBJbmRleCAhPSAwKSB7XHJcbiAgICAgICAgIHJldHVybiBmaWx0ZXIxLmdyb3VwSW5kZXggPiAwO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjb2xsaWRlID0gKGZpbHRlcjEubWFza0JpdHMgJiBmaWx0ZXIyLmNhdGVnb3J5Qml0cykgIT0gMCAmJiAoZmlsdGVyMS5jYXRlZ29yeUJpdHMgJiBmaWx0ZXIyLm1hc2tCaXRzKSAhPSAwO1xyXG4gICAgICByZXR1cm4gY29sbGlkZTtcclxuICAgfVxyXG4gICBiMkNvbnRhY3RGaWx0ZXIucHJvdG90eXBlLlJheUNvbGxpZGUgPSBmdW5jdGlvbiAodXNlckRhdGEsIGZpeHR1cmUpIHtcclxuICAgICAgaWYgKCF1c2VyRGF0YSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIHJldHVybiB0aGlzLlNob3VsZENvbGxpZGUoKHVzZXJEYXRhIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gdXNlckRhdGEgOiBudWxsKSwgZml4dHVyZSk7XHJcbiAgIH1cclxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdEZpbHRlci5iMl9kZWZhdWx0RmlsdGVyID0gbmV3IGIyQ29udGFjdEZpbHRlcigpO1xyXG4gICB9KTtcclxuICAgYjJDb250YWN0SW1wdWxzZS5iMkNvbnRhY3RJbXB1bHNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm5vcm1hbEltcHVsc2VzID0gbmV3IFZlY3Rvcl9hMmpfTnVtYmVyKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xyXG4gICAgICB0aGlzLnRhbmdlbnRJbXB1bHNlcyA9IG5ldyBWZWN0b3JfYTJqX051bWJlcihiMlNldHRpbmdzLmIyX21heE1hbmlmb2xkUG9pbnRzKTtcclxuICAgfTtcclxuICAgYjJDb250YWN0TGlzdGVuZXIuYjJDb250YWN0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgYjJDb250YWN0TGlzdGVuZXIucHJvdG90eXBlLkJlZ2luQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7fVxyXG4gICBiMkNvbnRhY3RMaXN0ZW5lci5wcm90b3R5cGUuRW5kQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7fVxyXG4gICBiMkNvbnRhY3RMaXN0ZW5lci5wcm90b3R5cGUuUHJlU29sdmUgPSBmdW5jdGlvbiAoY29udGFjdCwgb2xkTWFuaWZvbGQpIHt9XHJcbiAgIGIyQ29udGFjdExpc3RlbmVyLnByb3RvdHlwZS5Qb3N0U29sdmUgPSBmdW5jdGlvbiAoY29udGFjdCwgaW1wdWxzZSkge31cclxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLmIyX2RlZmF1bHRMaXN0ZW5lciA9IG5ldyBiMkNvbnRhY3RMaXN0ZW5lcigpO1xyXG4gICB9KTtcclxuICAgYjJDb250YWN0TWFuYWdlci5iMkNvbnRhY3RNYW5hZ2VyID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyQ29udGFjdE1hbmFnZXIucHJvdG90eXBlLmIyQ29udGFjdE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV93b3JsZCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9jb250YWN0Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLm1fY29udGFjdEZpbHRlciA9IGIyQ29udGFjdEZpbHRlci5iMl9kZWZhdWx0RmlsdGVyO1xyXG4gICAgICB0aGlzLm1fY29udGFjdExpc3RlbmVyID0gYjJDb250YWN0TGlzdGVuZXIuYjJfZGVmYXVsdExpc3RlbmVyO1xyXG4gICAgICB0aGlzLm1fY29udGFjdEZhY3RvcnkgPSBuZXcgYjJDb250YWN0RmFjdG9yeSh0aGlzLm1fYWxsb2NhdG9yKTtcclxuICAgICAgdGhpcy5tX2Jyb2FkUGhhc2UgPSBuZXcgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UoKTtcclxuICAgfVxyXG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5BZGRQYWlyID0gZnVuY3Rpb24gKHByb3h5VXNlckRhdGFBLCBwcm94eVVzZXJEYXRhQikge1xyXG4gICAgICB2YXIgZml4dHVyZUEgPSAocHJveHlVc2VyRGF0YUEgaW5zdGFuY2VvZiBiMkZpeHR1cmUgPyBwcm94eVVzZXJEYXRhQSA6IG51bGwpO1xyXG4gICAgICB2YXIgZml4dHVyZUIgPSAocHJveHlVc2VyRGF0YUIgaW5zdGFuY2VvZiBiMkZpeHR1cmUgPyBwcm94eVVzZXJEYXRhQiA6IG51bGwpO1xyXG4gICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XHJcbiAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLkdldEJvZHkoKTtcclxuICAgICAgaWYgKGJvZHlBID09IGJvZHlCKSByZXR1cm47XHJcbiAgICAgIHZhciBlZGdlID0gYm9keUIuR2V0Q29udGFjdExpc3QoKTtcclxuICAgICAgd2hpbGUgKGVkZ2UpIHtcclxuICAgICAgICAgaWYgKGVkZ2Uub3RoZXIgPT0gYm9keUEpIHtcclxuICAgICAgICAgICAgdmFyIGZBID0gZWRnZS5jb250YWN0LkdldEZpeHR1cmVBKCk7XHJcbiAgICAgICAgICAgIHZhciBmQiA9IGVkZ2UuY29udGFjdC5HZXRGaXh0dXJlQigpO1xyXG4gICAgICAgICAgICBpZiAoZkEgPT0gZml4dHVyZUEgJiYgZkIgPT0gZml4dHVyZUIpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKGZBID09IGZpeHR1cmVCICYmIGZCID09IGZpeHR1cmVBKSByZXR1cm47XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYm9keUIuU2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm1fY29udGFjdEZpbHRlci5TaG91bGRDb2xsaWRlKGZpeHR1cmVBLCBmaXh0dXJlQikgPT0gZmFsc2UpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjID0gdGhpcy5tX2NvbnRhY3RGYWN0b3J5LkNyZWF0ZShmaXh0dXJlQSwgZml4dHVyZUIpO1xyXG4gICAgICBmaXh0dXJlQSA9IGMuR2V0Rml4dHVyZUEoKTtcclxuICAgICAgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XHJcbiAgICAgIGJvZHlBID0gZml4dHVyZUEubV9ib2R5O1xyXG4gICAgICBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcclxuICAgICAgYy5tX3ByZXYgPSBudWxsO1xyXG4gICAgICBjLm1fbmV4dCA9IHRoaXMubV93b3JsZC5tX2NvbnRhY3RMaXN0O1xyXG4gICAgICBpZiAodGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICB0aGlzLm1fd29ybGQubV9jb250YWN0TGlzdC5tX3ByZXYgPSBjO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV93b3JsZC5tX2NvbnRhY3RMaXN0ID0gYztcclxuICAgICAgYy5tX25vZGVBLmNvbnRhY3QgPSBjO1xyXG4gICAgICBjLm1fbm9kZUEub3RoZXIgPSBib2R5QjtcclxuICAgICAgYy5tX25vZGVBLnByZXYgPSBudWxsO1xyXG4gICAgICBjLm1fbm9kZUEubmV4dCA9IGJvZHlBLm1fY29udGFjdExpc3Q7XHJcbiAgICAgIGlmIChib2R5QS5tX2NvbnRhY3RMaXN0ICE9IG51bGwpIHtcclxuICAgICAgICAgYm9keUEubV9jb250YWN0TGlzdC5wcmV2ID0gYy5tX25vZGVBO1xyXG4gICAgICB9XHJcbiAgICAgIGJvZHlBLm1fY29udGFjdExpc3QgPSBjLm1fbm9kZUE7XHJcbiAgICAgIGMubV9ub2RlQi5jb250YWN0ID0gYztcclxuICAgICAgYy5tX25vZGVCLm90aGVyID0gYm9keUE7XHJcbiAgICAgIGMubV9ub2RlQi5wcmV2ID0gbnVsbDtcclxuICAgICAgYy5tX25vZGVCLm5leHQgPSBib2R5Qi5tX2NvbnRhY3RMaXN0O1xyXG4gICAgICBpZiAoYm9keUIubV9jb250YWN0TGlzdCAhPSBudWxsKSB7XHJcbiAgICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QucHJldiA9IGMubV9ub2RlQjtcclxuICAgICAgfVxyXG4gICAgICBib2R5Qi5tX2NvbnRhY3RMaXN0ID0gYy5tX25vZGVCO1xyXG4gICAgICArK3RoaXMubV93b3JsZC5tX2NvbnRhY3RDb3VudDtcclxuICAgICAgcmV0dXJuO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdE1hbmFnZXIucHJvdG90eXBlLkZpbmROZXdDb250YWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2Jyb2FkUGhhc2UuVXBkYXRlUGFpcnMoQm94MkQuZ2VuZXJhdGVDYWxsYmFjayh0aGlzLCB0aGlzLkFkZFBhaXIpKTtcclxuICAgfVxyXG4gICBiMkNvbnRhY3RNYW5hZ2VyLnByb3RvdHlwZS5EZXN0cm95ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgdmFyIGZpeHR1cmVBID0gYy5HZXRGaXh0dXJlQSgpO1xyXG4gICAgICB2YXIgZml4dHVyZUIgPSBjLkdldEZpeHR1cmVCKCk7XHJcbiAgICAgIHZhciBib2R5QSA9IGZpeHR1cmVBLkdldEJvZHkoKTtcclxuICAgICAgdmFyIGJvZHlCID0gZml4dHVyZUIuR2V0Qm9keSgpO1xyXG4gICAgICBpZiAoYy5Jc1RvdWNoaW5nKCkpIHtcclxuICAgICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ZW5lci5FbmRDb250YWN0KGMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjLm1fcHJldikge1xyXG4gICAgICAgICBjLm1fcHJldi5tX25leHQgPSBjLm1fbmV4dDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYy5tX25leHQpIHtcclxuICAgICAgICAgYy5tX25leHQubV9wcmV2ID0gYy5tX3ByZXY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGMgPT0gdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QpIHtcclxuICAgICAgICAgdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3QgPSBjLm1fbmV4dDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYy5tX25vZGVBLnByZXYpIHtcclxuICAgICAgICAgYy5tX25vZGVBLnByZXYubmV4dCA9IGMubV9ub2RlQS5uZXh0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjLm1fbm9kZUEubmV4dCkge1xyXG4gICAgICAgICBjLm1fbm9kZUEubmV4dC5wcmV2ID0gYy5tX25vZGVBLnByZXY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGMubV9ub2RlQSA9PSBib2R5QS5tX2NvbnRhY3RMaXN0KSB7XHJcbiAgICAgICAgIGJvZHlBLm1fY29udGFjdExpc3QgPSBjLm1fbm9kZUEubmV4dDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYy5tX25vZGVCLnByZXYpIHtcclxuICAgICAgICAgYy5tX25vZGVCLnByZXYubmV4dCA9IGMubV9ub2RlQi5uZXh0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjLm1fbm9kZUIubmV4dCkge1xyXG4gICAgICAgICBjLm1fbm9kZUIubmV4dC5wcmV2ID0gYy5tX25vZGVCLnByZXY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGMubV9ub2RlQiA9PSBib2R5Qi5tX2NvbnRhY3RMaXN0KSB7XHJcbiAgICAgICAgIGJvZHlCLm1fY29udGFjdExpc3QgPSBjLm1fbm9kZUIubmV4dDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fY29udGFjdEZhY3RvcnkuRGVzdHJveShjKTtcclxuICAgICAgLS10aGlzLm1fY29udGFjdENvdW50O1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdE1hbmFnZXIucHJvdG90eXBlLkNvbGxpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBjID0gdGhpcy5tX3dvcmxkLm1fY29udGFjdExpc3Q7XHJcbiAgICAgIHdoaWxlIChjKSB7XHJcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGMuR2V0Rml4dHVyZUEoKTtcclxuICAgICAgICAgdmFyIGZpeHR1cmVCID0gYy5HZXRGaXh0dXJlQigpO1xyXG4gICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5HZXRCb2R5KCk7XHJcbiAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLkdldEJvZHkoKTtcclxuICAgICAgICAgaWYgKGJvZHlBLklzQXdha2UoKSA9PSBmYWxzZSAmJiBib2R5Qi5Jc0F3YWtlKCkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgYyA9IGMuR2V0TmV4dCgpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAoYy5tX2ZsYWdzICYgYjJDb250YWN0LmVfZmlsdGVyRmxhZykge1xyXG4gICAgICAgICAgICBpZiAoYm9keUIuU2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgdmFyIGNOdWtlID0gYztcclxuICAgICAgICAgICAgICAgYyA9IGNOdWtlLkdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgdGhpcy5EZXN0cm95KGNOdWtlKTtcclxuICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubV9jb250YWN0RmlsdGVyLlNob3VsZENvbGxpZGUoZml4dHVyZUEsIGZpeHR1cmVCKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICBjTnVrZSA9IGM7XHJcbiAgICAgICAgICAgICAgIGMgPSBjTnVrZS5HZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuRGVzdHJveShjTnVrZSk7XHJcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfZmlsdGVyRmxhZztcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgcHJveHlBID0gZml4dHVyZUEubV9wcm94eTtcclxuICAgICAgICAgdmFyIHByb3h5QiA9IGZpeHR1cmVCLm1fcHJveHk7XHJcbiAgICAgICAgIHZhciBvdmVybGFwID0gdGhpcy5tX2Jyb2FkUGhhc2UuVGVzdE92ZXJsYXAocHJveHlBLCBwcm94eUIpO1xyXG4gICAgICAgICBpZiAob3ZlcmxhcCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjTnVrZSA9IGM7XHJcbiAgICAgICAgICAgIGMgPSBjTnVrZS5HZXROZXh0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuRGVzdHJveShjTnVrZSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGMuVXBkYXRlKHRoaXMubV9jb250YWN0TGlzdGVuZXIpO1xyXG4gICAgICAgICBjID0gYy5HZXROZXh0KCk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJDb250YWN0TWFuYWdlci5zX2V2YWxDUCA9IG5ldyBiMkNvbnRhY3RQb2ludCgpO1xyXG4gICB9KTtcclxuICAgYjJEZWJ1Z0RyYXcuYjJEZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLmIyRGVidWdEcmF3ID0gZnVuY3Rpb24gKCkge31cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XHJcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XHJcbiAgIH1cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldEZsYWdzID0gZnVuY3Rpb24gKCkge31cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkFwcGVuZEZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XHJcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XHJcbiAgIH1cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkNsZWFyRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcclxuICAgICAgaWYgKGZsYWdzID09PSB1bmRlZmluZWQpIGZsYWdzID0gMDtcclxuICAgfVxyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0U3ByaXRlID0gZnVuY3Rpb24gKHNwcml0ZSkge31cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldFNwcml0ZSA9IGZ1bmN0aW9uICgpIHt9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXREcmF3U2NhbGUgPSBmdW5jdGlvbiAoZHJhd1NjYWxlKSB7XHJcbiAgICAgIGlmIChkcmF3U2NhbGUgPT09IHVuZGVmaW5lZCkgZHJhd1NjYWxlID0gMDtcclxuICAgfVxyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RHJhd1NjYWxlID0gZnVuY3Rpb24gKCkge31cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldExpbmVUaGlja25lc3MgPSBmdW5jdGlvbiAobGluZVRoaWNrbmVzcykge1xyXG4gICAgICBpZiAobGluZVRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkKSBsaW5lVGhpY2tuZXNzID0gMDtcclxuICAgfVxyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0TGluZVRoaWNrbmVzcyA9IGZ1bmN0aW9uICgpIHt9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xyXG4gICAgICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkgYWxwaGEgPSAwO1xyXG4gICB9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5HZXRBbHBoYSA9IGZ1bmN0aW9uICgpIHt9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRGaWxsQWxwaGEgPSBmdW5jdGlvbiAoYWxwaGEpIHtcclxuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcclxuICAgfVxyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmlsbEFscGhhID0gZnVuY3Rpb24gKCkge31cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoeGZvcm1TY2FsZSkge1xyXG4gICAgICBpZiAoeGZvcm1TY2FsZSA9PT0gdW5kZWZpbmVkKSB4Zm9ybVNjYWxlID0gMDtcclxuICAgfVxyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0WEZvcm1TY2FsZSA9IGZ1bmN0aW9uICgpIHt9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3UG9seWdvbiA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgdmVydGV4Q291bnQsIGNvbG9yKSB7XHJcbiAgICAgIGlmICh2ZXJ0ZXhDb3VudCA9PT0gdW5kZWZpbmVkKSB2ZXJ0ZXhDb3VudCA9IDA7XHJcbiAgIH1cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdTb2xpZFBvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xyXG4gICAgICBpZiAodmVydGV4Q291bnQgPT09IHVuZGVmaW5lZCkgdmVydGV4Q291bnQgPSAwO1xyXG4gICB9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3Q2lyY2xlID0gZnVuY3Rpb24gKGNlbnRlciwgcmFkaXVzLCBjb2xvcikge1xyXG4gICAgICBpZiAocmFkaXVzID09PSB1bmRlZmluZWQpIHJhZGl1cyA9IDA7XHJcbiAgIH1cclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdTb2xpZENpcmNsZSA9IGZ1bmN0aW9uIChjZW50ZXIsIHJhZGl1cywgYXhpcywgY29sb3IpIHtcclxuICAgICAgaWYgKHJhZGl1cyA9PT0gdW5kZWZpbmVkKSByYWRpdXMgPSAwO1xyXG4gICB9XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U2VnbWVudCA9IGZ1bmN0aW9uIChwMSwgcDIsIGNvbG9yKSB7fVxyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1RyYW5zZm9ybSA9IGZ1bmN0aW9uICh4Zikge31cclxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfc2hhcGVCaXQgPSAweDAwMDE7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfam9pbnRCaXQgPSAweDAwMDI7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3LmVfYWFiYkJpdCA9IDB4MDAwNDtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcuZV9wYWlyQml0ID0gMHgwMDA4O1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdy5lX2NlbnRlck9mTWFzc0JpdCA9IDB4MDAxMDtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0ID0gMHgwMDIwO1xyXG4gICB9KTtcclxuICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMkRlc3RydWN0aW9uTGlzdGVuZXIucHJvdG90eXBlLlNheUdvb2RieWVKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge31cclxuICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyLnByb3RvdHlwZS5TYXlHb29kYnllRml4dHVyZSA9IGZ1bmN0aW9uIChmaXh0dXJlKSB7fVxyXG4gICBiMkZpbHRlckRhdGEuYjJGaWx0ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmNhdGVnb3J5Qml0cyA9IDB4MDAwMTtcclxuICAgICAgdGhpcy5tYXNrQml0cyA9IDB4RkZGRjtcclxuICAgICAgdGhpcy5ncm91cEluZGV4ID0gMDtcclxuICAgfTtcclxuICAgYjJGaWx0ZXJEYXRhLnByb3RvdHlwZS5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgY29weSA9IG5ldyBiMkZpbHRlckRhdGEoKTtcclxuICAgICAgY29weS5jYXRlZ29yeUJpdHMgPSB0aGlzLmNhdGVnb3J5Qml0cztcclxuICAgICAgY29weS5tYXNrQml0cyA9IHRoaXMubWFza0JpdHM7XHJcbiAgICAgIGNvcHkuZ3JvdXBJbmRleCA9IHRoaXMuZ3JvdXBJbmRleDtcclxuICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLmIyRml4dHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2ZpbHRlciA9IG5ldyBiMkZpbHRlckRhdGEoKTtcclxuICAgfTtcclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLkdldFR5cGUoKTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlO1xyXG4gICB9XHJcbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuU2V0U2Vuc29yID0gZnVuY3Rpb24gKHNlbnNvcikge1xyXG4gICAgICBpZiAodGhpcy5tX2lzU2Vuc29yID09IHNlbnNvcikgcmV0dXJuO1xyXG4gICAgICB0aGlzLm1faXNTZW5zb3IgPSBzZW5zb3I7XHJcbiAgICAgIGlmICh0aGlzLm1fYm9keSA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgIHZhciBlZGdlID0gdGhpcy5tX2JvZHkuR2V0Q29udGFjdExpc3QoKTtcclxuICAgICAgd2hpbGUgKGVkZ2UpIHtcclxuICAgICAgICAgdmFyIGNvbnRhY3QgPSBlZGdlLmNvbnRhY3Q7XHJcbiAgICAgICAgIHZhciBmaXh0dXJlQSA9IGNvbnRhY3QuR2V0Rml4dHVyZUEoKTtcclxuICAgICAgICAgdmFyIGZpeHR1cmVCID0gY29udGFjdC5HZXRGaXh0dXJlQigpO1xyXG4gICAgICAgICBpZiAoZml4dHVyZUEgPT0gdGhpcyB8fCBmaXh0dXJlQiA9PSB0aGlzKSBjb250YWN0LlNldFNlbnNvcihmaXh0dXJlQS5Jc1NlbnNvcigpIHx8IGZpeHR1cmVCLklzU2Vuc29yKCkpO1xyXG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5Jc1NlbnNvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9pc1NlbnNvcjtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldEZpbHRlckRhdGEgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgIHRoaXMubV9maWx0ZXIgPSBmaWx0ZXIuQ29weSgpO1xyXG4gICAgICBpZiAodGhpcy5tX2JvZHkpIHJldHVybjtcclxuICAgICAgdmFyIGVkZ2UgPSB0aGlzLm1fYm9keS5HZXRDb250YWN0TGlzdCgpO1xyXG4gICAgICB3aGlsZSAoZWRnZSkge1xyXG4gICAgICAgICB2YXIgY29udGFjdCA9IGVkZ2UuY29udGFjdDtcclxuICAgICAgICAgdmFyIGZpeHR1cmVBID0gY29udGFjdC5HZXRGaXh0dXJlQSgpO1xyXG4gICAgICAgICB2YXIgZml4dHVyZUIgPSBjb250YWN0LkdldEZpeHR1cmVCKCk7XHJcbiAgICAgICAgIGlmIChmaXh0dXJlQSA9PSB0aGlzIHx8IGZpeHR1cmVCID09IHRoaXMpIGNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xyXG4gICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRGaWx0ZXJEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2ZpbHRlci5Db3B5KCk7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHk7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRVc2VyRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV91c2VyRGF0YTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldFVzZXJEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgdGhpcy5tX3VzZXJEYXRhID0gZGF0YTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlRlc3RQb2ludCA9IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fc2hhcGUuVGVzdFBvaW50KHRoaXMubV9ib2R5LkdldFRyYW5zZm9ybSgpLCBwKTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlJheUNhc3QgPSBmdW5jdGlvbiAob3V0cHV0LCBpbnB1dCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3NoYXBlLlJheUNhc3Qob3V0cHV0LCBpbnB1dCwgdGhpcy5tX2JvZHkuR2V0VHJhbnNmb3JtKCkpO1xyXG4gICB9XHJcbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0TWFzc0RhdGEgPSBmdW5jdGlvbiAobWFzc0RhdGEpIHtcclxuICAgICAgaWYgKG1hc3NEYXRhID09PSB1bmRlZmluZWQpIG1hc3NEYXRhID0gbnVsbDtcclxuICAgICAgaWYgKG1hc3NEYXRhID09IG51bGwpIHtcclxuICAgICAgICAgbWFzc0RhdGEgPSBuZXcgYjJNYXNzRGF0YSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9zaGFwZS5Db21wdXRlTWFzcyhtYXNzRGF0YSwgdGhpcy5tX2RlbnNpdHkpO1xyXG4gICAgICByZXR1cm4gbWFzc0RhdGE7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5TZXREZW5zaXR5ID0gZnVuY3Rpb24gKGRlbnNpdHkpIHtcclxuICAgICAgaWYgKGRlbnNpdHkgPT09IHVuZGVmaW5lZCkgZGVuc2l0eSA9IDA7XHJcbiAgICAgIHRoaXMubV9kZW5zaXR5ID0gZGVuc2l0eTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldERlbnNpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fZGVuc2l0eTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkdldEZyaWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2ZyaWN0aW9uO1xyXG4gICB9XHJcbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuU2V0RnJpY3Rpb24gPSBmdW5jdGlvbiAoZnJpY3Rpb24pIHtcclxuICAgICAgaWYgKGZyaWN0aW9uID09PSB1bmRlZmluZWQpIGZyaWN0aW9uID0gMDtcclxuICAgICAgdGhpcy5tX2ZyaWN0aW9uID0gZnJpY3Rpb247XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5HZXRSZXN0aXR1dGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9yZXN0aXR1dGlvbjtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLlNldFJlc3RpdHV0aW9uID0gZnVuY3Rpb24gKHJlc3RpdHV0aW9uKSB7XHJcbiAgICAgIGlmIChyZXN0aXR1dGlvbiA9PT0gdW5kZWZpbmVkKSByZXN0aXR1dGlvbiA9IDA7XHJcbiAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IHJlc3RpdHV0aW9uO1xyXG4gICB9XHJcbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuR2V0QUFCQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9hYWJiO1xyXG4gICB9XHJcbiAgIGIyRml4dHVyZS5wcm90b3R5cGUuYjJGaXh0dXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fYWFiYiA9IG5ldyBiMkFBQkIoKTtcclxuICAgICAgdGhpcy5tX3VzZXJEYXRhID0gbnVsbDtcclxuICAgICAgdGhpcy5tX2JvZHkgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fbmV4dCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9zaGFwZSA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9kZW5zaXR5ID0gMC4wO1xyXG4gICAgICB0aGlzLm1fZnJpY3Rpb24gPSAwLjA7XHJcbiAgICAgIHRoaXMubV9yZXN0aXR1dGlvbiA9IDAuMDtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkNyZWF0ZSA9IGZ1bmN0aW9uIChib2R5LCB4ZiwgZGVmKSB7XHJcbiAgICAgIHRoaXMubV91c2VyRGF0YSA9IGRlZi51c2VyRGF0YTtcclxuICAgICAgdGhpcy5tX2ZyaWN0aW9uID0gZGVmLmZyaWN0aW9uO1xyXG4gICAgICB0aGlzLm1fcmVzdGl0dXRpb24gPSBkZWYucmVzdGl0dXRpb247XHJcbiAgICAgIHRoaXMubV9ib2R5ID0gYm9keTtcclxuICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fZmlsdGVyID0gZGVmLmZpbHRlci5Db3B5KCk7XHJcbiAgICAgIHRoaXMubV9pc1NlbnNvciA9IGRlZi5pc1NlbnNvcjtcclxuICAgICAgdGhpcy5tX3NoYXBlID0gZGVmLnNoYXBlLkNvcHkoKTtcclxuICAgICAgdGhpcy5tX2RlbnNpdHkgPSBkZWYuZGVuc2l0eTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmUucHJvdG90eXBlLkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV9zaGFwZSA9IG51bGw7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5DcmVhdGVQcm94eSA9IGZ1bmN0aW9uIChicm9hZFBoYXNlLCB4Zikge1xyXG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIodGhpcy5tX2FhYmIsIHhmKTtcclxuICAgICAgdGhpcy5tX3Byb3h5ID0gYnJvYWRQaGFzZS5DcmVhdGVQcm94eSh0aGlzLm1fYWFiYiwgdGhpcyk7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5EZXN0cm95UHJveHkgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSkge1xyXG4gICAgICBpZiAodGhpcy5tX3Byb3h5ID09IG51bGwpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGJyb2FkUGhhc2UuRGVzdHJveVByb3h5KHRoaXMubV9wcm94eSk7XHJcbiAgICAgIHRoaXMubV9wcm94eSA9IG51bGw7XHJcbiAgIH1cclxuICAgYjJGaXh0dXJlLnByb3RvdHlwZS5TeW5jaHJvbml6ZSA9IGZ1bmN0aW9uIChicm9hZFBoYXNlLCB0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XHJcbiAgICAgIGlmICghdGhpcy5tX3Byb3h5KSByZXR1cm47XHJcbiAgICAgIHZhciBhYWJiMSA9IG5ldyBiMkFBQkIoKTtcclxuICAgICAgdmFyIGFhYmIyID0gbmV3IGIyQUFCQigpO1xyXG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIoYWFiYjEsIHRyYW5zZm9ybTEpO1xyXG4gICAgICB0aGlzLm1fc2hhcGUuQ29tcHV0ZUFBQkIoYWFiYjIsIHRyYW5zZm9ybTIpO1xyXG4gICAgICB0aGlzLm1fYWFiYi5Db21iaW5lKGFhYmIxLCBhYWJiMik7XHJcbiAgICAgIHZhciBkaXNwbGFjZW1lbnQgPSBiMk1hdGguU3VidHJhY3RWVih0cmFuc2Zvcm0yLnBvc2l0aW9uLCB0cmFuc2Zvcm0xLnBvc2l0aW9uKTtcclxuICAgICAgYnJvYWRQaGFzZS5Nb3ZlUHJveHkodGhpcy5tX3Byb3h5LCB0aGlzLm1fYWFiYiwgZGlzcGxhY2VtZW50KTtcclxuICAgfVxyXG4gICBiMkZpeHR1cmVEZWYuYjJGaXh0dXJlRGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmZpbHRlciA9IG5ldyBiMkZpbHRlckRhdGEoKTtcclxuICAgfTtcclxuICAgYjJGaXh0dXJlRGVmLnByb3RvdHlwZS5iMkZpeHR1cmVEZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xyXG4gICAgICB0aGlzLnVzZXJEYXRhID0gbnVsbDtcclxuICAgICAgdGhpcy5mcmljdGlvbiA9IDAuMjtcclxuICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IDAuMDtcclxuICAgICAgdGhpcy5kZW5zaXR5ID0gMC4wO1xyXG4gICAgICB0aGlzLmZpbHRlci5jYXRlZ29yeUJpdHMgPSAweDAwMDE7XHJcbiAgICAgIHRoaXMuZmlsdGVyLm1hc2tCaXRzID0gMHhGRkZGO1xyXG4gICAgICB0aGlzLmZpbHRlci5ncm91cEluZGV4ID0gMDtcclxuICAgICAgdGhpcy5pc1NlbnNvciA9IGZhbHNlO1xyXG4gICB9XHJcbiAgIGIySXNsYW5kLmIySXNsYW5kID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIySXNsYW5kLnByb3RvdHlwZS5iMklzbGFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2JvZGllcyA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RzID0gbmV3IFZlY3RvcigpO1xyXG4gICAgICB0aGlzLm1fam9pbnRzID0gbmV3IFZlY3RvcigpO1xyXG4gICB9XHJcbiAgIGIySXNsYW5kLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJvZHlDYXBhY2l0eSwgY29udGFjdENhcGFjaXR5LCBqb2ludENhcGFjaXR5LCBhbGxvY2F0b3IsIGxpc3RlbmVyLCBjb250YWN0U29sdmVyKSB7XHJcbiAgICAgIGlmIChib2R5Q2FwYWNpdHkgPT09IHVuZGVmaW5lZCkgYm9keUNhcGFjaXR5ID0gMDtcclxuICAgICAgaWYgKGNvbnRhY3RDYXBhY2l0eSA9PT0gdW5kZWZpbmVkKSBjb250YWN0Q2FwYWNpdHkgPSAwO1xyXG4gICAgICBpZiAoam9pbnRDYXBhY2l0eSA9PT0gdW5kZWZpbmVkKSBqb2ludENhcGFjaXR5ID0gMDtcclxuICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICB0aGlzLm1fYm9keUNhcGFjaXR5ID0gYm9keUNhcGFjaXR5O1xyXG4gICAgICB0aGlzLm1fY29udGFjdENhcGFjaXR5ID0gY29udGFjdENhcGFjaXR5O1xyXG4gICAgICB0aGlzLm1fam9pbnRDYXBhY2l0eSA9IGpvaW50Q2FwYWNpdHk7XHJcbiAgICAgIHRoaXMubV9ib2R5Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLm1fY29udGFjdENvdW50ID0gMDtcclxuICAgICAgdGhpcy5tX2pvaW50Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xyXG4gICAgICB0aGlzLm1fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RTb2x2ZXIgPSBjb250YWN0U29sdmVyO1xyXG4gICAgICBmb3IgKGkgPSB0aGlzLm1fYm9kaWVzLmxlbmd0aDtcclxuICAgICAgaSA8IGJvZHlDYXBhY2l0eTsgaSsrKVxyXG4gICAgICB0aGlzLm1fYm9kaWVzW2ldID0gbnVsbDtcclxuICAgICAgZm9yIChpID0gdGhpcy5tX2NvbnRhY3RzLmxlbmd0aDtcclxuICAgICAgaSA8IGNvbnRhY3RDYXBhY2l0eTsgaSsrKVxyXG4gICAgICB0aGlzLm1fY29udGFjdHNbaV0gPSBudWxsO1xyXG4gICAgICBmb3IgKGkgPSB0aGlzLm1fam9pbnRzLmxlbmd0aDtcclxuICAgICAgaSA8IGpvaW50Q2FwYWNpdHk7IGkrKylcclxuICAgICAgdGhpcy5tX2pvaW50c1tpXSA9IG51bGw7XHJcbiAgIH1cclxuICAgYjJJc2xhbmQucHJvdG90eXBlLkNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fYm9keUNvdW50ID0gMDtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RDb3VudCA9IDA7XHJcbiAgICAgIHRoaXMubV9qb2ludENvdW50ID0gMDtcclxuICAgfVxyXG4gICBiMklzbGFuZC5wcm90b3R5cGUuU29sdmUgPSBmdW5jdGlvbiAoc3RlcCwgZ3Jhdml0eSwgYWxsb3dTbGVlcCkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBqID0gMDtcclxuICAgICAgdmFyIGI7XHJcbiAgICAgIHZhciBqb2ludDtcclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IHRoaXMubV9ib2R5Q291bnQ7ICsraSkge1xyXG4gICAgICAgICBiID0gdGhpcy5tX2JvZGllc1tpXTtcclxuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSkgY29udGludWU7XHJcbiAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS54ICs9IHN0ZXAuZHQgKiAoZ3Jhdml0eS54ICsgYi5tX2ludk1hc3MgKiBiLm1fZm9yY2UueCk7XHJcbiAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICs9IHN0ZXAuZHQgKiAoZ3Jhdml0eS55ICsgYi5tX2ludk1hc3MgKiBiLm1fZm9yY2UueSk7XHJcbiAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgKz0gc3RlcC5kdCAqIGIubV9pbnZJICogYi5tX3RvcnF1ZTtcclxuICAgICAgICAgYi5tX2xpbmVhclZlbG9jaXR5Lk11bHRpcGx5KGIyTWF0aC5DbGFtcCgxLjAgLSBzdGVwLmR0ICogYi5tX2xpbmVhckRhbXBpbmcsIDAuMCwgMS4wKSk7XHJcbiAgICAgICAgIGIubV9hbmd1bGFyVmVsb2NpdHkgKj0gYjJNYXRoLkNsYW1wKDEuMCAtIHN0ZXAuZHQgKiBiLm1fYW5ndWxhckRhbXBpbmcsIDAuMCwgMS4wKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlci5Jbml0aWFsaXplKHN0ZXAsIHRoaXMubV9jb250YWN0cywgdGhpcy5tX2NvbnRhY3RDb3VudCwgdGhpcy5tX2FsbG9jYXRvcik7XHJcbiAgICAgIHZhciBjb250YWN0U29sdmVyID0gdGhpcy5tX2NvbnRhY3RTb2x2ZXI7XHJcbiAgICAgIGNvbnRhY3RTb2x2ZXIuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCB0aGlzLm1fam9pbnRDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIGpvaW50ID0gdGhpcy5tX2pvaW50c1tpXTtcclxuICAgICAgICAgam9pbnQuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcclxuICAgICAgICAgZm9yIChqID0gMDtcclxuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcclxuICAgICAgICAgICAgam9pbnQgPSB0aGlzLm1fam9pbnRzW2pdO1xyXG4gICAgICAgICAgICBqb2ludC5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoc3RlcCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwO1xyXG4gICAgICBpIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraSkge1xyXG4gICAgICAgICBqb2ludCA9IHRoaXMubV9qb2ludHNbaV07XHJcbiAgICAgICAgIGpvaW50LkZpbmFsaXplVmVsb2NpdHlDb25zdHJhaW50cygpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRhY3RTb2x2ZXIuRmluYWxpemVWZWxvY2l0eUNvbnN0cmFpbnRzKCk7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCB0aGlzLm1fYm9keUNvdW50OyArK2kpIHtcclxuICAgICAgICAgYiA9IHRoaXMubV9ib2RpZXNbaV07XHJcbiAgICAgICAgIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkgY29udGludWU7XHJcbiAgICAgICAgIHZhciB0cmFuc2xhdGlvblggPSBzdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lng7XHJcbiAgICAgICAgIHZhciB0cmFuc2xhdGlvblkgPSBzdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lnk7XHJcbiAgICAgICAgIGlmICgodHJhbnNsYXRpb25YICogdHJhbnNsYXRpb25YICsgdHJhbnNsYXRpb25ZICogdHJhbnNsYXRpb25ZKSA+IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb25TcXVhcmVkKSB7XHJcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgYi5tX2xpbmVhclZlbG9jaXR5LnggKj0gYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvbiAqIHN0ZXAuaW52X2R0O1xyXG4gICAgICAgICAgICBiLm1fbGluZWFyVmVsb2NpdHkueSAqPSBiMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uICogc3RlcC5pbnZfZHQ7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIHJvdGF0aW9uID0gc3RlcC5kdCAqIGIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgIGlmIChyb3RhdGlvbiAqIHJvdGF0aW9uID4gYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvblNxdWFyZWQpIHtcclxuICAgICAgICAgICAgaWYgKGIubV9hbmd1bGFyVmVsb2NpdHkgPCAwLjApIHtcclxuICAgICAgICAgICAgICAgYi5tX2FuZ3VsYXJWZWxvY2l0eSA9ICgtYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvbiAqIHN0ZXAuaW52X2R0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgYi5tX2FuZ3VsYXJWZWxvY2l0eSA9IGIyU2V0dGluZ3MuYjJfbWF4Um90YXRpb24gKiBzdGVwLmludl9kdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGIubV9zd2VlcC5jMC5TZXRWKGIubV9zd2VlcC5jKTtcclxuICAgICAgICAgYi5tX3N3ZWVwLmEwID0gYi5tX3N3ZWVwLmE7XHJcbiAgICAgICAgIGIubV9zd2VlcC5jLnggKz0gc3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS54O1xyXG4gICAgICAgICBiLm1fc3dlZXAuYy55ICs9IHN0ZXAuZHQgKiBiLm1fbGluZWFyVmVsb2NpdHkueTtcclxuICAgICAgICAgYi5tX3N3ZWVwLmEgKz0gc3RlcC5kdCAqIGIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwO1xyXG4gICAgICBpIDwgc3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnM7ICsraSkge1xyXG4gICAgICAgICB2YXIgY29udGFjdHNPa2F5ID0gY29udGFjdFNvbHZlci5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoYjJTZXR0aW5ncy5iMl9jb250YWN0QmF1bWdhcnRlKTtcclxuICAgICAgICAgdmFyIGpvaW50c09rYXkgPSB0cnVlO1xyXG4gICAgICAgICBmb3IgKGogPSAwO1xyXG4gICAgICAgICBqIDwgdGhpcy5tX2pvaW50Q291bnQ7ICsraikge1xyXG4gICAgICAgICAgICBqb2ludCA9IHRoaXMubV9qb2ludHNbal07XHJcbiAgICAgICAgICAgIHZhciBqb2ludE9rYXkgPSBqb2ludC5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoYjJTZXR0aW5ncy5iMl9jb250YWN0QmF1bWdhcnRlKTtcclxuICAgICAgICAgICAgam9pbnRzT2theSA9IGpvaW50c09rYXkgJiYgam9pbnRPa2F5O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGlmIChjb250YWN0c09rYXkgJiYgam9pbnRzT2theSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuUmVwb3J0KGNvbnRhY3RTb2x2ZXIubV9jb25zdHJhaW50cyk7XHJcbiAgICAgIGlmIChhbGxvd1NsZWVwKSB7XHJcbiAgICAgICAgIHZhciBtaW5TbGVlcFRpbWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICB2YXIgbGluVG9sU3FyID0gYjJTZXR0aW5ncy5iMl9saW5lYXJTbGVlcFRvbGVyYW5jZSAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xlZXBUb2xlcmFuY2U7XHJcbiAgICAgICAgIHZhciBhbmdUb2xTcXIgPSBiMlNldHRpbmdzLmIyX2FuZ3VsYXJTbGVlcFRvbGVyYW5jZSAqIGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsZWVwVG9sZXJhbmNlO1xyXG4gICAgICAgICBmb3IgKGkgPSAwO1xyXG4gICAgICAgICBpIDwgdGhpcy5tX2JvZHlDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLm1fYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcclxuICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChiLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gMCkge1xyXG4gICAgICAgICAgICAgICBiLm1fc2xlZXBUaW1lID0gMC4wO1xyXG4gICAgICAgICAgICAgICBtaW5TbGVlcFRpbWUgPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChiLm1fZmxhZ3MgJiBiMkJvZHkuZV9hbGxvd1NsZWVwRmxhZykgPT0gMCB8fCBiLm1fYW5ndWxhclZlbG9jaXR5ICogYi5tX2FuZ3VsYXJWZWxvY2l0eSA+IGFuZ1RvbFNxciB8fCBiMk1hdGguRG90KGIubV9saW5lYXJWZWxvY2l0eSwgYi5tX2xpbmVhclZlbG9jaXR5KSA+IGxpblRvbFNxcikge1xyXG4gICAgICAgICAgICAgICBiLm1fc2xlZXBUaW1lID0gMC4wO1xyXG4gICAgICAgICAgICAgICBtaW5TbGVlcFRpbWUgPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGIubV9zbGVlcFRpbWUgKz0gc3RlcC5kdDtcclxuICAgICAgICAgICAgICAgbWluU2xlZXBUaW1lID0gYjJNYXRoLk1pbihtaW5TbGVlcFRpbWUsIGIubV9zbGVlcFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKG1pblNsZWVwVGltZSA+PSBiMlNldHRpbmdzLmIyX3RpbWVUb1NsZWVwKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgICAgIGkgPCB0aGlzLm1fYm9keUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgYiA9IHRoaXMubV9ib2RpZXNbaV07XHJcbiAgICAgICAgICAgICAgIGIuU2V0QXdha2UoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIySXNsYW5kLnByb3RvdHlwZS5Tb2x2ZVRPSSA9IGZ1bmN0aW9uIChzdWJTdGVwKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuICAgICAgdmFyIGogPSAwO1xyXG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlci5Jbml0aWFsaXplKHN1YlN0ZXAsIHRoaXMubV9jb250YWN0cywgdGhpcy5tX2NvbnRhY3RDb3VudCwgdGhpcy5tX2FsbG9jYXRvcik7XHJcbiAgICAgIHZhciBjb250YWN0U29sdmVyID0gdGhpcy5tX2NvbnRhY3RTb2x2ZXI7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCB0aGlzLm1fam9pbnRDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHRoaXMubV9qb2ludHNbaV0uSW5pdFZlbG9jaXR5Q29uc3RyYWludHMoc3ViU3RlcCk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IHN1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zOyArK2kpIHtcclxuICAgICAgICAgY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcclxuICAgICAgICAgZm9yIChqID0gMDtcclxuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcclxuICAgICAgICAgICAgdGhpcy5tX2pvaW50c1tqXS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoc3ViU3RlcCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwO1xyXG4gICAgICBpIDwgdGhpcy5tX2JvZHlDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciBiID0gdGhpcy5tX2JvZGllc1tpXTtcclxuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSBjb250aW51ZTtcclxuICAgICAgICAgdmFyIHRyYW5zbGF0aW9uWCA9IHN1YlN0ZXAuZHQgKiBiLm1fbGluZWFyVmVsb2NpdHkueDtcclxuICAgICAgICAgdmFyIHRyYW5zbGF0aW9uWSA9IHN1YlN0ZXAuZHQgKiBiLm1fbGluZWFyVmVsb2NpdHkueTtcclxuICAgICAgICAgaWYgKCh0cmFuc2xhdGlvblggKiB0cmFuc2xhdGlvblggKyB0cmFuc2xhdGlvblkgKiB0cmFuc2xhdGlvblkpID4gYjJTZXR0aW5ncy5iMl9tYXhUcmFuc2xhdGlvblNxdWFyZWQpIHtcclxuICAgICAgICAgICAgYi5tX2xpbmVhclZlbG9jaXR5Lk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBiLm1fbGluZWFyVmVsb2NpdHkueCAqPSBiMlNldHRpbmdzLmIyX21heFRyYW5zbGF0aW9uICogc3ViU3RlcC5pbnZfZHQ7XHJcbiAgICAgICAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICo9IGIyU2V0dGluZ3MuYjJfbWF4VHJhbnNsYXRpb24gKiBzdWJTdGVwLmludl9kdDtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgcm90YXRpb24gPSBzdWJTdGVwLmR0ICogYi5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBiMlNldHRpbmdzLmIyX21heFJvdGF0aW9uU3F1YXJlZCkge1xyXG4gICAgICAgICAgICBpZiAoYi5tX2FuZ3VsYXJWZWxvY2l0eSA8IDAuMCkge1xyXG4gICAgICAgICAgICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ID0gKC1iMlNldHRpbmdzLmIyX21heFJvdGF0aW9uICogc3ViU3RlcC5pbnZfZHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ID0gYjJTZXR0aW5ncy5iMl9tYXhSb3RhdGlvbiAqIHN1YlN0ZXAuaW52X2R0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYi5tX3N3ZWVwLmMwLlNldFYoYi5tX3N3ZWVwLmMpO1xyXG4gICAgICAgICBiLm1fc3dlZXAuYTAgPSBiLm1fc3dlZXAuYTtcclxuICAgICAgICAgYi5tX3N3ZWVwLmMueCArPSBzdWJTdGVwLmR0ICogYi5tX2xpbmVhclZlbG9jaXR5Lng7XHJcbiAgICAgICAgIGIubV9zd2VlcC5jLnkgKz0gc3ViU3RlcC5kdCAqIGIubV9saW5lYXJWZWxvY2l0eS55O1xyXG4gICAgICAgICBiLm1fc3dlZXAuYSArPSBzdWJTdGVwLmR0ICogYi5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgYi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBrX3RvaUJhdW1nYXJ0ZSA9IDAuNzU7XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCBzdWJTdGVwLnBvc2l0aW9uSXRlcmF0aW9uczsgKytpKSB7XHJcbiAgICAgICAgIHZhciBjb250YWN0c09rYXkgPSBjb250YWN0U29sdmVyLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhrX3RvaUJhdW1nYXJ0ZSk7XHJcbiAgICAgICAgIHZhciBqb2ludHNPa2F5ID0gdHJ1ZTtcclxuICAgICAgICAgZm9yIChqID0gMDtcclxuICAgICAgICAgaiA8IHRoaXMubV9qb2ludENvdW50OyArK2opIHtcclxuICAgICAgICAgICAgdmFyIGpvaW50T2theSA9IHRoaXMubV9qb2ludHNbal0uU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKGIyU2V0dGluZ3MuYjJfY29udGFjdEJhdW1nYXJ0ZSk7XHJcbiAgICAgICAgICAgIGpvaW50c09rYXkgPSBqb2ludHNPa2F5ICYmIGpvaW50T2theTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAoY29udGFjdHNPa2F5ICYmIGpvaW50c09rYXkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLlJlcG9ydChjb250YWN0U29sdmVyLm1fY29uc3RyYWludHMpO1xyXG4gICB9XHJcbiAgIGIySXNsYW5kLnByb3RvdHlwZS5SZXBvcnQgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcclxuICAgICAgaWYgKHRoaXMubV9saXN0ZW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubV9jb250YWN0Q291bnQ7ICsraSkge1xyXG4gICAgICAgICB2YXIgYyA9IHRoaXMubV9jb250YWN0c1tpXTtcclxuICAgICAgICAgdmFyIGNjID0gY29uc3RyYWludHNbaV07XHJcbiAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2MucG9pbnRDb3VudDsgKytqKSB7XHJcbiAgICAgICAgICAgIGIySXNsYW5kLnNfaW1wdWxzZS5ub3JtYWxJbXB1bHNlc1tqXSA9IGNjLnBvaW50c1tqXS5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICBiMklzbGFuZC5zX2ltcHVsc2UudGFuZ2VudEltcHVsc2VzW2pdID0gY2MucG9pbnRzW2pdLnRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHRoaXMubV9saXN0ZW5lci5Qb3N0U29sdmUoYywgYjJJc2xhbmQuc19pbXB1bHNlKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIySXNsYW5kLnByb3RvdHlwZS5BZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgYm9keS5tX2lzbGFuZEluZGV4ID0gdGhpcy5tX2JvZHlDb3VudDtcclxuICAgICAgdGhpcy5tX2JvZGllc1t0aGlzLm1fYm9keUNvdW50KytdID0gYm9keTtcclxuICAgfVxyXG4gICBiMklzbGFuZC5wcm90b3R5cGUuQWRkQ29udGFjdCA9IGZ1bmN0aW9uIChjb250YWN0KSB7XHJcbiAgICAgIHRoaXMubV9jb250YWN0c1t0aGlzLm1fY29udGFjdENvdW50KytdID0gY29udGFjdDtcclxuICAgfVxyXG4gICBiMklzbGFuZC5wcm90b3R5cGUuQWRkSm9pbnQgPSBmdW5jdGlvbiAoam9pbnQpIHtcclxuICAgICAgdGhpcy5tX2pvaW50c1t0aGlzLm1fam9pbnRDb3VudCsrXSA9IGpvaW50O1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMklzbGFuZC5zX2ltcHVsc2UgPSBuZXcgYjJDb250YWN0SW1wdWxzZSgpO1xyXG4gICB9KTtcclxuICAgYjJUaW1lU3RlcC5iMlRpbWVTdGVwID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyVGltZVN0ZXAucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHRoaXMuZHQgPSBzdGVwLmR0O1xyXG4gICAgICB0aGlzLmludl9kdCA9IHN0ZXAuaW52X2R0O1xyXG4gICAgICB0aGlzLnBvc2l0aW9uSXRlcmF0aW9ucyA9IHN0ZXAucG9zaXRpb25JdGVyYXRpb25zO1xyXG4gICAgICB0aGlzLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zO1xyXG4gICAgICB0aGlzLndhcm1TdGFydGluZyA9IHN0ZXAud2FybVN0YXJ0aW5nO1xyXG4gICB9XHJcbiAgIGIyV29ybGQuYjJXb3JsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5zX3N0YWNrID0gbmV3IFZlY3RvcigpO1xyXG4gICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIgPSBuZXcgYjJDb250YWN0TWFuYWdlcigpO1xyXG4gICAgICB0aGlzLm1fY29udGFjdFNvbHZlciA9IG5ldyBiMkNvbnRhY3RTb2x2ZXIoKTtcclxuICAgICAgdGhpcy5tX2lzbGFuZCA9IG5ldyBiMklzbGFuZCgpO1xyXG4gICB9O1xyXG4gICBiMldvcmxkLnByb3RvdHlwZS5iMldvcmxkID0gZnVuY3Rpb24gKGdyYXZpdHksIGRvU2xlZXApIHtcclxuICAgICAgdGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fZGVidWdEcmF3ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX2pvaW50TGlzdCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9jb250cm9sbGVyTGlzdCA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9ib2R5Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLm1fY29udGFjdENvdW50ID0gMDtcclxuICAgICAgdGhpcy5tX2pvaW50Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50ID0gMDtcclxuICAgICAgYjJXb3JsZC5tX3dhcm1TdGFydGluZyA9IHRydWU7XHJcbiAgICAgIGIyV29ybGQubV9jb250aW51b3VzUGh5c2ljcyA9IHRydWU7XHJcbiAgICAgIHRoaXMubV9hbGxvd1NsZWVwID0gZG9TbGVlcDtcclxuICAgICAgdGhpcy5tX2dyYXZpdHkgPSBncmF2aXR5O1xyXG4gICAgICB0aGlzLm1faW52X2R0MCA9IDAuMDtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fd29ybGQgPSB0aGlzO1xyXG4gICAgICB2YXIgYmQgPSBuZXcgYjJCb2R5RGVmKCk7XHJcbiAgICAgIHRoaXMubV9ncm91bmRCb2R5ID0gdGhpcy5DcmVhdGVCb2R5KGJkKTtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5TZXREZXN0cnVjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0Q29udGFjdEZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdEZpbHRlciA9IGZpbHRlcjtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5TZXRDb250YWN0TGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdExpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0RGVidWdEcmF3ID0gZnVuY3Rpb24gKGRlYnVnRHJhdykge1xyXG4gICAgICB0aGlzLm1fZGVidWdEcmF3ID0gZGVidWdEcmF3O1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLlNldEJyb2FkUGhhc2UgPSBmdW5jdGlvbiAoYnJvYWRQaGFzZSkge1xyXG4gICAgICB2YXIgb2xkQnJvYWRQaGFzZSA9IHRoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XHJcbiAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2UgPSBicm9hZFBoYXNlO1xyXG4gICAgICBmb3IgKHZhciBiID0gdGhpcy5tX2JvZHlMaXN0OyBiOyBiID0gYi5tX25leHQpIHtcclxuICAgICAgICAgZm9yICh2YXIgZiA9IGIubV9maXh0dXJlTGlzdDsgZjsgZiA9IGYubV9uZXh0KSB7XHJcbiAgICAgICAgICAgIGYubV9wcm94eSA9IGJyb2FkUGhhc2UuQ3JlYXRlUHJveHkob2xkQnJvYWRQaGFzZS5HZXRGYXRBQUJCKGYubV9wcm94eSksIGYpO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5WYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZS5WYWxpZGF0ZSgpO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkdldFByb3h5Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlLkdldFByb3h5Q291bnQoKTtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5DcmVhdGVCb2R5ID0gZnVuY3Rpb24gKGRlZikge1xyXG4gICAgICBpZiAodGhpcy5Jc0xvY2tlZCgpID09IHRydWUpIHtcclxuICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGIgPSBuZXcgYjJCb2R5KGRlZiwgdGhpcyk7XHJcbiAgICAgIGIubV9wcmV2ID0gbnVsbDtcclxuICAgICAgYi5tX25leHQgPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgIGlmICh0aGlzLm1fYm9keUxpc3QpIHtcclxuICAgICAgICAgdGhpcy5tX2JvZHlMaXN0Lm1fcHJldiA9IGI7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gYjtcclxuICAgICAgKyt0aGlzLm1fYm9keUNvdW50O1xyXG4gICAgICByZXR1cm4gYjtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5EZXN0cm95Qm9keSA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIGlmICh0aGlzLklzTG9ja2VkKCkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGpuID0gYi5tX2pvaW50TGlzdDtcclxuICAgICAgd2hpbGUgKGpuKSB7XHJcbiAgICAgICAgIHZhciBqbjAgPSBqbjtcclxuICAgICAgICAgam4gPSBqbi5uZXh0O1xyXG4gICAgICAgICBpZiAodGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5tX2Rlc3RydWN0aW9uTGlzdGVuZXIuU2F5R29vZGJ5ZUpvaW50KGpuMC5qb2ludCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdGhpcy5EZXN0cm95Sm9pbnQoam4wLmpvaW50KTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY29lID0gYi5tX2NvbnRyb2xsZXJMaXN0O1xyXG4gICAgICB3aGlsZSAoY29lKSB7XHJcbiAgICAgICAgIHZhciBjb2UwID0gY29lO1xyXG4gICAgICAgICBjb2UgPSBjb2UubmV4dENvbnRyb2xsZXI7XHJcbiAgICAgICAgIGNvZTAuY29udHJvbGxlci5SZW1vdmVCb2R5KGIpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjZSA9IGIubV9jb250YWN0TGlzdDtcclxuICAgICAgd2hpbGUgKGNlKSB7XHJcbiAgICAgICAgIHZhciBjZTAgPSBjZTtcclxuICAgICAgICAgY2UgPSBjZS5uZXh0O1xyXG4gICAgICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIuRGVzdHJveShjZTAuY29udGFjdCk7XHJcbiAgICAgIH1cclxuICAgICAgYi5tX2NvbnRhY3RMaXN0ID0gbnVsbDtcclxuICAgICAgdmFyIGYgPSBiLm1fZml4dHVyZUxpc3Q7XHJcbiAgICAgIHdoaWxlIChmKSB7XHJcbiAgICAgICAgIHZhciBmMCA9IGY7XHJcbiAgICAgICAgIGYgPSBmLm1fbmV4dDtcclxuICAgICAgICAgaWYgKHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9kZXN0cnVjdGlvbkxpc3RlbmVyLlNheUdvb2RieWVGaXh0dXJlKGYwKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBmMC5EZXN0cm95UHJveHkodGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZSk7XHJcbiAgICAgICAgIGYwLkRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgICBiLm1fZml4dHVyZUxpc3QgPSBudWxsO1xyXG4gICAgICBiLm1fZml4dHVyZUNvdW50ID0gMDtcclxuICAgICAgaWYgKGIubV9wcmV2KSB7XHJcbiAgICAgICAgIGIubV9wcmV2Lm1fbmV4dCA9IGIubV9uZXh0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChiLm1fbmV4dCkge1xyXG4gICAgICAgICBiLm1fbmV4dC5tX3ByZXYgPSBiLm1fcHJldjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYiA9PSB0aGlzLm1fYm9keUxpc3QpIHtcclxuICAgICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gYi5tX25leHQ7XHJcbiAgICAgIH0tLXRoaXMubV9ib2R5Q291bnQ7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuQ3JlYXRlSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgIHZhciBqID0gYjJKb2ludC5DcmVhdGUoZGVmLCBudWxsKTtcclxuICAgICAgai5tX3ByZXYgPSBudWxsO1xyXG4gICAgICBqLm1fbmV4dCA9IHRoaXMubV9qb2ludExpc3Q7XHJcbiAgICAgIGlmICh0aGlzLm1fam9pbnRMaXN0KSB7XHJcbiAgICAgICAgIHRoaXMubV9qb2ludExpc3QubV9wcmV2ID0gajtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fam9pbnRMaXN0ID0gajtcclxuICAgICAgKyt0aGlzLm1fam9pbnRDb3VudDtcclxuICAgICAgai5tX2VkZ2VBLmpvaW50ID0gajtcclxuICAgICAgai5tX2VkZ2VBLm90aGVyID0gai5tX2JvZHlCO1xyXG4gICAgICBqLm1fZWRnZUEucHJldiA9IG51bGw7XHJcbiAgICAgIGoubV9lZGdlQS5uZXh0ID0gai5tX2JvZHlBLm1fam9pbnRMaXN0O1xyXG4gICAgICBpZiAoai5tX2JvZHlBLm1fam9pbnRMaXN0KSBqLm1fYm9keUEubV9qb2ludExpc3QucHJldiA9IGoubV9lZGdlQTtcclxuICAgICAgai5tX2JvZHlBLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VBO1xyXG4gICAgICBqLm1fZWRnZUIuam9pbnQgPSBqO1xyXG4gICAgICBqLm1fZWRnZUIub3RoZXIgPSBqLm1fYm9keUE7XHJcbiAgICAgIGoubV9lZGdlQi5wcmV2ID0gbnVsbDtcclxuICAgICAgai5tX2VkZ2VCLm5leHQgPSBqLm1fYm9keUIubV9qb2ludExpc3Q7XHJcbiAgICAgIGlmIChqLm1fYm9keUIubV9qb2ludExpc3QpIGoubV9ib2R5Qi5tX2pvaW50TGlzdC5wcmV2ID0gai5tX2VkZ2VCO1xyXG4gICAgICBqLm1fYm9keUIubV9qb2ludExpc3QgPSBqLm1fZWRnZUI7XHJcbiAgICAgIHZhciBib2R5QSA9IGRlZi5ib2R5QTtcclxuICAgICAgdmFyIGJvZHlCID0gZGVmLmJvZHlCO1xyXG4gICAgICBpZiAoZGVmLmNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgdmFyIGVkZ2UgPSBib2R5Qi5HZXRDb250YWN0TGlzdCgpO1xyXG4gICAgICAgICB3aGlsZSAoZWRnZSkge1xyXG4gICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xyXG4gICAgICAgICAgICAgICBlZGdlLmNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gajtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5EZXN0cm95Sm9pbnQgPSBmdW5jdGlvbiAoaikge1xyXG4gICAgICB2YXIgY29sbGlkZUNvbm5lY3RlZCA9IGoubV9jb2xsaWRlQ29ubmVjdGVkO1xyXG4gICAgICBpZiAoai5tX3ByZXYpIHtcclxuICAgICAgICAgai5tX3ByZXYubV9uZXh0ID0gai5tX25leHQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGoubV9uZXh0KSB7XHJcbiAgICAgICAgIGoubV9uZXh0Lm1fcHJldiA9IGoubV9wcmV2O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqID09IHRoaXMubV9qb2ludExpc3QpIHtcclxuICAgICAgICAgdGhpcy5tX2pvaW50TGlzdCA9IGoubV9uZXh0O1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBib2R5QSA9IGoubV9ib2R5QTtcclxuICAgICAgdmFyIGJvZHlCID0gai5tX2JvZHlCO1xyXG4gICAgICBib2R5QS5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIGlmIChqLm1fZWRnZUEucHJldikge1xyXG4gICAgICAgICBqLm1fZWRnZUEucHJldi5uZXh0ID0gai5tX2VkZ2VBLm5leHQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGoubV9lZGdlQS5uZXh0KSB7XHJcbiAgICAgICAgIGoubV9lZGdlQS5uZXh0LnByZXYgPSBqLm1fZWRnZUEucHJldjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoai5tX2VkZ2VBID09IGJvZHlBLm1fam9pbnRMaXN0KSB7XHJcbiAgICAgICAgIGJvZHlBLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VBLm5leHQ7XHJcbiAgICAgIH1cclxuICAgICAgai5tX2VkZ2VBLnByZXYgPSBudWxsO1xyXG4gICAgICBqLm1fZWRnZUEubmV4dCA9IG51bGw7XHJcbiAgICAgIGlmIChqLm1fZWRnZUIucHJldikge1xyXG4gICAgICAgICBqLm1fZWRnZUIucHJldi5uZXh0ID0gai5tX2VkZ2VCLm5leHQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGoubV9lZGdlQi5uZXh0KSB7XHJcbiAgICAgICAgIGoubV9lZGdlQi5uZXh0LnByZXYgPSBqLm1fZWRnZUIucHJldjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoai5tX2VkZ2VCID09IGJvZHlCLm1fam9pbnRMaXN0KSB7XHJcbiAgICAgICAgIGJvZHlCLm1fam9pbnRMaXN0ID0gai5tX2VkZ2VCLm5leHQ7XHJcbiAgICAgIH1cclxuICAgICAgai5tX2VkZ2VCLnByZXYgPSBudWxsO1xyXG4gICAgICBqLm1fZWRnZUIubmV4dCA9IG51bGw7XHJcbiAgICAgIGIySm9pbnQuRGVzdHJveShqLCBudWxsKTtcclxuICAgICAgLS10aGlzLm1fam9pbnRDb3VudDtcclxuICAgICAgaWYgKGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgdmFyIGVkZ2UgPSBib2R5Qi5HZXRDb250YWN0TGlzdCgpO1xyXG4gICAgICAgICB3aGlsZSAoZWRnZSkge1xyXG4gICAgICAgICAgICBpZiAoZWRnZS5vdGhlciA9PSBib2R5QSkge1xyXG4gICAgICAgICAgICAgICBlZGdlLmNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkFkZENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICBjLm1fbmV4dCA9IHRoaXMubV9jb250cm9sbGVyTGlzdDtcclxuICAgICAgYy5tX3ByZXYgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBjO1xyXG4gICAgICBjLm1fd29ybGQgPSB0aGlzO1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50Kys7XHJcbiAgICAgIHJldHVybiBjO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLlJlbW92ZUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICBpZiAoYy5tX3ByZXYpIGMubV9wcmV2Lm1fbmV4dCA9IGMubV9uZXh0O1xyXG4gICAgICBpZiAoYy5tX25leHQpIGMubV9uZXh0Lm1fcHJldiA9IGMubV9wcmV2O1xyXG4gICAgICBpZiAodGhpcy5tX2NvbnRyb2xsZXJMaXN0ID09IGMpIHRoaXMubV9jb250cm9sbGVyTGlzdCA9IGMubV9uZXh0O1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckNvdW50LS07XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuQ3JlYXRlQ29udHJvbGxlciA9IGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XHJcbiAgICAgIGlmIChjb250cm9sbGVyLm1fd29ybGQgIT0gdGhpcykgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJvbGxlciBjYW4gb25seSBiZSBhIG1lbWJlciBvZiBvbmUgd29ybGRcIik7XHJcbiAgICAgIGNvbnRyb2xsZXIubV9uZXh0ID0gdGhpcy5tX2NvbnRyb2xsZXJMaXN0O1xyXG4gICAgICBjb250cm9sbGVyLm1fcHJldiA9IG51bGw7XHJcbiAgICAgIGlmICh0aGlzLm1fY29udHJvbGxlckxpc3QpIHRoaXMubV9jb250cm9sbGVyTGlzdC5tX3ByZXYgPSBjb250cm9sbGVyO1xyXG4gICAgICB0aGlzLm1fY29udHJvbGxlckxpc3QgPSBjb250cm9sbGVyO1xyXG4gICAgICArK3RoaXMubV9jb250cm9sbGVyQ291bnQ7XHJcbiAgICAgIGNvbnRyb2xsZXIubV93b3JsZCA9IHRoaXM7XHJcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkRlc3Ryb3lDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgY29udHJvbGxlci5DbGVhcigpO1xyXG4gICAgICBpZiAoY29udHJvbGxlci5tX25leHQpIGNvbnRyb2xsZXIubV9uZXh0Lm1fcHJldiA9IGNvbnRyb2xsZXIubV9wcmV2O1xyXG4gICAgICBpZiAoY29udHJvbGxlci5tX3ByZXYpIGNvbnRyb2xsZXIubV9wcmV2Lm1fbmV4dCA9IGNvbnRyb2xsZXIubV9uZXh0O1xyXG4gICAgICBpZiAoY29udHJvbGxlciA9PSB0aGlzLm1fY29udHJvbGxlckxpc3QpIHRoaXMubV9jb250cm9sbGVyTGlzdCA9IGNvbnRyb2xsZXIubV9uZXh0O1xyXG4gICAgICAtLXRoaXMubV9jb250cm9sbGVyQ291bnQ7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0V2FybVN0YXJ0aW5nID0gZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgYjJXb3JsZC5tX3dhcm1TdGFydGluZyA9IGZsYWc7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0Q29udGludW91c1BoeXNpY3MgPSBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICBiMldvcmxkLm1fY29udGludW91c1BoeXNpY3MgPSBmbGFnO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEJvZHlDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Q291bnQ7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0Sm9pbnRDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9qb2ludENvdW50O1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkdldENvbnRhY3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9jb250YWN0Q291bnQ7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuU2V0R3Jhdml0eSA9IGZ1bmN0aW9uIChncmF2aXR5KSB7XHJcbiAgICAgIHRoaXMubV9ncmF2aXR5ID0gZ3Jhdml0eTtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5HZXRHcmF2aXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2dyYXZpdHk7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0R3JvdW5kQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ncm91bmRCb2R5O1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLlN0ZXAgPSBmdW5jdGlvbiAoZHQsIHZlbG9jaXR5SXRlcmF0aW9ucywgcG9zaXRpb25JdGVyYXRpb25zKSB7XHJcbiAgICAgIGlmIChkdCA9PT0gdW5kZWZpbmVkKSBkdCA9IDA7XHJcbiAgICAgIGlmICh2ZWxvY2l0eUl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgdmVsb2NpdHlJdGVyYXRpb25zID0gMDtcclxuICAgICAgaWYgKHBvc2l0aW9uSXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSBwb3NpdGlvbkl0ZXJhdGlvbnMgPSAwO1xyXG4gICAgICBpZiAodGhpcy5tX2ZsYWdzICYgYjJXb3JsZC5lX25ld0ZpeHR1cmUpIHtcclxuICAgICAgICAgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyV29ybGQuZV9uZXdGaXh0dXJlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9mbGFncyB8PSBiMldvcmxkLmVfbG9ja2VkO1xyXG4gICAgICB2YXIgc3RlcCA9IGIyV29ybGQuc190aW1lc3RlcDI7XHJcbiAgICAgIHN0ZXAuZHQgPSBkdDtcclxuICAgICAgc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnMgPSB2ZWxvY2l0eUl0ZXJhdGlvbnM7XHJcbiAgICAgIHN0ZXAucG9zaXRpb25JdGVyYXRpb25zID0gcG9zaXRpb25JdGVyYXRpb25zO1xyXG4gICAgICBpZiAoZHQgPiAwLjApIHtcclxuICAgICAgICAgc3RlcC5pbnZfZHQgPSAxLjAgLyBkdDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgc3RlcC5pbnZfZHQgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgc3RlcC5kdFJhdGlvID0gdGhpcy5tX2ludl9kdDAgKiBkdDtcclxuICAgICAgc3RlcC53YXJtU3RhcnRpbmcgPSBiMldvcmxkLm1fd2FybVN0YXJ0aW5nO1xyXG4gICAgICB0aGlzLm1fY29udGFjdE1hbmFnZXIuQ29sbGlkZSgpO1xyXG4gICAgICBpZiAoc3RlcC5kdCA+IDAuMCkge1xyXG4gICAgICAgICB0aGlzLlNvbHZlKHN0ZXApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChiMldvcmxkLm1fY29udGludW91c1BoeXNpY3MgJiYgc3RlcC5kdCA+IDAuMCkge1xyXG4gICAgICAgICB0aGlzLlNvbHZlVE9JKHN0ZXApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGVwLmR0ID4gMC4wKSB7XHJcbiAgICAgICAgIHRoaXMubV9pbnZfZHQwID0gc3RlcC5pbnZfZHQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMldvcmxkLmVfbG9ja2VkO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkNsZWFyRm9yY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBmb3IgKHZhciBib2R5ID0gdGhpcy5tX2JvZHlMaXN0OyBib2R5OyBib2R5ID0gYm9keS5tX25leHQpIHtcclxuICAgICAgICAgYm9keS5tX2ZvcmNlLlNldFplcm8oKTtcclxuICAgICAgICAgYm9keS5tX3RvcnF1ZSA9IDAuMDtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkRyYXdEZWJ1Z0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLm1fZGVidWdEcmF3ID09IG51bGwpIHtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9kZWJ1Z0RyYXcubV9zcHJpdGUuZ3JhcGhpY3MuY2xlYXIoKTtcclxuICAgICAgdmFyIGZsYWdzID0gdGhpcy5tX2RlYnVnRHJhdy5HZXRGbGFncygpO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBiO1xyXG4gICAgICB2YXIgZjtcclxuICAgICAgdmFyIHM7XHJcbiAgICAgIHZhciBqO1xyXG4gICAgICB2YXIgYnA7XHJcbiAgICAgIHZhciBpbnZRID0gbmV3IGIyVmVjMjtcclxuICAgICAgdmFyIHgxID0gbmV3IGIyVmVjMjtcclxuICAgICAgdmFyIHgyID0gbmV3IGIyVmVjMjtcclxuICAgICAgdmFyIHhmO1xyXG4gICAgICB2YXIgYjEgPSBuZXcgYjJBQUJCKCk7XHJcbiAgICAgIHZhciBiMiA9IG5ldyBiMkFBQkIoKTtcclxuICAgICAgdmFyIHZzID0gW25ldyBiMlZlYzIoKSwgbmV3IGIyVmVjMigpLCBuZXcgYjJWZWMyKCksIG5ldyBiMlZlYzIoKV07XHJcbiAgICAgIHZhciBjb2xvciA9IG5ldyBiMkNvbG9yKDAsIDAsIDApO1xyXG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX3NoYXBlQml0KSB7XHJcbiAgICAgICAgIGZvciAoYiA9IHRoaXMubV9ib2R5TGlzdDtcclxuICAgICAgICAgYjsgYiA9IGIubV9uZXh0KSB7XHJcbiAgICAgICAgICAgIHhmID0gYi5tX3hmO1xyXG4gICAgICAgICAgICBmb3IgKGYgPSBiLkdldEZpeHR1cmVMaXN0KCk7XHJcbiAgICAgICAgICAgIGY7IGYgPSBmLm1fbmV4dCkge1xyXG4gICAgICAgICAgICAgICBzID0gZi5HZXRTaGFwZSgpO1xyXG4gICAgICAgICAgICAgICBpZiAoYi5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yLlNldCgwLjUsIDAuNSwgMC4zKTtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBlbHNlIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICBjb2xvci5TZXQoMC41LCAwLjksIDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1NoYXBlKHMsIHhmLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX2tpbmVtYXRpY0JvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuNSwgMC41LCAwLjkpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLkRyYXdTaGFwZShzLCB4ZiwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuSXNBd2FrZSgpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yLlNldCgwLjYsIDAuNiwgMC42KTtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5EcmF3U2hhcGUocywgeGYsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgY29sb3IuU2V0KDAuOSwgMC43LCAwLjcpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLkRyYXdTaGFwZShzLCB4ZiwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChmbGFncyAmIGIyRGVidWdEcmF3LmVfam9pbnRCaXQpIHtcclxuICAgICAgICAgZm9yIChqID0gdGhpcy5tX2pvaW50TGlzdDtcclxuICAgICAgICAgajsgaiA9IGoubV9uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuRHJhd0pvaW50KGopO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGZsYWdzICYgYjJEZWJ1Z0RyYXcuZV9jb250cm9sbGVyQml0KSB7XHJcbiAgICAgICAgIGZvciAodmFyIGMgPSB0aGlzLm1fY29udHJvbGxlckxpc3Q7IGM7IGMgPSBjLm1fbmV4dCkge1xyXG4gICAgICAgICAgICBjLkRyYXcodGhpcy5tX2RlYnVnRHJhdyk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX3BhaXJCaXQpIHtcclxuICAgICAgICAgY29sb3IuU2V0KDAuMywgMC45LCAwLjkpO1xyXG4gICAgICAgICBmb3IgKHZhciBjb250YWN0ID0gdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdExpc3Q7IGNvbnRhY3Q7IGNvbnRhY3QgPSBjb250YWN0LkdldE5leHQoKSkge1xyXG4gICAgICAgICAgICB2YXIgZml4dHVyZUEgPSBjb250YWN0LkdldEZpeHR1cmVBKCk7XHJcbiAgICAgICAgICAgIHZhciBmaXh0dXJlQiA9IGNvbnRhY3QuR2V0Rml4dHVyZUIoKTtcclxuICAgICAgICAgICAgdmFyIGNBID0gZml4dHVyZUEuR2V0QUFCQigpLkdldENlbnRlcigpO1xyXG4gICAgICAgICAgICB2YXIgY0IgPSBmaXh0dXJlQi5HZXRBQUJCKCkuR2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQoY0EsIGNCLCBjb2xvcik7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX2FhYmJCaXQpIHtcclxuICAgICAgICAgYnAgPSB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9icm9hZFBoYXNlO1xyXG4gICAgICAgICB2cyA9IFtuZXcgYjJWZWMyKCksIG5ldyBiMlZlYzIoKSwgbmV3IGIyVmVjMigpLCBuZXcgYjJWZWMyKCldO1xyXG4gICAgICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgICAgIGI7IGIgPSBiLkdldE5leHQoKSkge1xyXG4gICAgICAgICAgICBpZiAoYi5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoZiA9IGIuR2V0Rml4dHVyZUxpc3QoKTtcclxuICAgICAgICAgICAgZjsgZiA9IGYuR2V0TmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBhYWJiID0gYnAuR2V0RmF0QUFCQihmLm1fcHJveHkpO1xyXG4gICAgICAgICAgICAgICB2c1swXS5TZXQoYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55KTtcclxuICAgICAgICAgICAgICAgdnNbMV0uU2V0KGFhYmIudXBwZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueSk7XHJcbiAgICAgICAgICAgICAgIHZzWzJdLlNldChhYWJiLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLnkpO1xyXG4gICAgICAgICAgICAgICB2c1szXS5TZXQoYWFiYi5sb3dlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55KTtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3UG9seWdvbih2cywgNCwgY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoZmxhZ3MgJiBiMkRlYnVnRHJhdy5lX2NlbnRlck9mTWFzc0JpdCkge1xyXG4gICAgICAgICBmb3IgKGIgPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgICAgIGI7IGIgPSBiLm1fbmV4dCkge1xyXG4gICAgICAgICAgICB4ZiA9IGIyV29ybGQuc194ZjtcclxuICAgICAgICAgICAgeGYuUiA9IGIubV94Zi5SO1xyXG4gICAgICAgICAgICB4Zi5wb3NpdGlvbiA9IGIuR2V0V29ybGRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3VHJhbnNmb3JtKHhmKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuUXVlcnlBQUJCID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhYWJiKSB7XHJcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xyXG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IF9fdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XHJcbiAgICAgICAgIHJldHVybiBjYWxsYmFjayhicm9hZFBoYXNlLkdldFVzZXJEYXRhKHByb3h5KSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGJyb2FkUGhhc2UuUXVlcnkoV29ybGRRdWVyeVdyYXBwZXIsIGFhYmIpO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLlF1ZXJ5U2hhcGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHNoYXBlLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XHJcbiAgICAgIGlmICh0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCkgdHJhbnNmb3JtID0gbnVsbDtcclxuICAgICAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSB7XHJcbiAgICAgICAgIHRyYW5zZm9ybSA9IG5ldyBiMlRyYW5zZm9ybSgpO1xyXG4gICAgICAgICB0cmFuc2Zvcm0uU2V0SWRlbnRpdHkoKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IF9fdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XHJcbiAgICAgICAgIHZhciBmaXh0dXJlID0gKGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gYnJvYWRQaGFzZS5HZXRVc2VyRGF0YShwcm94eSkgOiBudWxsKTtcclxuICAgICAgICAgaWYgKGIyU2hhcGUuVGVzdE92ZXJsYXAoc2hhcGUsIHRyYW5zZm9ybSwgZml4dHVyZS5HZXRTaGFwZSgpLCBmaXh0dXJlLkdldEJvZHkoKS5HZXRUcmFuc2Zvcm0oKSkpIHJldHVybiBjYWxsYmFjayhmaXh0dXJlKTtcclxuICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBhYWJiID0gbmV3IGIyQUFCQigpO1xyXG4gICAgICBzaGFwZS5Db21wdXRlQUFCQihhYWJiLCB0cmFuc2Zvcm0pO1xyXG4gICAgICBicm9hZFBoYXNlLlF1ZXJ5KFdvcmxkUXVlcnlXcmFwcGVyLCBhYWJiKTtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5RdWVyeVBvaW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBwKSB7XHJcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xyXG4gICAgICB2YXIgYnJvYWRQaGFzZSA9IF9fdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fYnJvYWRQaGFzZTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIFdvcmxkUXVlcnlXcmFwcGVyKHByb3h5KSB7XHJcbiAgICAgICAgIHZhciBmaXh0dXJlID0gKGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpIGluc3RhbmNlb2YgYjJGaXh0dXJlID8gYnJvYWRQaGFzZS5HZXRVc2VyRGF0YShwcm94eSkgOiBudWxsKTtcclxuICAgICAgICAgaWYgKGZpeHR1cmUuVGVzdFBvaW50KHApKSByZXR1cm4gY2FsbGJhY2soZml4dHVyZSk7XHJcbiAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9O1xyXG4gICAgICB2YXIgYWFiYiA9IG5ldyBiMkFBQkIoKTtcclxuICAgICAgYWFiYi5sb3dlckJvdW5kLlNldChwLnggLSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsIHAueSAtIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCk7XHJcbiAgICAgIGFhYmIudXBwZXJCb3VuZC5TZXQocC54ICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCBwLnkgKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApO1xyXG4gICAgICBicm9hZFBoYXNlLlF1ZXJ5KFdvcmxkUXVlcnlXcmFwcGVyLCBhYWJiKTtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5SYXlDYXN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBwb2ludDEsIHBvaW50Mikge1xyXG4gICAgICB2YXIgX190aGlzID0gdGhpcztcclxuICAgICAgdmFyIGJyb2FkUGhhc2UgPSBfX3RoaXMubV9jb250YWN0TWFuYWdlci5tX2Jyb2FkUGhhc2U7XHJcbiAgICAgIHZhciBvdXRwdXQgPSBuZXcgYjJSYXlDYXN0T3V0cHV0O1xyXG5cclxuICAgICAgZnVuY3Rpb24gUmF5Q2FzdFdyYXBwZXIoaW5wdXQsIHByb3h5KSB7XHJcbiAgICAgICAgIHZhciB1c2VyRGF0YSA9IGJyb2FkUGhhc2UuR2V0VXNlckRhdGEocHJveHkpO1xyXG4gICAgICAgICB2YXIgZml4dHVyZSA9ICh1c2VyRGF0YSBpbnN0YW5jZW9mIGIyRml4dHVyZSA/IHVzZXJEYXRhIDogbnVsbCk7XHJcbiAgICAgICAgIHZhciBoaXQgPSBmaXh0dXJlLlJheUNhc3Qob3V0cHV0LCBpbnB1dCk7XHJcbiAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgdmFyIGZyYWN0aW9uID0gb3V0cHV0LmZyYWN0aW9uO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBuZXcgYjJWZWMyKCgxLjAgLSBmcmFjdGlvbikgKiBwb2ludDEueCArIGZyYWN0aW9uICogcG9pbnQyLngsICgxLjAgLSBmcmFjdGlvbikgKiBwb2ludDEueSArIGZyYWN0aW9uICogcG9pbnQyLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZml4dHVyZSwgcG9pbnQsIG91dHB1dC5ub3JtYWwsIGZyYWN0aW9uKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICByZXR1cm4gaW5wdXQubWF4RnJhY3Rpb247XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBpbnB1dCA9IG5ldyBiMlJheUNhc3RJbnB1dChwb2ludDEsIHBvaW50Mik7XHJcbiAgICAgIGJyb2FkUGhhc2UuUmF5Q2FzdChSYXlDYXN0V3JhcHBlciwgaW5wdXQpO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLlJheUNhc3RPbmUgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIpIHtcclxuICAgICAgdmFyIF9fdGhpcyA9IHRoaXM7XHJcbiAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICBmdW5jdGlvbiBSYXlDYXN0T25lV3JhcHBlcihmaXh0dXJlLCBwb2ludCwgbm9ybWFsLCBmcmFjdGlvbikge1xyXG4gICAgICAgICBpZiAoZnJhY3Rpb24gPT09IHVuZGVmaW5lZCkgZnJhY3Rpb24gPSAwO1xyXG4gICAgICAgICByZXN1bHQgPSBmaXh0dXJlO1xyXG4gICAgICAgICByZXR1cm4gZnJhY3Rpb247XHJcbiAgICAgIH07XHJcbiAgICAgIF9fdGhpcy5SYXlDYXN0KFJheUNhc3RPbmVXcmFwcGVyLCBwb2ludDEsIHBvaW50Mik7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuUmF5Q2FzdEFsbCA9IGZ1bmN0aW9uIChwb2ludDEsIHBvaW50Mikge1xyXG4gICAgICB2YXIgX190aGlzID0gdGhpcztcclxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIFJheUNhc3RBbGxXcmFwcGVyKGZpeHR1cmUsIHBvaW50LCBub3JtYWwsIGZyYWN0aW9uKSB7XHJcbiAgICAgICAgIGlmIChmcmFjdGlvbiA9PT0gdW5kZWZpbmVkKSBmcmFjdGlvbiA9IDA7XHJcbiAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGZpeHR1cmU7XHJcbiAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9O1xyXG4gICAgICBfX3RoaXMuUmF5Q2FzdChSYXlDYXN0QWxsV3JhcHBlciwgcG9pbnQxLCBwb2ludDIpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEJvZHlMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlMaXN0O1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkdldEpvaW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9qb2ludExpc3Q7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuR2V0Q29udGFjdExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fY29udGFjdExpc3Q7XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuSXNMb2NrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJXb3JsZC5lX2xvY2tlZCkgPiAwO1xyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLlNvbHZlID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgdmFyIGI7XHJcbiAgICAgIGZvciAodmFyIGNvbnRyb2xsZXIgPSB0aGlzLm1fY29udHJvbGxlckxpc3Q7IGNvbnRyb2xsZXI7IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyLm1fbmV4dCkge1xyXG4gICAgICAgICBjb250cm9sbGVyLlN0ZXAoc3RlcCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGlzbGFuZCA9IHRoaXMubV9pc2xhbmQ7XHJcbiAgICAgIGlzbGFuZC5Jbml0aWFsaXplKHRoaXMubV9ib2R5Q291bnQsIHRoaXMubV9jb250YWN0Q291bnQsIHRoaXMubV9qb2ludENvdW50LCBudWxsLCB0aGlzLm1fY29udGFjdE1hbmFnZXIubV9jb250YWN0TGlzdGVuZXIsIHRoaXMubV9jb250YWN0U29sdmVyKTtcclxuICAgICAgZm9yIChiID0gdGhpcy5tX2JvZHlMaXN0O1xyXG4gICAgICBiOyBiID0gYi5tX25leHQpIHtcclxuICAgICAgICAgYi5tX2ZsYWdzICY9IH5iMkJvZHkuZV9pc2xhbmRGbGFnO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIGMgPSB0aGlzLm1fY29udGFjdExpc3Q7IGM7IGMgPSBjLm1fbmV4dCkge1xyXG4gICAgICAgICBjLm1fZmxhZ3MgJj0gfmIyQ29udGFjdC5lX2lzbGFuZEZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaiA9IHRoaXMubV9qb2ludExpc3Q7IGo7IGogPSBqLm1fbmV4dCkge1xyXG4gICAgICAgICBqLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzdGFja1NpemUgPSBwYXJzZUludCh0aGlzLm1fYm9keUNvdW50KTtcclxuICAgICAgdmFyIHN0YWNrID0gdGhpcy5zX3N0YWNrO1xyXG4gICAgICBmb3IgKHZhciBzZWVkID0gdGhpcy5tX2JvZHlMaXN0OyBzZWVkOyBzZWVkID0gc2VlZC5tX25leHQpIHtcclxuICAgICAgICAgaWYgKHNlZWQubV9mbGFncyAmIGIyQm9keS5lX2lzbGFuZEZsYWcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKHNlZWQuSXNBd2FrZSgpID09IGZhbHNlIHx8IHNlZWQuSXNBY3RpdmUoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAoc2VlZC5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaXNsYW5kLkNsZWFyKCk7XHJcbiAgICAgICAgIHZhciBzdGFja0NvdW50ID0gMDtcclxuICAgICAgICAgc3RhY2tbc3RhY2tDb3VudCsrXSA9IHNlZWQ7XHJcbiAgICAgICAgIHNlZWQubV9mbGFncyB8PSBiMkJvZHkuZV9pc2xhbmRGbGFnO1xyXG4gICAgICAgICB3aGlsZSAoc3RhY2tDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgYiA9IHN0YWNrWy0tc3RhY2tDb3VudF07XHJcbiAgICAgICAgICAgIGlzbGFuZC5BZGRCb2R5KGIpO1xyXG4gICAgICAgICAgICBpZiAoYi5Jc0F3YWtlKCkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgYi5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgPT0gYjJCb2R5LmIyX3N0YXRpY0JvZHkpIHtcclxuICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG90aGVyO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjZSA9IGIubV9jb250YWN0TGlzdDsgY2U7IGNlID0gY2UubmV4dCkge1xyXG4gICAgICAgICAgICAgICBpZiAoY2UuY29udGFjdC5tX2ZsYWdzICYgYjJDb250YWN0LmVfaXNsYW5kRmxhZykge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZiAoY2UuY29udGFjdC5Jc1NlbnNvcigpID09IHRydWUgfHwgY2UuY29udGFjdC5Jc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjZS5jb250YWN0LklzVG91Y2hpbmcoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpc2xhbmQuQWRkQ29udGFjdChjZS5jb250YWN0KTtcclxuICAgICAgICAgICAgICAgY2UuY29udGFjdC5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2lzbGFuZEZsYWc7XHJcbiAgICAgICAgICAgICAgIG90aGVyID0gY2Uub3RoZXI7XHJcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2ZsYWdzICYgYjJCb2R5LmVfaXNsYW5kRmxhZykge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzdGFja1tzdGFja0NvdW50KytdID0gb3RoZXI7XHJcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqbiA9IGIubV9qb2ludExpc3Q7IGpuOyBqbiA9IGpuLm5leHQpIHtcclxuICAgICAgICAgICAgICAgaWYgKGpuLmpvaW50Lm1faXNsYW5kRmxhZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIG90aGVyID0gam4ub3RoZXI7XHJcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5Jc0FjdGl2ZSgpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGlzbGFuZC5BZGRKb2ludChqbi5qb2ludCk7XHJcbiAgICAgICAgICAgICAgIGpuLmpvaW50Lm1faXNsYW5kRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgIGlmIChvdGhlci5tX2ZsYWdzICYgYjJCb2R5LmVfaXNsYW5kRmxhZykge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBzdGFja1tzdGFja0NvdW50KytdID0gb3RoZXI7XHJcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGlzbGFuZC5Tb2x2ZShzdGVwLCB0aGlzLm1fZ3Jhdml0eSwgdGhpcy5tX2FsbG93U2xlZXApO1xyXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlzbGFuZC5tX2JvZHlDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGIgPSBpc2xhbmQubV9ib2RpZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSA9PSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xyXG4gICAgICAgICAgICAgICBiLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2lzbGFuZEZsYWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgIGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICBpZiAoIXN0YWNrW2ldKSBicmVhaztcclxuICAgICAgICAgc3RhY2tbaV0gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoYiA9IHRoaXMubV9ib2R5TGlzdDtcclxuICAgICAgYjsgYiA9IGIubV9uZXh0KSB7XHJcbiAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSB8fCBiLklzQWN0aXZlKCkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKGIuR2V0VHlwZSgpID09IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlci5GaW5kTmV3Q29udGFjdHMoKTtcclxuICAgfVxyXG4gICBiMldvcmxkLnByb3RvdHlwZS5Tb2x2ZVRPSSA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBiO1xyXG4gICAgICB2YXIgZkE7XHJcbiAgICAgIHZhciBmQjtcclxuICAgICAgdmFyIGJBO1xyXG4gICAgICB2YXIgYkI7XHJcbiAgICAgIHZhciBjRWRnZTtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBpc2xhbmQgPSB0aGlzLm1faXNsYW5kO1xyXG4gICAgICBpc2xhbmQuSW5pdGlhbGl6ZSh0aGlzLm1fYm9keUNvdW50LCBiMlNldHRpbmdzLmIyX21heFRPSUNvbnRhY3RzUGVySXNsYW5kLCBiMlNldHRpbmdzLmIyX21heFRPSUpvaW50c1BlcklzbGFuZCwgbnVsbCwgdGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdExpc3RlbmVyLCB0aGlzLm1fY29udGFjdFNvbHZlcik7XHJcbiAgICAgIHZhciBxdWV1ZSA9IGIyV29ybGQuc19xdWV1ZTtcclxuICAgICAgZm9yIChiID0gdGhpcy5tX2JvZHlMaXN0O1xyXG4gICAgICBiOyBiID0gYi5tX25leHQpIHtcclxuICAgICAgICAgYi5tX2ZsYWdzICY9IH5iMkJvZHkuZV9pc2xhbmRGbGFnO1xyXG4gICAgICAgICBiLm1fc3dlZXAudDAgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGM7XHJcbiAgICAgIGZvciAoYyA9IHRoaXMubV9jb250YWN0TGlzdDtcclxuICAgICAgYzsgYyA9IGMubV9uZXh0KSB7XHJcbiAgICAgICAgIGMubV9mbGFncyAmPSB+IChiMkNvbnRhY3QuZV90b2lGbGFnIHwgYjJDb250YWN0LmVfaXNsYW5kRmxhZyk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChqID0gdGhpcy5tX2pvaW50TGlzdDtcclxuICAgICAgajsgaiA9IGoubV9uZXh0KSB7XHJcbiAgICAgICAgIGoubV9pc2xhbmRGbGFnID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICB2YXIgbWluQ29udGFjdCA9IG51bGw7XHJcbiAgICAgICAgIHZhciBtaW5UT0kgPSAxLjA7XHJcbiAgICAgICAgIGZvciAoYyA9IHRoaXMubV9jb250YWN0TGlzdDtcclxuICAgICAgICAgYzsgYyA9IGMubV9uZXh0KSB7XHJcbiAgICAgICAgICAgIGlmIChjLklzU2Vuc29yKCkgPT0gdHJ1ZSB8fCBjLklzRW5hYmxlZCgpID09IGZhbHNlIHx8IGMuSXNDb250aW51b3VzKCkgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvaSA9IDEuMDtcclxuICAgICAgICAgICAgaWYgKGMubV9mbGFncyAmIGIyQ29udGFjdC5lX3RvaUZsYWcpIHtcclxuICAgICAgICAgICAgICAgdG9pID0gYy5tX3RvaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgZkEgPSBjLm1fZml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgIGZCID0gYy5tX2ZpeHR1cmVCO1xyXG4gICAgICAgICAgICAgICBiQSA9IGZBLm1fYm9keTtcclxuICAgICAgICAgICAgICAgYkIgPSBmQi5tX2JvZHk7XHJcbiAgICAgICAgICAgICAgIGlmICgoYkEuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSB8fCBiQS5Jc0F3YWtlKCkgPT0gZmFsc2UpICYmIChiQi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5IHx8IGJCLklzQXdha2UoKSA9PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdmFyIHQwID0gYkEubV9zd2VlcC50MDtcclxuICAgICAgICAgICAgICAgaWYgKGJBLm1fc3dlZXAudDAgPCBiQi5tX3N3ZWVwLnQwKSB7XHJcbiAgICAgICAgICAgICAgICAgIHQwID0gYkIubV9zd2VlcC50MDtcclxuICAgICAgICAgICAgICAgICAgYkEubV9zd2VlcC5BZHZhbmNlKHQwKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBlbHNlIGlmIChiQi5tX3N3ZWVwLnQwIDwgYkEubV9zd2VlcC50MCkge1xyXG4gICAgICAgICAgICAgICAgICB0MCA9IGJBLm1fc3dlZXAudDA7XHJcbiAgICAgICAgICAgICAgICAgIGJCLm1fc3dlZXAuQWR2YW5jZSh0MCk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgdG9pID0gYy5Db21wdXRlVE9JKGJBLm1fc3dlZXAsIGJCLm1fc3dlZXApO1xyXG4gICAgICAgICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KDAuMCA8PSB0b2kgJiYgdG9pIDw9IDEuMCk7XHJcbiAgICAgICAgICAgICAgIGlmICh0b2kgPiAwLjAgJiYgdG9pIDwgMS4wKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRvaSA9ICgxLjAgLSB0b2kpICogdDAgKyB0b2k7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0b2kgPiAxKSB0b2kgPSAxO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGMubV90b2kgPSB0b2k7XHJcbiAgICAgICAgICAgICAgIGMubV9mbGFncyB8PSBiMkNvbnRhY3QuZV90b2lGbGFnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuTUlOX1ZBTFVFIDwgdG9pICYmIHRvaSA8IG1pblRPSSkge1xyXG4gICAgICAgICAgICAgICBtaW5Db250YWN0ID0gYztcclxuICAgICAgICAgICAgICAgbWluVE9JID0gdG9pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxLjAgLSAxMDAuMCAqIE51bWJlci5NSU5fVkFMVUUgPCBtaW5UT0kpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZkEgPSBtaW5Db250YWN0Lm1fZml4dHVyZUE7XHJcbiAgICAgICAgIGZCID0gbWluQ29udGFjdC5tX2ZpeHR1cmVCO1xyXG4gICAgICAgICBiQSA9IGZBLm1fYm9keTtcclxuICAgICAgICAgYkIgPSBmQi5tX2JvZHk7XHJcbiAgICAgICAgIGIyV29ybGQuc19iYWNrdXBBLlNldChiQS5tX3N3ZWVwKTtcclxuICAgICAgICAgYjJXb3JsZC5zX2JhY2t1cEIuU2V0KGJCLm1fc3dlZXApO1xyXG4gICAgICAgICBiQS5BZHZhbmNlKG1pblRPSSk7XHJcbiAgICAgICAgIGJCLkFkdmFuY2UobWluVE9JKTtcclxuICAgICAgICAgbWluQ29udGFjdC5VcGRhdGUodGhpcy5tX2NvbnRhY3RNYW5hZ2VyLm1fY29udGFjdExpc3RlbmVyKTtcclxuICAgICAgICAgbWluQ29udGFjdC5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV90b2lGbGFnO1xyXG4gICAgICAgICBpZiAobWluQ29udGFjdC5Jc1NlbnNvcigpID09IHRydWUgfHwgbWluQ29udGFjdC5Jc0VuYWJsZWQoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBiQS5tX3N3ZWVwLlNldChiMldvcmxkLnNfYmFja3VwQSk7XHJcbiAgICAgICAgICAgIGJCLm1fc3dlZXAuU2V0KGIyV29ybGQuc19iYWNrdXBCKTtcclxuICAgICAgICAgICAgYkEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgaWYgKG1pbkNvbnRhY3QuSXNUb3VjaGluZygpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBzZWVkID0gYkE7XHJcbiAgICAgICAgIGlmIChzZWVkLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcclxuICAgICAgICAgICAgc2VlZCA9IGJCO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGlzbGFuZC5DbGVhcigpO1xyXG4gICAgICAgICB2YXIgcXVldWVTdGFydCA9IDA7XHJcbiAgICAgICAgIHZhciBxdWV1ZVNpemUgPSAwO1xyXG4gICAgICAgICBxdWV1ZVtxdWV1ZVN0YXJ0ICsgcXVldWVTaXplKytdID0gc2VlZDtcclxuICAgICAgICAgc2VlZC5tX2ZsYWdzIHw9IGIyQm9keS5lX2lzbGFuZEZsYWc7XHJcbiAgICAgICAgIHdoaWxlIChxdWV1ZVNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGIgPSBxdWV1ZVtxdWV1ZVN0YXJ0KytdO1xyXG4gICAgICAgICAgICAtLXF1ZXVlU2l6ZTtcclxuICAgICAgICAgICAgaXNsYW5kLkFkZEJvZHkoYik7XHJcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICBiLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkpIHtcclxuICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjRWRnZSA9IGIubV9jb250YWN0TGlzdDtcclxuICAgICAgICAgICAgY0VkZ2U7IGNFZGdlID0gY0VkZ2UubmV4dCkge1xyXG4gICAgICAgICAgICAgICBpZiAoaXNsYW5kLm1fY29udGFjdENvdW50ID09IGlzbGFuZC5tX2NvbnRhY3RDYXBhY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZiAoY0VkZ2UuY29udGFjdC5tX2ZsYWdzICYgYjJDb250YWN0LmVfaXNsYW5kRmxhZykge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpZiAoY0VkZ2UuY29udGFjdC5Jc1NlbnNvcigpID09IHRydWUgfHwgY0VkZ2UuY29udGFjdC5Jc0VuYWJsZWQoKSA9PSBmYWxzZSB8fCBjRWRnZS5jb250YWN0LklzVG91Y2hpbmcoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpc2xhbmQuQWRkQ29udGFjdChjRWRnZS5jb250YWN0KTtcclxuICAgICAgICAgICAgICAgY0VkZ2UuY29udGFjdC5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2lzbGFuZEZsYWc7XHJcbiAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNFZGdlLm90aGVyO1xyXG4gICAgICAgICAgICAgICBpZiAob3RoZXIubV9mbGFncyAmIGIyQm9keS5lX2lzbGFuZEZsYWcpIHtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgaWYgKG90aGVyLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfc3RhdGljQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICBvdGhlci5BZHZhbmNlKG1pblRPSSk7XHJcbiAgICAgICAgICAgICAgICAgIG90aGVyLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHF1ZXVlW3F1ZXVlU3RhcnQgKyBxdWV1ZVNpemVdID0gb3RoZXI7XHJcbiAgICAgICAgICAgICAgICsrcXVldWVTaXplO1xyXG4gICAgICAgICAgICAgICBvdGhlci5tX2ZsYWdzIHw9IGIyQm9keS5lX2lzbGFuZEZsYWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgakVkZ2UgPSBiLm1fam9pbnRMaXN0OyBqRWRnZTsgakVkZ2UgPSBqRWRnZS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgIGlmIChpc2xhbmQubV9qb2ludENvdW50ID09IGlzbGFuZC5tX2pvaW50Q2FwYWNpdHkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICBpZiAoakVkZ2Uuam9pbnQubV9pc2xhbmRGbGFnID09IHRydWUpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICBvdGhlciA9IGpFZGdlLm90aGVyO1xyXG4gICAgICAgICAgICAgICBpZiAob3RoZXIuSXNBY3RpdmUoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBpc2xhbmQuQWRkSm9pbnQoakVkZ2Uuam9pbnQpO1xyXG4gICAgICAgICAgICAgICBqRWRnZS5qb2ludC5tX2lzbGFuZEZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICBpZiAob3RoZXIubV9mbGFncyAmIGIyQm9keS5lX2lzbGFuZEZsYWcpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICBpZiAob3RoZXIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9zdGF0aWNCb2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgIG90aGVyLkFkdmFuY2UobWluVE9JKTtcclxuICAgICAgICAgICAgICAgICAgb3RoZXIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgcXVldWVbcXVldWVTdGFydCArIHF1ZXVlU2l6ZV0gPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgKytxdWV1ZVNpemU7XHJcbiAgICAgICAgICAgICAgIG90aGVyLm1fZmxhZ3MgfD0gYjJCb2R5LmVfaXNsYW5kRmxhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBzdWJTdGVwID0gYjJXb3JsZC5zX3RpbWVzdGVwO1xyXG4gICAgICAgICBzdWJTdGVwLndhcm1TdGFydGluZyA9IGZhbHNlO1xyXG4gICAgICAgICBzdWJTdGVwLmR0ID0gKDEuMCAtIG1pblRPSSkgKiBzdGVwLmR0O1xyXG4gICAgICAgICBzdWJTdGVwLmludl9kdCA9IDEuMCAvIHN1YlN0ZXAuZHQ7XHJcbiAgICAgICAgIHN1YlN0ZXAuZHRSYXRpbyA9IDAuMDtcclxuICAgICAgICAgc3ViU3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnMgPSBzdGVwLnZlbG9jaXR5SXRlcmF0aW9ucztcclxuICAgICAgICAgc3ViU3RlcC5wb3NpdGlvbkl0ZXJhdGlvbnMgPSBzdGVwLnBvc2l0aW9uSXRlcmF0aW9ucztcclxuICAgICAgICAgaXNsYW5kLlNvbHZlVE9JKHN1YlN0ZXApO1xyXG4gICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgIGkgPCBpc2xhbmQubV9ib2R5Q291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBiID0gaXNsYW5kLm1fYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICBiLm1fZmxhZ3MgJj0gfmIyQm9keS5lX2lzbGFuZEZsYWc7XHJcbiAgICAgICAgICAgIGlmIChiLklzQXdha2UoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5KSB7XHJcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xyXG4gICAgICAgICAgICBmb3IgKGNFZGdlID0gYi5tX2NvbnRhY3RMaXN0O1xyXG4gICAgICAgICAgICBjRWRnZTsgY0VkZ2UgPSBjRWRnZS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgIGNFZGdlLmNvbnRhY3QubV9mbGFncyAmPSB+YjJDb250YWN0LmVfdG9pRmxhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgIGkgPCBpc2xhbmQubV9jb250YWN0Q291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBjID0gaXNsYW5kLm1fY29udGFjdHNbaV07XHJcbiAgICAgICAgICAgIGMubV9mbGFncyAmPSB+IChiMkNvbnRhY3QuZV90b2lGbGFnIHwgYjJDb250YWN0LmVfaXNsYW5kRmxhZyk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZm9yIChpID0gMDtcclxuICAgICAgICAgaSA8IGlzbGFuZC5tX2pvaW50Q291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBqID0gaXNsYW5kLm1fam9pbnRzW2ldO1xyXG4gICAgICAgICAgICBqLm1faXNsYW5kRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHRoaXMubV9jb250YWN0TWFuYWdlci5GaW5kTmV3Q29udGFjdHMoKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyV29ybGQucHJvdG90eXBlLkRyYXdKb2ludCA9IGZ1bmN0aW9uIChqb2ludCkge1xyXG4gICAgICB2YXIgYjEgPSBqb2ludC5HZXRCb2R5QSgpO1xyXG4gICAgICB2YXIgYjIgPSBqb2ludC5HZXRCb2R5QigpO1xyXG4gICAgICB2YXIgeGYxID0gYjEubV94ZjtcclxuICAgICAgdmFyIHhmMiA9IGIyLm1feGY7XHJcbiAgICAgIHZhciB4MSA9IHhmMS5wb3NpdGlvbjtcclxuICAgICAgdmFyIHgyID0geGYyLnBvc2l0aW9uO1xyXG4gICAgICB2YXIgcDEgPSBqb2ludC5HZXRBbmNob3JBKCk7XHJcbiAgICAgIHZhciBwMiA9IGpvaW50LkdldEFuY2hvckIoKTtcclxuICAgICAgdmFyIGNvbG9yID0gYjJXb3JsZC5zX2pvaW50Q29sb3I7XHJcbiAgICAgIHN3aXRjaCAoam9pbnQubV90eXBlKSB7XHJcbiAgICAgIGNhc2UgYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQ6XHJcbiAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NlZ21lbnQocDEsIHAyLCBjb2xvcik7XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9wdWxsZXlKb2ludDpcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgcHVsbGV5ID0gKChqb2ludCBpbnN0YW5jZW9mIGIyUHVsbGV5Sm9pbnQgPyBqb2ludCA6IG51bGwpKTtcclxuICAgICAgICAgICAgdmFyIHMxID0gcHVsbGV5LkdldEdyb3VuZEFuY2hvckEoKTtcclxuICAgICAgICAgICAgdmFyIHMyID0gcHVsbGV5LkdldEdyb3VuZEFuY2hvckIoKTtcclxuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChzMSwgcDEsIGNvbG9yKTtcclxuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChzMiwgcDIsIGNvbG9yKTtcclxuICAgICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChzMSwgczIsIGNvbG9yKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBiMkpvaW50LmVfbW91c2VKb2ludDpcclxuICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChwMSwgcDIsIGNvbG9yKTtcclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgIGlmIChiMSAhPSB0aGlzLm1fZ3JvdW5kQm9keSkgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudCh4MSwgcDEsIGNvbG9yKTtcclxuICAgICAgICAgdGhpcy5tX2RlYnVnRHJhdy5EcmF3U2VnbWVudChwMSwgcDIsIGNvbG9yKTtcclxuICAgICAgICAgaWYgKGIyICE9IHRoaXMubV9ncm91bmRCb2R5KSB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KHgyLCBwMiwgY29sb3IpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJXb3JsZC5wcm90b3R5cGUuRHJhd1NoYXBlID0gZnVuY3Rpb24gKHNoYXBlLCB4ZiwgY29sb3IpIHtcclxuICAgICAgc3dpdGNoIChzaGFwZS5tX3R5cGUpIHtcclxuICAgICAgY2FzZSBiMlNoYXBlLmVfY2lyY2xlU2hhcGU6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGNpcmNsZSA9ICgoc2hhcGUgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gc2hhcGUgOiBudWxsKSk7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBiMk1hdGguTXVsWCh4ZiwgY2lyY2xlLm1fcCk7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBjaXJjbGUubV9yYWRpdXM7XHJcbiAgICAgICAgICAgIHZhciBheGlzID0geGYuUi5jb2wxO1xyXG4gICAgICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTb2xpZENpcmNsZShjZW50ZXIsIHJhZGl1cywgYXhpcywgY29sb3IpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGU6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcG9seSA9ICgoc2hhcGUgaW5zdGFuY2VvZiBiMlBvbHlnb25TaGFwZSA/IHNoYXBlIDogbnVsbCkpO1xyXG4gICAgICAgICAgICB2YXIgdmVydGV4Q291bnQgPSBwYXJzZUludChwb2x5LkdldFZlcnRleENvdW50KCkpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxWZXJ0aWNlcyA9IHBvbHkuR2V0VmVydGljZXMoKTtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gbmV3IFZlY3Rvcih2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgICAgIGkgPCB2ZXJ0ZXhDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldID0gYjJNYXRoLk11bFgoeGYsIGxvY2FsVmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubV9kZWJ1Z0RyYXcuRHJhd1NvbGlkUG9seWdvbih2ZXJ0aWNlcywgdmVydGV4Q291bnQsIGNvbG9yKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBiMlNoYXBlLmVfZWRnZVNoYXBlOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBlZGdlID0gKHNoYXBlIGluc3RhbmNlb2YgYjJFZGdlU2hhcGUgPyBzaGFwZSA6IG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLm1fZGVidWdEcmF3LkRyYXdTZWdtZW50KGIyTWF0aC5NdWxYKHhmLCBlZGdlLkdldFZlcnRleDEoKSksIGIyTWF0aC5NdWxYKHhmLCBlZGdlLkdldFZlcnRleDIoKSksIGNvbG9yKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfdGltZXN0ZXAyID0gbmV3IGIyVGltZVN0ZXAoKTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX3hmID0gbmV3IGIyVHJhbnNmb3JtKCk7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuc19iYWNrdXBBID0gbmV3IGIyU3dlZXAoKTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuYjJXb3JsZC5zX2JhY2t1cEIgPSBuZXcgYjJTd2VlcCgpO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfdGltZXN0ZXAgPSBuZXcgYjJUaW1lU3RlcCgpO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLnNfcXVldWUgPSBuZXcgVmVjdG9yKCk7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuc19qb2ludENvbG9yID0gbmV3IGIyQ29sb3IoMC41LCAwLjgsIDAuOCk7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLmIyV29ybGQuZV9uZXdGaXh0dXJlID0gMHgwMDAxO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5iMldvcmxkLmVfbG9ja2VkID0gMHgwMDAyO1xyXG4gICB9KTtcclxufSkoKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgdmFyIGIyQ2lyY2xlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyQ2lyY2xlU2hhcGUsXHJcbiAgICAgIGIyRWRnZUNoYWluRGVmID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VDaGFpbkRlZixcclxuICAgICAgYjJFZGdlU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyRWRnZVNoYXBlLFxyXG4gICAgICBiMk1hc3NEYXRhID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMk1hc3NEYXRhLFxyXG4gICAgICBiMlBvbHlnb25TaGFwZSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJQb2x5Z29uU2hhcGUsXHJcbiAgICAgIGIyU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyU2hhcGUsXHJcbiAgICAgIGIyQ2lyY2xlQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ2lyY2xlQ29udGFjdCxcclxuICAgICAgYjJDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LFxyXG4gICAgICBiMkNvbnRhY3RDb25zdHJhaW50ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0Q29uc3RyYWludCxcclxuICAgICAgYjJDb250YWN0Q29uc3RyYWludFBvaW50ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0Q29uc3RyYWludFBvaW50LFxyXG4gICAgICBiMkNvbnRhY3RFZGdlID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0RWRnZSxcclxuICAgICAgYjJDb250YWN0RmFjdG9yeSA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdEZhY3RvcnksXHJcbiAgICAgIGIyQ29udGFjdFJlZ2lzdGVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0UmVnaXN0ZXIsXHJcbiAgICAgIGIyQ29udGFjdFJlc3VsdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdFJlc3VsdCxcclxuICAgICAgYjJDb250YWN0U29sdmVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0U29sdmVyLFxyXG4gICAgICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCxcclxuICAgICAgYjJOdWxsQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyTnVsbENvbnRhY3QsXHJcbiAgICAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMlBvbHlBbmRDaXJjbGVDb250YWN0LFxyXG4gICAgICBiMlBvbHlBbmRFZGdlQ29udGFjdCA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyUG9seUFuZEVkZ2VDb250YWN0LFxyXG4gICAgICBiMlBvbHlnb25Db250YWN0ID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb2x5Z29uQ29udGFjdCxcclxuICAgICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLFxyXG4gICAgICBiMkJvZHkgPSBCb3gyRC5EeW5hbWljcy5iMkJvZHksXHJcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcclxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxyXG4gICAgICBiMkNvbnRhY3RJbXB1bHNlID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0SW1wdWxzZSxcclxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcclxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXHJcbiAgICAgIGIyRGVidWdEcmF3ID0gQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcsXHJcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcclxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxyXG4gICAgICBiMkZpeHR1cmUgPSBCb3gyRC5EeW5hbWljcy5iMkZpeHR1cmUsXHJcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcclxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcclxuICAgICAgYjJUaW1lU3RlcCA9IEJveDJELkR5bmFtaWNzLmIyVGltZVN0ZXAsXHJcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxyXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXHJcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcclxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxyXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcclxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXHJcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcclxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXHJcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXHJcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcclxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxyXG4gICAgICBiMkFBQkIgPSBCb3gyRC5Db2xsaXNpb24uYjJBQUJCLFxyXG4gICAgICBiMkJvdW5kID0gQm94MkQuQ29sbGlzaW9uLmIyQm91bmQsXHJcbiAgICAgIGIyQm91bmRWYWx1ZXMgPSBCb3gyRC5Db2xsaXNpb24uYjJCb3VuZFZhbHVlcyxcclxuICAgICAgYjJDb2xsaXNpb24gPSBCb3gyRC5Db2xsaXNpb24uYjJDb2xsaXNpb24sXHJcbiAgICAgIGIyQ29udGFjdElEID0gQm94MkQuQ29sbGlzaW9uLmIyQ29udGFjdElELFxyXG4gICAgICBiMkNvbnRhY3RQb2ludCA9IEJveDJELkNvbGxpc2lvbi5iMkNvbnRhY3RQb2ludCxcclxuICAgICAgYjJEaXN0YW5jZSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlLFxyXG4gICAgICBiMkRpc3RhbmNlSW5wdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJEaXN0YW5jZUlucHV0LFxyXG4gICAgICBiMkRpc3RhbmNlT3V0cHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyRGlzdGFuY2VPdXRwdXQsXHJcbiAgICAgIGIyRGlzdGFuY2VQcm94eSA9IEJveDJELkNvbGxpc2lvbi5iMkRpc3RhbmNlUHJveHksXHJcbiAgICAgIGIyRHluYW1pY1RyZWUgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZSxcclxuICAgICAgYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UgPSBCb3gyRC5Db2xsaXNpb24uYjJEeW5hbWljVHJlZUJyb2FkUGhhc2UsXHJcbiAgICAgIGIyRHluYW1pY1RyZWVOb2RlID0gQm94MkQuQ29sbGlzaW9uLmIyRHluYW1pY1RyZWVOb2RlLFxyXG4gICAgICBiMkR5bmFtaWNUcmVlUGFpciA9IEJveDJELkNvbGxpc2lvbi5iMkR5bmFtaWNUcmVlUGFpcixcclxuICAgICAgYjJNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMk1hbmlmb2xkLFxyXG4gICAgICBiMk1hbmlmb2xkUG9pbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJNYW5pZm9sZFBvaW50LFxyXG4gICAgICBiMlBvaW50ID0gQm94MkQuQ29sbGlzaW9uLmIyUG9pbnQsXHJcbiAgICAgIGIyUmF5Q2FzdElucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyUmF5Q2FzdElucHV0LFxyXG4gICAgICBiMlJheUNhc3RPdXRwdXQgPSBCb3gyRC5Db2xsaXNpb24uYjJSYXlDYXN0T3V0cHV0LFxyXG4gICAgICBiMlNlZ21lbnQgPSBCb3gyRC5Db2xsaXNpb24uYjJTZWdtZW50LFxyXG4gICAgICBiMlNlcGFyYXRpb25GdW5jdGlvbiA9IEJveDJELkNvbGxpc2lvbi5iMlNlcGFyYXRpb25GdW5jdGlvbixcclxuICAgICAgYjJTaW1wbGV4ID0gQm94MkQuQ29sbGlzaW9uLmIyU2ltcGxleCxcclxuICAgICAgYjJTaW1wbGV4Q2FjaGUgPSBCb3gyRC5Db2xsaXNpb24uYjJTaW1wbGV4Q2FjaGUsXHJcbiAgICAgIGIyU2ltcGxleFZlcnRleCA9IEJveDJELkNvbGxpc2lvbi5iMlNpbXBsZXhWZXJ0ZXgsXHJcbiAgICAgIGIyVGltZU9mSW1wYWN0ID0gQm94MkQuQ29sbGlzaW9uLmIyVGltZU9mSW1wYWN0LFxyXG4gICAgICBiMlRPSUlucHV0ID0gQm94MkQuQ29sbGlzaW9uLmIyVE9JSW5wdXQsXHJcbiAgICAgIGIyV29ybGRNYW5pZm9sZCA9IEJveDJELkNvbGxpc2lvbi5iMldvcmxkTWFuaWZvbGQsXHJcbiAgICAgIENsaXBWZXJ0ZXggPSBCb3gyRC5Db2xsaXNpb24uQ2xpcFZlcnRleCxcclxuICAgICAgRmVhdHVyZXMgPSBCb3gyRC5Db2xsaXNpb24uRmVhdHVyZXMsXHJcbiAgICAgIElCcm9hZFBoYXNlID0gQm94MkQuQ29sbGlzaW9uLklCcm9hZFBoYXNlO1xyXG5cclxuICAgQm94MkQuaW5oZXJpdChiMkNpcmNsZUNvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XHJcbiAgIGIyQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5wcm90b3R5cGU7XHJcbiAgIGIyQ2lyY2xlQ29udGFjdC5iMkNpcmNsZUNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgYjJDaXJjbGVDb250YWN0LkNyZWF0ZSA9IGZ1bmN0aW9uIChhbGxvY2F0b3IpIHtcclxuICAgICAgcmV0dXJuIG5ldyBiMkNpcmNsZUNvbnRhY3QoKTtcclxuICAgfVxyXG4gICBiMkNpcmNsZUNvbnRhY3QuRGVzdHJveSA9IGZ1bmN0aW9uIChjb250YWN0LCBhbGxvY2F0b3IpIHt9XHJcbiAgIGIyQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XHJcbiAgICAgIHRoaXMuX19zdXBlci5SZXNldC5jYWxsKHRoaXMsIGZpeHR1cmVBLCBmaXh0dXJlQik7XHJcbiAgIH1cclxuICAgYjJDaXJjbGVDb250YWN0LnByb3RvdHlwZS5FdmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2ZpeHR1cmVBLkdldEJvZHkoKTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2ZpeHR1cmVCLkdldEJvZHkoKTtcclxuICAgICAgYjJDb2xsaXNpb24uQ29sbGlkZUNpcmNsZXModGhpcy5tX21hbmlmb2xkLCAodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJDaXJjbGVTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdC5iMkNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV9ub2RlQSA9IG5ldyBiMkNvbnRhY3RFZGdlKCk7XHJcbiAgICAgIHRoaXMubV9ub2RlQiA9IG5ldyBiMkNvbnRhY3RFZGdlKCk7XHJcbiAgICAgIHRoaXMubV9tYW5pZm9sZCA9IG5ldyBiMk1hbmlmb2xkKCk7XHJcbiAgICAgIHRoaXMubV9vbGRNYW5pZm9sZCA9IG5ldyBiMk1hbmlmb2xkKCk7XHJcbiAgIH07XHJcbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuR2V0TWFuaWZvbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fbWFuaWZvbGQ7XHJcbiAgIH1cclxuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXRXb3JsZE1hbmlmb2xkID0gZnVuY3Rpb24gKHdvcmxkTWFuaWZvbGQpIHtcclxuICAgICAgdmFyIGJvZHlBID0gdGhpcy5tX2ZpeHR1cmVBLkdldEJvZHkoKTtcclxuICAgICAgdmFyIGJvZHlCID0gdGhpcy5tX2ZpeHR1cmVCLkdldEJvZHkoKTtcclxuICAgICAgdmFyIHNoYXBlQSA9IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpO1xyXG4gICAgICB2YXIgc2hhcGVCID0gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCk7XHJcbiAgICAgIHdvcmxkTWFuaWZvbGQuSW5pdGlhbGl6ZSh0aGlzLm1fbWFuaWZvbGQsIGJvZHlBLkdldFRyYW5zZm9ybSgpLCBzaGFwZUEubV9yYWRpdXMsIGJvZHlCLkdldFRyYW5zZm9ybSgpLCBzaGFwZUIubV9yYWRpdXMpO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuSXNUb3VjaGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICh0aGlzLm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWcpID09IGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZztcclxuICAgfVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLklzQ29udGludW91cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICh0aGlzLm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9jb250aW51b3VzRmxhZykgPT0gYjJDb250YWN0LmVfY29udGludW91c0ZsYWc7XHJcbiAgIH1cclxuICAgYjJDb250YWN0LnByb3RvdHlwZS5TZXRTZW5zb3IgPSBmdW5jdGlvbiAoc2Vuc29yKSB7XHJcbiAgICAgIGlmIChzZW5zb3IpIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3NlbnNvckZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfc2Vuc29yRmxhZztcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuSXNTZW5zb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfc2Vuc29yRmxhZykgPT0gYjJDb250YWN0LmVfc2Vuc29yRmxhZztcclxuICAgfVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLlNldEVuYWJsZWQgPSBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICBpZiAoZmxhZykge1xyXG4gICAgICAgICB0aGlzLm1fZmxhZ3MgfD0gYjJDb250YWN0LmVfZW5hYmxlZEZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyAmPSB+YjJDb250YWN0LmVfZW5hYmxlZEZsYWc7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLklzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICh0aGlzLm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9lbmFibGVkRmxhZykgPT0gYjJDb250YWN0LmVfZW5hYmxlZEZsYWc7XHJcbiAgIH1cclxuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XHJcbiAgIH1cclxuICAgYjJDb250YWN0LnByb3RvdHlwZS5HZXRGaXh0dXJlQSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9maXh0dXJlQTtcclxuICAgfVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkdldEZpeHR1cmVCID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2ZpeHR1cmVCO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdC5wcm90b3R5cGUuRmxhZ0ZvckZpbHRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2ZpbHRlckZsYWc7XHJcbiAgIH1cclxuICAgYjJDb250YWN0LnByb3RvdHlwZS5iMkNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7fVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xyXG4gICAgICBpZiAoZml4dHVyZUEgPT09IHVuZGVmaW5lZCkgZml4dHVyZUEgPSBudWxsO1xyXG4gICAgICBpZiAoZml4dHVyZUIgPT09IHVuZGVmaW5lZCkgZml4dHVyZUIgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fZmxhZ3MgPSBiMkNvbnRhY3QuZV9lbmFibGVkRmxhZztcclxuICAgICAgaWYgKCFmaXh0dXJlQSB8fCAhZml4dHVyZUIpIHtcclxuICAgICAgICAgdGhpcy5tX2ZpeHR1cmVBID0gbnVsbDtcclxuICAgICAgICAgdGhpcy5tX2ZpeHR1cmVCID0gbnVsbDtcclxuICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChmaXh0dXJlQS5Jc1NlbnNvcigpIHx8IGZpeHR1cmVCLklzU2Vuc29yKCkpIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3NlbnNvckZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGJvZHlBID0gZml4dHVyZUEuR2V0Qm9keSgpO1xyXG4gICAgICB2YXIgYm9keUIgPSBmaXh0dXJlQi5HZXRCb2R5KCk7XHJcbiAgICAgIGlmIChib2R5QS5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5IHx8IGJvZHlBLklzQnVsbGV0KCkgfHwgYm9keUIuR2V0VHlwZSgpICE9IGIyQm9keS5iMl9keW5hbWljQm9keSB8fCBib2R5Qi5Jc0J1bGxldCgpKSB7XHJcbiAgICAgICAgIHRoaXMubV9mbGFncyB8PSBiMkNvbnRhY3QuZV9jb250aW51b3VzRmxhZztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fZml4dHVyZUEgPSBmaXh0dXJlQTtcclxuICAgICAgdGhpcy5tX2ZpeHR1cmVCID0gZml4dHVyZUI7XHJcbiAgICAgIHRoaXMubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPSAwO1xyXG4gICAgICB0aGlzLm1fcHJldiA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9uZXh0ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX25vZGVBLmNvbnRhY3QgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fbm9kZUEucHJldiA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9ub2RlQS5uZXh0ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX25vZGVBLm90aGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5tX25vZGVCLmNvbnRhY3QgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fbm9kZUIucHJldiA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9ub2RlQi5uZXh0ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX25vZGVCLm90aGVyID0gbnVsbDtcclxuICAgfVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLlVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICB2YXIgdE1hbmlmb2xkID0gdGhpcy5tX29sZE1hbmlmb2xkO1xyXG4gICAgICB0aGlzLm1fb2xkTWFuaWZvbGQgPSB0aGlzLm1fbWFuaWZvbGQ7XHJcbiAgICAgIHRoaXMubV9tYW5pZm9sZCA9IHRNYW5pZm9sZDtcclxuICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2VuYWJsZWRGbGFnO1xyXG4gICAgICB2YXIgdG91Y2hpbmcgPSBmYWxzZTtcclxuICAgICAgdmFyIHdhc1RvdWNoaW5nID0gKHRoaXMubV9mbGFncyAmIGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZykgPT0gYjJDb250YWN0LmVfdG91Y2hpbmdGbGFnO1xyXG4gICAgICB2YXIgYm9keUEgPSB0aGlzLm1fZml4dHVyZUEubV9ib2R5O1xyXG4gICAgICB2YXIgYm9keUIgPSB0aGlzLm1fZml4dHVyZUIubV9ib2R5O1xyXG4gICAgICB2YXIgYWFiYk92ZXJsYXAgPSB0aGlzLm1fZml4dHVyZUEubV9hYWJiLlRlc3RPdmVybGFwKHRoaXMubV9maXh0dXJlQi5tX2FhYmIpO1xyXG4gICAgICBpZiAodGhpcy5tX2ZsYWdzICYgYjJDb250YWN0LmVfc2Vuc29yRmxhZykge1xyXG4gICAgICAgICBpZiAoYWFiYk92ZXJsYXApIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlQSA9IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGVCID0gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCk7XHJcbiAgICAgICAgICAgIHZhciB4ZkEgPSBib2R5QS5HZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgdmFyIHhmQiA9IGJvZHlCLkdldFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB0b3VjaGluZyA9IGIyU2hhcGUuVGVzdE92ZXJsYXAoc2hhcGVBLCB4ZkEsIHNoYXBlQiwgeGZCKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB0aGlzLm1fbWFuaWZvbGQubV9wb2ludENvdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgaWYgKGJvZHlBLkdldFR5cGUoKSAhPSBiMkJvZHkuYjJfZHluYW1pY0JvZHkgfHwgYm9keUEuSXNCdWxsZXQoKSB8fCBib2R5Qi5HZXRUeXBlKCkgIT0gYjJCb2R5LmIyX2R5bmFtaWNCb2R5IHx8IGJvZHlCLklzQnVsbGV0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1fZmxhZ3MgJj0gfmIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGlmIChhYWJiT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICB0aGlzLkV2YWx1YXRlKCk7XHJcbiAgICAgICAgICAgIHRvdWNoaW5nID0gdGhpcy5tX21hbmlmb2xkLm1fcG9pbnRDb3VudCA+IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX21hbmlmb2xkLm1fcG9pbnRDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgIHZhciBtcDIgPSB0aGlzLm1fbWFuaWZvbGQubV9wb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgIG1wMi5tX25vcm1hbEltcHVsc2UgPSAwLjA7XHJcbiAgICAgICAgICAgICAgIG1wMi5tX3RhbmdlbnRJbXB1bHNlID0gMC4wO1xyXG4gICAgICAgICAgICAgICB2YXIgaWQyID0gbXAyLm1faWQ7XHJcbiAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5tX29sZE1hbmlmb2xkLm1fcG9pbnRDb3VudDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBtcDEgPSB0aGlzLm1fb2xkTWFuaWZvbGQubV9wb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgIGlmIChtcDEubV9pZC5rZXkgPT0gaWQyLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICBtcDIubV9ub3JtYWxJbXB1bHNlID0gbXAxLm1fbm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgbXAyLm1fdGFuZ2VudEltcHVsc2UgPSBtcDEubV90YW5nZW50SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPSAwO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGlmICh0b3VjaGluZyAhPSB3YXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICBib2R5QS5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgICAgICAgYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAodG91Y2hpbmcpIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzIHw9IGIyQ29udGFjdC5lX3RvdWNoaW5nRmxhZztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2ZsYWdzICY9IH5iMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHdhc1RvdWNoaW5nID09IGZhbHNlICYmIHRvdWNoaW5nID09IHRydWUpIHtcclxuICAgICAgICAgbGlzdGVuZXIuQmVnaW5Db250YWN0KHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh3YXNUb3VjaGluZyA9PSB0cnVlICYmIHRvdWNoaW5nID09IGZhbHNlKSB7XHJcbiAgICAgICAgIGxpc3RlbmVyLkVuZENvbnRhY3QodGhpcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCh0aGlzLm1fZmxhZ3MgJiBiMkNvbnRhY3QuZV9zZW5zb3JGbGFnKSA9PSAwKSB7XHJcbiAgICAgICAgIGxpc3RlbmVyLlByZVNvbHZlKHRoaXMsIHRoaXMubV9vbGRNYW5pZm9sZCk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge31cclxuICAgYjJDb250YWN0LnByb3RvdHlwZS5Db21wdXRlVE9JID0gZnVuY3Rpb24gKHN3ZWVwQSwgc3dlZXBCKSB7XHJcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnByb3h5QS5TZXQodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkpO1xyXG4gICAgICBiMkNvbnRhY3Quc19pbnB1dC5wcm94eUIuU2V0KHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpKTtcclxuICAgICAgYjJDb250YWN0LnNfaW5wdXQuc3dlZXBBID0gc3dlZXBBO1xyXG4gICAgICBiMkNvbnRhY3Quc19pbnB1dC5zd2VlcEIgPSBzd2VlcEI7XHJcbiAgICAgIGIyQ29udGFjdC5zX2lucHV0LnRvbGVyYW5jZSA9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcclxuICAgICAgcmV0dXJuIGIyVGltZU9mSW1wYWN0LlRpbWVPZkltcGFjdChiMkNvbnRhY3Quc19pbnB1dCk7XHJcbiAgIH1cclxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX3NlbnNvckZsYWcgPSAweDAwMDE7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX2NvbnRpbnVvdXNGbGFnID0gMHgwMDAyO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV9pc2xhbmRGbGFnID0gMHgwMDA0O1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV90b2lGbGFnID0gMHgwMDA4O1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV90b3VjaGluZ0ZsYWcgPSAweDAwMTA7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5lX2VuYWJsZWRGbGFnID0gMHgwMDIwO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuZV9maWx0ZXJGbGFnID0gMHgwMDQwO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3Quc19pbnB1dCA9IG5ldyBiMlRPSUlucHV0KCk7XHJcbiAgIH0pO1xyXG4gICBiMkNvbnRhY3RDb25zdHJhaW50LmIyQ29udGFjdENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5sb2NhbFBvaW50ID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm5vcm1hbCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5ub3JtYWxNYXNzID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcclxuICAgfTtcclxuICAgYjJDb250YWN0Q29uc3RyYWludC5wcm90b3R5cGUuYjJDb250YWN0Q29uc3RyYWludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5wb2ludHMgPSBuZXcgVmVjdG9yKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xyXG4gICAgICAgICB0aGlzLnBvaW50c1tpXSA9IG5ldyBiMkNvbnRhY3RDb25zdHJhaW50UG9pbnQoKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQ29udGFjdENvbnN0cmFpbnRQb2ludC5iMkNvbnRhY3RDb25zdHJhaW50UG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubG9jYWxQb2ludCA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5yQSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5yQiA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJDb250YWN0RWRnZS5iMkNvbnRhY3RFZGdlID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyQ29udGFjdEZhY3RvcnkuYjJDb250YWN0RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMkNvbnRhY3RGYWN0b3J5LnByb3RvdHlwZS5iMkNvbnRhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xyXG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xyXG4gICAgICB0aGlzLkluaXRpYWxpemVSZWdpc3RlcnMoKTtcclxuICAgfVxyXG4gICBiMkNvbnRhY3RGYWN0b3J5LnByb3RvdHlwZS5BZGRUeXBlID0gZnVuY3Rpb24gKGNyZWF0ZUZjbiwgZGVzdHJveUZjbiwgdHlwZTEsIHR5cGUyKSB7XHJcbiAgICAgIGlmICh0eXBlMSA9PT0gdW5kZWZpbmVkKSB0eXBlMSA9IDA7XHJcbiAgICAgIGlmICh0eXBlMiA9PT0gdW5kZWZpbmVkKSB0eXBlMiA9IDA7XHJcbiAgICAgIHRoaXMubV9yZWdpc3RlcnNbdHlwZTFdW3R5cGUyXS5jcmVhdGVGY24gPSBjcmVhdGVGY247XHJcbiAgICAgIHRoaXMubV9yZWdpc3RlcnNbdHlwZTFdW3R5cGUyXS5kZXN0cm95RmNuID0gZGVzdHJveUZjbjtcclxuICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdLnByaW1hcnkgPSB0cnVlO1xyXG4gICAgICBpZiAodHlwZTEgIT0gdHlwZTIpIHtcclxuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMl1bdHlwZTFdLmNyZWF0ZUZjbiA9IGNyZWF0ZUZjbjtcclxuICAgICAgICAgdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMl1bdHlwZTFdLmRlc3Ryb3lGY24gPSBkZXN0cm95RmNuO1xyXG4gICAgICAgICB0aGlzLm1fcmVnaXN0ZXJzW3R5cGUyXVt0eXBlMV0ucHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJDb250YWN0RmFjdG9yeS5wcm90b3R5cGUuSW5pdGlhbGl6ZVJlZ2lzdGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX3JlZ2lzdGVycyA9IG5ldyBWZWN0b3IoYjJTaGFwZS5lX3NoYXBlVHlwZUNvdW50KTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiMlNoYXBlLmVfc2hhcGVUeXBlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICB0aGlzLm1fcmVnaXN0ZXJzW2ldID0gbmV3IFZlY3RvcihiMlNoYXBlLmVfc2hhcGVUeXBlQ291bnQpO1xyXG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIyU2hhcGUuZV9zaGFwZVR5cGVDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9yZWdpc3RlcnNbaV1bal0gPSBuZXcgYjJDb250YWN0UmVnaXN0ZXIoKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuQWRkVHlwZShiMkNpcmNsZUNvbnRhY3QuQ3JlYXRlLCBiMkNpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlLCBiMlNoYXBlLmVfY2lyY2xlU2hhcGUpO1xyXG4gICAgICB0aGlzLkFkZFR5cGUoYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5DcmVhdGUsIGIyUG9seUFuZENpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX3BvbHlnb25TaGFwZSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlKTtcclxuICAgICAgdGhpcy5BZGRUeXBlKGIyUG9seWdvbkNvbnRhY3QuQ3JlYXRlLCBiMlBvbHlnb25Db250YWN0LkRlc3Ryb3ksIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUsIGIyU2hhcGUuZV9wb2x5Z29uU2hhcGUpO1xyXG4gICAgICB0aGlzLkFkZFR5cGUoYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5DcmVhdGUsIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX2VkZ2VTaGFwZSwgYjJTaGFwZS5lX2NpcmNsZVNoYXBlKTtcclxuICAgICAgdGhpcy5BZGRUeXBlKGIyUG9seUFuZEVkZ2VDb250YWN0LkNyZWF0ZSwgYjJQb2x5QW5kRWRnZUNvbnRhY3QuRGVzdHJveSwgYjJTaGFwZS5lX3BvbHlnb25TaGFwZSwgYjJTaGFwZS5lX2VkZ2VTaGFwZSk7XHJcbiAgIH1cclxuICAgYjJDb250YWN0RmFjdG9yeS5wcm90b3R5cGUuQ3JlYXRlID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xyXG4gICAgICB2YXIgdHlwZTEgPSBwYXJzZUludChmaXh0dXJlQS5HZXRUeXBlKCkpO1xyXG4gICAgICB2YXIgdHlwZTIgPSBwYXJzZUludChmaXh0dXJlQi5HZXRUeXBlKCkpO1xyXG4gICAgICB2YXIgcmVnID0gdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdO1xyXG4gICAgICB2YXIgYztcclxuICAgICAgaWYgKHJlZy5wb29sKSB7XHJcbiAgICAgICAgIGMgPSByZWcucG9vbDtcclxuICAgICAgICAgcmVnLnBvb2wgPSBjLm1fbmV4dDtcclxuICAgICAgICAgcmVnLnBvb2xDb3VudC0tO1xyXG4gICAgICAgICBjLlJlc2V0KGZpeHR1cmVBLCBmaXh0dXJlQik7XHJcbiAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjcmVhdGVGY24gPSByZWcuY3JlYXRlRmNuO1xyXG4gICAgICBpZiAoY3JlYXRlRmNuICE9IG51bGwpIHtcclxuICAgICAgICAgaWYgKHJlZy5wcmltYXJ5KSB7XHJcbiAgICAgICAgICAgIGMgPSBjcmVhdGVGY24odGhpcy5tX2FsbG9jYXRvcik7XHJcbiAgICAgICAgICAgIGMuUmVzZXQoZml4dHVyZUEsIGZpeHR1cmVCKTtcclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGMgPSBjcmVhdGVGY24odGhpcy5tX2FsbG9jYXRvcik7XHJcbiAgICAgICAgICAgIGMuUmVzZXQoZml4dHVyZUIsIGZpeHR1cmVBKTtcclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkNvbnRhY3RGYWN0b3J5LnByb3RvdHlwZS5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QpIHtcclxuICAgICAgaWYgKGNvbnRhY3QubV9tYW5pZm9sZC5tX3BvaW50Q291bnQgPiAwKSB7XHJcbiAgICAgICAgIGNvbnRhY3QubV9maXh0dXJlQS5tX2JvZHkuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgICAgIGNvbnRhY3QubV9maXh0dXJlQi5tX2JvZHkuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHR5cGUxID0gcGFyc2VJbnQoY29udGFjdC5tX2ZpeHR1cmVBLkdldFR5cGUoKSk7XHJcbiAgICAgIHZhciB0eXBlMiA9IHBhcnNlSW50KGNvbnRhY3QubV9maXh0dXJlQi5HZXRUeXBlKCkpO1xyXG4gICAgICB2YXIgcmVnID0gdGhpcy5tX3JlZ2lzdGVyc1t0eXBlMV1bdHlwZTJdO1xyXG4gICAgICBpZiAodHJ1ZSkge1xyXG4gICAgICAgICByZWcucG9vbENvdW50Kys7XHJcbiAgICAgICAgIGNvbnRhY3QubV9uZXh0ID0gcmVnLnBvb2w7XHJcbiAgICAgICAgIHJlZy5wb29sID0gY29udGFjdDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZGVzdHJveUZjbiA9IHJlZy5kZXN0cm95RmNuO1xyXG4gICAgICBkZXN0cm95RmNuKGNvbnRhY3QsIHRoaXMubV9hbGxvY2F0b3IpO1xyXG4gICB9XHJcbiAgIGIyQ29udGFjdFJlZ2lzdGVyLmIyQ29udGFjdFJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyQ29udGFjdFJlc3VsdC5iMkNvbnRhY3RSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubm9ybWFsID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLmlkID0gbmV3IGIyQ29udGFjdElEKCk7XHJcbiAgIH07XHJcbiAgIGIyQ29udGFjdFNvbHZlci5iMkNvbnRhY3RTb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV9zdGVwID0gbmV3IGIyVGltZVN0ZXAoKTtcclxuICAgICAgdGhpcy5tX2NvbnN0cmFpbnRzID0gbmV3IFZlY3RvcigpO1xyXG4gICB9O1xyXG4gICBiMkNvbnRhY3RTb2x2ZXIucHJvdG90eXBlLmIyQ29udGFjdFNvbHZlciA9IGZ1bmN0aW9uICgpIHt9XHJcbiAgIGIyQ29udGFjdFNvbHZlci5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChzdGVwLCBjb250YWN0cywgY29udGFjdENvdW50LCBhbGxvY2F0b3IpIHtcclxuICAgICAgaWYgKGNvbnRhY3RDb3VudCA9PT0gdW5kZWZpbmVkKSBjb250YWN0Q291bnQgPSAwO1xyXG4gICAgICB2YXIgY29udGFjdDtcclxuICAgICAgdGhpcy5tX3N0ZXAuU2V0KHN0ZXApO1xyXG4gICAgICB0aGlzLm1fYWxsb2NhdG9yID0gYWxsb2NhdG9yO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciB0VmVjO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdGhpcy5tX2NvbnN0cmFpbnRDb3VudCA9IGNvbnRhY3RDb3VudDtcclxuICAgICAgd2hpbGUgKHRoaXMubV9jb25zdHJhaW50cy5sZW5ndGggPCB0aGlzLm1fY29uc3RyYWludENvdW50KSB7XHJcbiAgICAgICAgIHRoaXMubV9jb25zdHJhaW50c1t0aGlzLm1fY29uc3RyYWludHMubGVuZ3RoXSA9IG5ldyBiMkNvbnRhY3RDb25zdHJhaW50KCk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMDtcclxuICAgICAgaSA8IGNvbnRhY3RDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIGNvbnRhY3QgPSBjb250YWN0c1tpXTtcclxuICAgICAgICAgdmFyIGZpeHR1cmVBID0gY29udGFjdC5tX2ZpeHR1cmVBO1xyXG4gICAgICAgICB2YXIgZml4dHVyZUIgPSBjb250YWN0Lm1fZml4dHVyZUI7XHJcbiAgICAgICAgIHZhciBzaGFwZUEgPSBmaXh0dXJlQS5tX3NoYXBlO1xyXG4gICAgICAgICB2YXIgc2hhcGVCID0gZml4dHVyZUIubV9zaGFwZTtcclxuICAgICAgICAgdmFyIHJhZGl1c0EgPSBzaGFwZUEubV9yYWRpdXM7XHJcbiAgICAgICAgIHZhciByYWRpdXNCID0gc2hhcGVCLm1fcmFkaXVzO1xyXG4gICAgICAgICB2YXIgYm9keUEgPSBmaXh0dXJlQS5tX2JvZHk7XHJcbiAgICAgICAgIHZhciBib2R5QiA9IGZpeHR1cmVCLm1fYm9keTtcclxuICAgICAgICAgdmFyIG1hbmlmb2xkID0gY29udGFjdC5HZXRNYW5pZm9sZCgpO1xyXG4gICAgICAgICB2YXIgZnJpY3Rpb24gPSBiMlNldHRpbmdzLmIyTWl4RnJpY3Rpb24oZml4dHVyZUEuR2V0RnJpY3Rpb24oKSwgZml4dHVyZUIuR2V0RnJpY3Rpb24oKSk7XHJcbiAgICAgICAgIHZhciByZXN0aXR1dGlvbiA9IGIyU2V0dGluZ3MuYjJNaXhSZXN0aXR1dGlvbihmaXh0dXJlQS5HZXRSZXN0aXR1dGlvbigpLCBmaXh0dXJlQi5HZXRSZXN0aXR1dGlvbigpKTtcclxuICAgICAgICAgdmFyIHZBWCA9IGJvZHlBLm1fbGluZWFyVmVsb2NpdHkueDtcclxuICAgICAgICAgdmFyIHZBWSA9IGJvZHlBLm1fbGluZWFyVmVsb2NpdHkueTtcclxuICAgICAgICAgdmFyIHZCWCA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHkueDtcclxuICAgICAgICAgdmFyIHZCWSA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHkueTtcclxuICAgICAgICAgdmFyIHdBID0gYm9keUEubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgIHZhciB3QiA9IGJvZHlCLm1fYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KG1hbmlmb2xkLm1fcG9pbnRDb3VudCA+IDApO1xyXG4gICAgICAgICBiMkNvbnRhY3RTb2x2ZXIuc193b3JsZE1hbmlmb2xkLkluaXRpYWxpemUobWFuaWZvbGQsIGJvZHlBLm1feGYsIHJhZGl1c0EsIGJvZHlCLm1feGYsIHJhZGl1c0IpO1xyXG4gICAgICAgICB2YXIgbm9ybWFsWCA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9ub3JtYWwueDtcclxuICAgICAgICAgdmFyIG5vcm1hbFkgPSBiMkNvbnRhY3RTb2x2ZXIuc193b3JsZE1hbmlmb2xkLm1fbm9ybWFsLnk7XHJcbiAgICAgICAgIHZhciBjYyA9IHRoaXMubV9jb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgY2MuYm9keUEgPSBib2R5QTtcclxuICAgICAgICAgY2MuYm9keUIgPSBib2R5QjtcclxuICAgICAgICAgY2MubWFuaWZvbGQgPSBtYW5pZm9sZDtcclxuICAgICAgICAgY2Mubm9ybWFsLnggPSBub3JtYWxYO1xyXG4gICAgICAgICBjYy5ub3JtYWwueSA9IG5vcm1hbFk7XHJcbiAgICAgICAgIGNjLnBvaW50Q291bnQgPSBtYW5pZm9sZC5tX3BvaW50Q291bnQ7XHJcbiAgICAgICAgIGNjLmZyaWN0aW9uID0gZnJpY3Rpb247XHJcbiAgICAgICAgIGNjLnJlc3RpdHV0aW9uID0gcmVzdGl0dXRpb247XHJcbiAgICAgICAgIGNjLmxvY2FsUGxhbmVOb3JtYWwueCA9IG1hbmlmb2xkLm1fbG9jYWxQbGFuZU5vcm1hbC54O1xyXG4gICAgICAgICBjYy5sb2NhbFBsYW5lTm9ybWFsLnkgPSBtYW5pZm9sZC5tX2xvY2FsUGxhbmVOb3JtYWwueTtcclxuICAgICAgICAgY2MubG9jYWxQb2ludC54ID0gbWFuaWZvbGQubV9sb2NhbFBvaW50Lng7XHJcbiAgICAgICAgIGNjLmxvY2FsUG9pbnQueSA9IG1hbmlmb2xkLm1fbG9jYWxQb2ludC55O1xyXG4gICAgICAgICBjYy5yYWRpdXMgPSByYWRpdXNBICsgcmFkaXVzQjtcclxuICAgICAgICAgY2MudHlwZSA9IG1hbmlmb2xkLm1fdHlwZTtcclxuICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjYy5wb2ludENvdW50OyArK2spIHtcclxuICAgICAgICAgICAgdmFyIGNwID0gbWFuaWZvbGQubV9wb2ludHNba107XHJcbiAgICAgICAgICAgIHZhciBjY3AgPSBjYy5wb2ludHNba107XHJcbiAgICAgICAgICAgIGNjcC5ub3JtYWxJbXB1bHNlID0gY3AubV9ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICBjY3AudGFuZ2VudEltcHVsc2UgPSBjcC5tX3RhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICAgICBjY3AubG9jYWxQb2ludC5TZXRWKGNwLm1fbG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIHZhciByQVggPSBjY3AuckEueCA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9wb2ludHNba10ueCAtIGJvZHlBLm1fc3dlZXAuYy54O1xyXG4gICAgICAgICAgICB2YXIgckFZID0gY2NwLnJBLnkgPSBiMkNvbnRhY3RTb2x2ZXIuc193b3JsZE1hbmlmb2xkLm1fcG9pbnRzW2tdLnkgLSBib2R5QS5tX3N3ZWVwLmMueTtcclxuICAgICAgICAgICAgdmFyIHJCWCA9IGNjcC5yQi54ID0gYjJDb250YWN0U29sdmVyLnNfd29ybGRNYW5pZm9sZC5tX3BvaW50c1trXS54IC0gYm9keUIubV9zd2VlcC5jLng7XHJcbiAgICAgICAgICAgIHZhciByQlkgPSBjY3AuckIueSA9IGIyQ29udGFjdFNvbHZlci5zX3dvcmxkTWFuaWZvbGQubV9wb2ludHNba10ueSAtIGJvZHlCLm1fc3dlZXAuYy55O1xyXG4gICAgICAgICAgICB2YXIgcm5BID0gckFYICogbm9ybWFsWSAtIHJBWSAqIG5vcm1hbFg7XHJcbiAgICAgICAgICAgIHZhciBybkIgPSByQlggKiBub3JtYWxZIC0gckJZICogbm9ybWFsWDtcclxuICAgICAgICAgICAgcm5BICo9IHJuQTtcclxuICAgICAgICAgICAgcm5CICo9IHJuQjtcclxuICAgICAgICAgICAgdmFyIGtOb3JtYWwgPSBib2R5QS5tX2ludk1hc3MgKyBib2R5Qi5tX2ludk1hc3MgKyBib2R5QS5tX2ludkkgKiBybkEgKyBib2R5Qi5tX2ludkkgKiBybkI7XHJcbiAgICAgICAgICAgIGNjcC5ub3JtYWxNYXNzID0gMS4wIC8ga05vcm1hbDtcclxuICAgICAgICAgICAgdmFyIGtFcXVhbGl6ZWQgPSBib2R5QS5tX21hc3MgKiBib2R5QS5tX2ludk1hc3MgKyBib2R5Qi5tX21hc3MgKiBib2R5Qi5tX2ludk1hc3M7XHJcbiAgICAgICAgICAgIGtFcXVhbGl6ZWQgKz0gYm9keUEubV9tYXNzICogYm9keUEubV9pbnZJICogcm5BICsgYm9keUIubV9tYXNzICogYm9keUIubV9pbnZJICogcm5CO1xyXG4gICAgICAgICAgICBjY3AuZXF1YWxpemVkTWFzcyA9IDEuMCAvIGtFcXVhbGl6ZWQ7XHJcbiAgICAgICAgICAgIHZhciB0YW5nZW50WCA9IG5vcm1hbFk7XHJcbiAgICAgICAgICAgIHZhciB0YW5nZW50WSA9ICgtbm9ybWFsWCk7XHJcbiAgICAgICAgICAgIHZhciBydEEgPSByQVggKiB0YW5nZW50WSAtIHJBWSAqIHRhbmdlbnRYO1xyXG4gICAgICAgICAgICB2YXIgcnRCID0gckJYICogdGFuZ2VudFkgLSByQlkgKiB0YW5nZW50WDtcclxuICAgICAgICAgICAgcnRBICo9IHJ0QTtcclxuICAgICAgICAgICAgcnRCICo9IHJ0QjtcclxuICAgICAgICAgICAgdmFyIGtUYW5nZW50ID0gYm9keUEubV9pbnZNYXNzICsgYm9keUIubV9pbnZNYXNzICsgYm9keUEubV9pbnZJICogcnRBICsgYm9keUIubV9pbnZJICogcnRCO1xyXG4gICAgICAgICAgICBjY3AudGFuZ2VudE1hc3MgPSAxLjAgLyBrVGFuZ2VudDtcclxuICAgICAgICAgICAgY2NwLnZlbG9jaXR5QmlhcyA9IDAuMDtcclxuICAgICAgICAgICAgdmFyIHRYID0gdkJYICsgKCgtd0IgKiByQlkpKSAtIHZBWCAtICgoLXdBICogckFZKSk7XHJcbiAgICAgICAgICAgIHZhciB0WSA9IHZCWSArICh3QiAqIHJCWCkgLSB2QVkgLSAod0EgKiByQVgpO1xyXG4gICAgICAgICAgICB2YXIgdlJlbCA9IGNjLm5vcm1hbC54ICogdFggKyBjYy5ub3JtYWwueSAqIHRZO1xyXG4gICAgICAgICAgICBpZiAodlJlbCA8ICgtYjJTZXR0aW5ncy5iMl92ZWxvY2l0eVRocmVzaG9sZCkpIHtcclxuICAgICAgICAgICAgICAgY2NwLnZlbG9jaXR5QmlhcyArPSAoLWNjLnJlc3RpdHV0aW9uICogdlJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAoY2MucG9pbnRDb3VudCA9PSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBjY3AxID0gY2MucG9pbnRzWzBdO1xyXG4gICAgICAgICAgICB2YXIgY2NwMiA9IGNjLnBvaW50c1sxXTtcclxuICAgICAgICAgICAgdmFyIGludk1hc3NBID0gYm9keUEubV9pbnZNYXNzO1xyXG4gICAgICAgICAgICB2YXIgaW52SUEgPSBib2R5QS5tX2ludkk7XHJcbiAgICAgICAgICAgIHZhciBpbnZNYXNzQiA9IGJvZHlCLm1faW52TWFzcztcclxuICAgICAgICAgICAgdmFyIGludklCID0gYm9keUIubV9pbnZJO1xyXG4gICAgICAgICAgICB2YXIgcm4xQSA9IGNjcDEuckEueCAqIG5vcm1hbFkgLSBjY3AxLnJBLnkgKiBub3JtYWxYO1xyXG4gICAgICAgICAgICB2YXIgcm4xQiA9IGNjcDEuckIueCAqIG5vcm1hbFkgLSBjY3AxLnJCLnkgKiBub3JtYWxYO1xyXG4gICAgICAgICAgICB2YXIgcm4yQSA9IGNjcDIuckEueCAqIG5vcm1hbFkgLSBjY3AyLnJBLnkgKiBub3JtYWxYO1xyXG4gICAgICAgICAgICB2YXIgcm4yQiA9IGNjcDIuckIueCAqIG5vcm1hbFkgLSBjY3AyLnJCLnkgKiBub3JtYWxYO1xyXG4gICAgICAgICAgICB2YXIgazExID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4xQSAqIHJuMUEgKyBpbnZJQiAqIHJuMUIgKiBybjFCO1xyXG4gICAgICAgICAgICB2YXIgazIyID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4yQSAqIHJuMkEgKyBpbnZJQiAqIHJuMkIgKiBybjJCO1xyXG4gICAgICAgICAgICB2YXIgazEyID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4xQSAqIHJuMkEgKyBpbnZJQiAqIHJuMUIgKiBybjJCO1xyXG4gICAgICAgICAgICB2YXIga19tYXhDb25kaXRpb25OdW1iZXIgPSAxMDAuMDtcclxuICAgICAgICAgICAgaWYgKGsxMSAqIGsxMSA8IGtfbWF4Q29uZGl0aW9uTnVtYmVyICogKGsxMSAqIGsyMiAtIGsxMiAqIGsxMikpIHtcclxuICAgICAgICAgICAgICAgY2MuSy5jb2wxLlNldChrMTEsIGsxMik7XHJcbiAgICAgICAgICAgICAgIGNjLksuY29sMi5TZXQoazEyLCBrMjIpO1xyXG4gICAgICAgICAgICAgICBjYy5LLkdldEludmVyc2UoY2Mubm9ybWFsTWFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIGNjLnBvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQ29udGFjdFNvbHZlci5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgdFZlYztcclxuICAgICAgdmFyIHRWZWMyO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1fY29uc3RyYWludENvdW50OyArK2kpIHtcclxuICAgICAgICAgdmFyIGMgPSB0aGlzLm1fY29uc3RyYWludHNbaV07XHJcbiAgICAgICAgIHZhciBib2R5QSA9IGMuYm9keUE7XHJcbiAgICAgICAgIHZhciBib2R5QiA9IGMuYm9keUI7XHJcbiAgICAgICAgIHZhciBpbnZNYXNzQSA9IGJvZHlBLm1faW52TWFzcztcclxuICAgICAgICAgdmFyIGludklBID0gYm9keUEubV9pbnZJO1xyXG4gICAgICAgICB2YXIgaW52TWFzc0IgPSBib2R5Qi5tX2ludk1hc3M7XHJcbiAgICAgICAgIHZhciBpbnZJQiA9IGJvZHlCLm1faW52STtcclxuICAgICAgICAgdmFyIG5vcm1hbFggPSBjLm5vcm1hbC54O1xyXG4gICAgICAgICB2YXIgbm9ybWFsWSA9IGMubm9ybWFsLnk7XHJcbiAgICAgICAgIHZhciB0YW5nZW50WCA9IG5vcm1hbFk7XHJcbiAgICAgICAgIHZhciB0YW5nZW50WSA9ICgtbm9ybWFsWCk7XHJcbiAgICAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICAgdmFyIHRDb3VudCA9IDA7XHJcbiAgICAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xyXG4gICAgICAgICAgICB0Q291bnQgPSBjLnBvaW50Q291bnQ7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7XHJcbiAgICAgICAgICAgIGogPCB0Q291bnQ7ICsraikge1xyXG4gICAgICAgICAgICAgICB2YXIgY2NwID0gYy5wb2ludHNbal07XHJcbiAgICAgICAgICAgICAgIGNjcC5ub3JtYWxJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgY2NwLnRhbmdlbnRJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgdmFyIFBYID0gY2NwLm5vcm1hbEltcHVsc2UgKiBub3JtYWxYICsgY2NwLnRhbmdlbnRJbXB1bHNlICogdGFuZ2VudFg7XHJcbiAgICAgICAgICAgICAgIHZhciBQWSA9IGNjcC5ub3JtYWxJbXB1bHNlICogbm9ybWFsWSArIGNjcC50YW5nZW50SW1wdWxzZSAqIHRhbmdlbnRZO1xyXG4gICAgICAgICAgICAgICBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSBpbnZJQSAqIChjY3AuckEueCAqIFBZIC0gY2NwLnJBLnkgKiBQWCk7XHJcbiAgICAgICAgICAgICAgIGJvZHlBLm1fbGluZWFyVmVsb2NpdHkueCAtPSBpbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICAgICAgICBib2R5QS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gaW52TWFzc0EgKiBQWTtcclxuICAgICAgICAgICAgICAgYm9keUIubV9hbmd1bGFyVmVsb2NpdHkgKz0gaW52SUIgKiAoY2NwLnJCLnggKiBQWSAtIGNjcC5yQi55ICogUFgpO1xyXG4gICAgICAgICAgICAgICBib2R5Qi5tX2xpbmVhclZlbG9jaXR5LnggKz0gaW52TWFzc0IgKiBQWDtcclxuICAgICAgICAgICAgICAgYm9keUIubV9saW5lYXJWZWxvY2l0eS55ICs9IGludk1hc3NCICogUFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdENvdW50ID0gYy5wb2ludENvdW50O1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwO1xyXG4gICAgICAgICAgICBqIDwgdENvdW50OyArK2opIHtcclxuICAgICAgICAgICAgICAgdmFyIGNjcDIgPSBjLnBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgY2NwMi5ub3JtYWxJbXB1bHNlID0gMC4wO1xyXG4gICAgICAgICAgICAgICBjY3AyLnRhbmdlbnRJbXB1bHNlID0gMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQ29udGFjdFNvbHZlci5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaiA9IDA7XHJcbiAgICAgIHZhciBjY3A7XHJcbiAgICAgIHZhciByQVggPSAwO1xyXG4gICAgICB2YXIgckFZID0gMDtcclxuICAgICAgdmFyIHJCWCA9IDA7XHJcbiAgICAgIHZhciByQlkgPSAwO1xyXG4gICAgICB2YXIgZHZYID0gMDtcclxuICAgICAgdmFyIGR2WSA9IDA7XHJcbiAgICAgIHZhciB2biA9IDA7XHJcbiAgICAgIHZhciB2dCA9IDA7XHJcbiAgICAgIHZhciBsYW1iZGEgPSAwO1xyXG4gICAgICB2YXIgbWF4RnJpY3Rpb24gPSAwO1xyXG4gICAgICB2YXIgbmV3SW1wdWxzZSA9IDA7XHJcbiAgICAgIHZhciBQWCA9IDA7XHJcbiAgICAgIHZhciBQWSA9IDA7XHJcbiAgICAgIHZhciBkWCA9IDA7XHJcbiAgICAgIHZhciBkWSA9IDA7XHJcbiAgICAgIHZhciBQMVggPSAwO1xyXG4gICAgICB2YXIgUDFZID0gMDtcclxuICAgICAgdmFyIFAyWCA9IDA7XHJcbiAgICAgIHZhciBQMlkgPSAwO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRWZWM7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciBjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xyXG4gICAgICAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xyXG4gICAgICAgICB2YXIgd0EgPSBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgdmFyIHdCID0gYm9keUIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgIHZhciB2QSA9IGJvZHlBLm1fbGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgIHZhciB2QiA9IGJvZHlCLm1fbGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgIHZhciBpbnZNYXNzQSA9IGJvZHlBLm1faW52TWFzcztcclxuICAgICAgICAgdmFyIGludklBID0gYm9keUEubV9pbnZJO1xyXG4gICAgICAgICB2YXIgaW52TWFzc0IgPSBib2R5Qi5tX2ludk1hc3M7XHJcbiAgICAgICAgIHZhciBpbnZJQiA9IGJvZHlCLm1faW52STtcclxuICAgICAgICAgdmFyIG5vcm1hbFggPSBjLm5vcm1hbC54O1xyXG4gICAgICAgICB2YXIgbm9ybWFsWSA9IGMubm9ybWFsLnk7XHJcbiAgICAgICAgIHZhciB0YW5nZW50WCA9IG5vcm1hbFk7XHJcbiAgICAgICAgIHZhciB0YW5nZW50WSA9ICgtbm9ybWFsWCk7XHJcbiAgICAgICAgIHZhciBmcmljdGlvbiA9IGMuZnJpY3Rpb247XHJcbiAgICAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgICAgIGZvciAoaiA9IDA7XHJcbiAgICAgICAgIGogPCBjLnBvaW50Q291bnQ7IGorKykge1xyXG4gICAgICAgICAgICBjY3AgPSBjLnBvaW50c1tqXTtcclxuICAgICAgICAgICAgZHZYID0gdkIueCAtIHdCICogY2NwLnJCLnkgLSB2QS54ICsgd0EgKiBjY3AuckEueTtcclxuICAgICAgICAgICAgZHZZID0gdkIueSArIHdCICogY2NwLnJCLnggLSB2QS55IC0gd0EgKiBjY3AuckEueDtcclxuICAgICAgICAgICAgdnQgPSBkdlggKiB0YW5nZW50WCArIGR2WSAqIHRhbmdlbnRZO1xyXG4gICAgICAgICAgICBsYW1iZGEgPSBjY3AudGFuZ2VudE1hc3MgKiAoLXZ0KTtcclxuICAgICAgICAgICAgbWF4RnJpY3Rpb24gPSBmcmljdGlvbiAqIGNjcC5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICBuZXdJbXB1bHNlID0gYjJNYXRoLkNsYW1wKGNjcC50YW5nZW50SW1wdWxzZSArIGxhbWJkYSwgKC1tYXhGcmljdGlvbiksIG1heEZyaWN0aW9uKTtcclxuICAgICAgICAgICAgbGFtYmRhID0gbmV3SW1wdWxzZSAtIGNjcC50YW5nZW50SW1wdWxzZTtcclxuICAgICAgICAgICAgUFggPSBsYW1iZGEgKiB0YW5nZW50WDtcclxuICAgICAgICAgICAgUFkgPSBsYW1iZGEgKiB0YW5nZW50WTtcclxuICAgICAgICAgICAgdkEueCAtPSBpbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogUFk7XHJcbiAgICAgICAgICAgIHdBIC09IGludklBICogKGNjcC5yQS54ICogUFkgLSBjY3AuckEueSAqIFBYKTtcclxuICAgICAgICAgICAgdkIueCArPSBpbnZNYXNzQiAqIFBYO1xyXG4gICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogUFk7XHJcbiAgICAgICAgICAgIHdCICs9IGludklCICogKGNjcC5yQi54ICogUFkgLSBjY3AuckIueSAqIFBYKTtcclxuICAgICAgICAgICAgY2NwLnRhbmdlbnRJbXB1bHNlID0gbmV3SW1wdWxzZTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgdENvdW50ID0gcGFyc2VJbnQoYy5wb2ludENvdW50KTtcclxuICAgICAgICAgaWYgKGMucG9pbnRDb3VudCA9PSAxKSB7XHJcbiAgICAgICAgICAgIGNjcCA9IGMucG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBkdlggPSB2Qi54ICsgKCgtd0IgKiBjY3AuckIueSkpIC0gdkEueCAtICgoLXdBICogY2NwLnJBLnkpKTtcclxuICAgICAgICAgICAgZHZZID0gdkIueSArICh3QiAqIGNjcC5yQi54KSAtIHZBLnkgLSAod0EgKiBjY3AuckEueCk7XHJcbiAgICAgICAgICAgIHZuID0gZHZYICogbm9ybWFsWCArIGR2WSAqIG5vcm1hbFk7XHJcbiAgICAgICAgICAgIGxhbWJkYSA9ICgtY2NwLm5vcm1hbE1hc3MgKiAodm4gLSBjY3AudmVsb2NpdHlCaWFzKSk7XHJcbiAgICAgICAgICAgIG5ld0ltcHVsc2UgPSBjY3Aubm9ybWFsSW1wdWxzZSArIGxhbWJkYTtcclxuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IG5ld0ltcHVsc2UgPiAwID8gbmV3SW1wdWxzZSA6IDAuMDtcclxuICAgICAgICAgICAgbGFtYmRhID0gbmV3SW1wdWxzZSAtIGNjcC5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICBQWCA9IGxhbWJkYSAqIG5vcm1hbFg7XHJcbiAgICAgICAgICAgIFBZID0gbGFtYmRhICogbm9ybWFsWTtcclxuICAgICAgICAgICAgdkEueCAtPSBpbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogUFk7XHJcbiAgICAgICAgICAgIHdBIC09IGludklBICogKGNjcC5yQS54ICogUFkgLSBjY3AuckEueSAqIFBYKTtcclxuICAgICAgICAgICAgdkIueCArPSBpbnZNYXNzQiAqIFBYO1xyXG4gICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogUFk7XHJcbiAgICAgICAgICAgIHdCICs9IGludklCICogKGNjcC5yQi54ICogUFkgLSBjY3AuckIueSAqIFBYKTtcclxuICAgICAgICAgICAgY2NwLm5vcm1hbEltcHVsc2UgPSBuZXdJbXB1bHNlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY3AxID0gYy5wb2ludHNbMF07XHJcbiAgICAgICAgICAgIHZhciBjcDIgPSBjLnBvaW50c1sxXTtcclxuICAgICAgICAgICAgdmFyIGFYID0gY3AxLm5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgIHZhciBhWSA9IGNwMi5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICB2YXIgZHYxWCA9IHZCLnggLSB3QiAqIGNwMS5yQi55IC0gdkEueCArIHdBICogY3AxLnJBLnk7XHJcbiAgICAgICAgICAgIHZhciBkdjFZID0gdkIueSArIHdCICogY3AxLnJCLnggLSB2QS55IC0gd0EgKiBjcDEuckEueDtcclxuICAgICAgICAgICAgdmFyIGR2MlggPSB2Qi54IC0gd0IgKiBjcDIuckIueSAtIHZBLnggKyB3QSAqIGNwMi5yQS55O1xyXG4gICAgICAgICAgICB2YXIgZHYyWSA9IHZCLnkgKyB3QiAqIGNwMi5yQi54IC0gdkEueSAtIHdBICogY3AyLnJBLng7XHJcbiAgICAgICAgICAgIHZhciB2bjEgPSBkdjFYICogbm9ybWFsWCArIGR2MVkgKiBub3JtYWxZO1xyXG4gICAgICAgICAgICB2YXIgdm4yID0gZHYyWCAqIG5vcm1hbFggKyBkdjJZICogbm9ybWFsWTtcclxuICAgICAgICAgICAgdmFyIGJYID0gdm4xIC0gY3AxLnZlbG9jaXR5QmlhcztcclxuICAgICAgICAgICAgdmFyIGJZID0gdm4yIC0gY3AyLnZlbG9jaXR5QmlhcztcclxuICAgICAgICAgICAgdE1hdCA9IGMuSztcclxuICAgICAgICAgICAgYlggLT0gdE1hdC5jb2wxLnggKiBhWCArIHRNYXQuY29sMi54ICogYVk7XHJcbiAgICAgICAgICAgIGJZIC09IHRNYXQuY29sMS55ICogYVggKyB0TWF0LmNvbDIueSAqIGFZO1xyXG4gICAgICAgICAgICB2YXIga19lcnJvclRvbCA9IDAuMDAxO1xyXG4gICAgICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICAgICAgIHRNYXQgPSBjLm5vcm1hbE1hc3M7XHJcbiAgICAgICAgICAgICAgIHZhciB4WCA9ICgtKHRNYXQuY29sMS54ICogYlggKyB0TWF0LmNvbDIueCAqIGJZKSk7XHJcbiAgICAgICAgICAgICAgIHZhciB4WSA9ICgtKHRNYXQuY29sMS55ICogYlggKyB0TWF0LmNvbDIueSAqIGJZKSk7XHJcbiAgICAgICAgICAgICAgIGlmICh4WCA+PSAwLjAgJiYgeFkgPj0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgIGRYID0geFggLSBhWDtcclxuICAgICAgICAgICAgICAgICAgZFkgPSB4WSAtIGFZO1xyXG4gICAgICAgICAgICAgICAgICBQMVggPSBkWCAqIG5vcm1hbFg7XHJcbiAgICAgICAgICAgICAgICAgIFAxWSA9IGRYICogbm9ybWFsWTtcclxuICAgICAgICAgICAgICAgICAgUDJYID0gZFkgKiBub3JtYWxYO1xyXG4gICAgICAgICAgICAgICAgICBQMlkgPSBkWSAqIG5vcm1hbFk7XHJcbiAgICAgICAgICAgICAgICAgIHZBLnggLT0gaW52TWFzc0EgKiAoUDFYICsgUDJYKTtcclxuICAgICAgICAgICAgICAgICAgdkEueSAtPSBpbnZNYXNzQSAqIChQMVkgKyBQMlkpO1xyXG4gICAgICAgICAgICAgICAgICB3QSAtPSBpbnZJQSAqIChjcDEuckEueCAqIFAxWSAtIGNwMS5yQS55ICogUDFYICsgY3AyLnJBLnggKiBQMlkgLSBjcDIuckEueSAqIFAyWCk7XHJcbiAgICAgICAgICAgICAgICAgIHZCLnggKz0gaW52TWFzc0IgKiAoUDFYICsgUDJYKTtcclxuICAgICAgICAgICAgICAgICAgdkIueSArPSBpbnZNYXNzQiAqIChQMVkgKyBQMlkpO1xyXG4gICAgICAgICAgICAgICAgICB3QiArPSBpbnZJQiAqIChjcDEuckIueCAqIFAxWSAtIGNwMS5yQi55ICogUDFYICsgY3AyLnJCLnggKiBQMlkgLSBjcDIuckIueSAqIFAyWCk7XHJcbiAgICAgICAgICAgICAgICAgIGNwMS5ub3JtYWxJbXB1bHNlID0geFg7XHJcbiAgICAgICAgICAgICAgICAgIGNwMi5ub3JtYWxJbXB1bHNlID0geFk7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIHhYID0gKC1jcDEubm9ybWFsTWFzcyAqIGJYKTtcclxuICAgICAgICAgICAgICAgeFkgPSAwLjA7XHJcbiAgICAgICAgICAgICAgIHZuMSA9IDAuMDtcclxuICAgICAgICAgICAgICAgdm4yID0gYy5LLmNvbDEueSAqIHhYICsgYlk7XHJcbiAgICAgICAgICAgICAgIGlmICh4WCA+PSAwLjAgJiYgdm4yID49IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgICBkWCA9IHhYIC0gYVg7XHJcbiAgICAgICAgICAgICAgICAgIGRZID0geFkgLSBhWTtcclxuICAgICAgICAgICAgICAgICAgUDFYID0gZFggKiBub3JtYWxYO1xyXG4gICAgICAgICAgICAgICAgICBQMVkgPSBkWCAqIG5vcm1hbFk7XHJcbiAgICAgICAgICAgICAgICAgIFAyWCA9IGRZICogbm9ybWFsWDtcclxuICAgICAgICAgICAgICAgICAgUDJZID0gZFkgKiBub3JtYWxZO1xyXG4gICAgICAgICAgICAgICAgICB2QS54IC09IGludk1hc3NBICogKFAxWCArIFAyWCk7XHJcbiAgICAgICAgICAgICAgICAgIHZBLnkgLT0gaW52TWFzc0EgKiAoUDFZICsgUDJZKTtcclxuICAgICAgICAgICAgICAgICAgd0EgLT0gaW52SUEgKiAoY3AxLnJBLnggKiBQMVkgLSBjcDEuckEueSAqIFAxWCArIGNwMi5yQS54ICogUDJZIC0gY3AyLnJBLnkgKiBQMlgpO1xyXG4gICAgICAgICAgICAgICAgICB2Qi54ICs9IGludk1hc3NCICogKFAxWCArIFAyWCk7XHJcbiAgICAgICAgICAgICAgICAgIHZCLnkgKz0gaW52TWFzc0IgKiAoUDFZICsgUDJZKTtcclxuICAgICAgICAgICAgICAgICAgd0IgKz0gaW52SUIgKiAoY3AxLnJCLnggKiBQMVkgLSBjcDEuckIueSAqIFAxWCArIGNwMi5yQi54ICogUDJZIC0gY3AyLnJCLnkgKiBQMlgpO1xyXG4gICAgICAgICAgICAgICAgICBjcDEubm9ybWFsSW1wdWxzZSA9IHhYO1xyXG4gICAgICAgICAgICAgICAgICBjcDIubm9ybWFsSW1wdWxzZSA9IHhZO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB4WCA9IDAuMDtcclxuICAgICAgICAgICAgICAgeFkgPSAoLWNwMi5ub3JtYWxNYXNzICogYlkpO1xyXG4gICAgICAgICAgICAgICB2bjEgPSBjLksuY29sMi54ICogeFkgKyBiWDtcclxuICAgICAgICAgICAgICAgdm4yID0gMC4wO1xyXG4gICAgICAgICAgICAgICBpZiAoeFkgPj0gMC4wICYmIHZuMSA+PSAwLjApIHtcclxuICAgICAgICAgICAgICAgICAgZFggPSB4WCAtIGFYO1xyXG4gICAgICAgICAgICAgICAgICBkWSA9IHhZIC0gYVk7XHJcbiAgICAgICAgICAgICAgICAgIFAxWCA9IGRYICogbm9ybWFsWDtcclxuICAgICAgICAgICAgICAgICAgUDFZID0gZFggKiBub3JtYWxZO1xyXG4gICAgICAgICAgICAgICAgICBQMlggPSBkWSAqIG5vcm1hbFg7XHJcbiAgICAgICAgICAgICAgICAgIFAyWSA9IGRZICogbm9ybWFsWTtcclxuICAgICAgICAgICAgICAgICAgdkEueCAtPSBpbnZNYXNzQSAqIChQMVggKyBQMlgpO1xyXG4gICAgICAgICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogKFAxWSArIFAyWSk7XHJcbiAgICAgICAgICAgICAgICAgIHdBIC09IGludklBICogKGNwMS5yQS54ICogUDFZIC0gY3AxLnJBLnkgKiBQMVggKyBjcDIuckEueCAqIFAyWSAtIGNwMi5yQS55ICogUDJYKTtcclxuICAgICAgICAgICAgICAgICAgdkIueCArPSBpbnZNYXNzQiAqIChQMVggKyBQMlgpO1xyXG4gICAgICAgICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogKFAxWSArIFAyWSk7XHJcbiAgICAgICAgICAgICAgICAgIHdCICs9IGludklCICogKGNwMS5yQi54ICogUDFZIC0gY3AxLnJCLnkgKiBQMVggKyBjcDIuckIueCAqIFAyWSAtIGNwMi5yQi55ICogUDJYKTtcclxuICAgICAgICAgICAgICAgICAgY3AxLm5vcm1hbEltcHVsc2UgPSB4WDtcclxuICAgICAgICAgICAgICAgICAgY3AyLm5vcm1hbEltcHVsc2UgPSB4WTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgeFggPSAwLjA7XHJcbiAgICAgICAgICAgICAgIHhZID0gMC4wO1xyXG4gICAgICAgICAgICAgICB2bjEgPSBiWDtcclxuICAgICAgICAgICAgICAgdm4yID0gYlk7XHJcbiAgICAgICAgICAgICAgIGlmICh2bjEgPj0gMC4wICYmIHZuMiA+PSAwLjApIHtcclxuICAgICAgICAgICAgICAgICAgZFggPSB4WCAtIGFYO1xyXG4gICAgICAgICAgICAgICAgICBkWSA9IHhZIC0gYVk7XHJcbiAgICAgICAgICAgICAgICAgIFAxWCA9IGRYICogbm9ybWFsWDtcclxuICAgICAgICAgICAgICAgICAgUDFZID0gZFggKiBub3JtYWxZO1xyXG4gICAgICAgICAgICAgICAgICBQMlggPSBkWSAqIG5vcm1hbFg7XHJcbiAgICAgICAgICAgICAgICAgIFAyWSA9IGRZICogbm9ybWFsWTtcclxuICAgICAgICAgICAgICAgICAgdkEueCAtPSBpbnZNYXNzQSAqIChQMVggKyBQMlgpO1xyXG4gICAgICAgICAgICAgICAgICB2QS55IC09IGludk1hc3NBICogKFAxWSArIFAyWSk7XHJcbiAgICAgICAgICAgICAgICAgIHdBIC09IGludklBICogKGNwMS5yQS54ICogUDFZIC0gY3AxLnJBLnkgKiBQMVggKyBjcDIuckEueCAqIFAyWSAtIGNwMi5yQS55ICogUDJYKTtcclxuICAgICAgICAgICAgICAgICAgdkIueCArPSBpbnZNYXNzQiAqIChQMVggKyBQMlgpO1xyXG4gICAgICAgICAgICAgICAgICB2Qi55ICs9IGludk1hc3NCICogKFAxWSArIFAyWSk7XHJcbiAgICAgICAgICAgICAgICAgIHdCICs9IGludklCICogKGNwMS5yQi54ICogUDFZIC0gY3AxLnJCLnkgKiBQMVggKyBjcDIuckIueCAqIFAyWSAtIGNwMi5yQi55ICogUDJYKTtcclxuICAgICAgICAgICAgICAgICAgY3AxLm5vcm1hbEltcHVsc2UgPSB4WDtcclxuICAgICAgICAgICAgICAgICAgY3AyLm5vcm1hbEltcHVsc2UgPSB4WTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBib2R5QS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdBO1xyXG4gICAgICAgICBib2R5Qi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdCO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5GaW5hbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgKytpKSB7XHJcbiAgICAgICAgIHZhciBjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICB2YXIgbSA9IGMubWFuaWZvbGQ7XHJcbiAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5wb2ludENvdW50OyArK2opIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50MSA9IG0ubV9wb2ludHNbal07XHJcbiAgICAgICAgICAgIHZhciBwb2ludDIgPSBjLnBvaW50c1tqXTtcclxuICAgICAgICAgICAgcG9pbnQxLm1fbm9ybWFsSW1wdWxzZSA9IHBvaW50Mi5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICBwb2ludDEubV90YW5nZW50SW1wdWxzZSA9IHBvaW50Mi50YW5nZW50SW1wdWxzZTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJDb250YWN0U29sdmVyLnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XHJcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcclxuICAgICAgdmFyIG1pblNlcGFyYXRpb24gPSAwLjA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tX2NvbnN0cmFpbnRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgIHZhciBjID0gdGhpcy5tX2NvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICB2YXIgYm9keUEgPSBjLmJvZHlBO1xyXG4gICAgICAgICB2YXIgYm9keUIgPSBjLmJvZHlCO1xyXG4gICAgICAgICB2YXIgaW52TWFzc0EgPSBib2R5QS5tX21hc3MgKiBib2R5QS5tX2ludk1hc3M7XHJcbiAgICAgICAgIHZhciBpbnZJQSA9IGJvZHlBLm1fbWFzcyAqIGJvZHlBLm1faW52STtcclxuICAgICAgICAgdmFyIGludk1hc3NCID0gYm9keUIubV9tYXNzICogYm9keUIubV9pbnZNYXNzO1xyXG4gICAgICAgICB2YXIgaW52SUIgPSBib2R5Qi5tX21hc3MgKiBib2R5Qi5tX2ludkk7XHJcbiAgICAgICAgIGIyQ29udGFjdFNvbHZlci5zX3BzbS5Jbml0aWFsaXplKGMpO1xyXG4gICAgICAgICB2YXIgbm9ybWFsID0gYjJDb250YWN0U29sdmVyLnNfcHNtLm1fbm9ybWFsO1xyXG4gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMucG9pbnRDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBjY3AgPSBjLnBvaW50c1tqXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gYjJDb250YWN0U29sdmVyLnNfcHNtLm1fcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IGIyQ29udGFjdFNvbHZlci5zX3BzbS5tX3NlcGFyYXRpb25zW2pdO1xyXG4gICAgICAgICAgICB2YXIgckFYID0gcG9pbnQueCAtIGJvZHlBLm1fc3dlZXAuYy54O1xyXG4gICAgICAgICAgICB2YXIgckFZID0gcG9pbnQueSAtIGJvZHlBLm1fc3dlZXAuYy55O1xyXG4gICAgICAgICAgICB2YXIgckJYID0gcG9pbnQueCAtIGJvZHlCLm1fc3dlZXAuYy54O1xyXG4gICAgICAgICAgICB2YXIgckJZID0gcG9pbnQueSAtIGJvZHlCLm1fc3dlZXAuYy55O1xyXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uID0gbWluU2VwYXJhdGlvbiA8IHNlcGFyYXRpb24gPyBtaW5TZXBhcmF0aW9uIDogc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgdmFyIEMgPSBiMk1hdGguQ2xhbXAoYmF1bWdhcnRlICogKHNlcGFyYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XHJcbiAgICAgICAgICAgIHZhciBpbXB1bHNlID0gKC1jY3AuZXF1YWxpemVkTWFzcyAqIEMpO1xyXG4gICAgICAgICAgICB2YXIgUFggPSBpbXB1bHNlICogbm9ybWFsLng7XHJcbiAgICAgICAgICAgIHZhciBQWSA9IGltcHVsc2UgKiBub3JtYWwueTtib2R5QS5tX3N3ZWVwLmMueCAtPSBpbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICAgICBib2R5QS5tX3N3ZWVwLmMueSAtPSBpbnZNYXNzQSAqIFBZO1xyXG4gICAgICAgICAgICBib2R5QS5tX3N3ZWVwLmEgLT0gaW52SUEgKiAockFYICogUFkgLSByQVkgKiBQWCk7XHJcbiAgICAgICAgICAgIGJvZHlBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGJvZHlCLm1fc3dlZXAuYy54ICs9IGludk1hc3NCICogUFg7XHJcbiAgICAgICAgICAgIGJvZHlCLm1fc3dlZXAuYy55ICs9IGludk1hc3NCICogUFk7XHJcbiAgICAgICAgICAgIGJvZHlCLm1fc3dlZXAuYSArPSBpbnZJQiAqIChyQlggKiBQWSAtIHJCWSAqIFBYKTtcclxuICAgICAgICAgICAgYm9keUIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtaW5TZXBhcmF0aW9uID4gKC0xLjUgKiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApO1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RTb2x2ZXIuc193b3JsZE1hbmlmb2xkID0gbmV3IGIyV29ybGRNYW5pZm9sZCgpO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3RTb2x2ZXIuc19wc20gPSBuZXcgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkKCk7XHJcbiAgIH0pO1xyXG4gICBCb3gyRC5pbmhlcml0KGIyRWRnZUFuZENpcmNsZUNvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XHJcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xyXG4gICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0LmIyRWRnZUFuZENpcmNsZUNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdC5DcmVhdGUgPSBmdW5jdGlvbiAoYWxsb2NhdG9yKSB7XHJcbiAgICAgIHJldHVybiBuZXcgYjJFZGdlQW5kQ2lyY2xlQ29udGFjdCgpO1xyXG4gICB9XHJcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QuRGVzdHJveSA9IGZ1bmN0aW9uIChjb250YWN0LCBhbGxvY2F0b3IpIHt9XHJcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuUmVzZXQuY2FsbCh0aGlzLCBmaXh0dXJlQSwgZml4dHVyZUIpO1xyXG4gICB9XHJcbiAgIGIyRWRnZUFuZENpcmNsZUNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fZml4dHVyZUEuR2V0Qm9keSgpO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fZml4dHVyZUIuR2V0Qm9keSgpO1xyXG4gICAgICB0aGlzLmIyQ29sbGlkZUVkZ2VBbmRDaXJjbGUodGhpcy5tX21hbmlmb2xkLCAodGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMkVkZ2VTaGFwZSA/IHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIDogbnVsbCksIGJBLm1feGYsICh0aGlzLm1fZml4dHVyZUIuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyQ2lyY2xlU2hhcGUgPyB0aGlzLm1fZml4dHVyZUIuR2V0U2hhcGUoKSA6IG51bGwpLCBiQi5tX3hmKTtcclxuICAgfVxyXG4gICBiMkVkZ2VBbmRDaXJjbGVDb250YWN0LnByb3RvdHlwZS5iMkNvbGxpZGVFZGdlQW5kQ2lyY2xlID0gZnVuY3Rpb24gKG1hbmlmb2xkLCBlZGdlLCB4ZjEsIGNpcmNsZSwgeGYyKSB7fVxyXG4gICBCb3gyRC5pbmhlcml0KGIyTnVsbENvbnRhY3QsIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdCk7XHJcbiAgIGIyTnVsbENvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xyXG4gICBiMk51bGxDb250YWN0LmIyTnVsbENvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5iMkNvbnRhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgYjJOdWxsQ29udGFjdC5wcm90b3R5cGUuYjJOdWxsQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIyQ29udGFjdC5jYWxsKHRoaXMpO1xyXG4gICB9XHJcbiAgIGIyTnVsbENvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge31cclxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlBbmRDaXJjbGVDb250YWN0LCBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QpO1xyXG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LnByb3RvdHlwZTtcclxuICAgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5iMlBvbHlBbmRDaXJjbGVDb250YWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QuYjJDb250YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgIH07XHJcbiAgIGIyUG9seUFuZENpcmNsZUNvbnRhY3QuQ3JlYXRlID0gZnVuY3Rpb24gKGFsbG9jYXRvcikge1xyXG4gICAgICByZXR1cm4gbmV3IGIyUG9seUFuZENpcmNsZUNvbnRhY3QoKTtcclxuICAgfVxyXG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LkRlc3Ryb3kgPSBmdW5jdGlvbiAoY29udGFjdCwgYWxsb2NhdG9yKSB7fVxyXG4gICBiMlBvbHlBbmRDaXJjbGVDb250YWN0LnByb3RvdHlwZS5SZXNldCA9IGZ1bmN0aW9uIChmaXh0dXJlQSwgZml4dHVyZUIpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLlJlc2V0LmNhbGwodGhpcywgZml4dHVyZUEsIGZpeHR1cmVCKTtcclxuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmaXh0dXJlQS5HZXRUeXBlKCkgPT0gYjJTaGFwZS5lX3BvbHlnb25TaGFwZSk7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZml4dHVyZUIuR2V0VHlwZSgpID09IGIyU2hhcGUuZV9jaXJjbGVTaGFwZSk7XHJcbiAgIH1cclxuICAgYjJQb2x5QW5kQ2lyY2xlQ29udGFjdC5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9maXh0dXJlQS5tX2JvZHk7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9maXh0dXJlQi5tX2JvZHk7XHJcbiAgICAgIGIyQ29sbGlzaW9uLkNvbGxpZGVQb2x5Z29uQW5kQ2lyY2xlKHRoaXMubV9tYW5pZm9sZCwgKHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyB0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSA6IG51bGwpLCBiQS5tX3hmLCAodGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMkNpcmNsZVNoYXBlID8gdGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgOiBudWxsKSwgYkIubV94Zik7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMlBvbHlBbmRFZGdlQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcclxuICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250YWN0cy5iMkNvbnRhY3QucHJvdG90eXBlO1xyXG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5iMlBvbHlBbmRFZGdlQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5DcmVhdGUgPSBmdW5jdGlvbiAoYWxsb2NhdG9yKSB7XHJcbiAgICAgIHJldHVybiBuZXcgYjJQb2x5QW5kRWRnZUNvbnRhY3QoKTtcclxuICAgfVxyXG4gICBiMlBvbHlBbmRFZGdlQ29udGFjdC5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGFsbG9jYXRvcikge31cclxuICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKGZpeHR1cmVBLCBmaXh0dXJlQikge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuUmVzZXQuY2FsbCh0aGlzLCBmaXh0dXJlQSwgZml4dHVyZUIpO1xyXG4gICAgICBiMlNldHRpbmdzLmIyQXNzZXJ0KGZpeHR1cmVBLkdldFR5cGUoKSA9PSBiMlNoYXBlLmVfcG9seWdvblNoYXBlKTtcclxuICAgICAgYjJTZXR0aW5ncy5iMkFzc2VydChmaXh0dXJlQi5HZXRUeXBlKCkgPT0gYjJTaGFwZS5lX2VkZ2VTaGFwZSk7XHJcbiAgIH1cclxuICAgYjJQb2x5QW5kRWRnZUNvbnRhY3QucHJvdG90eXBlLkV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fZml4dHVyZUEuR2V0Qm9keSgpO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fZml4dHVyZUIuR2V0Qm9keSgpO1xyXG4gICAgICB0aGlzLmIyQ29sbGlkZVBvbHlBbmRFZGdlKHRoaXMubV9tYW5pZm9sZCwgKHRoaXMubV9maXh0dXJlQS5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyB0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSA6IG51bGwpLCBiQS5tX3hmLCAodGhpcy5tX2ZpeHR1cmVCLkdldFNoYXBlKCkgaW5zdGFuY2VvZiBiMkVkZ2VTaGFwZSA/IHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIDogbnVsbCksIGJCLm1feGYpO1xyXG4gICB9XHJcbiAgIGIyUG9seUFuZEVkZ2VDb250YWN0LnByb3RvdHlwZS5iMkNvbGxpZGVQb2x5QW5kRWRnZSA9IGZ1bmN0aW9uIChtYW5pZm9sZCwgcG9seWdvbiwgeGYxLCBlZGdlLCB4ZjIpIHt9XHJcbiAgIEJveDJELmluaGVyaXQoYjJQb2x5Z29uQ29udGFjdCwgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0KTtcclxuICAgYjJQb2x5Z29uQ29udGFjdC5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRhY3RzLmIyQ29udGFjdC5wcm90b3R5cGU7XHJcbiAgIGIyUG9seWdvbkNvbnRhY3QuYjJQb2x5Z29uQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJDb250YWN0LmIyQ29udGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICB9O1xyXG4gICBiMlBvbHlnb25Db250YWN0LkNyZWF0ZSA9IGZ1bmN0aW9uIChhbGxvY2F0b3IpIHtcclxuICAgICAgcmV0dXJuIG5ldyBiMlBvbHlnb25Db250YWN0KCk7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uQ29udGFjdC5EZXN0cm95ID0gZnVuY3Rpb24gKGNvbnRhY3QsIGFsbG9jYXRvcikge31cclxuICAgYjJQb2x5Z29uQ29udGFjdC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoZml4dHVyZUEsIGZpeHR1cmVCKSB7XHJcbiAgICAgIHRoaXMuX19zdXBlci5SZXNldC5jYWxsKHRoaXMsIGZpeHR1cmVBLCBmaXh0dXJlQik7XHJcbiAgIH1cclxuICAgYjJQb2x5Z29uQ29udGFjdC5wcm90b3R5cGUuRXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9maXh0dXJlQS5HZXRCb2R5KCk7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9maXh0dXJlQi5HZXRCb2R5KCk7XHJcbiAgICAgIGIyQ29sbGlzaW9uLkNvbGxpZGVQb2x5Z29ucyh0aGlzLm1fbWFuaWZvbGQsICh0aGlzLm1fZml4dHVyZUEuR2V0U2hhcGUoKSBpbnN0YW5jZW9mIGIyUG9seWdvblNoYXBlID8gdGhpcy5tX2ZpeHR1cmVBLkdldFNoYXBlKCkgOiBudWxsKSwgYkEubV94ZiwgKHRoaXMubV9maXh0dXJlQi5HZXRTaGFwZSgpIGluc3RhbmNlb2YgYjJQb2x5Z29uU2hhcGUgPyB0aGlzLm1fZml4dHVyZUIuR2V0U2hhcGUoKSA6IG51bGwpLCBiQi5tX3hmKTtcclxuICAgfVxyXG4gICBiMlBvc2l0aW9uU29sdmVyTWFuaWZvbGQuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIyUG9zaXRpb25Tb2x2ZXJNYW5pZm9sZC5wcm90b3R5cGUuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fbm9ybWFsID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fc2VwYXJhdGlvbnMgPSBuZXcgVmVjdG9yX2Eyal9OdW1iZXIoYjJTZXR0aW5ncy5iMl9tYXhNYW5pZm9sZFBvaW50cyk7XHJcbiAgICAgIHRoaXMubV9wb2ludHMgPSBuZXcgVmVjdG9yKGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHMpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIyU2V0dGluZ3MuYjJfbWF4TWFuaWZvbGRQb2ludHM7IGkrKykge1xyXG4gICAgICAgICB0aGlzLm1fcG9pbnRzW2ldID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGNjKSB7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoY2MucG9pbnRDb3VudCA+IDApO1xyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHZhciBjbGlwUG9pbnRYID0gMDtcclxuICAgICAgdmFyIGNsaXBQb2ludFkgPSAwO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRWZWM7XHJcbiAgICAgIHZhciBwbGFuZVBvaW50WCA9IDA7XHJcbiAgICAgIHZhciBwbGFuZVBvaW50WSA9IDA7XHJcbiAgICAgIHN3aXRjaCAoY2MudHlwZSkge1xyXG4gICAgICBjYXNlIGIyTWFuaWZvbGQuZV9jaXJjbGVzOlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIHRNYXQgPSBjYy5ib2R5QS5tX3hmLlI7XHJcbiAgICAgICAgICAgIHRWZWMgPSBjYy5sb2NhbFBvaW50O1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRBWCA9IGNjLmJvZHlBLm1feGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgICAgdmFyIHBvaW50QVkgPSBjYy5ib2R5QS5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgIHRNYXQgPSBjYy5ib2R5Qi5tX3hmLlI7XHJcbiAgICAgICAgICAgIHRWZWMgPSBjYy5wb2ludHNbMF0ubG9jYWxQb2ludDtcclxuICAgICAgICAgICAgdmFyIHBvaW50QlggPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgIHZhciBwb2ludEJZID0gY2MuYm9keUIubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICAgICAgICB2YXIgZFggPSBwb2ludEJYIC0gcG9pbnRBWDtcclxuICAgICAgICAgICAgdmFyIGRZID0gcG9pbnRCWSAtIHBvaW50QVk7XHJcbiAgICAgICAgICAgIHZhciBkMiA9IGRYICogZFggKyBkWSAqIGRZO1xyXG4gICAgICAgICAgICBpZiAoZDIgPiBOdW1iZXIuTUlOX1ZBTFVFICogTnVtYmVyLk1JTl9WQUxVRSkge1xyXG4gICAgICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkMik7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9IGRYIC8gZDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gZFkgLyBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggPSAxLjA7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1fcG9pbnRzWzBdLnggPSAwLjUgKiAocG9pbnRBWCArIHBvaW50QlgpO1xyXG4gICAgICAgICAgICB0aGlzLm1fcG9pbnRzWzBdLnkgPSAwLjUgKiAocG9pbnRBWSArIHBvaW50QlkpO1xyXG4gICAgICAgICAgICB0aGlzLm1fc2VwYXJhdGlvbnNbMF0gPSBkWCAqIHRoaXMubV9ub3JtYWwueCArIGRZICogdGhpcy5tX25vcm1hbC55IC0gY2MucmFkaXVzO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIyTWFuaWZvbGQuZV9mYWNlQTpcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICB0TWF0ID0gY2MuYm9keUEubV94Zi5SO1xyXG4gICAgICAgICAgICB0VmVjID0gY2MubG9jYWxQbGFuZU5vcm1hbDtcclxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC54ID0gdE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueTtcclxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ID0gdE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueTtcclxuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlBLm1feGYuUjtcclxuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgIHBsYW5lUG9pbnRYID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICAgICAgICBwbGFuZVBvaW50WSA9IGNjLmJvZHlBLm1feGYucG9zaXRpb24ueSArICh0TWF0LmNvbDEueSAqIHRWZWMueCArIHRNYXQuY29sMi55ICogdFZlYy55KTtcclxuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlCLm1feGYuUjtcclxuICAgICAgICAgICAgZm9yIChpID0gMDtcclxuICAgICAgICAgICAgaSA8IGNjLnBvaW50Q291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICB0VmVjID0gY2MucG9pbnRzW2ldLmxvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFggPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnggKyAodE1hdC5jb2wxLnggKiB0VmVjLnggKyB0TWF0LmNvbDIueCAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgICAgIGNsaXBQb2ludFkgPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9zZXBhcmF0aW9uc1tpXSA9IChjbGlwUG9pbnRYIC0gcGxhbmVQb2ludFgpICogdGhpcy5tX25vcm1hbC54ICsgKGNsaXBQb2ludFkgLSBwbGFuZVBvaW50WSkgKiB0aGlzLm1fbm9ybWFsLnkgLSBjYy5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9wb2ludHNbaV0ueCA9IGNsaXBQb2ludFg7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9wb2ludHNbaV0ueSA9IGNsaXBQb2ludFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBiMk1hbmlmb2xkLmVfZmFjZUI6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgdE1hdCA9IGNjLmJvZHlCLm1feGYuUjtcclxuICAgICAgICAgICAgdFZlYyA9IGNjLmxvY2FsUGxhbmVOb3JtYWw7XHJcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWwueSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgICAgIHRNYXQgPSBjYy5ib2R5Qi5tX3hmLlI7XHJcbiAgICAgICAgICAgIHRWZWMgPSBjYy5sb2NhbFBvaW50O1xyXG4gICAgICAgICAgICBwbGFuZVBvaW50WCA9IGNjLmJvZHlCLm1feGYucG9zaXRpb24ueCArICh0TWF0LmNvbDEueCAqIHRWZWMueCArIHRNYXQuY29sMi54ICogdFZlYy55KTtcclxuICAgICAgICAgICAgcGxhbmVQb2ludFkgPSBjYy5ib2R5Qi5tX3hmLnBvc2l0aW9uLnkgKyAodE1hdC5jb2wxLnkgKiB0VmVjLnggKyB0TWF0LmNvbDIueSAqIHRWZWMueSk7XHJcbiAgICAgICAgICAgIHRNYXQgPSBjYy5ib2R5QS5tX3hmLlI7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7XHJcbiAgICAgICAgICAgIGkgPCBjYy5wb2ludENvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgdFZlYyA9IGNjLnBvaW50c1tpXS5sb2NhbFBvaW50O1xyXG4gICAgICAgICAgICAgICBjbGlwUG9pbnRYID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi54ICsgKHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnkpO1xyXG4gICAgICAgICAgICAgICBjbGlwUG9pbnRZID0gY2MuYm9keUEubV94Zi5wb3NpdGlvbi55ICsgKHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnkpO1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fc2VwYXJhdGlvbnNbaV0gPSAoY2xpcFBvaW50WCAtIHBsYW5lUG9pbnRYKSAqIHRoaXMubV9ub3JtYWwueCArIChjbGlwUG9pbnRZIC0gcGxhbmVQb2ludFkpICogdGhpcy5tX25vcm1hbC55IC0gY2MucmFkaXVzO1xyXG4gICAgICAgICAgICAgICB0aGlzLm1fcG9pbnRzW2ldLlNldChjbGlwUG9pbnRYLCBjbGlwUG9pbnRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1fbm9ybWFsLnggKj0gKC0xKTtcclxuICAgICAgICAgICAgdGhpcy5tX25vcm1hbC55ICo9ICgtMSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmNpcmNsZVBvaW50QSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuQ29udGFjdHMuYjJQb3NpdGlvblNvbHZlck1hbmlmb2xkLmNpcmNsZVBvaW50QiA9IG5ldyBiMlZlYzIoKTtcclxuICAgfSk7XHJcbn0pKCk7XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgIHZhciBiMkJvZHkgPSBCb3gyRC5EeW5hbWljcy5iMkJvZHksXHJcbiAgICAgIGIyQm9keURlZiA9IEJveDJELkR5bmFtaWNzLmIyQm9keURlZixcclxuICAgICAgYjJDb250YWN0RmlsdGVyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0RmlsdGVyLFxyXG4gICAgICBiMkNvbnRhY3RJbXB1bHNlID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0SW1wdWxzZSxcclxuICAgICAgYjJDb250YWN0TGlzdGVuZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RMaXN0ZW5lcixcclxuICAgICAgYjJDb250YWN0TWFuYWdlciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdE1hbmFnZXIsXHJcbiAgICAgIGIyRGVidWdEcmF3ID0gQm94MkQuRHluYW1pY3MuYjJEZWJ1Z0RyYXcsXHJcbiAgICAgIGIyRGVzdHJ1Y3Rpb25MaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyRGVzdHJ1Y3Rpb25MaXN0ZW5lcixcclxuICAgICAgYjJGaWx0ZXJEYXRhID0gQm94MkQuRHluYW1pY3MuYjJGaWx0ZXJEYXRhLFxyXG4gICAgICBiMkZpeHR1cmUgPSBCb3gyRC5EeW5hbWljcy5iMkZpeHR1cmUsXHJcbiAgICAgIGIyRml4dHVyZURlZiA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZURlZixcclxuICAgICAgYjJJc2xhbmQgPSBCb3gyRC5EeW5hbWljcy5iMklzbGFuZCxcclxuICAgICAgYjJUaW1lU3RlcCA9IEJveDJELkR5bmFtaWNzLmIyVGltZVN0ZXAsXHJcbiAgICAgIGIyV29ybGQgPSBCb3gyRC5EeW5hbWljcy5iMldvcmxkLFxyXG4gICAgICBiMk1hdDIyID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQyMixcclxuICAgICAgYjJNYXQzMyA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0MzMsXHJcbiAgICAgIGIyTWF0aCA9IEJveDJELkNvbW1vbi5NYXRoLmIyTWF0aCxcclxuICAgICAgYjJTd2VlcCA9IEJveDJELkNvbW1vbi5NYXRoLmIyU3dlZXAsXHJcbiAgICAgIGIyVHJhbnNmb3JtID0gQm94MkQuQ29tbW9uLk1hdGguYjJUcmFuc2Zvcm0sXHJcbiAgICAgIGIyVmVjMiA9IEJveDJELkNvbW1vbi5NYXRoLmIyVmVjMixcclxuICAgICAgYjJWZWMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMzLFxyXG4gICAgICBiMkNvbG9yID0gQm94MkQuQ29tbW9uLmIyQ29sb3IsXHJcbiAgICAgIGIyaW50ZXJuYWwgPSBCb3gyRC5Db21tb24uYjJpbnRlcm5hbCxcclxuICAgICAgYjJTZXR0aW5ncyA9IEJveDJELkNvbW1vbi5iMlNldHRpbmdzLFxyXG4gICAgICBiMkNpcmNsZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkNpcmNsZVNoYXBlLFxyXG4gICAgICBiMkVkZ2VDaGFpbkRlZiA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJFZGdlQ2hhaW5EZWYsXHJcbiAgICAgIGIyRWRnZVNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMkVkZ2VTaGFwZSxcclxuICAgICAgYjJNYXNzRGF0YSA9IEJveDJELkNvbGxpc2lvbi5TaGFwZXMuYjJNYXNzRGF0YSxcclxuICAgICAgYjJQb2x5Z29uU2hhcGUgPSBCb3gyRC5Db2xsaXNpb24uU2hhcGVzLmIyUG9seWdvblNoYXBlLFxyXG4gICAgICBiMlNoYXBlID0gQm94MkQuQ29sbGlzaW9uLlNoYXBlcy5iMlNoYXBlLFxyXG4gICAgICBiMkJ1b3lhbmN5Q29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQnVveWFuY3lDb250cm9sbGVyLFxyXG4gICAgICBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb25zdGFudEFjY2VsQ29udHJvbGxlcixcclxuICAgICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIsXHJcbiAgICAgIGIyQ29udHJvbGxlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcixcclxuICAgICAgYjJDb250cm9sbGVyRWRnZSA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlckVkZ2UsXHJcbiAgICAgIGIyR3Jhdml0eUNvbnRyb2xsZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkdyYXZpdHlDb250cm9sbGVyLFxyXG4gICAgICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlcjtcclxuXHJcbiAgIEJveDJELmluaGVyaXQoYjJCdW95YW5jeUNvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XHJcbiAgIGIyQnVveWFuY3lDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcclxuICAgYjJCdW95YW5jeUNvbnRyb2xsZXIuYjJCdW95YW5jeUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5ub3JtYWwgPSBuZXcgYjJWZWMyKDAsICgtMSkpO1xyXG4gICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgIHRoaXMuZGVuc2l0eSA9IDA7XHJcbiAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgYjJWZWMyKDAsIDApO1xyXG4gICAgICB0aGlzLmxpbmVhckRyYWcgPSAyO1xyXG4gICAgICB0aGlzLmFuZ3VsYXJEcmFnID0gMTtcclxuICAgICAgdGhpcy51c2VEZW5zaXR5ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudXNlV29ybGRHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5ncmF2aXR5ID0gbnVsbDtcclxuICAgfTtcclxuICAgYjJCdW95YW5jeUNvbnRyb2xsZXIucHJvdG90eXBlLlN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICBpZiAoIXRoaXMubV9ib2R5TGlzdCkgcmV0dXJuO1xyXG4gICAgICBpZiAodGhpcy51c2VXb3JsZEdyYXZpdHkpIHtcclxuICAgICAgICAgdGhpcy5ncmF2aXR5ID0gdGhpcy5HZXRXb3JsZCgpLkdldEdyYXZpdHkoKS5Db3B5KCk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubV9ib2R5TGlzdDsgaTsgaSA9IGkubmV4dEJvZHkpIHtcclxuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XHJcbiAgICAgICAgIGlmIChib2R5LklzQXdha2UoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgYXJlYWMgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgICAgIHZhciBtYXNzYyA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgICAgdmFyIGFyZWEgPSAwLjA7XHJcbiAgICAgICAgIHZhciBtYXNzID0gMC4wO1xyXG4gICAgICAgICBmb3IgKHZhciBmaXh0dXJlID0gYm9keS5HZXRGaXh0dXJlTGlzdCgpOyBmaXh0dXJlOyBmaXh0dXJlID0gZml4dHVyZS5HZXROZXh0KCkpIHtcclxuICAgICAgICAgICAgdmFyIHNjID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICAgICAgICB2YXIgc2FyZWEgPSBmaXh0dXJlLkdldFNoYXBlKCkuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEodGhpcy5ub3JtYWwsIHRoaXMub2Zmc2V0LCBib2R5LkdldFRyYW5zZm9ybSgpLCBzYyk7XHJcbiAgICAgICAgICAgIGFyZWEgKz0gc2FyZWE7XHJcbiAgICAgICAgICAgIGFyZWFjLnggKz0gc2FyZWEgKiBzYy54O1xyXG4gICAgICAgICAgICBhcmVhYy55ICs9IHNhcmVhICogc2MueTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlRGVuc2l0eSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZURlbnNpdHkpIHtcclxuICAgICAgICAgICAgICAgc2hhcGVEZW5zaXR5ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgc2hhcGVEZW5zaXR5ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXNzICs9IHNhcmVhICogc2hhcGVEZW5zaXR5O1xyXG4gICAgICAgICAgICBtYXNzYy54ICs9IHNhcmVhICogc2MueCAqIHNoYXBlRGVuc2l0eTtcclxuICAgICAgICAgICAgbWFzc2MueSArPSBzYXJlYSAqIHNjLnkgKiBzaGFwZURlbnNpdHk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgYXJlYWMueCAvPSBhcmVhO1xyXG4gICAgICAgICBhcmVhYy55IC89IGFyZWE7XHJcbiAgICAgICAgIG1hc3NjLnggLz0gbWFzcztcclxuICAgICAgICAgbWFzc2MueSAvPSBtYXNzO1xyXG4gICAgICAgICBpZiAoYXJlYSA8IE51bWJlci5NSU5fVkFMVUUpIGNvbnRpbnVlO1xyXG4gICAgICAgICB2YXIgYnVveWFuY3lGb3JjZSA9IHRoaXMuZ3Jhdml0eS5HZXROZWdhdGl2ZSgpO1xyXG4gICAgICAgICBidW95YW5jeUZvcmNlLk11bHRpcGx5KHRoaXMuZGVuc2l0eSAqIGFyZWEpO1xyXG4gICAgICAgICBib2R5LkFwcGx5Rm9yY2UoYnVveWFuY3lGb3JjZSwgbWFzc2MpO1xyXG4gICAgICAgICB2YXIgZHJhZ0ZvcmNlID0gYm9keS5HZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KGFyZWFjKTtcclxuICAgICAgICAgZHJhZ0ZvcmNlLlN1YnRyYWN0KHRoaXMudmVsb2NpdHkpO1xyXG4gICAgICAgICBkcmFnRm9yY2UuTXVsdGlwbHkoKC10aGlzLmxpbmVhckRyYWcgKiBhcmVhKSk7XHJcbiAgICAgICAgIGJvZHkuQXBwbHlGb3JjZShkcmFnRm9yY2UsIGFyZWFjKTtcclxuICAgICAgICAgYm9keS5BcHBseVRvcnF1ZSgoLWJvZHkuR2V0SW5lcnRpYSgpIC8gYm9keS5HZXRNYXNzKCkgKiBhcmVhICogYm9keS5HZXRBbmd1bGFyVmVsb2NpdHkoKSAqIHRoaXMuYW5ndWxhckRyYWcpKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyQnVveWFuY3lDb250cm9sbGVyLnByb3RvdHlwZS5EcmF3ID0gZnVuY3Rpb24gKGRlYnVnRHJhdykge1xyXG4gICAgICB2YXIgciA9IDEwMDA7XHJcbiAgICAgIHZhciBwMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdmFyIHAyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICBwMS54ID0gdGhpcy5ub3JtYWwueCAqIHRoaXMub2Zmc2V0ICsgdGhpcy5ub3JtYWwueSAqIHI7XHJcbiAgICAgIHAxLnkgPSB0aGlzLm5vcm1hbC55ICogdGhpcy5vZmZzZXQgLSB0aGlzLm5vcm1hbC54ICogcjtcclxuICAgICAgcDIueCA9IHRoaXMubm9ybWFsLnggKiB0aGlzLm9mZnNldCAtIHRoaXMubm9ybWFsLnkgKiByO1xyXG4gICAgICBwMi55ID0gdGhpcy5ub3JtYWwueSAqIHRoaXMub2Zmc2V0ICsgdGhpcy5ub3JtYWwueCAqIHI7XHJcbiAgICAgIHZhciBjb2xvciA9IG5ldyBiMkNvbG9yKDAsIDAsIDEpO1xyXG4gICAgICBkZWJ1Z0RyYXcuRHJhd1NlZ21lbnQocDEsIHAyLCBjb2xvcik7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLCBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIpO1xyXG4gICBiMkNvbnN0YW50QWNjZWxDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcclxuICAgYjJDb25zdGFudEFjY2VsQ29udHJvbGxlci5iMkNvbnN0YW50QWNjZWxDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIuYjJDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMuQSA9IG5ldyBiMlZlYzIoMCwgMCk7XHJcbiAgIH07XHJcbiAgIGIyQ29uc3RhbnRBY2NlbENvbnRyb2xsZXIucHJvdG90eXBlLlN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgc21hbGxBID0gbmV3IGIyVmVjMih0aGlzLkEueCAqIHN0ZXAuZHQsIHRoaXMuQS55ICogc3RlcC5kdCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm1fYm9keUxpc3Q7IGk7IGkgPSBpLm5leHRCb2R5KSB7XHJcbiAgICAgICAgIHZhciBib2R5ID0gaS5ib2R5O1xyXG4gICAgICAgICBpZiAoIWJvZHkuSXNBd2FrZSgpKSBjb250aW51ZTtcclxuICAgICAgICAgYm9keS5TZXRMaW5lYXJWZWxvY2l0eShuZXcgYjJWZWMyKGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS54ICsgc21hbGxBLngsIGJvZHkuR2V0TGluZWFyVmVsb2NpdHkoKS55ICsgc21hbGxBLnkpKTtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIEJveDJELmluaGVyaXQoYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciwgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyKTtcclxuICAgYjJDb25zdGFudEZvcmNlQ29udHJvbGxlci5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5wcm90b3R5cGU7XHJcbiAgIGIyQ29uc3RhbnRGb3JjZUNvbnRyb2xsZXIuYjJDb25zdGFudEZvcmNlQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLmIyQ29udHJvbGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLkYgPSBuZXcgYjJWZWMyKDAsIDApO1xyXG4gICB9O1xyXG4gICBiMkNvbnN0YW50Rm9yY2VDb250cm9sbGVyLnByb3RvdHlwZS5TdGVwID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubV9ib2R5TGlzdDsgaTsgaSA9IGkubmV4dEJvZHkpIHtcclxuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XHJcbiAgICAgICAgIGlmICghYm9keS5Jc0F3YWtlKCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICBib2R5LkFwcGx5Rm9yY2UodGhpcy5GLCBib2R5LkdldFdvcmxkQ2VudGVyKCkpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJDb250cm9sbGVyLmIyQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLlN0ZXAgPSBmdW5jdGlvbiAoc3RlcCkge31cclxuICAgYjJDb250cm9sbGVyLnByb3RvdHlwZS5EcmF3ID0gZnVuY3Rpb24gKGRlYnVnRHJhdykge31cclxuICAgYjJDb250cm9sbGVyLnByb3RvdHlwZS5BZGRCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcclxuICAgICAgdmFyIGVkZ2UgPSBuZXcgYjJDb250cm9sbGVyRWRnZSgpO1xyXG4gICAgICBlZGdlLmNvbnRyb2xsZXIgPSB0aGlzO1xyXG4gICAgICBlZGdlLmJvZHkgPSBib2R5O1xyXG4gICAgICBlZGdlLm5leHRCb2R5ID0gdGhpcy5tX2JvZHlMaXN0O1xyXG4gICAgICBlZGdlLnByZXZCb2R5ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX2JvZHlMaXN0ID0gZWRnZTtcclxuICAgICAgaWYgKGVkZ2UubmV4dEJvZHkpIGVkZ2UubmV4dEJvZHkucHJldkJvZHkgPSBlZGdlO1xyXG4gICAgICB0aGlzLm1fYm9keUNvdW50Kys7XHJcbiAgICAgIGVkZ2UubmV4dENvbnRyb2xsZXIgPSBib2R5Lm1fY29udHJvbGxlckxpc3Q7XHJcbiAgICAgIGVkZ2UucHJldkNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgICBib2R5Lm1fY29udHJvbGxlckxpc3QgPSBlZGdlO1xyXG4gICAgICBpZiAoZWRnZS5uZXh0Q29udHJvbGxlcikgZWRnZS5uZXh0Q29udHJvbGxlci5wcmV2Q29udHJvbGxlciA9IGVkZ2U7XHJcbiAgICAgIGJvZHkubV9jb250cm9sbGVyQ291bnQrKztcclxuICAgfVxyXG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLlJlbW92ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xyXG4gICAgICB2YXIgZWRnZSA9IGJvZHkubV9jb250cm9sbGVyTGlzdDtcclxuICAgICAgd2hpbGUgKGVkZ2UgJiYgZWRnZS5jb250cm9sbGVyICE9IHRoaXMpXHJcbiAgICAgIGVkZ2UgPSBlZGdlLm5leHRDb250cm9sbGVyO1xyXG4gICAgICBpZiAoZWRnZS5wcmV2Qm9keSkgZWRnZS5wcmV2Qm9keS5uZXh0Qm9keSA9IGVkZ2UubmV4dEJvZHk7XHJcbiAgICAgIGlmIChlZGdlLm5leHRCb2R5KSBlZGdlLm5leHRCb2R5LnByZXZCb2R5ID0gZWRnZS5wcmV2Qm9keTtcclxuICAgICAgaWYgKGVkZ2UubmV4dENvbnRyb2xsZXIpIGVkZ2UubmV4dENvbnRyb2xsZXIucHJldkNvbnRyb2xsZXIgPSBlZGdlLnByZXZDb250cm9sbGVyO1xyXG4gICAgICBpZiAoZWRnZS5wcmV2Q29udHJvbGxlcikgZWRnZS5wcmV2Q29udHJvbGxlci5uZXh0Q29udHJvbGxlciA9IGVkZ2UubmV4dENvbnRyb2xsZXI7XHJcbiAgICAgIGlmICh0aGlzLm1fYm9keUxpc3QgPT0gZWRnZSkgdGhpcy5tX2JvZHlMaXN0ID0gZWRnZS5uZXh0Qm9keTtcclxuICAgICAgaWYgKGJvZHkubV9jb250cm9sbGVyTGlzdCA9PSBlZGdlKSBib2R5Lm1fY29udHJvbGxlckxpc3QgPSBlZGdlLm5leHRDb250cm9sbGVyO1xyXG4gICAgICBib2R5Lm1fY29udHJvbGxlckNvdW50LS07XHJcbiAgICAgIHRoaXMubV9ib2R5Q291bnQtLTtcclxuICAgfVxyXG4gICBiMkNvbnRyb2xsZXIucHJvdG90eXBlLkNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB3aGlsZSAodGhpcy5tX2JvZHlMaXN0KVxyXG4gICAgICB0aGlzLlJlbW92ZUJvZHkodGhpcy5tX2JvZHlMaXN0LmJvZHkpO1xyXG4gICB9XHJcbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuR2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9uZXh0O1xyXG4gICB9XHJcbiAgIGIyQ29udHJvbGxlci5wcm90b3R5cGUuR2V0V29ybGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fd29ybGQ7XHJcbiAgIH1cclxuICAgYjJDb250cm9sbGVyLnByb3RvdHlwZS5HZXRCb2R5TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5TGlzdDtcclxuICAgfVxyXG4gICBiMkNvbnRyb2xsZXJFZGdlLmIyQ29udHJvbGxlckVkZ2UgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgQm94MkQuaW5oZXJpdChiMkdyYXZpdHlDb250cm9sbGVyLCBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIpO1xyXG4gICBiMkdyYXZpdHlDb250cm9sbGVyLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuQ29udHJvbGxlcnMuYjJDb250cm9sbGVyLnByb3RvdHlwZTtcclxuICAgYjJHcmF2aXR5Q29udHJvbGxlci5iMkdyYXZpdHlDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIuYjJDb250cm9sbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMuRyA9IDE7XHJcbiAgICAgIHRoaXMuaW52U3FyID0gdHJ1ZTtcclxuICAgfTtcclxuICAgYjJHcmF2aXR5Q29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBpID0gbnVsbDtcclxuICAgICAgdmFyIGJvZHkxID0gbnVsbDtcclxuICAgICAgdmFyIHAxID0gbnVsbDtcclxuICAgICAgdmFyIG1hc3MxID0gMDtcclxuICAgICAgdmFyIGogPSBudWxsO1xyXG4gICAgICB2YXIgYm9keTIgPSBudWxsO1xyXG4gICAgICB2YXIgcDIgPSBudWxsO1xyXG4gICAgICB2YXIgZHggPSAwO1xyXG4gICAgICB2YXIgZHkgPSAwO1xyXG4gICAgICB2YXIgcjIgPSAwO1xyXG4gICAgICB2YXIgZiA9IG51bGw7XHJcbiAgICAgIGlmICh0aGlzLmludlNxcikge1xyXG4gICAgICAgICBmb3IgKGkgPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgICAgIGk7IGkgPSBpLm5leHRCb2R5KSB7XHJcbiAgICAgICAgICAgIGJvZHkxID0gaS5ib2R5O1xyXG4gICAgICAgICAgICBwMSA9IGJvZHkxLkdldFdvcmxkQ2VudGVyKCk7XHJcbiAgICAgICAgICAgIG1hc3MxID0gYm9keTEuR2V0TWFzcygpO1xyXG4gICAgICAgICAgICBmb3IgKGogPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgICAgICAgIGogIT0gaTsgaiA9IGoubmV4dEJvZHkpIHtcclxuICAgICAgICAgICAgICAgYm9keTIgPSBqLmJvZHk7XHJcbiAgICAgICAgICAgICAgIHAyID0gYm9keTIuR2V0V29ybGRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgZHggPSBwMi54IC0gcDEueDtcclxuICAgICAgICAgICAgICAgZHkgPSBwMi55IC0gcDEueTtcclxuICAgICAgICAgICAgICAgcjIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgICAgICAgaWYgKHIyIDwgTnVtYmVyLk1JTl9WQUxVRSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgIGYgPSBuZXcgYjJWZWMyKGR4LCBkeSk7XHJcbiAgICAgICAgICAgICAgIGYuTXVsdGlwbHkodGhpcy5HIC8gcjIgLyBNYXRoLnNxcnQocjIpICogbWFzczEgKiBib2R5Mi5HZXRNYXNzKCkpO1xyXG4gICAgICAgICAgICAgICBpZiAoYm9keTEuSXNBd2FrZSgpKSBib2R5MS5BcHBseUZvcmNlKGYsIHAxKTtcclxuICAgICAgICAgICAgICAgZi5NdWx0aXBseSgoLTEpKTtcclxuICAgICAgICAgICAgICAgaWYgKGJvZHkyLklzQXdha2UoKSkgYm9keTIuQXBwbHlGb3JjZShmLCBwMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICBmb3IgKGkgPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgICAgIGk7IGkgPSBpLm5leHRCb2R5KSB7XHJcbiAgICAgICAgICAgIGJvZHkxID0gaS5ib2R5O1xyXG4gICAgICAgICAgICBwMSA9IGJvZHkxLkdldFdvcmxkQ2VudGVyKCk7XHJcbiAgICAgICAgICAgIG1hc3MxID0gYm9keTEuR2V0TWFzcygpO1xyXG4gICAgICAgICAgICBmb3IgKGogPSB0aGlzLm1fYm9keUxpc3Q7XHJcbiAgICAgICAgICAgIGogIT0gaTsgaiA9IGoubmV4dEJvZHkpIHtcclxuICAgICAgICAgICAgICAgYm9keTIgPSBqLmJvZHk7XHJcbiAgICAgICAgICAgICAgIHAyID0gYm9keTIuR2V0V29ybGRDZW50ZXIoKTtcclxuICAgICAgICAgICAgICAgZHggPSBwMi54IC0gcDEueDtcclxuICAgICAgICAgICAgICAgZHkgPSBwMi55IC0gcDEueTtcclxuICAgICAgICAgICAgICAgcjIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgICAgICAgaWYgKHIyIDwgTnVtYmVyLk1JTl9WQUxVRSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgIGYgPSBuZXcgYjJWZWMyKGR4LCBkeSk7XHJcbiAgICAgICAgICAgICAgIGYuTXVsdGlwbHkodGhpcy5HIC8gcjIgKiBtYXNzMSAqIGJvZHkyLkdldE1hc3MoKSk7XHJcbiAgICAgICAgICAgICAgIGlmIChib2R5MS5Jc0F3YWtlKCkpIGJvZHkxLkFwcGx5Rm9yY2UoZiwgcDEpO1xyXG4gICAgICAgICAgICAgICBmLk11bHRpcGx5KCgtMSkpO1xyXG4gICAgICAgICAgICAgICBpZiAoYm9keTIuSXNBd2FrZSgpKSBib2R5Mi5BcHBseUZvcmNlKGYsIHAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBCb3gyRC5pbmhlcml0KGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIsIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlcik7XHJcbiAgIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Db250cm9sbGVycy5iMkNvbnRyb2xsZXIucHJvdG90eXBlO1xyXG4gICBiMlRlbnNvckRhbXBpbmdDb250cm9sbGVyLmIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkNvbnRyb2xsZXJzLmIyQ29udHJvbGxlci5iMkNvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5UID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgdGhpcy5tYXhUaW1lc3RlcCA9IDA7XHJcbiAgIH07XHJcbiAgIGIyVGVuc29yRGFtcGluZ0NvbnRyb2xsZXIucHJvdG90eXBlLlNldEF4aXNBbGlnbmVkID0gZnVuY3Rpb24gKHhEYW1waW5nLCB5RGFtcGluZykge1xyXG4gICAgICBpZiAoeERhbXBpbmcgPT09IHVuZGVmaW5lZCkgeERhbXBpbmcgPSAwO1xyXG4gICAgICBpZiAoeURhbXBpbmcgPT09IHVuZGVmaW5lZCkgeURhbXBpbmcgPSAwO1xyXG4gICAgICB0aGlzLlQuY29sMS54ID0gKC14RGFtcGluZyk7XHJcbiAgICAgIHRoaXMuVC5jb2wxLnkgPSAwO1xyXG4gICAgICB0aGlzLlQuY29sMi54ID0gMDtcclxuICAgICAgdGhpcy5ULmNvbDIueSA9ICgteURhbXBpbmcpO1xyXG4gICAgICBpZiAoeERhbXBpbmcgPiAwIHx8IHlEYW1waW5nID4gMCkge1xyXG4gICAgICAgICB0aGlzLm1heFRpbWVzdGVwID0gMSAvIE1hdGgubWF4KHhEYW1waW5nLCB5RGFtcGluZyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubWF4VGltZXN0ZXAgPSAwO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJUZW5zb3JEYW1waW5nQ29udHJvbGxlci5wcm90b3R5cGUuU3RlcCA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciB0aW1lc3RlcCA9IHN0ZXAuZHQ7XHJcbiAgICAgIGlmICh0aW1lc3RlcCA8PSBOdW1iZXIuTUlOX1ZBTFVFKSByZXR1cm47XHJcbiAgICAgIGlmICh0aW1lc3RlcCA+IHRoaXMubWF4VGltZXN0ZXAgJiYgdGhpcy5tYXhUaW1lc3RlcCA+IDApIHRpbWVzdGVwID0gdGhpcy5tYXhUaW1lc3RlcDtcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubV9ib2R5TGlzdDsgaTsgaSA9IGkubmV4dEJvZHkpIHtcclxuICAgICAgICAgdmFyIGJvZHkgPSBpLmJvZHk7XHJcbiAgICAgICAgIGlmICghYm9keS5Jc0F3YWtlKCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgdmFyIGRhbXBpbmcgPSBib2R5LkdldFdvcmxkVmVjdG9yKGIyTWF0aC5NdWxNVih0aGlzLlQsIGJvZHkuR2V0TG9jYWxWZWN0b3IoYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpKSkpO1xyXG4gICAgICAgICBib2R5LlNldExpbmVhclZlbG9jaXR5KG5ldyBiMlZlYzIoYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpLnggKyBkYW1waW5nLnggKiB0aW1lc3RlcCwgYm9keS5HZXRMaW5lYXJWZWxvY2l0eSgpLnkgKyBkYW1waW5nLnkgKiB0aW1lc3RlcCkpO1xyXG4gICAgICB9XHJcbiAgIH1cclxufSkoKTtcclxuKGZ1bmN0aW9uICgpIHtcclxuICAgdmFyIGIyQ29sb3IgPSBCb3gyRC5Db21tb24uYjJDb2xvcixcclxuICAgICAgYjJpbnRlcm5hbCA9IEJveDJELkNvbW1vbi5iMmludGVybmFsLFxyXG4gICAgICBiMlNldHRpbmdzID0gQm94MkQuQ29tbW9uLmIyU2V0dGluZ3MsXHJcbiAgICAgIGIyTWF0MjIgPSBCb3gyRC5Db21tb24uTWF0aC5iMk1hdDIyLFxyXG4gICAgICBiMk1hdDMzID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXQzMyxcclxuICAgICAgYjJNYXRoID0gQm94MkQuQ29tbW9uLk1hdGguYjJNYXRoLFxyXG4gICAgICBiMlN3ZWVwID0gQm94MkQuQ29tbW9uLk1hdGguYjJTd2VlcCxcclxuICAgICAgYjJUcmFuc2Zvcm0gPSBCb3gyRC5Db21tb24uTWF0aC5iMlRyYW5zZm9ybSxcclxuICAgICAgYjJWZWMyID0gQm94MkQuQ29tbW9uLk1hdGguYjJWZWMyLFxyXG4gICAgICBiMlZlYzMgPSBCb3gyRC5Db21tb24uTWF0aC5iMlZlYzMsXHJcbiAgICAgIGIyRGlzdGFuY2VKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkRpc3RhbmNlSm9pbnQsXHJcbiAgICAgIGIyRGlzdGFuY2VKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkRpc3RhbmNlSm9pbnREZWYsXHJcbiAgICAgIGIyRnJpY3Rpb25Kb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnQsXHJcbiAgICAgIGIyRnJpY3Rpb25Kb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkZyaWN0aW9uSm9pbnREZWYsXHJcbiAgICAgIGIyR2VhckpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyR2VhckpvaW50LFxyXG4gICAgICBiMkdlYXJKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkdlYXJKb2ludERlZixcclxuICAgICAgYjJKYWNvYmlhbiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkphY29iaWFuLFxyXG4gICAgICBiMkpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQsXHJcbiAgICAgIGIySm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZixcclxuICAgICAgYjJKb2ludEVkZ2UgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludEVkZ2UsXHJcbiAgICAgIGIyTGluZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTGluZUpvaW50LFxyXG4gICAgICBiMkxpbmVKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkxpbmVKb2ludERlZixcclxuICAgICAgYjJNb3VzZUpvaW50ID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTW91c2VKb2ludCxcclxuICAgICAgYjJNb3VzZUpvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyTW91c2VKb2ludERlZixcclxuICAgICAgYjJQcmlzbWF0aWNKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlByaXNtYXRpY0pvaW50LFxyXG4gICAgICBiMlByaXNtYXRpY0pvaW50RGVmID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHJpc21hdGljSm9pbnREZWYsXHJcbiAgICAgIGIyUHVsbGV5Sm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJQdWxsZXlKb2ludCxcclxuICAgICAgYjJQdWxsZXlKb2ludERlZiA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlB1bGxleUpvaW50RGVmLFxyXG4gICAgICBiMlJldm9sdXRlSm9pbnQgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJSZXZvbHV0ZUpvaW50LFxyXG4gICAgICBiMlJldm9sdXRlSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJSZXZvbHV0ZUpvaW50RGVmLFxyXG4gICAgICBiMldlbGRKb2ludCA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMldlbGRKb2ludCxcclxuICAgICAgYjJXZWxkSm9pbnREZWYgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJXZWxkSm9pbnREZWYsXHJcbiAgICAgIGIyQm9keSA9IEJveDJELkR5bmFtaWNzLmIyQm9keSxcclxuICAgICAgYjJCb2R5RGVmID0gQm94MkQuRHluYW1pY3MuYjJCb2R5RGVmLFxyXG4gICAgICBiMkNvbnRhY3RGaWx0ZXIgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RGaWx0ZXIsXHJcbiAgICAgIGIyQ29udGFjdEltcHVsc2UgPSBCb3gyRC5EeW5hbWljcy5iMkNvbnRhY3RJbXB1bHNlLFxyXG4gICAgICBiMkNvbnRhY3RMaXN0ZW5lciA9IEJveDJELkR5bmFtaWNzLmIyQ29udGFjdExpc3RlbmVyLFxyXG4gICAgICBiMkNvbnRhY3RNYW5hZ2VyID0gQm94MkQuRHluYW1pY3MuYjJDb250YWN0TWFuYWdlcixcclxuICAgICAgYjJEZWJ1Z0RyYXcgPSBCb3gyRC5EeW5hbWljcy5iMkRlYnVnRHJhdyxcclxuICAgICAgYjJEZXN0cnVjdGlvbkxpc3RlbmVyID0gQm94MkQuRHluYW1pY3MuYjJEZXN0cnVjdGlvbkxpc3RlbmVyLFxyXG4gICAgICBiMkZpbHRlckRhdGEgPSBCb3gyRC5EeW5hbWljcy5iMkZpbHRlckRhdGEsXHJcbiAgICAgIGIyRml4dHVyZSA9IEJveDJELkR5bmFtaWNzLmIyRml4dHVyZSxcclxuICAgICAgYjJGaXh0dXJlRGVmID0gQm94MkQuRHluYW1pY3MuYjJGaXh0dXJlRGVmLFxyXG4gICAgICBiMklzbGFuZCA9IEJveDJELkR5bmFtaWNzLmIySXNsYW5kLFxyXG4gICAgICBiMlRpbWVTdGVwID0gQm94MkQuRHluYW1pY3MuYjJUaW1lU3RlcCxcclxuICAgICAgYjJXb3JsZCA9IEJveDJELkR5bmFtaWNzLmIyV29ybGQ7XHJcblxyXG4gICBCb3gyRC5pbmhlcml0KGIyRGlzdGFuY2VKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xyXG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5iMkRpc3RhbmNlSm9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMiA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX3UgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjEpO1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV91LngsIGludl9kdCAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX3UueSk7XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gMC4wO1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2xlbmd0aDtcclxuICAgfVxyXG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLlNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSBsZW5ndGggPSAwO1xyXG4gICAgICB0aGlzLm1fbGVuZ3RoID0gbGVuZ3RoO1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0RnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2ZyZXF1ZW5jeUh6O1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU2V0RnJlcXVlbmN5ID0gZnVuY3Rpb24gKGh6KSB7XHJcbiAgICAgIGlmIChoeiA9PT0gdW5kZWZpbmVkKSBoeiA9IDA7XHJcbiAgICAgIHRoaXMubV9mcmVxdWVuY3lIeiA9IGh6O1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuR2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2RhbXBpbmdSYXRpbztcclxuICAgfVxyXG4gICBiMkRpc3RhbmNlSm9pbnQucHJvdG90eXBlLlNldERhbXBpbmdSYXRpbyA9IGZ1bmN0aW9uIChyYXRpbykge1xyXG4gICAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkgcmF0aW8gPSAwO1xyXG4gICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gcmF0aW87XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5iMkRpc3RhbmNlSm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciB0WSA9IDA7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0VihkZWYubG9jYWxBbmNob3JBKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKGRlZi5sb2NhbEFuY2hvckIpO1xyXG4gICAgICB0aGlzLm1fbGVuZ3RoID0gZGVmLmxlbmd0aDtcclxuICAgICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gZGVmLmZyZXF1ZW5jeUh6O1xyXG4gICAgICB0aGlzLm1fZGFtcGluZ1JhdGlvID0gZGVmLmRhbXBpbmdSYXRpbztcclxuICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9nYW1tYSA9IDAuMDtcclxuICAgICAgdGhpcy5tX2JpYXMgPSAwLjA7XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgdFggPSAwO1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcclxuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XHJcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcclxuICAgICAgcjFYID0gdFg7XHJcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xyXG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XHJcbiAgICAgIHIyWCA9IHRYO1xyXG4gICAgICB0aGlzLm1fdS54ID0gYkIubV9zd2VlcC5jLnggKyByMlggLSBiQS5tX3N3ZWVwLmMueCAtIHIxWDtcclxuICAgICAgdGhpcy5tX3UueSA9IGJCLm1fc3dlZXAuYy55ICsgcjJZIC0gYkEubV9zd2VlcC5jLnkgLSByMVk7XHJcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodGhpcy5tX3UueCAqIHRoaXMubV91LnggKyB0aGlzLm1fdS55ICogdGhpcy5tX3UueSk7XHJcbiAgICAgIGlmIChsZW5ndGggPiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcclxuICAgICAgICAgdGhpcy5tX3UuTXVsdGlwbHkoMS4wIC8gbGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX3UuU2V0WmVybygpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjcjF1ID0gKHIxWCAqIHRoaXMubV91LnkgLSByMVkgKiB0aGlzLm1fdS54KTtcclxuICAgICAgdmFyIGNyMnUgPSAocjJYICogdGhpcy5tX3UueSAtIHIyWSAqIHRoaXMubV91LngpO1xyXG4gICAgICB2YXIgaW52TWFzcyA9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNyMXUgKiBjcjF1ICsgYkIubV9pbnZNYXNzICsgYkIubV9pbnZJICogY3IydSAqIGNyMnU7XHJcbiAgICAgIHRoaXMubV9tYXNzID0gaW52TWFzcyAhPSAwLjAgPyAxLjAgLyBpbnZNYXNzIDogMC4wO1xyXG4gICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XHJcbiAgICAgICAgIHZhciBDID0gbGVuZ3RoIC0gdGhpcy5tX2xlbmd0aDtcclxuICAgICAgICAgdmFyIG9tZWdhID0gMi4wICogTWF0aC5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejtcclxuICAgICAgICAgdmFyIGQgPSAyLjAgKiB0aGlzLm1fbWFzcyAqIHRoaXMubV9kYW1waW5nUmF0aW8gKiBvbWVnYTtcclxuICAgICAgICAgdmFyIGsgPSB0aGlzLm1fbWFzcyAqIG9tZWdhICogb21lZ2E7XHJcbiAgICAgICAgIHRoaXMubV9nYW1tYSA9IHN0ZXAuZHQgKiAoZCArIHN0ZXAuZHQgKiBrKTtcclxuICAgICAgICAgdGhpcy5tX2dhbW1hID0gdGhpcy5tX2dhbW1hICE9IDAuMCA/IDEgLyB0aGlzLm1fZ2FtbWEgOiAwLjA7XHJcbiAgICAgICAgIHRoaXMubV9iaWFzID0gQyAqIHN0ZXAuZHQgKiBrICogdGhpcy5tX2dhbW1hO1xyXG4gICAgICAgICB0aGlzLm1fbWFzcyA9IGludk1hc3MgKyB0aGlzLm1fZ2FtbWE7XHJcbiAgICAgICAgIHRoaXMubV9tYXNzID0gdGhpcy5tX21hc3MgIT0gMC4wID8gMS4wIC8gdGhpcy5tX21hc3MgOiAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdmFyIFBYID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdS54O1xyXG4gICAgICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV91Lnk7XHJcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCAtPSBiQS5tX2ludk1hc3MgKiBQWDtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IGJBLm1faW52TWFzcyAqIFBZO1xyXG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSBiQS5tX2ludkkgKiAocjFYICogUFkgLSByMVkgKiBQWCk7XHJcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQWDtcclxuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IGJCLm1faW52TWFzcyAqIFBZO1xyXG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQi5tX2ludkkgKiAocjJYICogUFkgLSByMlkgKiBQWCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICByMVggPSB0WDtcclxuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcclxuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgcjJYID0gdFg7XHJcbiAgICAgIHZhciB2MVggPSBiQS5tX2xpbmVhclZlbG9jaXR5LnggKyAoKC1iQS5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIxWSkpO1xyXG4gICAgICB2YXIgdjFZID0gYkEubV9saW5lYXJWZWxvY2l0eS55ICsgKGJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFYKTtcclxuICAgICAgdmFyIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XHJcbiAgICAgIHZhciB2MlkgPSBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYkIubV9hbmd1bGFyVmVsb2NpdHkgKiByMlgpO1xyXG4gICAgICB2YXIgQ2RvdCA9ICh0aGlzLm1fdS54ICogKHYyWCAtIHYxWCkgKyB0aGlzLm1fdS55ICogKHYyWSAtIHYxWSkpO1xyXG4gICAgICB2YXIgaW1wdWxzZSA9ICgtdGhpcy5tX21hc3MgKiAoQ2RvdCArIHRoaXMubV9iaWFzICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX2ltcHVsc2UpKTtcclxuICAgICAgdGhpcy5tX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuICAgICAgdmFyIFBYID0gaW1wdWxzZSAqIHRoaXMubV91Lng7XHJcbiAgICAgIHZhciBQWSA9IGltcHVsc2UgKiB0aGlzLm1fdS55O1xyXG4gICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gYkEubV9pbnZNYXNzICogUFg7XHJcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSAtPSBiQS5tX2ludk1hc3MgKiBQWTtcclxuICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgLT0gYkEubV9pbnZJICogKHIxWCAqIFBZIC0gcjFZICogUFgpO1xyXG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogUFg7XHJcbiAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQi5tX2ludk1hc3MgKiBQWTtcclxuICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFBZIC0gcjJZICogUFgpO1xyXG4gICB9XHJcbiAgIGIyRGlzdGFuY2VKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xyXG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICBpZiAodGhpcy5tX2ZyZXF1ZW5jeUh6ID4gMC4wKSB7XHJcbiAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xyXG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XHJcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcclxuICAgICAgcjFYID0gdFg7XHJcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xyXG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XHJcbiAgICAgIHIyWCA9IHRYO1xyXG4gICAgICB2YXIgZFggPSBiQi5tX3N3ZWVwLmMueCArIHIyWCAtIGJBLm1fc3dlZXAuYy54IC0gcjFYO1xyXG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xyXG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcclxuICAgICAgZFggLz0gbGVuZ3RoO1xyXG4gICAgICBkWSAvPSBsZW5ndGg7XHJcbiAgICAgIHZhciBDID0gbGVuZ3RoIC0gdGhpcy5tX2xlbmd0aDtcclxuICAgICAgQyA9IGIyTWF0aC5DbGFtcChDLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIGIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbik7XHJcbiAgICAgIHZhciBpbXB1bHNlID0gKC10aGlzLm1fbWFzcyAqIEMpO1xyXG4gICAgICB0aGlzLm1fdS5TZXQoZFgsIGRZKTtcclxuICAgICAgdmFyIFBYID0gaW1wdWxzZSAqIHRoaXMubV91Lng7XHJcbiAgICAgIHZhciBQWSA9IGltcHVsc2UgKiB0aGlzLm1fdS55O1xyXG4gICAgICBiQS5tX3N3ZWVwLmMueCAtPSBiQS5tX2ludk1hc3MgKiBQWDtcclxuICAgICAgYkEubV9zd2VlcC5jLnkgLT0gYkEubV9pbnZNYXNzICogUFk7XHJcbiAgICAgIGJBLm1fc3dlZXAuYSAtPSBiQS5tX2ludkkgKiAocjFYICogUFkgLSByMVkgKiBQWCk7XHJcbiAgICAgIGJCLm1fc3dlZXAuYy54ICs9IGJCLm1faW52TWFzcyAqIFBYO1xyXG4gICAgICBiQi5tX3N3ZWVwLmMueSArPSBiQi5tX2ludk1hc3MgKiBQWTtcclxuICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBQWSAtIHIyWSAqIFBYKTtcclxuICAgICAgYkEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgcmV0dXJuIGIyTWF0aC5BYnMoQykgPCBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMkRpc3RhbmNlSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcclxuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xyXG4gICBiMkRpc3RhbmNlSm9pbnREZWYuYjJEaXN0YW5jZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5iMkRpc3RhbmNlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50RGVmLmNhbGwodGhpcyk7XHJcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV9kaXN0YW5jZUpvaW50O1xyXG4gICAgICB0aGlzLmxlbmd0aCA9IDEuMDtcclxuICAgICAgdGhpcy5mcmVxdWVuY3lIeiA9IDAuMDtcclxuICAgICAgdGhpcy5kYW1waW5nUmF0aW8gPSAwLjA7XHJcbiAgIH1cclxuICAgYjJEaXN0YW5jZUpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yQSwgYW5jaG9yQikge1xyXG4gICAgICB0aGlzLmJvZHlBID0gYkE7XHJcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEuU2V0Vih0aGlzLmJvZHlBLkdldExvY2FsUG9pbnQoYW5jaG9yQSkpO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQi5TZXRWKHRoaXMuYm9keUIuR2V0TG9jYWxQb2ludChhbmNob3JCKSk7XHJcbiAgICAgIHZhciBkWCA9IGFuY2hvckIueCAtIGFuY2hvckEueDtcclxuICAgICAgdmFyIGRZID0gYW5jaG9yQi55IC0gYW5jaG9yQS55O1xyXG4gICAgICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XHJcbiAgICAgIHRoaXMuZnJlcXVlbmN5SHogPSAwLjA7XHJcbiAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gMC4wO1xyXG4gICB9XHJcbiAgIEJveDJELmluaGVyaXQoYjJGcmljdGlvbkpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XHJcbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LnByb3RvdHlwZTtcclxuICAgYjJGcmljdGlvbkpvaW50LmIyRnJpY3Rpb25Kb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbGluZWFyTWFzcyA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JBKTtcclxuICAgfVxyXG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3JCKTtcclxuICAgfVxyXG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2xpbmVhckltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2xpbmVhckltcHVsc2UueSk7XHJcbiAgIH1cclxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xyXG4gICB9XHJcbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuU2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgaWYgKGZvcmNlID09PSB1bmRlZmluZWQpIGZvcmNlID0gMDtcclxuICAgICAgdGhpcy5tX21heEZvcmNlID0gZm9yY2U7XHJcbiAgIH1cclxuICAgYjJGcmljdGlvbkpvaW50LnByb3RvdHlwZS5HZXRNYXhGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9tYXhGb3JjZTtcclxuICAgfVxyXG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLlNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcclxuICAgICAgaWYgKHRvcnF1ZSA9PT0gdW5kZWZpbmVkKSB0b3JxdWUgPSAwO1xyXG4gICAgICB0aGlzLm1fbWF4VG9ycXVlID0gdG9ycXVlO1xyXG4gICB9XHJcbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuR2V0TWF4VG9ycXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX21heFRvcnF1ZTtcclxuICAgfVxyXG4gICBiMkZyaWN0aW9uSm9pbnQucHJvdG90eXBlLmIyRnJpY3Rpb25Kb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcclxuICAgICAgdGhpcy5tX2xpbmVhck1hc3MuU2V0WmVybygpO1xyXG4gICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLlNldFplcm8oKTtcclxuICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlID0gMC4wO1xyXG4gICAgICB0aGlzLm1fbWF4Rm9yY2UgPSBkZWYubWF4Rm9yY2U7XHJcbiAgICAgIHRoaXMubV9tYXhUb3JxdWUgPSBkZWYubWF4VG9ycXVlO1xyXG4gICB9XHJcbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByQVkgPSB0aGlzLm1fbG9jYWxBbmNob3JBLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckFYICsgdE1hdC5jb2wyLnggKiByQVkpO1xyXG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XHJcbiAgICAgIHJBWCA9IHRYO1xyXG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgckJZID0gdGhpcy5tX2xvY2FsQW5jaG9yQi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJCWCArIHRNYXQuY29sMi54ICogckJZKTtcclxuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xyXG4gICAgICByQlggPSB0WDtcclxuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgbUIgPSBiQi5tX2ludk1hc3M7XHJcbiAgICAgIHZhciBpQSA9IGJBLm1faW52STtcclxuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xyXG4gICAgICB2YXIgSyA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgICAgIEsuY29sMS54ID0gbUEgKyBtQjtcclxuICAgICAgSy5jb2wyLnggPSAwLjA7XHJcbiAgICAgIEsuY29sMS55ID0gMC4wO1xyXG4gICAgICBLLmNvbDIueSA9IG1BICsgbUI7XHJcbiAgICAgIEsuY29sMS54ICs9IGlBICogckFZICogckFZO1xyXG4gICAgICBLLmNvbDIueCArPSAoLWlBICogckFYICogckFZKTtcclxuICAgICAgSy5jb2wxLnkgKz0gKC1pQSAqIHJBWCAqIHJBWSk7XHJcbiAgICAgIEsuY29sMi55ICs9IGlBICogckFYICogckFYO1xyXG4gICAgICBLLmNvbDEueCArPSBpQiAqIHJCWSAqIHJCWTtcclxuICAgICAgSy5jb2wyLnggKz0gKC1pQiAqIHJCWCAqIHJCWSk7XHJcbiAgICAgIEsuY29sMS55ICs9ICgtaUIgKiByQlggKiByQlkpO1xyXG4gICAgICBLLmNvbDIueSArPSBpQiAqIHJCWCAqIHJCWDtcclxuICAgICAgSy5HZXRJbnZlcnNlKHRoaXMubV9saW5lYXJNYXNzKTtcclxuICAgICAgdGhpcy5tX2FuZ3VsYXJNYXNzID0gaUEgKyBpQjtcclxuICAgICAgaWYgKHRoaXMubV9hbmd1bGFyTWFzcyA+IDAuMCkge1xyXG4gICAgICAgICB0aGlzLm1fYW5ndWxhck1hc3MgPSAxLjAgLyB0aGlzLm1fYW5ndWxhck1hc3M7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XHJcbiAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLnggKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdGhpcy5tX2FuZ3VsYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdmFyIFAgPSB0aGlzLm1fbGluZWFySW1wdWxzZTtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IG1BICogUC54O1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbUEgKiBQLnk7XHJcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IGlBICogKHJBWCAqIFAueSAtIHJBWSAqIFAueCArIHRoaXMubV9hbmd1bGFySW1wdWxzZSk7XHJcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBtQiAqIFAueDtcclxuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG1CICogUC55O1xyXG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBpQiAqIChyQlggKiBQLnkgLSByQlkgKiBQLnggKyB0aGlzLm1fYW5ndWxhckltcHVsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IDAuMDtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdkEgPSBiQS5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgd0EgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHdCID0gYkIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciBtQSA9IGJBLm1faW52TWFzcztcclxuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgaUEgPSBiQS5tX2ludkk7XHJcbiAgICAgIHZhciBpQiA9IGJCLm1faW52STtcclxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcclxuICAgICAgdmFyIHJBWCA9IHRoaXMubV9sb2NhbEFuY2hvckEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHJBWSA9IHRoaXMubV9sb2NhbEFuY2hvckEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XHJcbiAgICAgIHJBWSA9ICh0TWF0LmNvbDEueSAqIHJBWCArIHRNYXQuY29sMi55ICogckFZKTtcclxuICAgICAgckFYID0gdFg7XHJcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgIHZhciByQlggPSB0aGlzLm1fbG9jYWxBbmNob3JCLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByQlkgPSB0aGlzLm1fbG9jYWxBbmNob3JCLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xyXG4gICAgICByQlkgPSAodE1hdC5jb2wxLnkgKiByQlggKyB0TWF0LmNvbDIueSAqIHJCWSk7XHJcbiAgICAgIHJCWCA9IHRYO1xyXG4gICAgICB2YXIgbWF4SW1wdWxzZSA9IDA7IHtcclxuICAgICAgICAgdmFyIENkb3QgPSB3QiAtIHdBO1xyXG4gICAgICAgICB2YXIgaW1wdWxzZSA9ICgtdGhpcy5tX2FuZ3VsYXJNYXNzICogQ2RvdCk7XHJcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX2FuZ3VsYXJJbXB1bHNlO1xyXG4gICAgICAgICBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhUb3JxdWU7XHJcbiAgICAgICAgIHRoaXMubV9hbmd1bGFySW1wdWxzZSA9IGIyTWF0aC5DbGFtcCh0aGlzLm1fYW5ndWxhckltcHVsc2UgKyBpbXB1bHNlLCAoLW1heEltcHVsc2UpLCBtYXhJbXB1bHNlKTtcclxuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcbiAgICAgICAgIHdBIC09IGlBICogaW1wdWxzZTtcclxuICAgICAgICAgd0IgKz0gaUIgKiBpbXB1bHNlO1xyXG4gICAgICB9IHtcclxuICAgICAgICAgdmFyIENkb3RYID0gdkIueCAtIHdCICogckJZIC0gdkEueCArIHdBICogckFZO1xyXG4gICAgICAgICB2YXIgQ2RvdFkgPSB2Qi55ICsgd0IgKiByQlggLSB2QS55IC0gd0EgKiByQVg7XHJcbiAgICAgICAgIHZhciBpbXB1bHNlViA9IGIyTWF0aC5NdWxNVih0aGlzLm1fbGluZWFyTWFzcywgbmV3IGIyVmVjMigoLUNkb3RYKSwgKC1DZG90WSkpKTtcclxuICAgICAgICAgdmFyIG9sZEltcHVsc2VWID0gdGhpcy5tX2xpbmVhckltcHVsc2UuQ29weSgpO1xyXG4gICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5BZGQoaW1wdWxzZVYpO1xyXG4gICAgICAgICBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhGb3JjZTtcclxuICAgICAgICAgaWYgKHRoaXMubV9saW5lYXJJbXB1bHNlLkxlbmd0aFNxdWFyZWQoKSA+IG1heEltcHVsc2UgKiBtYXhJbXB1bHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9saW5lYXJJbXB1bHNlLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1fbGluZWFySW1wdWxzZS5NdWx0aXBseShtYXhJbXB1bHNlKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpbXB1bHNlViA9IGIyTWF0aC5TdWJ0cmFjdFZWKHRoaXMubV9saW5lYXJJbXB1bHNlLCBvbGRJbXB1bHNlVik7XHJcbiAgICAgICAgIHZBLnggLT0gbUEgKiBpbXB1bHNlVi54O1xyXG4gICAgICAgICB2QS55IC09IG1BICogaW1wdWxzZVYueTtcclxuICAgICAgICAgd0EgLT0gaUEgKiAockFYICogaW1wdWxzZVYueSAtIHJBWSAqIGltcHVsc2VWLngpO1xyXG4gICAgICAgICB2Qi54ICs9IG1CICogaW1wdWxzZVYueDtcclxuICAgICAgICAgdkIueSArPSBtQiAqIGltcHVsc2VWLnk7XHJcbiAgICAgICAgIHdCICs9IGlCICogKHJCWCAqIGltcHVsc2VWLnkgLSByQlkgKiBpbXB1bHNlVi54KTtcclxuICAgICAgfVxyXG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdBO1xyXG4gICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHdCO1xyXG4gICB9XHJcbiAgIGIyRnJpY3Rpb25Kb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xyXG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICB9XHJcbiAgIEJveDJELmluaGVyaXQoYjJGcmljdGlvbkpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XHJcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcclxuICAgYjJGcmljdGlvbkpvaW50RGVmLmIyRnJpY3Rpb25Kb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyRnJpY3Rpb25Kb2ludERlZi5wcm90b3R5cGUuYjJGcmljdGlvbkpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfZnJpY3Rpb25Kb2ludDtcclxuICAgICAgdGhpcy5tYXhGb3JjZSA9IDAuMDtcclxuICAgICAgdGhpcy5tYXhUb3JxdWUgPSAwLjA7XHJcbiAgIH1cclxuICAgYjJGcmljdGlvbkpvaW50RGVmLnByb3RvdHlwZS5Jbml0aWFsaXplID0gZnVuY3Rpb24gKGJBLCBiQiwgYW5jaG9yKSB7XHJcbiAgICAgIHRoaXMuYm9keUEgPSBiQTtcclxuICAgICAgdGhpcy5ib2R5QiA9IGJCO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQS5TZXRWKHRoaXMuYm9keUEuR2V0TG9jYWxQb2ludChhbmNob3IpKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckIuU2V0Vih0aGlzLmJvZHlCLkdldExvY2FsUG9pbnQoYW5jaG9yKSk7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMkdlYXJKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xyXG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LnByb3RvdHlwZTtcclxuICAgYjJHZWFySm9pbnQuYjJHZWFySm9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fSiA9IG5ldyBiMkphY29iaWFuKCk7XHJcbiAgIH07XHJcbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgIH1cclxuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcclxuICAgfVxyXG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLnkpO1xyXG4gICB9XHJcbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICB2YXIgdE1hdCA9IHRoaXMubV9ib2R5Qi5tX3hmLlI7XHJcbiAgICAgIHZhciByWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIHRoaXMubV9ib2R5Qi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHZhciB0WCA9IHRNYXQuY29sMS54ICogclggKyB0TWF0LmNvbDIueCAqIHJZO1xyXG4gICAgICByWSA9IHRNYXQuY29sMS55ICogclggKyB0TWF0LmNvbDIueSAqIHJZO1xyXG4gICAgICByWCA9IHRYO1xyXG4gICAgICB2YXIgUFggPSB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueDtcclxuICAgICAgdmFyIFBZID0gdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLnk7XHJcbiAgICAgIHJldHVybiBpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5hbmd1bGFyQiAtIHJYICogUFkgKyByWSAqIFBYKTtcclxuICAgfVxyXG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuR2V0UmF0aW8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fcmF0aW87XHJcbiAgIH1cclxuICAgYjJHZWFySm9pbnQucHJvdG90eXBlLlNldFJhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XHJcbiAgICAgIGlmIChyYXRpbyA9PT0gdW5kZWZpbmVkKSByYXRpbyA9IDA7XHJcbiAgICAgIHRoaXMubV9yYXRpbyA9IHJhdGlvO1xyXG4gICB9XHJcbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5iMkdlYXJKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xyXG4gICAgICB2YXIgdHlwZTEgPSBwYXJzZUludChkZWYuam9pbnQxLm1fdHlwZSk7XHJcbiAgICAgIHZhciB0eXBlMiA9IHBhcnNlSW50KGRlZi5qb2ludDIubV90eXBlKTtcclxuICAgICAgdGhpcy5tX3Jldm9sdXRlMSA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9wcmlzbWF0aWMxID0gbnVsbDtcclxuICAgICAgdGhpcy5tX3Jldm9sdXRlMiA9IG51bGw7XHJcbiAgICAgIHRoaXMubV9wcmlzbWF0aWMyID0gbnVsbDtcclxuICAgICAgdmFyIGNvb3JkaW5hdGUxID0gMDtcclxuICAgICAgdmFyIGNvb3JkaW5hdGUyID0gMDtcclxuICAgICAgdGhpcy5tX2dyb3VuZDEgPSBkZWYuam9pbnQxLkdldEJvZHlBKCk7XHJcbiAgICAgIHRoaXMubV9ib2R5QSA9IGRlZi5qb2ludDEuR2V0Qm9keUIoKTtcclxuICAgICAgaWYgKHR5cGUxID09IGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50KSB7XHJcbiAgICAgICAgIHRoaXMubV9yZXZvbHV0ZTEgPSAoZGVmLmpvaW50MSBpbnN0YW5jZW9mIGIyUmV2b2x1dGVKb2ludCA/IGRlZi5qb2ludDEgOiBudWxsKTtcclxuICAgICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjEuU2V0Vih0aGlzLm1fcmV2b2x1dGUxLm1fbG9jYWxBbmNob3IxKTtcclxuICAgICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKHRoaXMubV9yZXZvbHV0ZTEubV9sb2NhbEFuY2hvcjIpO1xyXG4gICAgICAgICBjb29yZGluYXRlMSA9IHRoaXMubV9yZXZvbHV0ZTEuR2V0Sm9pbnRBbmdsZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1fcHJpc21hdGljMSA9IChkZWYuam9pbnQxIGluc3RhbmNlb2YgYjJQcmlzbWF0aWNKb2ludCA/IGRlZi5qb2ludDEgOiBudWxsKTtcclxuICAgICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjEuU2V0Vih0aGlzLm1fcHJpc21hdGljMS5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0Vih0aGlzLm1fcHJpc21hdGljMS5tX2xvY2FsQW5jaG9yMik7XHJcbiAgICAgICAgIGNvb3JkaW5hdGUxID0gdGhpcy5tX3ByaXNtYXRpYzEuR2V0Sm9pbnRUcmFuc2xhdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubV9ncm91bmQyID0gZGVmLmpvaW50Mi5HZXRCb2R5QSgpO1xyXG4gICAgICB0aGlzLm1fYm9keUIgPSBkZWYuam9pbnQyLkdldEJvZHlCKCk7XHJcbiAgICAgIGlmICh0eXBlMiA9PSBiMkpvaW50LmVfcmV2b2x1dGVKb2ludCkge1xyXG4gICAgICAgICB0aGlzLm1fcmV2b2x1dGUyID0gKGRlZi5qb2ludDIgaW5zdGFuY2VvZiBiMlJldm9sdXRlSm9pbnQgPyBkZWYuam9pbnQyIDogbnVsbCk7XHJcbiAgICAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyLlNldFYodGhpcy5tX3Jldm9sdXRlMi5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgICAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0Vih0aGlzLm1fcmV2b2x1dGUyLm1fbG9jYWxBbmNob3IyKTtcclxuICAgICAgICAgY29vcmRpbmF0ZTIgPSB0aGlzLm1fcmV2b2x1dGUyLkdldEpvaW50QW5nbGUoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX3ByaXNtYXRpYzIgPSAoZGVmLmpvaW50MiBpbnN0YW5jZW9mIGIyUHJpc21hdGljSm9pbnQgPyBkZWYuam9pbnQyIDogbnVsbCk7XHJcbiAgICAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyLlNldFYodGhpcy5tX3ByaXNtYXRpYzIubV9sb2NhbEFuY2hvcjEpO1xyXG4gICAgICAgICB0aGlzLm1fbG9jYWxBbmNob3IyLlNldFYodGhpcy5tX3ByaXNtYXRpYzIubV9sb2NhbEFuY2hvcjIpO1xyXG4gICAgICAgICBjb29yZGluYXRlMiA9IHRoaXMubV9wcmlzbWF0aWMyLkdldEpvaW50VHJhbnNsYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fcmF0aW8gPSBkZWYucmF0aW87XHJcbiAgICAgIHRoaXMubV9jb25zdGFudCA9IGNvb3JkaW5hdGUxICsgdGhpcy5tX3JhdGlvICogY29vcmRpbmF0ZTI7XHJcbiAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xyXG4gICB9XHJcbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBnMSA9IHRoaXMubV9ncm91bmQxO1xyXG4gICAgICB2YXIgZzIgPSB0aGlzLm1fZ3JvdW5kMjtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHZhciB1Z1ggPSAwO1xyXG4gICAgICB2YXIgdWdZID0gMDtcclxuICAgICAgdmFyIHJYID0gMDtcclxuICAgICAgdmFyIHJZID0gMDtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0VmVjO1xyXG4gICAgICB2YXIgY3J1ZyA9IDA7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciBLID0gMC4wO1xyXG4gICAgICB0aGlzLm1fSi5TZXRaZXJvKCk7XHJcbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUxKSB7XHJcbiAgICAgICAgIHRoaXMubV9KLmFuZ3VsYXJBID0gKC0xLjApO1xyXG4gICAgICAgICBLICs9IGJBLm1faW52STtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdE1hdCA9IGcxLm1feGYuUjtcclxuICAgICAgICAgdFZlYyA9IHRoaXMubV9wcmlzbWF0aWMxLm1fbG9jYWxYQXhpczE7XHJcbiAgICAgICAgIHVnWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgIHVnWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgICAgIHJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICAgICByWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSB0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWTtcclxuICAgICAgICAgclkgPSB0TWF0LmNvbDEueSAqIHJYICsgdE1hdC5jb2wyLnkgKiByWTtcclxuICAgICAgICAgclggPSB0WDtcclxuICAgICAgICAgY3J1ZyA9IHJYICogdWdZIC0gclkgKiB1Z1g7XHJcbiAgICAgICAgIHRoaXMubV9KLmxpbmVhckEuU2V0KCgtdWdYKSwgKC11Z1kpKTtcclxuICAgICAgICAgdGhpcy5tX0ouYW5ndWxhckEgPSAoLWNydWcpO1xyXG4gICAgICAgICBLICs9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNydWcgKiBjcnVnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm1fcmV2b2x1dGUyKSB7XHJcbiAgICAgICAgIHRoaXMubV9KLmFuZ3VsYXJCID0gKC10aGlzLm1fcmF0aW8pO1xyXG4gICAgICAgICBLICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqIGJCLm1faW52STtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdE1hdCA9IGcyLm1feGYuUjtcclxuICAgICAgICAgdFZlYyA9IHRoaXMubV9wcmlzbWF0aWMyLm1fbG9jYWxYQXhpczE7XHJcbiAgICAgICAgIHVnWCA9IHRNYXQuY29sMS54ICogdFZlYy54ICsgdE1hdC5jb2wyLnggKiB0VmVjLnk7XHJcbiAgICAgICAgIHVnWSA9IHRNYXQuY29sMS55ICogdFZlYy54ICsgdE1hdC5jb2wyLnkgKiB0VmVjLnk7XHJcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgICAgIHJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICAgICByWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSB0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWTtcclxuICAgICAgICAgclkgPSB0TWF0LmNvbDEueSAqIHJYICsgdE1hdC5jb2wyLnkgKiByWTtcclxuICAgICAgICAgclggPSB0WDtcclxuICAgICAgICAgY3J1ZyA9IHJYICogdWdZIC0gclkgKiB1Z1g7XHJcbiAgICAgICAgIHRoaXMubV9KLmxpbmVhckIuU2V0KCgtdGhpcy5tX3JhdGlvICogdWdYKSwgKC10aGlzLm1fcmF0aW8gKiB1Z1kpKTtcclxuICAgICAgICAgdGhpcy5tX0ouYW5ndWxhckIgPSAoLXRoaXMubV9yYXRpbyAqIGNydWcpO1xyXG4gICAgICAgICBLICs9IHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqIChiQi5tX2ludk1hc3MgKyBiQi5tX2ludkkgKiBjcnVnICogY3J1Zyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX21hc3MgPSBLID4gMC4wID8gMS4wIC8gSyA6IDAuMDtcclxuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XHJcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckEueDtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55ICs9IGJBLm1faW52TWFzcyAqIHRoaXMubV9pbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS55O1xyXG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQS5tX2ludkkgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJBO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJCLng7XHJcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQi5tX2ludk1hc3MgKiB0aGlzLm1faW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcclxuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fSi5hbmd1bGFyQjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkdlYXJKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHZhciBDZG90ID0gdGhpcy5tX0ouQ29tcHV0ZShiQS5tX2xpbmVhclZlbG9jaXR5LCBiQS5tX2FuZ3VsYXJWZWxvY2l0eSwgYkIubV9saW5lYXJWZWxvY2l0eSwgYkIubV9hbmd1bGFyVmVsb2NpdHkpO1xyXG4gICAgICB2YXIgaW1wdWxzZSA9ICgtdGhpcy5tX21hc3MgKiBDZG90KTtcclxuICAgICAgdGhpcy5tX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54ICs9IGJBLm1faW52TWFzcyAqIGltcHVsc2UgKiB0aGlzLm1fSi5saW5lYXJBLng7XHJcbiAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS55O1xyXG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQS5tX2ludkkgKiBpbXB1bHNlICogdGhpcy5tX0ouYW5ndWxhckE7XHJcbiAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQi54O1xyXG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogaW1wdWxzZSAqIHRoaXMubV9KLmxpbmVhckIueTtcclxuICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogaW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJCO1xyXG4gICB9XHJcbiAgIGIyR2VhckpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XHJcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcclxuICAgICAgdmFyIGxpbmVhckVycm9yID0gMC4wO1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIGNvb3JkaW5hdGUxID0gMDtcclxuICAgICAgdmFyIGNvb3JkaW5hdGUyID0gMDtcclxuICAgICAgaWYgKHRoaXMubV9yZXZvbHV0ZTEpIHtcclxuICAgICAgICAgY29vcmRpbmF0ZTEgPSB0aGlzLm1fcmV2b2x1dGUxLkdldEpvaW50QW5nbGUoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgY29vcmRpbmF0ZTEgPSB0aGlzLm1fcHJpc21hdGljMS5HZXRKb2ludFRyYW5zbGF0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9yZXZvbHV0ZTIpIHtcclxuICAgICAgICAgY29vcmRpbmF0ZTIgPSB0aGlzLm1fcmV2b2x1dGUyLkdldEpvaW50QW5nbGUoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgY29vcmRpbmF0ZTIgPSB0aGlzLm1fcHJpc21hdGljMi5HZXRKb2ludFRyYW5zbGF0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIEMgPSB0aGlzLm1fY29uc3RhbnQgLSAoY29vcmRpbmF0ZTEgKyB0aGlzLm1fcmF0aW8gKiBjb29yZGluYXRlMik7XHJcbiAgICAgIHZhciBpbXB1bHNlID0gKC10aGlzLm1fbWFzcyAqIEMpO1xyXG4gICAgICBiQS5tX3N3ZWVwLmMueCArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS54O1xyXG4gICAgICBiQS5tX3N3ZWVwLmMueSArPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQS55O1xyXG4gICAgICBiQS5tX3N3ZWVwLmEgKz0gYkEubV9pbnZJICogaW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJBO1xyXG4gICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQi54O1xyXG4gICAgICBiQi5tX3N3ZWVwLmMueSArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlICogdGhpcy5tX0oubGluZWFyQi55O1xyXG4gICAgICBiQi5tX3N3ZWVwLmEgKz0gYkIubV9pbnZJICogaW1wdWxzZSAqIHRoaXMubV9KLmFuZ3VsYXJCO1xyXG4gICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICByZXR1cm4gbGluZWFyRXJyb3IgPCBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3A7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMkdlYXJKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xyXG4gICBiMkdlYXJKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcclxuICAgYjJHZWFySm9pbnREZWYuYjJHZWFySm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgfTtcclxuICAgYjJHZWFySm9pbnREZWYucHJvdG90eXBlLmIyR2VhckpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfZ2VhckpvaW50O1xyXG4gICAgICB0aGlzLmpvaW50MSA9IG51bGw7XHJcbiAgICAgIHRoaXMuam9pbnQyID0gbnVsbDtcclxuICAgICAgdGhpcy5yYXRpbyA9IDEuMDtcclxuICAgfVxyXG4gICBiMkphY29iaWFuLmIySmFjb2JpYW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubGluZWFyQSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5saW5lYXJCID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMkphY29iaWFuLnByb3RvdHlwZS5TZXRaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmxpbmVhckEuU2V0WmVybygpO1xyXG4gICAgICB0aGlzLmFuZ3VsYXJBID0gMC4wO1xyXG4gICAgICB0aGlzLmxpbmVhckIuU2V0WmVybygpO1xyXG4gICAgICB0aGlzLmFuZ3VsYXJCID0gMC4wO1xyXG4gICB9XHJcbiAgIGIySmFjb2JpYW4ucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4MSwgYTEsIHgyLCBhMikge1xyXG4gICAgICBpZiAoYTEgPT09IHVuZGVmaW5lZCkgYTEgPSAwO1xyXG4gICAgICBpZiAoYTIgPT09IHVuZGVmaW5lZCkgYTIgPSAwO1xyXG4gICAgICB0aGlzLmxpbmVhckEuU2V0Vih4MSk7XHJcbiAgICAgIHRoaXMuYW5ndWxhckEgPSBhMTtcclxuICAgICAgdGhpcy5saW5lYXJCLlNldFYoeDIpO1xyXG4gICAgICB0aGlzLmFuZ3VsYXJCID0gYTI7XHJcbiAgIH1cclxuICAgYjJKYWNvYmlhbi5wcm90b3R5cGUuQ29tcHV0ZSA9IGZ1bmN0aW9uICh4MSwgYTEsIHgyLCBhMikge1xyXG4gICAgICBpZiAoYTEgPT09IHVuZGVmaW5lZCkgYTEgPSAwO1xyXG4gICAgICBpZiAoYTIgPT09IHVuZGVmaW5lZCkgYTIgPSAwO1xyXG4gICAgICByZXR1cm4gKHRoaXMubGluZWFyQS54ICogeDEueCArIHRoaXMubGluZWFyQS55ICogeDEueSkgKyB0aGlzLmFuZ3VsYXJBICogYTEgKyAodGhpcy5saW5lYXJCLnggKiB4Mi54ICsgdGhpcy5saW5lYXJCLnkgKiB4Mi55KSArIHRoaXMuYW5ndWxhckIgKiBhMjtcclxuICAgfVxyXG4gICBiMkpvaW50LmIySm9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubV9lZGdlQSA9IG5ldyBiMkpvaW50RWRnZSgpO1xyXG4gICAgICB0aGlzLm1fZWRnZUIgPSBuZXcgYjJKb2ludEVkZ2UoKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQiA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJKb2ludC5wcm90b3R5cGUuR2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV90eXBlO1xyXG4gICB9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICB9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICB9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgIH1cclxuICAgYjJKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIDAuMDtcclxuICAgfVxyXG4gICBiMkpvaW50LnByb3RvdHlwZS5HZXRCb2R5QSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QTtcclxuICAgfVxyXG4gICBiMkpvaW50LnByb3RvdHlwZS5HZXRCb2R5QiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QjtcclxuICAgfVxyXG4gICBiMkpvaW50LnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX25leHQ7XHJcbiAgIH1cclxuICAgYjJKb2ludC5wcm90b3R5cGUuR2V0VXNlckRhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fdXNlckRhdGE7XHJcbiAgIH1cclxuICAgYjJKb2ludC5wcm90b3R5cGUuU2V0VXNlckRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICB0aGlzLm1fdXNlckRhdGEgPSBkYXRhO1xyXG4gICB9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLklzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLklzQWN0aXZlKCkgJiYgdGhpcy5tX2JvZHlCLklzQWN0aXZlKCk7XHJcbiAgIH1cclxuICAgYjJKb2ludC5DcmVhdGUgPSBmdW5jdGlvbiAoZGVmLCBhbGxvY2F0b3IpIHtcclxuICAgICAgdmFyIGpvaW50ID0gbnVsbDtcclxuICAgICAgc3dpdGNoIChkZWYudHlwZSkge1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9kaXN0YW5jZUpvaW50OlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyRGlzdGFuY2VKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJEaXN0YW5jZUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9tb3VzZUpvaW50OlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyTW91c2VKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJNb3VzZUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9wcmlzbWF0aWNKb2ludDpcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMlByaXNtYXRpY0pvaW50KChkZWYgaW5zdGFuY2VvZiBiMlByaXNtYXRpY0pvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9yZXZvbHV0ZUpvaW50OlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyUmV2b2x1dGVKb2ludCgoZGVmIGluc3RhbmNlb2YgYjJSZXZvbHV0ZUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9wdWxsZXlKb2ludDpcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICBqb2ludCA9IG5ldyBiMlB1bGxleUpvaW50KChkZWYgaW5zdGFuY2VvZiBiMlB1bGxleUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9nZWFySm9pbnQ6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJHZWFySm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyR2VhckpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9saW5lSm9pbnQ6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJMaW5lSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyTGluZUpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV93ZWxkSm9pbnQ6XHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgam9pbnQgPSBuZXcgYjJXZWxkSm9pbnQoKGRlZiBpbnN0YW5jZW9mIGIyV2VsZEpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIGIySm9pbnQuZV9mcmljdGlvbkpvaW50OlxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIGpvaW50ID0gbmV3IGIyRnJpY3Rpb25Kb2ludCgoZGVmIGluc3RhbmNlb2YgYjJGcmljdGlvbkpvaW50RGVmID8gZGVmIDogbnVsbCkpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gam9pbnQ7XHJcbiAgIH1cclxuICAgYjJKb2ludC5EZXN0cm95ID0gZnVuY3Rpb24gKGpvaW50LCBhbGxvY2F0b3IpIHt9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLmIySm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgIGIyU2V0dGluZ3MuYjJBc3NlcnQoZGVmLmJvZHlBICE9IGRlZi5ib2R5Qik7XHJcbiAgICAgIHRoaXMubV90eXBlID0gZGVmLnR5cGU7XHJcbiAgICAgIHRoaXMubV9wcmV2ID0gbnVsbDtcclxuICAgICAgdGhpcy5tX25leHQgPSBudWxsO1xyXG4gICAgICB0aGlzLm1fYm9keUEgPSBkZWYuYm9keUE7XHJcbiAgICAgIHRoaXMubV9ib2R5QiA9IGRlZi5ib2R5QjtcclxuICAgICAgdGhpcy5tX2NvbGxpZGVDb25uZWN0ZWQgPSBkZWYuY29sbGlkZUNvbm5lY3RlZDtcclxuICAgICAgdGhpcy5tX2lzbGFuZEZsYWcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5tX3VzZXJEYXRhID0gZGVmLnVzZXJEYXRhO1xyXG4gICB9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHt9XHJcbiAgIGIySm9pbnQucHJvdG90eXBlLlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7fVxyXG4gICBiMkpvaW50LnByb3RvdHlwZS5GaW5hbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7fVxyXG4gICBiMkpvaW50LnByb3RvdHlwZS5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoYmF1bWdhcnRlKSB7XHJcbiAgICAgIGlmIChiYXVtZ2FydGUgPT09IHVuZGVmaW5lZCkgYmF1bWdhcnRlID0gMDtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICB9XHJcbiAgIEJveDJELnBvc3REZWZzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX3Vua25vd25Kb2ludCA9IDA7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmVfcmV2b2x1dGVKb2ludCA9IDE7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmVfcHJpc21hdGljSm9pbnQgPSAyO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2Rpc3RhbmNlSm9pbnQgPSAzO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX3B1bGxleUpvaW50ID0gNDtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9tb3VzZUpvaW50ID0gNTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9nZWFySm9pbnQgPSA2O1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2xpbmVKb2ludCA9IDc7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmVfd2VsZEpvaW50ID0gODtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9mcmljdGlvbkpvaW50ID0gOTtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0ID0gMDtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuZV9hdExvd2VyTGltaXQgPSAxO1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5lX2F0VXBwZXJMaW1pdCA9IDI7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmVfZXF1YWxMaW1pdHMgPSAzO1xyXG4gICB9KTtcclxuICAgYjJKb2ludERlZi5iMkpvaW50RGVmID0gZnVuY3Rpb24gKCkge307XHJcbiAgIGIySm9pbnREZWYucHJvdG90eXBlLmIySm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMudHlwZSA9IGIySm9pbnQuZV91bmtub3duSm9pbnQ7XHJcbiAgICAgIHRoaXMudXNlckRhdGEgPSBudWxsO1xyXG4gICAgICB0aGlzLmJvZHlBID0gbnVsbDtcclxuICAgICAgdGhpcy5ib2R5QiA9IG51bGw7XHJcbiAgICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICB9XHJcbiAgIGIySm9pbnRFZGdlLmIySm9pbnRFZGdlID0gZnVuY3Rpb24gKCkge307XHJcbiAgIEJveDJELmluaGVyaXQoYjJMaW5lSm9pbnQsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50KTtcclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XHJcbiAgIGIyTGluZUpvaW50LmIyTGluZUpvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbFhBeGlzMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2xvY2FsWUF4aXMxID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fYXhpcyA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX3BlcnAgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9LID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgdGhpcy5tX2ltcHVsc2UgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnggKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnkpICogdGhpcy5tX2F4aXMueCksIGludl9kdCAqICh0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueSkgKiB0aGlzLm1fYXhpcy55KSk7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xyXG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XHJcbiAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS55O1xyXG4gICB9XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRKb2ludFRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciBwMSA9IGJBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgICAgIHZhciBwMiA9IGJCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XHJcbiAgICAgIHZhciBkWCA9IHAyLnggLSBwMS54O1xyXG4gICAgICB2YXIgZFkgPSBwMi55IC0gcDEueTtcclxuICAgICAgdmFyIGF4aXMgPSBiQS5HZXRXb3JsZFZlY3Rvcih0aGlzLm1fbG9jYWxYQXhpczEpO1xyXG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSBheGlzLnggKiBkWCArIGF4aXMueSAqIGRZO1xyXG4gICAgICByZXR1cm4gdHJhbnNsYXRpb247XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldEpvaW50U3BlZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcclxuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdmFyIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xyXG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XHJcbiAgICAgIHIxWCA9IHRYO1xyXG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcclxuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xyXG4gICAgICByMlggPSB0WDtcclxuICAgICAgdmFyIHAxWCA9IGJBLm1fc3dlZXAuYy54ICsgcjFYO1xyXG4gICAgICB2YXIgcDFZID0gYkEubV9zd2VlcC5jLnkgKyByMVk7XHJcbiAgICAgIHZhciBwMlggPSBiQi5tX3N3ZWVwLmMueCArIHIyWDtcclxuICAgICAgdmFyIHAyWSA9IGJCLm1fc3dlZXAuYy55ICsgcjJZO1xyXG4gICAgICB2YXIgZFggPSBwMlggLSBwMVg7XHJcbiAgICAgIHZhciBkWSA9IHAyWSAtIHAxWTtcclxuICAgICAgdmFyIGF4aXMgPSBiQS5HZXRXb3JsZFZlY3Rvcih0aGlzLm1fbG9jYWxYQXhpczEpO1xyXG4gICAgICB2YXIgdjEgPSBiQS5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdjIgPSBiQi5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdzEgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHcyID0gYkIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciBzcGVlZCA9IChkWCAqICgoLXcxICogYXhpcy55KSkgKyBkWSAqICh3MSAqIGF4aXMueCkpICsgKGF4aXMueCAqICgoKHYyLnggKyAoKC13MiAqIHIyWSkpKSAtIHYxLngpIC0gKCgtdzEgKiByMVkpKSkgKyBheGlzLnkgKiAoKCh2Mi55ICsgKHcyICogcjJYKSkgLSB2MS55KSAtICh3MSAqIHIxWCkpKTtcclxuICAgICAgcmV0dXJuIHNwZWVkO1xyXG4gICB9XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVMaW1pdDtcclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuRW5hYmxlTGltaXQgPSBmdW5jdGlvbiAoZmxhZykge1xyXG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9ib2R5Qi5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0TG93ZXJMaW1pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uO1xyXG4gICB9XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRVcHBlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLlNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcclxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIGxvd2VyID0gMDtcclxuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHVwcGVyID0gMDtcclxuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gbG93ZXI7XHJcbiAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gdXBwZXI7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLklzTW90b3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2VuYWJsZU1vdG9yO1xyXG4gICB9XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5FbmFibGVNb3RvciA9IGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgIHRoaXMubV9ib2R5QS5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBmbGFnO1xyXG4gICB9XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5TZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XHJcbiAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSBzcGVlZCA9IDA7XHJcbiAgICAgIHRoaXMubV9ib2R5QS5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fbW90b3JTcGVlZCA9IHNwZWVkO1xyXG4gICB9XHJcbiAgIGIyTGluZUpvaW50LnByb3RvdHlwZS5HZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX21vdG9yU3BlZWQ7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLlNldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgaWYgKGZvcmNlID09PSB1bmRlZmluZWQpIGZvcmNlID0gMDtcclxuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZm9yY2U7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLkdldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fbWF4TW90b3JGb3JjZTtcclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuR2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9tb3RvckltcHVsc2U7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnQucHJvdG90eXBlLmIyTGluZUpvaW50ID0gZnVuY3Rpb24gKGRlZikge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludC5jYWxsKHRoaXMsIGRlZik7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgdFggPSAwO1xyXG4gICAgICB2YXIgdFkgPSAwO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcclxuICAgICAgdGhpcy5tX2xvY2FsWEF4aXMxLlNldFYoZGVmLmxvY2FsQXhpc0EpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEueCA9ICgtdGhpcy5tX2xvY2FsWEF4aXMxLnkpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxZQXhpczEueSA9IHRoaXMubV9sb2NhbFhBeGlzMS54O1xyXG4gICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gZGVmLmxvd2VyVHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gZGVmLnVwcGVyVHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZGVmLm1heE1vdG9yRm9yY2U7XHJcbiAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gZGVmLm1vdG9yU3BlZWQ7XHJcbiAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcclxuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZGVmLmVuYWJsZU1vdG9yO1xyXG4gICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICB0aGlzLm1fYXhpcy5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9wZXJwLlNldFplcm8oKTtcclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHRoaXMubV9sb2NhbENlbnRlckEuU2V0VihiQS5HZXRMb2NhbENlbnRlcigpKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQi5TZXRWKGJCLkdldExvY2FsQ2VudGVyKCkpO1xyXG4gICAgICB2YXIgeGYxID0gYkEuR2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgIHZhciB4ZjIgPSBiQi5HZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcclxuICAgICAgdmFyIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIHRoaXMubV9sb2NhbENlbnRlckEueDtcclxuICAgICAgdmFyIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIHRoaXMubV9sb2NhbENlbnRlckEueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XHJcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcclxuICAgICAgcjFYID0gdFg7XHJcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJCLng7XHJcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJCLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xyXG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XHJcbiAgICAgIHIyWCA9IHRYO1xyXG4gICAgICB2YXIgZFggPSBiQi5tX3N3ZWVwLmMueCArIHIyWCAtIGJBLm1fc3dlZXAuYy54IC0gcjFYO1xyXG4gICAgICB2YXIgZFkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWSAtIGJBLm1fc3dlZXAuYy55IC0gcjFZO1xyXG4gICAgICB0aGlzLm1faW52TWFzc0EgPSBiQS5tX2ludk1hc3M7XHJcbiAgICAgIHRoaXMubV9pbnZNYXNzQiA9IGJCLm1faW52TWFzcztcclxuICAgICAgdGhpcy5tX2ludklBID0gYkEubV9pbnZJO1xyXG4gICAgICB0aGlzLm1faW52SUIgPSBiQi5tX2ludkk7IHtcclxuICAgICAgICAgdGhpcy5tX2F4aXMuU2V0VihiMk1hdGguTXVsTVYoeGYxLlIsIHRoaXMubV9sb2NhbFhBeGlzMSkpO1xyXG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICB0aGlzLm1fYTIgPSByMlggKiB0aGlzLm1fYXhpcy55IC0gcjJZICogdGhpcy5tX2F4aXMueDtcclxuICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IHRoaXMubV9pbnZNYXNzQSArIHRoaXMubV9pbnZNYXNzQiArIHRoaXMubV9pbnZJQSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIHRoaXMubV9pbnZJQiAqIHRoaXMubV9hMiAqIHRoaXMubV9hMjtcclxuICAgICAgICAgdGhpcy5tX21vdG9yTWFzcyA9IHRoaXMubV9tb3Rvck1hc3MgPiBOdW1iZXIuTUlOX1ZBTFVFID8gMS4wIC8gdGhpcy5tX21vdG9yTWFzcyA6IDAuMDtcclxuICAgICAgfSB7XHJcbiAgICAgICAgIHRoaXMubV9wZXJwLlNldFYoYjJNYXRoLk11bE1WKHhmMS5SLCB0aGlzLm1fbG9jYWxZQXhpczEpKTtcclxuICAgICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcclxuICAgICAgICAgdGhpcy5tX3MyID0gcjJYICogdGhpcy5tX3BlcnAueSAtIHIyWSAqIHRoaXMubV9wZXJwLng7XHJcbiAgICAgICAgIHZhciBtMSA9IHRoaXMubV9pbnZNYXNzQTtcclxuICAgICAgICAgdmFyIG0yID0gdGhpcy5tX2ludk1hc3NCO1xyXG4gICAgICAgICB2YXIgaTEgPSB0aGlzLm1faW52SUE7XHJcbiAgICAgICAgIHZhciBpMiA9IHRoaXMubV9pbnZJQjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMS54ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX3MxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fczI7XHJcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueSA9IGkxICogdGhpcy5tX3MxICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fczIgKiB0aGlzLm1fYTI7XHJcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueCA9IHRoaXMubV9LLmNvbDEueTtcclxuICAgICAgICAgdGhpcy5tX0suY29sMi55ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xyXG4gICAgICAgICB2YXIgam9pbnRUcmFuc2l0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xyXG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xyXG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9lcXVhbExpbWl0cztcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIGlmIChqb2ludFRyYW5zaXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRMb3dlckxpbWl0O1xyXG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2l0aW9uID49IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gMC4wO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xyXG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICB2YXIgUFggPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueCArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueSkgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueSkgKiB0aGlzLm1fYXhpcy55O1xyXG4gICAgICAgICB2YXIgTDEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS55KSAqIHRoaXMubV9hMTtcclxuICAgICAgICAgdmFyIEwyID0gdGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9zMiArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueSkgKiB0aGlzLm1fYTI7XHJcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCAtPSB0aGlzLm1faW52TWFzc0EgKiBQWDtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xyXG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSB0aGlzLm1faW52SUEgKiBMMTtcclxuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XHJcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMubV9pbnZJQiAqIEwyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciB3MSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdjIgPSBiQi5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIFBYID0gMDtcclxuICAgICAgdmFyIFBZID0gMDtcclxuICAgICAgdmFyIEwxID0gMDtcclxuICAgICAgdmFyIEwyID0gMDtcclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfZXF1YWxMaW1pdHMpIHtcclxuICAgICAgICAgdmFyIENkb3QgPSB0aGlzLm1fYXhpcy54ICogKHYyLnggLSB2MS54KSArIHRoaXMubV9heGlzLnkgKiAodjIueSAtIHYxLnkpICsgdGhpcy5tX2EyICogdzIgLSB0aGlzLm1fYTEgKiB3MTtcclxuICAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLm1fbW90b3JNYXNzICogKHRoaXMubV9tb3RvclNwZWVkIC0gQ2RvdCk7XHJcbiAgICAgICAgIHZhciBvbGRJbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZTtcclxuICAgICAgICAgdmFyIG1heEltcHVsc2UgPSBzdGVwLmR0ICogdGhpcy5tX21heE1vdG9yRm9yY2U7XHJcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSBiMk1hdGguQ2xhbXAodGhpcy5tX21vdG9ySW1wdWxzZSArIGltcHVsc2UsICgtbWF4SW1wdWxzZSksIG1heEltcHVsc2UpO1xyXG4gICAgICAgICBpbXB1bHNlID0gdGhpcy5tX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcbiAgICAgICAgIFBYID0gaW1wdWxzZSAqIHRoaXMubV9heGlzLng7XHJcbiAgICAgICAgIFBZID0gaW1wdWxzZSAqIHRoaXMubV9heGlzLnk7XHJcbiAgICAgICAgIEwxID0gaW1wdWxzZSAqIHRoaXMubV9hMTtcclxuICAgICAgICAgTDIgPSBpbXB1bHNlICogdGhpcy5tX2EyO1xyXG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICB2MS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xyXG4gICAgICAgICB3MSAtPSB0aGlzLm1faW52SUEgKiBMMTtcclxuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcclxuICAgICAgICAgdjIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcclxuICAgICAgICAgdzIgKz0gdGhpcy5tX2ludklCICogTDI7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIENkb3QxID0gdGhpcy5tX3BlcnAueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fcGVycC55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9zMiAqIHcyIC0gdGhpcy5tX3MxICogdzE7XHJcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcclxuICAgICAgICAgdmFyIENkb3QyID0gdGhpcy5tX2F4aXMueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fYXhpcy55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9hMiAqIHcyIC0gdGhpcy5tX2ExICogdzE7XHJcbiAgICAgICAgIHZhciBmMSA9IHRoaXMubV9pbXB1bHNlLkNvcHkoKTtcclxuICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suU29sdmUobmV3IGIyVmVjMigpLCAoLUNkb3QxKSwgKC1DZG90MikpO1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5BZGQoZGYpO1xyXG4gICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xyXG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gYjJNYXRoLk1heCh0aGlzLm1faW1wdWxzZS55LCAwLjApO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSA9IGIyTWF0aC5NaW4odGhpcy5tX2ltcHVsc2UueSwgMC4wKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB2YXIgYiA9ICgtQ2RvdDEpIC0gKHRoaXMubV9pbXB1bHNlLnkgLSBmMS55KSAqIHRoaXMubV9LLmNvbDIueDtcclxuICAgICAgICAgdmFyIGYyciA9IDA7XHJcbiAgICAgICAgIGlmICh0aGlzLm1fSy5jb2wxLnggIT0gMC4wKSB7XHJcbiAgICAgICAgICAgIGYyciA9IGIgLyB0aGlzLm1fSy5jb2wxLnggKyBmMS54O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmMnIgPSBmMS54O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggPSBmMnI7XHJcbiAgICAgICAgIGRmLnggPSB0aGlzLm1faW1wdWxzZS54IC0gZjEueDtcclxuICAgICAgICAgZGYueSA9IHRoaXMubV9pbXB1bHNlLnkgLSBmMS55O1xyXG4gICAgICAgICBQWCA9IGRmLnggKiB0aGlzLm1fcGVycC54ICsgZGYueSAqIHRoaXMubV9heGlzLng7XHJcbiAgICAgICAgIFBZID0gZGYueCAqIHRoaXMubV9wZXJwLnkgKyBkZi55ICogdGhpcy5tX2F4aXMueTtcclxuICAgICAgICAgTDEgPSBkZi54ICogdGhpcy5tX3MxICsgZGYueSAqIHRoaXMubV9hMTtcclxuICAgICAgICAgTDIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueSAqIHRoaXMubV9hMjtcclxuICAgICAgICAgdjEueCAtPSB0aGlzLm1faW52TWFzc0EgKiBQWDtcclxuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcclxuICAgICAgICAgdzEgLT0gdGhpcy5tX2ludklBICogTDE7XHJcbiAgICAgICAgIHYyLnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XHJcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XHJcbiAgICAgICAgIHcyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB2YXIgZGYyID0gMDtcclxuICAgICAgICAgaWYgKHRoaXMubV9LLmNvbDEueCAhPSAwLjApIHtcclxuICAgICAgICAgICAgZGYyID0gKCgtQ2RvdDEpKSAvIHRoaXMubV9LLmNvbDEueDtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGYyID0gMC4wO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gZGYyO1xyXG4gICAgICAgICBQWCA9IGRmMiAqIHRoaXMubV9wZXJwLng7XHJcbiAgICAgICAgIFBZID0gZGYyICogdGhpcy5tX3BlcnAueTtcclxuICAgICAgICAgTDEgPSBkZjIgKiB0aGlzLm1fczE7XHJcbiAgICAgICAgIEwyID0gZGYyICogdGhpcy5tX3MyO1xyXG4gICAgICAgICB2MS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICB2MS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xyXG4gICAgICAgICB3MSAtPSB0aGlzLm1faW52SUEgKiBMMTtcclxuICAgICAgICAgdjIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcclxuICAgICAgICAgdjIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcclxuICAgICAgICAgdzIgKz0gdGhpcy5tX2ludklCICogTDI7XHJcbiAgICAgIH1cclxuICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYxKTtcclxuICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgPSB3MTtcclxuICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS5TZXRWKHYyKTtcclxuICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgPSB3MjtcclxuICAgfVxyXG4gICBiMkxpbmVKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xyXG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XHJcbiAgICAgIHZhciBsaW1pdEMgPSAwO1xyXG4gICAgICB2YXIgb2xkTGltaXRJbXB1bHNlID0gMDtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHZhciBjMSA9IGJBLm1fc3dlZXAuYztcclxuICAgICAgdmFyIGExID0gYkEubV9zd2VlcC5hO1xyXG4gICAgICB2YXIgYzIgPSBiQi5tX3N3ZWVwLmM7XHJcbiAgICAgIHZhciBhMiA9IGJCLm1fc3dlZXAuYTtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciBtMSA9IDA7XHJcbiAgICAgIHZhciBtMiA9IDA7XHJcbiAgICAgIHZhciBpMSA9IDA7XHJcbiAgICAgIHZhciBpMiA9IDA7XHJcbiAgICAgIHZhciBsaW5lYXJFcnJvciA9IDAuMDtcclxuICAgICAgdmFyIGFuZ3VsYXJFcnJvciA9IDAuMDtcclxuICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICB2YXIgQzIgPSAwLjA7XHJcbiAgICAgIHZhciBSMSA9IGIyTWF0MjIuRnJvbUFuZ2xlKGExKTtcclxuICAgICAgdmFyIFIyID0gYjJNYXQyMi5Gcm9tQW5nbGUoYTIpO1xyXG4gICAgICB0TWF0ID0gUjE7XHJcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJBLng7XHJcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJBLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xyXG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XHJcbiAgICAgIHIxWCA9IHRYO1xyXG4gICAgICB0TWF0ID0gUjI7XHJcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSB0aGlzLm1fbG9jYWxDZW50ZXJCLng7XHJcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSB0aGlzLm1fbG9jYWxDZW50ZXJCLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xyXG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XHJcbiAgICAgIHIyWCA9IHRYO1xyXG4gICAgICB2YXIgZFggPSBjMi54ICsgcjJYIC0gYzEueCAtIHIxWDtcclxuICAgICAgdmFyIGRZID0gYzIueSArIHIyWSAtIGMxLnkgLSByMVk7XHJcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQpIHtcclxuICAgICAgICAgdGhpcy5tX2F4aXMgPSBiMk1hdGguTXVsTVYoUjEsIHRoaXMubV9sb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgIHRoaXMubV9hMSA9IChkWCArIHIxWCkgKiB0aGlzLm1fYXhpcy55IC0gKGRZICsgcjFZKSAqIHRoaXMubV9heGlzLng7XHJcbiAgICAgICAgIHRoaXMubV9hMiA9IHIyWCAqIHRoaXMubV9heGlzLnkgLSByMlkgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0aGlzLm1fYXhpcy54ICogZFggKyB0aGlzLm1fYXhpcy55ICogZFk7XHJcbiAgICAgICAgIGlmIChiMk1hdGguQWJzKHRoaXMubV91cHBlclRyYW5zbGF0aW9uIC0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIDwgMi4wICogYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XHJcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIGIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gYjJNYXRoLkFicyh0cmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcclxuICAgICAgICAgICAgQzIgPSBiMk1hdGguQ2xhbXAodHJhbnNsYXRpb24gLSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCAwLjApO1xyXG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uIC0gdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPj0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24pIHtcclxuICAgICAgICAgICAgQzIgPSBiMk1hdGguQ2xhbXAodHJhbnNsYXRpb24gLSB0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiArIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCwgMC4wLCBiMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fcGVycCA9IGIyTWF0aC5NdWxNVihSMSwgdGhpcy5tX2xvY2FsWUF4aXMxKTtcclxuICAgICAgdGhpcy5tX3MxID0gKGRYICsgcjFYKSAqIHRoaXMubV9wZXJwLnkgLSAoZFkgKyByMVkpICogdGhpcy5tX3BlcnAueDtcclxuICAgICAgdGhpcy5tX3MyID0gcjJYICogdGhpcy5tX3BlcnAueSAtIHIyWSAqIHRoaXMubV9wZXJwLng7XHJcbiAgICAgIHZhciBpbXB1bHNlID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB2YXIgQzEgPSB0aGlzLm1fcGVycC54ICogZFggKyB0aGlzLm1fcGVycC55ICogZFk7XHJcbiAgICAgIGxpbmVhckVycm9yID0gYjJNYXRoLk1heChsaW5lYXJFcnJvciwgYjJNYXRoLkFicyhDMSkpO1xyXG4gICAgICBhbmd1bGFyRXJyb3IgPSAwLjA7XHJcbiAgICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgICAgbTEgPSB0aGlzLm1faW52TWFzc0E7XHJcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xyXG4gICAgICAgICBpMSA9IHRoaXMubV9pbnZJQTtcclxuICAgICAgICAgaTIgPSB0aGlzLm1faW52SUI7XHJcbiAgICAgICAgIHRoaXMubV9LLmNvbDEueCA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnkgPSBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX2EyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnggPSB0aGlzLm1fSy5jb2wxLnk7XHJcbiAgICAgICAgIHRoaXMubV9LLmNvbDIueSA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9hMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xyXG4gICAgICAgICB0aGlzLm1fSy5Tb2x2ZShpbXB1bHNlLCAoLUMxKSwgKC1DMikpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICBtMSA9IHRoaXMubV9pbnZNYXNzQTtcclxuICAgICAgICAgbTIgPSB0aGlzLm1faW52TWFzc0I7XHJcbiAgICAgICAgIGkxID0gdGhpcy5tX2ludklBO1xyXG4gICAgICAgICBpMiA9IHRoaXMubV9pbnZJQjtcclxuICAgICAgICAgdmFyIGsxMSA9IG0xICsgbTIgKyBpMSAqIHRoaXMubV9zMSAqIHRoaXMubV9zMSArIGkyICogdGhpcy5tX3MyICogdGhpcy5tX3MyO1xyXG4gICAgICAgICB2YXIgaW1wdWxzZTEgPSAwO1xyXG4gICAgICAgICBpZiAoazExICE9IDAuMCkge1xyXG4gICAgICAgICAgICBpbXB1bHNlMSA9ICgoLUMxKSkgLyBrMTE7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGltcHVsc2UxID0gMC4wO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGltcHVsc2UueCA9IGltcHVsc2UxO1xyXG4gICAgICAgICBpbXB1bHNlLnkgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIFBYID0gaW1wdWxzZS54ICogdGhpcy5tX3BlcnAueCArIGltcHVsc2UueSAqIHRoaXMubV9heGlzLng7XHJcbiAgICAgIHZhciBQWSA9IGltcHVsc2UueCAqIHRoaXMubV9wZXJwLnkgKyBpbXB1bHNlLnkgKiB0aGlzLm1fYXhpcy55O1xyXG4gICAgICB2YXIgTDEgPSBpbXB1bHNlLnggKiB0aGlzLm1fczEgKyBpbXB1bHNlLnkgKiB0aGlzLm1fYTE7XHJcbiAgICAgIHZhciBMMiA9IGltcHVsc2UueCAqIHRoaXMubV9zMiArIGltcHVsc2UueSAqIHRoaXMubV9hMjtcclxuICAgICAgYzEueCAtPSB0aGlzLm1faW52TWFzc0EgKiBQWDtcclxuICAgICAgYzEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcclxuICAgICAgYTEgLT0gdGhpcy5tX2ludklBICogTDE7XHJcbiAgICAgIGMyLnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XHJcbiAgICAgIGMyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XHJcbiAgICAgIGEyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xyXG4gICAgICBiQS5tX3N3ZWVwLmEgPSBhMTtcclxuICAgICAgYkIubV9zd2VlcC5hID0gYTI7XHJcbiAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgIGJCLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8PSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3A7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMkxpbmVKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xyXG4gICBiMkxpbmVKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcclxuICAgYjJMaW5lSm9pbnREZWYuYjJMaW5lSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLmxvY2FsQXhpc0EgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyTGluZUpvaW50RGVmLnByb3RvdHlwZS5iMkxpbmVKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX2xpbmVKb2ludDtcclxuICAgICAgdGhpcy5sb2NhbEF4aXNBLlNldCgxLjAsIDAuMCk7XHJcbiAgICAgIHRoaXMuZW5hYmxlTGltaXQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5sb3dlclRyYW5zbGF0aW9uID0gMC4wO1xyXG4gICAgICB0aGlzLnVwcGVyVHJhbnNsYXRpb24gPSAwLjA7XHJcbiAgICAgIHRoaXMuZW5hYmxlTW90b3IgPSBmYWxzZTtcclxuICAgICAgdGhpcy5tYXhNb3RvckZvcmNlID0gMC4wO1xyXG4gICAgICB0aGlzLm1vdG9yU3BlZWQgPSAwLjA7XHJcbiAgIH1cclxuICAgYjJMaW5lSm9pbnREZWYucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoYkEsIGJCLCBhbmNob3IsIGF4aXMpIHtcclxuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xyXG4gICAgICB0aGlzLmJvZHlCID0gYkI7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvcik7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gdGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcik7XHJcbiAgICAgIHRoaXMubG9jYWxBeGlzQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxWZWN0b3IoYXhpcyk7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMk1vdXNlSm9pbnQsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50KTtcclxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xyXG4gICBiMk1vdXNlSm9pbnQuYjJNb3VzZUpvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5iMkpvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMuSyA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgICAgIHRoaXMuSzEgPSBuZXcgYjJNYXQyMigpO1xyXG4gICAgICB0aGlzLksyID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fdGFyZ2V0ID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX21hc3MgPSBuZXcgYjJNYXQyMigpO1xyXG4gICAgICB0aGlzLm1fQyA9IG5ldyBiMlZlYzIoKTtcclxuICAgfTtcclxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3RhcmdldDtcclxuICAgfVxyXG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IpO1xyXG4gICB9XHJcbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Gb3JjZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gbmV3IGIyVmVjMihpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS54LCBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS55KTtcclxuICAgfVxyXG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xyXG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XHJcbiAgICAgIHJldHVybiAwLjA7XHJcbiAgIH1cclxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fdGFyZ2V0O1xyXG4gICB9XHJcbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICBpZiAodGhpcy5tX2JvZHlCLklzQXdha2UoKSA9PSBmYWxzZSkge1xyXG4gICAgICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX3RhcmdldCA9IHRhcmdldDtcclxuICAgfVxyXG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLkdldE1heEZvcmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX21heEZvcmNlO1xyXG4gICB9XHJcbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU2V0TWF4Rm9yY2UgPSBmdW5jdGlvbiAobWF4Rm9yY2UpIHtcclxuICAgICAgaWYgKG1heEZvcmNlID09PSB1bmRlZmluZWQpIG1heEZvcmNlID0gMDtcclxuICAgICAgdGhpcy5tX21heEZvcmNlID0gbWF4Rm9yY2U7XHJcbiAgIH1cclxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fZnJlcXVlbmN5SHo7XHJcbiAgIH1cclxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5TZXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoaHopIHtcclxuICAgICAgaWYgKGh6ID09PSB1bmRlZmluZWQpIGh6ID0gMDtcclxuICAgICAgdGhpcy5tX2ZyZXF1ZW5jeUh6ID0gaHo7XHJcbiAgIH1cclxuICAgYjJNb3VzZUpvaW50LnByb3RvdHlwZS5HZXREYW1waW5nUmF0aW8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fZGFtcGluZ1JhdGlvO1xyXG4gICB9XHJcbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuU2V0RGFtcGluZ1JhdGlvID0gZnVuY3Rpb24gKHJhdGlvKSB7XHJcbiAgICAgIGlmIChyYXRpbyA9PT0gdW5kZWZpbmVkKSByYXRpbyA9IDA7XHJcbiAgICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSByYXRpbztcclxuICAgfVxyXG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLmIyTW91c2VKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xyXG4gICAgICB0aGlzLm1fdGFyZ2V0LlNldFYoZGVmLnRhcmdldCk7XHJcbiAgICAgIHZhciB0WCA9IHRoaXMubV90YXJnZXQueCAtIHRoaXMubV9ib2R5Qi5tX3hmLnBvc2l0aW9uLng7XHJcbiAgICAgIHZhciB0WSA9IHRoaXMubV90YXJnZXQueSAtIHRoaXMubV9ib2R5Qi5tX3hmLnBvc2l0aW9uLnk7XHJcbiAgICAgIHZhciB0TWF0ID0gdGhpcy5tX2JvZHlCLm1feGYuUjtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yLnggPSAodFggKiB0TWF0LmNvbDEueCArIHRZICogdE1hdC5jb2wxLnkpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IueSA9ICh0WCAqIHRNYXQuY29sMi54ICsgdFkgKiB0TWF0LmNvbDIueSk7XHJcbiAgICAgIHRoaXMubV9tYXhGb3JjZSA9IGRlZi5tYXhGb3JjZTtcclxuICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xyXG4gICAgICB0aGlzLm1fZnJlcXVlbmN5SHogPSBkZWYuZnJlcXVlbmN5SHo7XHJcbiAgICAgIHRoaXMubV9kYW1waW5nUmF0aW8gPSBkZWYuZGFtcGluZ1JhdGlvO1xyXG4gICAgICB0aGlzLm1fYmV0YSA9IDAuMDtcclxuICAgICAgdGhpcy5tX2dhbW1hID0gMC4wO1xyXG4gICB9XHJcbiAgIGIyTW91c2VKb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgYiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIG1hc3MgPSBiLkdldE1hc3MoKTtcclxuICAgICAgdmFyIG9tZWdhID0gMi4wICogTWF0aC5QSSAqIHRoaXMubV9mcmVxdWVuY3lIejtcclxuICAgICAgdmFyIGQgPSAyLjAgKiBtYXNzICogdGhpcy5tX2RhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG4gICAgICB2YXIgayA9IG1hc3MgKiBvbWVnYSAqIG9tZWdhO1xyXG4gICAgICB0aGlzLm1fZ2FtbWEgPSBzdGVwLmR0ICogKGQgKyBzdGVwLmR0ICogayk7XHJcbiAgICAgIHRoaXMubV9nYW1tYSA9IHRoaXMubV9nYW1tYSAhPSAwID8gMSAvIHRoaXMubV9nYW1tYSA6IDAuMDtcclxuICAgICAgdGhpcy5tX2JldGEgPSBzdGVwLmR0ICogayAqIHRoaXMubV9nYW1tYTtcclxuICAgICAgdmFyIHRNYXQ7dE1hdCA9IGIubV94Zi5SO1xyXG4gICAgICB2YXIgclggPSB0aGlzLm1fbG9jYWxBbmNob3IueCAtIGIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IueSAtIGIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByWCArIHRNYXQuY29sMi54ICogclkpO3JZID0gKHRNYXQuY29sMS55ICogclggKyB0TWF0LmNvbDIueSAqIHJZKTtcclxuICAgICAgclggPSB0WDtcclxuICAgICAgdmFyIGludk1hc3MgPSBiLm1faW52TWFzcztcclxuICAgICAgdmFyIGludkkgPSBiLm1faW52STt0aGlzLksxLmNvbDEueCA9IGludk1hc3M7XHJcbiAgICAgIHRoaXMuSzEuY29sMi54ID0gMC4wO1xyXG4gICAgICB0aGlzLksxLmNvbDEueSA9IDAuMDtcclxuICAgICAgdGhpcy5LMS5jb2wyLnkgPSBpbnZNYXNzO1xyXG4gICAgICB0aGlzLksyLmNvbDEueCA9IGludkkgKiByWSAqIHJZO1xyXG4gICAgICB0aGlzLksyLmNvbDIueCA9ICgtaW52SSAqIHJYICogclkpO1xyXG4gICAgICB0aGlzLksyLmNvbDEueSA9ICgtaW52SSAqIHJYICogclkpO1xyXG4gICAgICB0aGlzLksyLmNvbDIueSA9IGludkkgKiByWCAqIHJYO1xyXG4gICAgICB0aGlzLksuU2V0TSh0aGlzLksxKTtcclxuICAgICAgdGhpcy5LLkFkZE0odGhpcy5LMik7XHJcbiAgICAgIHRoaXMuSy5jb2wxLnggKz0gdGhpcy5tX2dhbW1hO1xyXG4gICAgICB0aGlzLksuY29sMi55ICs9IHRoaXMubV9nYW1tYTtcclxuICAgICAgdGhpcy5LLkdldEludmVyc2UodGhpcy5tX21hc3MpO1xyXG4gICAgICB0aGlzLm1fQy54ID0gYi5tX3N3ZWVwLmMueCArIHJYIC0gdGhpcy5tX3RhcmdldC54O1xyXG4gICAgICB0aGlzLm1fQy55ID0gYi5tX3N3ZWVwLmMueSArIHJZIC0gdGhpcy5tX3RhcmdldC55O1xyXG4gICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICo9IDAuOTg7XHJcbiAgICAgIHRoaXMubV9pbXB1bHNlLnggKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgYi5tX2xpbmVhclZlbG9jaXR5LnggKz0gaW52TWFzcyAqIHRoaXMubV9pbXB1bHNlLng7XHJcbiAgICAgIGIubV9saW5lYXJWZWxvY2l0eS55ICs9IGludk1hc3MgKiB0aGlzLm1faW1wdWxzZS55O1xyXG4gICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICs9IGludkkgKiAoclggKiB0aGlzLm1faW1wdWxzZS55IC0gclkgKiB0aGlzLm1faW1wdWxzZS54KTtcclxuICAgfVxyXG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBiID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIHRZID0gMDtcclxuICAgICAgdE1hdCA9IGIubV94Zi5SO1xyXG4gICAgICB2YXIgclggPSB0aGlzLm1fbG9jYWxBbmNob3IueCAtIGIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgclkgPSB0aGlzLm1fbG9jYWxBbmNob3IueSAtIGIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJYICsgdE1hdC5jb2wyLnggKiByWSk7XHJcbiAgICAgIHJZID0gKHRNYXQuY29sMS55ICogclggKyB0TWF0LmNvbDIueSAqIHJZKTtcclxuICAgICAgclggPSB0WDtcclxuICAgICAgdmFyIENkb3RYID0gYi5tX2xpbmVhclZlbG9jaXR5LnggKyAoKC1iLm1fYW5ndWxhclZlbG9jaXR5ICogclkpKTtcclxuICAgICAgdmFyIENkb3RZID0gYi5tX2xpbmVhclZlbG9jaXR5LnkgKyAoYi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHJYKTtcclxuICAgICAgdE1hdCA9IHRoaXMubV9tYXNzO1xyXG4gICAgICB0WCA9IENkb3RYICsgdGhpcy5tX2JldGEgKiB0aGlzLm1fQy54ICsgdGhpcy5tX2dhbW1hICogdGhpcy5tX2ltcHVsc2UueDtcclxuICAgICAgdFkgPSBDZG90WSArIHRoaXMubV9iZXRhICogdGhpcy5tX0MueSArIHRoaXMubV9nYW1tYSAqIHRoaXMubV9pbXB1bHNlLnk7XHJcbiAgICAgIHZhciBpbXB1bHNlWCA9ICgtKHRNYXQuY29sMS54ICogdFggKyB0TWF0LmNvbDIueCAqIHRZKSk7XHJcbiAgICAgIHZhciBpbXB1bHNlWSA9ICgtKHRNYXQuY29sMS55ICogdFggKyB0TWF0LmNvbDIueSAqIHRZKSk7XHJcbiAgICAgIHZhciBvbGRJbXB1bHNlWCA9IHRoaXMubV9pbXB1bHNlLng7XHJcbiAgICAgIHZhciBvbGRJbXB1bHNlWSA9IHRoaXMubV9pbXB1bHNlLnk7XHJcbiAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gaW1wdWxzZVg7XHJcbiAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gaW1wdWxzZVk7XHJcbiAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhGb3JjZTtcclxuICAgICAgaWYgKHRoaXMubV9pbXB1bHNlLkxlbmd0aFNxdWFyZWQoKSA+IG1heEltcHVsc2UgKiBtYXhJbXB1bHNlKSB7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLk11bHRpcGx5KG1heEltcHVsc2UgLyB0aGlzLm1faW1wdWxzZS5MZW5ndGgoKSk7XHJcbiAgICAgIH1cclxuICAgICAgaW1wdWxzZVggPSB0aGlzLm1faW1wdWxzZS54IC0gb2xkSW1wdWxzZVg7XHJcbiAgICAgIGltcHVsc2VZID0gdGhpcy5tX2ltcHVsc2UueSAtIG9sZEltcHVsc2VZO1xyXG4gICAgICBiLm1fbGluZWFyVmVsb2NpdHkueCArPSBiLm1faW52TWFzcyAqIGltcHVsc2VYO1xyXG4gICAgICBiLm1fbGluZWFyVmVsb2NpdHkueSArPSBiLm1faW52TWFzcyAqIGltcHVsc2VZO1xyXG4gICAgICBiLm1fYW5ndWxhclZlbG9jaXR5ICs9IGIubV9pbnZJICogKHJYICogaW1wdWxzZVkgLSByWSAqIGltcHVsc2VYKTtcclxuICAgfVxyXG4gICBiMk1vdXNlSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcclxuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgfVxyXG4gICBCb3gyRC5pbmhlcml0KGIyTW91c2VKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xyXG4gICBiMk1vdXNlSm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XHJcbiAgIGIyTW91c2VKb2ludERlZi5iMk1vdXNlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy50YXJnZXQgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyTW91c2VKb2ludERlZi5wcm90b3R5cGUuYjJNb3VzZUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfbW91c2VKb2ludDtcclxuICAgICAgdGhpcy5tYXhGb3JjZSA9IDAuMDtcclxuICAgICAgdGhpcy5mcmVxdWVuY3lIeiA9IDUuMDtcclxuICAgICAgdGhpcy5kYW1waW5nUmF0aW8gPSAwLjc7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMlByaXNtYXRpY0pvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XHJcbiAgIGIyUHJpc21hdGljSm9pbnQuYjJQcmlzbWF0aWNKb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxYQXhpczEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbFlBeGlzMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2F4aXMgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9wZXJwID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fSyA9IG5ldyBiMk1hdDMzKCk7XHJcbiAgICAgIHRoaXMubV9pbXB1bHNlID0gbmV3IGIyVmVjMygpO1xyXG4gICB9O1xyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgIH1cclxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogKHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fcGVycC54ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9heGlzLngpLCBpbnZfZHQgKiAodGhpcy5tX2ltcHVsc2UueCAqIHRoaXMubV9wZXJwLnkgKyAodGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopICogdGhpcy5tX2F4aXMueSkpO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xyXG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XHJcbiAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS55O1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldEpvaW50VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHAxID0gYkEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcclxuICAgICAgdmFyIHAyID0gYkIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcclxuICAgICAgdmFyIGRYID0gcDIueCAtIHAxLng7XHJcbiAgICAgIHZhciBkWSA9IHAyLnkgLSBwMS55O1xyXG4gICAgICB2YXIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKHRoaXMubV9sb2NhbFhBeGlzMSk7XHJcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IGF4aXMueCAqIGRYICsgYXhpcy55ICogZFk7XHJcbiAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRKb2ludFNwZWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICByMVggPSB0WDtcclxuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcclxuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgcjJYID0gdFg7XHJcbiAgICAgIHZhciBwMVggPSBiQS5tX3N3ZWVwLmMueCArIHIxWDtcclxuICAgICAgdmFyIHAxWSA9IGJBLm1fc3dlZXAuYy55ICsgcjFZO1xyXG4gICAgICB2YXIgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XHJcbiAgICAgIHZhciBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcclxuICAgICAgdmFyIGRYID0gcDJYIC0gcDFYO1xyXG4gICAgICB2YXIgZFkgPSBwMlkgLSBwMVk7XHJcbiAgICAgIHZhciBheGlzID0gYkEuR2V0V29ybGRWZWN0b3IodGhpcy5tX2xvY2FsWEF4aXMxKTtcclxuICAgICAgdmFyIHYxID0gYkEubV9saW5lYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHYyID0gYkIubV9saW5lYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHcxID0gYkEubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciB3MiA9IGJCLm1fYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgc3BlZWQgPSAoZFggKiAoKC13MSAqIGF4aXMueSkpICsgZFkgKiAodzEgKiBheGlzLngpKSArIChheGlzLnggKiAoKCh2Mi54ICsgKCgtdzIgKiByMlkpKSkgLSB2MS54KSAtICgoLXcxICogcjFZKSkpICsgYXhpcy55ICogKCgodjIueSArICh3MiAqIHIyWCkpIC0gdjEueSkgLSAodzEgKiByMVgpKSk7XHJcbiAgICAgIHJldHVybiBzcGVlZDtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVMaW1pdDtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5FbmFibGVMaW1pdCA9IGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgIHRoaXMubV9ib2R5QS5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fZW5hYmxlTGltaXQgPSBmbGFnO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLkdldExvd2VyTGltaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbjtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5HZXRVcHBlckxpbWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb247XHJcbiAgIH1cclxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuU2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xyXG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCkgbG93ZXIgPSAwO1xyXG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkgdXBwZXIgPSAwO1xyXG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9ib2R5Qi5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gPSBsb3dlcjtcclxuICAgICAgdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gPSB1cHBlcjtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jc01vdG9yRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3RvcjtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5FbmFibGVNb3RvciA9IGZ1bmN0aW9uIChmbGFnKSB7XHJcbiAgICAgIHRoaXMubV9ib2R5QS5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgdGhpcy5tX2JvZHlCLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBmbGFnO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcclxuICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHNwZWVkID0gMDtcclxuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XHJcbiAgIH1cclxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9tb3RvclNwZWVkO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNldE1heE1vdG9yRm9yY2UgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgaWYgKGZvcmNlID09PSB1bmRlZmluZWQpIGZvcmNlID0gMDtcclxuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZm9yY2U7XHJcbiAgIH1cclxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuR2V0TW90b3JGb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9tb3RvckltcHVsc2U7XHJcbiAgIH1cclxuICAgYjJQcmlzbWF0aWNKb2ludC5wcm90b3R5cGUuYjJQcmlzbWF0aWNKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIHRZID0gMDtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMS5TZXRWKGRlZi5sb2NhbEFuY2hvckEpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyLlNldFYoZGVmLmxvY2FsQW5jaG9yQik7XHJcbiAgICAgIHRoaXMubV9sb2NhbFhBeGlzMS5TZXRWKGRlZi5sb2NhbEF4aXNBKTtcclxuICAgICAgdGhpcy5tX2xvY2FsWUF4aXMxLnggPSAoLXRoaXMubV9sb2NhbFhBeGlzMS55KTtcclxuICAgICAgdGhpcy5tX2xvY2FsWUF4aXMxLnkgPSB0aGlzLm1fbG9jYWxYQXhpczEueDtcclxuICAgICAgdGhpcy5tX3JlZkFuZ2xlID0gZGVmLnJlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uID0gZGVmLmxvd2VyVHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubV91cHBlclRyYW5zbGF0aW9uID0gZGVmLnVwcGVyVHJhbnNsYXRpb247XHJcbiAgICAgIHRoaXMubV9tYXhNb3RvckZvcmNlID0gZGVmLm1heE1vdG9yRm9yY2U7XHJcbiAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gZGVmLm1vdG9yU3BlZWQ7XHJcbiAgICAgIHRoaXMubV9lbmFibGVMaW1pdCA9IGRlZi5lbmFibGVMaW1pdDtcclxuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZGVmLmVuYWJsZU1vdG9yO1xyXG4gICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICB0aGlzLm1fYXhpcy5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9wZXJwLlNldFplcm8oKTtcclxuICAgfVxyXG4gICBiMlByaXNtYXRpY0pvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdGhpcy5tX2xvY2FsQ2VudGVyQS5TZXRWKGJBLkdldExvY2FsQ2VudGVyKCkpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxDZW50ZXJCLlNldFYoYkIuR2V0TG9jYWxDZW50ZXIoKSk7XHJcbiAgICAgIHZhciB4ZjEgPSBiQS5HZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgdmFyIHhmMiA9IGJCLkdldFRyYW5zZm9ybSgpO1xyXG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xyXG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQS54O1xyXG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQS55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICByMVggPSB0WDtcclxuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcclxuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIHRoaXMubV9sb2NhbENlbnRlckIueDtcclxuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIHRoaXMubV9sb2NhbENlbnRlckIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgcjJYID0gdFg7XHJcbiAgICAgIHZhciBkWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XHJcbiAgICAgIHZhciBkWSA9IGJCLm1fc3dlZXAuYy55ICsgcjJZIC0gYkEubV9zd2VlcC5jLnkgLSByMVk7XHJcbiAgICAgIHRoaXMubV9pbnZNYXNzQSA9IGJBLm1faW52TWFzcztcclxuICAgICAgdGhpcy5tX2ludk1hc3NCID0gYkIubV9pbnZNYXNzO1xyXG4gICAgICB0aGlzLm1faW52SUEgPSBiQS5tX2ludkk7XHJcbiAgICAgIHRoaXMubV9pbnZJQiA9IGJCLm1faW52STsge1xyXG4gICAgICAgICB0aGlzLm1fYXhpcy5TZXRWKGIyTWF0aC5NdWxNVih4ZjEuUiwgdGhpcy5tX2xvY2FsWEF4aXMxKSk7XHJcbiAgICAgICAgIHRoaXMubV9hMSA9IChkWCArIHIxWCkgKiB0aGlzLm1fYXhpcy55IC0gKGRZICsgcjFZKSAqIHRoaXMubV9heGlzLng7XHJcbiAgICAgICAgIHRoaXMubV9hMiA9IHIyWCAqIHRoaXMubV9heGlzLnkgLSByMlkgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICB0aGlzLm1fbW90b3JNYXNzID0gdGhpcy5tX2ludk1hc3NBICsgdGhpcy5tX2ludk1hc3NCICsgdGhpcy5tX2ludklBICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgdGhpcy5tX2ludklCICogdGhpcy5tX2EyICogdGhpcy5tX2EyO1xyXG4gICAgICAgICBpZiAodGhpcy5tX21vdG9yTWFzcyA+IE51bWJlci5NSU5fVkFMVUUpIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyB0aGlzLm1fbW90b3JNYXNzO1xyXG4gICAgICB9IHtcclxuICAgICAgICAgdGhpcy5tX3BlcnAuU2V0VihiMk1hdGguTXVsTVYoeGYxLlIsIHRoaXMubV9sb2NhbFlBeGlzMSkpO1xyXG4gICAgICAgICB0aGlzLm1fczEgPSAoZFggKyByMVgpICogdGhpcy5tX3BlcnAueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fcGVycC54O1xyXG4gICAgICAgICB0aGlzLm1fczIgPSByMlggKiB0aGlzLm1fcGVycC55IC0gcjJZICogdGhpcy5tX3BlcnAueDtcclxuICAgICAgICAgdmFyIG0xID0gdGhpcy5tX2ludk1hc3NBO1xyXG4gICAgICAgICB2YXIgbTIgPSB0aGlzLm1faW52TWFzc0I7XHJcbiAgICAgICAgIHZhciBpMSA9IHRoaXMubV9pbnZJQTtcclxuICAgICAgICAgdmFyIGkyID0gdGhpcy5tX2ludklCO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnggPSBtMSArIG0yICsgaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9zMjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMS55ID0gaTEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMS56ID0gaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMi54ID0gdGhpcy5tX0suY29sMS55O1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnkgPSBpMSArIGkyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnogPSBpMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wzLnggPSB0aGlzLm1fSy5jb2wxLno7XHJcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueSA9IHRoaXMubV9LLmNvbDIuejtcclxuICAgICAgICAgdGhpcy5tX0suY29sMy56ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCkge1xyXG4gICAgICAgICB2YXIgam9pbnRUcmFuc2l0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xyXG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xyXG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9lcXVhbExpbWl0cztcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIGlmIChqb2ludFRyYW5zaXRpb24gPD0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRMb3dlckxpbWl0O1xyXG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2l0aW9uID49IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciA9PSBmYWxzZSkge1xyXG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICB2YXIgUFggPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueCArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICB2YXIgUFkgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYXhpcy55O1xyXG4gICAgICAgICB2YXIgTDEgPSB0aGlzLm1faW1wdWxzZS54ICogdGhpcy5tX3MxICsgdGhpcy5tX2ltcHVsc2UueSArICh0aGlzLm1fbW90b3JJbXB1bHNlICsgdGhpcy5tX2ltcHVsc2UueikgKiB0aGlzLm1fYTE7XHJcbiAgICAgICAgIHZhciBMMiA9IHRoaXMubV9pbXB1bHNlLnggKiB0aGlzLm1fczIgKyB0aGlzLm1faW1wdWxzZS55ICsgKHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KSAqIHRoaXMubV9hMjtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XHJcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5IC09IHRoaXMubV9pbnZJQSAqIEwxO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XHJcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcclxuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5tX2ludklCICogTDI7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLlNldFplcm8oKTtcclxuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcclxuICAgICAgfVxyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdjEgPSBiQS5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdzEgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHYyID0gYkIubV9saW5lYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHcyID0gYkIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciBQWCA9IDA7XHJcbiAgICAgIHZhciBQWSA9IDA7XHJcbiAgICAgIHZhciBMMSA9IDA7XHJcbiAgICAgIHZhciBMMiA9IDA7XHJcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XHJcbiAgICAgICAgIHZhciBDZG90ID0gdGhpcy5tX2F4aXMueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fYXhpcy55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9hMiAqIHcyIC0gdGhpcy5tX2ExICogdzE7XHJcbiAgICAgICAgIHZhciBpbXB1bHNlID0gdGhpcy5tX21vdG9yTWFzcyAqICh0aGlzLm1fbW90b3JTcGVlZCAtIENkb3QpO1xyXG4gICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvckZvcmNlO1xyXG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gYjJNYXRoLkNsYW1wKHRoaXMubV9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAoLW1heEltcHVsc2UpLCBtYXhJbXB1bHNlKTtcclxuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG4gICAgICAgICBQWCA9IGltcHVsc2UgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICBQWSA9IGltcHVsc2UgKiB0aGlzLm1fYXhpcy55O1xyXG4gICAgICAgICBMMSA9IGltcHVsc2UgKiB0aGlzLm1fYTE7XHJcbiAgICAgICAgIEwyID0gaW1wdWxzZSAqIHRoaXMubV9hMjtcclxuICAgICAgICAgdjEueCAtPSB0aGlzLm1faW52TWFzc0EgKiBQWDtcclxuICAgICAgICAgdjEueSAtPSB0aGlzLm1faW52TWFzc0EgKiBQWTtcclxuICAgICAgICAgdzEgLT0gdGhpcy5tX2ludklBICogTDE7XHJcbiAgICAgICAgIHYyLnggKz0gdGhpcy5tX2ludk1hc3NCICogUFg7XHJcbiAgICAgICAgIHYyLnkgKz0gdGhpcy5tX2ludk1hc3NCICogUFk7XHJcbiAgICAgICAgIHcyICs9IHRoaXMubV9pbnZJQiAqIEwyO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBDZG90MVggPSB0aGlzLm1fcGVycC54ICogKHYyLnggLSB2MS54KSArIHRoaXMubV9wZXJwLnkgKiAodjIueSAtIHYxLnkpICsgdGhpcy5tX3MyICogdzIgLSB0aGlzLm1fczEgKiB3MTtcclxuICAgICAgdmFyIENkb3QxWSA9IHcyIC0gdzE7XHJcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcclxuICAgICAgICAgdmFyIENkb3QyID0gdGhpcy5tX2F4aXMueCAqICh2Mi54IC0gdjEueCkgKyB0aGlzLm1fYXhpcy55ICogKHYyLnkgLSB2MS55KSArIHRoaXMubV9hMiAqIHcyIC0gdGhpcy5tX2ExICogdzE7XHJcbiAgICAgICAgIHZhciBmMSA9IHRoaXMubV9pbXB1bHNlLkNvcHkoKTtcclxuICAgICAgICAgdmFyIGRmID0gdGhpcy5tX0suU29sdmUzMyhuZXcgYjJWZWMzKCksICgtQ2RvdDFYKSwgKC1DZG90MVkpLCAoLUNkb3QyKSk7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLkFkZChkZik7XHJcbiAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBiMkpvaW50LmVfYXRMb3dlckxpbWl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSBiMk1hdGguTWF4KHRoaXMubV9pbXB1bHNlLnosIDAuMCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xyXG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gYjJNYXRoLk1pbih0aGlzLm1faW1wdWxzZS56LCAwLjApO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHZhciBiWCA9ICgtQ2RvdDFYKSAtICh0aGlzLm1faW1wdWxzZS56IC0gZjEueikgKiB0aGlzLm1fSy5jb2wzLng7XHJcbiAgICAgICAgIHZhciBiWSA9ICgtQ2RvdDFZKSAtICh0aGlzLm1faW1wdWxzZS56IC0gZjEueikgKiB0aGlzLm1fSy5jb2wzLnk7XHJcbiAgICAgICAgIHZhciBmMnIgPSB0aGlzLm1fSy5Tb2x2ZTIyKG5ldyBiMlZlYzIoKSwgYlgsIGJZKTtcclxuICAgICAgICAgZjJyLnggKz0gZjEueDtcclxuICAgICAgICAgZjJyLnkgKz0gZjEueTtcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCA9IGYyci54O1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ID0gZjJyLnk7XHJcbiAgICAgICAgIGRmLnggPSB0aGlzLm1faW1wdWxzZS54IC0gZjEueDtcclxuICAgICAgICAgZGYueSA9IHRoaXMubV9pbXB1bHNlLnkgLSBmMS55O1xyXG4gICAgICAgICBkZi56ID0gdGhpcy5tX2ltcHVsc2UueiAtIGYxLno7XHJcbiAgICAgICAgIFBYID0gZGYueCAqIHRoaXMubV9wZXJwLnggKyBkZi56ICogdGhpcy5tX2F4aXMueDtcclxuICAgICAgICAgUFkgPSBkZi54ICogdGhpcy5tX3BlcnAueSArIGRmLnogKiB0aGlzLm1fYXhpcy55O1xyXG4gICAgICAgICBMMSA9IGRmLnggKiB0aGlzLm1fczEgKyBkZi55ICsgZGYueiAqIHRoaXMubV9hMTtcclxuICAgICAgICAgTDIgPSBkZi54ICogdGhpcy5tX3MyICsgZGYueSArIGRmLnogKiB0aGlzLm1fYTI7XHJcbiAgICAgICAgIHYxLnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XHJcbiAgICAgICAgIHYxLnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XHJcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xyXG4gICAgICAgICB2Mi54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xyXG4gICAgICAgICB2Mi55ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBZO1xyXG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdmFyIGRmMiA9IHRoaXMubV9LLlNvbHZlMjIobmV3IGIyVmVjMigpLCAoLUNkb3QxWCksICgtQ2RvdDFZKSk7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gZGYyLng7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnkgKz0gZGYyLnk7XHJcbiAgICAgICAgIFBYID0gZGYyLnggKiB0aGlzLm1fcGVycC54O1xyXG4gICAgICAgICBQWSA9IGRmMi54ICogdGhpcy5tX3BlcnAueTtcclxuICAgICAgICAgTDEgPSBkZjIueCAqIHRoaXMubV9zMSArIGRmMi55O1xyXG4gICAgICAgICBMMiA9IGRmMi54ICogdGhpcy5tX3MyICsgZGYyLnk7XHJcbiAgICAgICAgIHYxLnggLT0gdGhpcy5tX2ludk1hc3NBICogUFg7XHJcbiAgICAgICAgIHYxLnkgLT0gdGhpcy5tX2ludk1hc3NBICogUFk7XHJcbiAgICAgICAgIHcxIC09IHRoaXMubV9pbnZJQSAqIEwxO1xyXG4gICAgICAgICB2Mi54ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBYO1xyXG4gICAgICAgICB2Mi55ICs9IHRoaXMubV9pbnZNYXNzQiAqIFBZO1xyXG4gICAgICAgICB3MiArPSB0aGlzLm1faW52SUIgKiBMMjtcclxuICAgICAgfVxyXG4gICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LlNldFYodjEpO1xyXG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcxO1xyXG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LlNldFYodjIpO1xyXG4gICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcyO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcclxuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xyXG4gICAgICB2YXIgbGltaXRDID0gMDtcclxuICAgICAgdmFyIG9sZExpbWl0SW1wdWxzZSA9IDA7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgYzEgPSBiQS5tX3N3ZWVwLmM7XHJcbiAgICAgIHZhciBhMSA9IGJBLm1fc3dlZXAuYTtcclxuICAgICAgdmFyIGMyID0gYkIubV9zd2VlcC5jO1xyXG4gICAgICB2YXIgYTIgPSBiQi5tX3N3ZWVwLmE7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgdFggPSAwO1xyXG4gICAgICB2YXIgbTEgPSAwO1xyXG4gICAgICB2YXIgbTIgPSAwO1xyXG4gICAgICB2YXIgaTEgPSAwO1xyXG4gICAgICB2YXIgaTIgPSAwO1xyXG4gICAgICB2YXIgbGluZWFyRXJyb3IgPSAwLjA7XHJcbiAgICAgIHZhciBhbmd1bGFyRXJyb3IgPSAwLjA7XHJcbiAgICAgIHZhciBhY3RpdmUgPSBmYWxzZTtcclxuICAgICAgdmFyIEMyID0gMC4wO1xyXG4gICAgICB2YXIgUjEgPSBiMk1hdDIyLkZyb21BbmdsZShhMSk7XHJcbiAgICAgIHZhciBSMiA9IGIyTWF0MjIuRnJvbUFuZ2xlKGEyKTtcclxuICAgICAgdE1hdCA9IFIxO1xyXG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQS54O1xyXG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQS55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICByMVggPSB0WDtcclxuICAgICAgdE1hdCA9IFIyO1xyXG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi54O1xyXG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gdGhpcy5tX2xvY2FsQ2VudGVyQi55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcclxuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xyXG4gICAgICByMlggPSB0WDtcclxuICAgICAgdmFyIGRYID0gYzIueCArIHIyWCAtIGMxLnggLSByMVg7XHJcbiAgICAgIHZhciBkWSA9IGMyLnkgKyByMlkgLSBjMS55IC0gcjFZO1xyXG4gICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XHJcbiAgICAgICAgIHRoaXMubV9heGlzID0gYjJNYXRoLk11bE1WKFIxLCB0aGlzLm1fbG9jYWxYQXhpczEpO1xyXG4gICAgICAgICB0aGlzLm1fYTEgPSAoZFggKyByMVgpICogdGhpcy5tX2F4aXMueSAtIChkWSArIHIxWSkgKiB0aGlzLm1fYXhpcy54O1xyXG4gICAgICAgICB0aGlzLm1fYTIgPSByMlggKiB0aGlzLm1fYXhpcy55IC0gcjJZICogdGhpcy5tX2F4aXMueDtcclxuICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5tX2F4aXMueCAqIGRYICsgdGhpcy5tX2F4aXMueSAqIGRZO1xyXG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJUcmFuc2xhdGlvbiAtIHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xyXG4gICAgICAgICAgICBDMiA9IGIyTWF0aC5DbGFtcCh0cmFuc2xhdGlvbiwgKC1iMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pLCBiMlNldHRpbmdzLmIyX21heExpbmVhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5BYnModHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uIDw9IHRoaXMubV9sb3dlclRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX2xvd2VyVHJhbnNsYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgMC4wKTtcclxuICAgICAgICAgICAgbGluZWFyRXJyb3IgPSB0aGlzLm1fbG93ZXJUcmFuc2xhdGlvbiAtIHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uID49IHRoaXMubV91cHBlclRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIEMyID0gYjJNYXRoLkNsYW1wKHRyYW5zbGF0aW9uIC0gdGhpcy5tX3VwcGVyVHJhbnNsYXRpb24gKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsIDAuMCwgYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgbGluZWFyRXJyb3IgPSB0cmFuc2xhdGlvbiAtIHRoaXMubV91cHBlclRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tX3BlcnAgPSBiMk1hdGguTXVsTVYoUjEsIHRoaXMubV9sb2NhbFlBeGlzMSk7XHJcbiAgICAgIHRoaXMubV9zMSA9IChkWCArIHIxWCkgKiB0aGlzLm1fcGVycC55IC0gKGRZICsgcjFZKSAqIHRoaXMubV9wZXJwLng7XHJcbiAgICAgIHRoaXMubV9zMiA9IHIyWCAqIHRoaXMubV9wZXJwLnkgLSByMlkgKiB0aGlzLm1fcGVycC54O1xyXG4gICAgICB2YXIgaW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcclxuICAgICAgdmFyIEMxWCA9IHRoaXMubV9wZXJwLnggKiBkWCArIHRoaXMubV9wZXJwLnkgKiBkWTtcclxuICAgICAgdmFyIEMxWSA9IGEyIC0gYTEgLSB0aGlzLm1fcmVmQW5nbGU7XHJcbiAgICAgIGxpbmVhckVycm9yID0gYjJNYXRoLk1heChsaW5lYXJFcnJvciwgYjJNYXRoLkFicyhDMVgpKTtcclxuICAgICAgYW5ndWxhckVycm9yID0gYjJNYXRoLkFicyhDMVkpO1xyXG4gICAgICBpZiAoYWN0aXZlKSB7XHJcbiAgICAgICAgIG0xID0gdGhpcy5tX2ludk1hc3NBO1xyXG4gICAgICAgICBtMiA9IHRoaXMubV9pbnZNYXNzQjtcclxuICAgICAgICAgaTEgPSB0aGlzLm1faW52SUE7XHJcbiAgICAgICAgIGkyID0gdGhpcy5tX2ludklCO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wxLnggPSBtMSArIG0yICsgaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9zMjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMS55ID0gaTEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMS56ID0gaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fYTEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9hMjtcclxuICAgICAgICAgdGhpcy5tX0suY29sMi54ID0gdGhpcy5tX0suY29sMS55O1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnkgPSBpMSArIGkyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wyLnogPSBpMSAqIHRoaXMubV9hMSArIGkyICogdGhpcy5tX2EyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wzLnggPSB0aGlzLm1fSy5jb2wxLno7XHJcbiAgICAgICAgIHRoaXMubV9LLmNvbDMueSA9IHRoaXMubV9LLmNvbDIuejtcclxuICAgICAgICAgdGhpcy5tX0suY29sMy56ID0gbTEgKyBtMiArIGkxICogdGhpcy5tX2ExICogdGhpcy5tX2ExICsgaTIgKiB0aGlzLm1fYTIgKiB0aGlzLm1fYTI7XHJcbiAgICAgICAgIHRoaXMubV9LLlNvbHZlMzMoaW1wdWxzZSwgKC1DMVgpLCAoLUMxWSksICgtQzIpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgbTEgPSB0aGlzLm1faW52TWFzc0E7XHJcbiAgICAgICAgIG0yID0gdGhpcy5tX2ludk1hc3NCO1xyXG4gICAgICAgICBpMSA9IHRoaXMubV9pbnZJQTtcclxuICAgICAgICAgaTIgPSB0aGlzLm1faW52SUI7XHJcbiAgICAgICAgIHZhciBrMTEgPSBtMSArIG0yICsgaTEgKiB0aGlzLm1fczEgKiB0aGlzLm1fczEgKyBpMiAqIHRoaXMubV9zMiAqIHRoaXMubV9zMjtcclxuICAgICAgICAgdmFyIGsxMiA9IGkxICogdGhpcy5tX3MxICsgaTIgKiB0aGlzLm1fczI7XHJcbiAgICAgICAgIHZhciBrMjIgPSBpMSArIGkyO1xyXG4gICAgICAgICB0aGlzLm1fSy5jb2wxLlNldChrMTEsIGsxMiwgMC4wKTtcclxuICAgICAgICAgdGhpcy5tX0suY29sMi5TZXQoazEyLCBrMjIsIDAuMCk7XHJcbiAgICAgICAgIHZhciBpbXB1bHNlMSA9IHRoaXMubV9LLlNvbHZlMjIobmV3IGIyVmVjMigpLCAoLUMxWCksICgtQzFZKSk7XHJcbiAgICAgICAgIGltcHVsc2UueCA9IGltcHVsc2UxLng7XHJcbiAgICAgICAgIGltcHVsc2UueSA9IGltcHVsc2UxLnk7XHJcbiAgICAgICAgIGltcHVsc2UueiA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgUFggPSBpbXB1bHNlLnggKiB0aGlzLm1fcGVycC54ICsgaW1wdWxzZS56ICogdGhpcy5tX2F4aXMueDtcclxuICAgICAgdmFyIFBZID0gaW1wdWxzZS54ICogdGhpcy5tX3BlcnAueSArIGltcHVsc2UueiAqIHRoaXMubV9heGlzLnk7XHJcbiAgICAgIHZhciBMMSA9IGltcHVsc2UueCAqIHRoaXMubV9zMSArIGltcHVsc2UueSArIGltcHVsc2UueiAqIHRoaXMubV9hMTtcclxuICAgICAgdmFyIEwyID0gaW1wdWxzZS54ICogdGhpcy5tX3MyICsgaW1wdWxzZS55ICsgaW1wdWxzZS56ICogdGhpcy5tX2EyO1xyXG4gICAgICBjMS54IC09IHRoaXMubV9pbnZNYXNzQSAqIFBYO1xyXG4gICAgICBjMS55IC09IHRoaXMubV9pbnZNYXNzQSAqIFBZO1xyXG4gICAgICBhMSAtPSB0aGlzLm1faW52SUEgKiBMMTtcclxuICAgICAgYzIueCArPSB0aGlzLm1faW52TWFzc0IgKiBQWDtcclxuICAgICAgYzIueSArPSB0aGlzLm1faW52TWFzc0IgKiBQWTtcclxuICAgICAgYTIgKz0gdGhpcy5tX2ludklCICogTDI7XHJcbiAgICAgIGJBLm1fc3dlZXAuYSA9IGExO1xyXG4gICAgICBiQi5tX3N3ZWVwLmEgPSBhMjtcclxuICAgICAgYkEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcclxuICAgfVxyXG4gICBCb3gyRC5pbmhlcml0KGIyUHJpc21hdGljSm9pbnREZWYsIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmKTtcclxuICAgYjJQcmlzbWF0aWNKb2ludERlZi5wcm90b3R5cGUuX19zdXBlciA9IEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLnByb3RvdHlwZTtcclxuICAgYjJQcmlzbWF0aWNKb2ludERlZi5iMlByaXNtYXRpY0pvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5iMkpvaW50RGVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5sb2NhbEF4aXNBID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMlByaXNtYXRpY0pvaW50RGVmLnByb3RvdHlwZS5iMlByaXNtYXRpY0pvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfcHJpc21hdGljSm9pbnQ7XHJcbiAgICAgIHRoaXMubG9jYWxBeGlzQS5TZXQoMS4wLCAwLjApO1xyXG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gMC4wO1xyXG4gICAgICB0aGlzLmVuYWJsZUxpbWl0ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubG93ZXJUcmFuc2xhdGlvbiA9IDAuMDtcclxuICAgICAgdGhpcy51cHBlclRyYW5zbGF0aW9uID0gMC4wO1xyXG4gICAgICB0aGlzLmVuYWJsZU1vdG9yID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubWF4TW90b3JGb3JjZSA9IDAuMDtcclxuICAgICAgdGhpcy5tb3RvclNwZWVkID0gMC4wO1xyXG4gICB9XHJcbiAgIGIyUHJpc21hdGljSm9pbnREZWYucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoYkEsIGJCLCBhbmNob3IsIGF4aXMpIHtcclxuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xyXG4gICAgICB0aGlzLmJvZHlCID0gYkI7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvcik7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gdGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcik7XHJcbiAgICAgIHRoaXMubG9jYWxBeGlzQSA9IHRoaXMuYm9keUEuR2V0TG9jYWxWZWN0b3IoYXhpcyk7XHJcbiAgICAgIHRoaXMucmVmZXJlbmNlQW5nbGUgPSB0aGlzLmJvZHlCLkdldEFuZ2xlKCkgLSB0aGlzLmJvZHlBLkdldEFuZ2xlKCk7XHJcbiAgIH1cclxuICAgQm94MkQuaW5oZXJpdChiMlB1bGxleUpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XHJcbiAgIGIyUHVsbGV5Sm9pbnQuYjJQdWxsZXlKb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLm1fZ3JvdW5kQW5jaG9yMSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX2dyb3VuZEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubV91MSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5tX3UyID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgIH1cclxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5Qi5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvcjIpO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdTIueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UgKiB0aGlzLm1fdTIueSk7XHJcbiAgIH1cclxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0UmVhY3Rpb25Ub3JxdWUgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIDAuMDtcclxuICAgfVxyXG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5HZXRHcm91bmRBbmNob3JBID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi5Db3B5KCk7XHJcbiAgICAgIGEuQWRkKHRoaXMubV9ncm91bmRBbmNob3IxKTtcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgIH1cclxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuR2V0R3JvdW5kQW5jaG9yQiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGEgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24uQ29weSgpO1xyXG4gICAgICBhLkFkZCh0aGlzLm1fZ3JvdW5kQW5jaG9yMik7XHJcbiAgICAgIHJldHVybiBhO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldExlbmd0aDEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwID0gdGhpcy5tX2JvZHlBLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMSk7XHJcbiAgICAgIHZhciBzWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjEueDtcclxuICAgICAgdmFyIHNZID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnkgKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMS55O1xyXG4gICAgICB2YXIgZFggPSBwLnggLSBzWDtcclxuICAgICAgdmFyIGRZID0gcC55IC0gc1k7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldExlbmd0aDIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwID0gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yMik7XHJcbiAgICAgIHZhciBzWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueDtcclxuICAgICAgdmFyIHNZID0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnkgKyB0aGlzLm1fZ3JvdW5kQW5jaG9yMi55O1xyXG4gICAgICB2YXIgZFggPSBwLnggLSBzWDtcclxuICAgICAgdmFyIGRZID0gcC55IC0gc1k7XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkdldFJhdGlvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX3JhdGlvO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLmIyUHVsbGV5Sm9pbnQgPSBmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgIHRoaXMuX19zdXBlci5iMkpvaW50LmNhbGwodGhpcywgZGVmKTtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciB0WSA9IDA7XHJcbiAgICAgIHRoaXMubV9ncm91bmQgPSB0aGlzLm1fYm9keUEubV93b3JsZC5tX2dyb3VuZEJvZHk7XHJcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IxLnggPSBkZWYuZ3JvdW5kQW5jaG9yQS54IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IxLnkgPSBkZWYuZ3JvdW5kQW5jaG9yQS55IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnk7XHJcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyLnggPSBkZWYuZ3JvdW5kQW5jaG9yQi54IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMubV9ncm91bmRBbmNob3IyLnkgPSBkZWYuZ3JvdW5kQW5jaG9yQi55IC0gdGhpcy5tX2dyb3VuZC5tX3hmLnBvc2l0aW9uLnk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjEuU2V0VihkZWYubG9jYWxBbmNob3JBKTtcclxuICAgICAgdGhpcy5tX2xvY2FsQW5jaG9yMi5TZXRWKGRlZi5sb2NhbEFuY2hvckIpO1xyXG4gICAgICB0aGlzLm1fcmF0aW8gPSBkZWYucmF0aW87XHJcbiAgICAgIHRoaXMubV9jb25zdGFudCA9IGRlZi5sZW5ndGhBICsgdGhpcy5tX3JhdGlvICogZGVmLmxlbmd0aEI7XHJcbiAgICAgIHRoaXMubV9tYXhMZW5ndGgxID0gYjJNYXRoLk1pbihkZWYubWF4TGVuZ3RoQSwgdGhpcy5tX2NvbnN0YW50IC0gdGhpcy5tX3JhdGlvICogYjJQdWxsZXlKb2ludC5iMl9taW5QdWxsZXlMZW5ndGgpO1xyXG4gICAgICB0aGlzLm1fbWF4TGVuZ3RoMiA9IGIyTWF0aC5NaW4oZGVmLm1heExlbmd0aEIsICh0aGlzLm1fY29uc3RhbnQgLSBiMlB1bGxleUpvaW50LmIyX21pblB1bGxleUxlbmd0aCkgLyB0aGlzLm1fcmF0aW8pO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcclxuICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTEgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyID0gMC4wO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnQucHJvdG90eXBlLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB0TWF0ID0gYkEubV94Zi5SO1xyXG4gICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB2YXIgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XHJcbiAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcclxuICAgICAgcjFYID0gdFg7XHJcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgIHZhciByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xyXG4gICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XHJcbiAgICAgIHIyWCA9IHRYO1xyXG4gICAgICB2YXIgcDFYID0gYkEubV9zd2VlcC5jLnggKyByMVg7XHJcbiAgICAgIHZhciBwMVkgPSBiQS5tX3N3ZWVwLmMueSArIHIxWTtcclxuICAgICAgdmFyIHAyWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYO1xyXG4gICAgICB2YXIgcDJZID0gYkIubV9zd2VlcC5jLnkgKyByMlk7XHJcbiAgICAgIHZhciBzMVggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IxLng7XHJcbiAgICAgIHZhciBzMVkgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueSArIHRoaXMubV9ncm91bmRBbmNob3IxLnk7XHJcbiAgICAgIHZhciBzMlggPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueCArIHRoaXMubV9ncm91bmRBbmNob3IyLng7XHJcbiAgICAgIHZhciBzMlkgPSB0aGlzLm1fZ3JvdW5kLm1feGYucG9zaXRpb24ueSArIHRoaXMubV9ncm91bmRBbmNob3IyLnk7XHJcbiAgICAgIHRoaXMubV91MS5TZXQocDFYIC0gczFYLCBwMVkgLSBzMVkpO1xyXG4gICAgICB0aGlzLm1fdTIuU2V0KHAyWCAtIHMyWCwgcDJZIC0gczJZKTtcclxuICAgICAgdmFyIGxlbmd0aDEgPSB0aGlzLm1fdTEuTGVuZ3RoKCk7XHJcbiAgICAgIHZhciBsZW5ndGgyID0gdGhpcy5tX3UyLkxlbmd0aCgpO1xyXG4gICAgICBpZiAobGVuZ3RoMSA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xyXG4gICAgICAgICB0aGlzLm1fdTEuTXVsdGlwbHkoMS4wIC8gbGVuZ3RoMSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV91MS5TZXRaZXJvKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlbmd0aDIgPiBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3ApIHtcclxuICAgICAgICAgdGhpcy5tX3UyLk11bHRpcGx5KDEuMCAvIGxlbmd0aDIpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1fdTIuU2V0WmVybygpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBDID0gdGhpcy5tX2NvbnN0YW50IC0gbGVuZ3RoMSAtIHRoaXMubV9yYXRpbyAqIGxlbmd0aDI7XHJcbiAgICAgIGlmIChDID4gMC4wKSB7XHJcbiAgICAgICAgIHRoaXMubV9zdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX3N0YXRlID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAobGVuZ3RoMSA8IHRoaXMubV9tYXhMZW5ndGgxKSB7XHJcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlMSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUxID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAobGVuZ3RoMiA8IHRoaXMubV9tYXhMZW5ndGgyKSB7XHJcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlMiA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMiA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUyID0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY3IxdTEgPSByMVggKiB0aGlzLm1fdTEueSAtIHIxWSAqIHRoaXMubV91MS54O1xyXG4gICAgICB2YXIgY3IydTIgPSByMlggKiB0aGlzLm1fdTIueSAtIHIyWSAqIHRoaXMubV91Mi54O1xyXG4gICAgICB0aGlzLm1fbGltaXRNYXNzMSA9IGJBLm1faW52TWFzcyArIGJBLm1faW52SSAqIGNyMXUxICogY3IxdTE7XHJcbiAgICAgIHRoaXMubV9saW1pdE1hc3MyID0gYkIubV9pbnZNYXNzICsgYkIubV9pbnZJICogY3IydTIgKiBjcjJ1MjtcclxuICAgICAgdGhpcy5tX3B1bGxleU1hc3MgPSB0aGlzLm1fbGltaXRNYXNzMSArIHRoaXMubV9yYXRpbyAqIHRoaXMubV9yYXRpbyAqIHRoaXMubV9saW1pdE1hc3MyO1xyXG4gICAgICB0aGlzLm1fbGltaXRNYXNzMSA9IDEuMCAvIHRoaXMubV9saW1pdE1hc3MxO1xyXG4gICAgICB0aGlzLm1fbGltaXRNYXNzMiA9IDEuMCAvIHRoaXMubV9saW1pdE1hc3MyO1xyXG4gICAgICB0aGlzLm1fcHVsbGV5TWFzcyA9IDEuMCAvIHRoaXMubV9wdWxsZXlNYXNzO1xyXG4gICAgICBpZiAoc3RlcC53YXJtU3RhcnRpbmcpIHtcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgIHRoaXMubV9saW1pdEltcHVsc2UyICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdmFyIFAxWCA9ICgoLXRoaXMubV9pbXB1bHNlKSAtIHRoaXMubV9saW1pdEltcHVsc2UxKSAqIHRoaXMubV91MS54O1xyXG4gICAgICAgICB2YXIgUDFZID0gKCgtdGhpcy5tX2ltcHVsc2UpIC0gdGhpcy5tX2xpbWl0SW1wdWxzZTEpICogdGhpcy5tX3UxLnk7XHJcbiAgICAgICAgIHZhciBQMlggPSAoKC10aGlzLm1fcmF0aW8gKiB0aGlzLm1faW1wdWxzZSkgLSB0aGlzLm1fbGltaXRJbXB1bHNlMikgKiB0aGlzLm1fdTIueDtcclxuICAgICAgICAgdmFyIFAyWSA9ICgoLXRoaXMubV9yYXRpbyAqIHRoaXMubV9pbXB1bHNlKSAtIHRoaXMubV9saW1pdEltcHVsc2UyKSAqIHRoaXMubV91Mi55O1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkEubV9pbnZNYXNzICogUDFYO1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkEubV9pbnZNYXNzICogUDFZO1xyXG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQS5tX2ludkkgKiAocjFYICogUDFZIC0gcjFZICogUDFYKTtcclxuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS54ICs9IGJCLm1faW52TWFzcyAqIFAyWDtcclxuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IGJCLm1faW52TWFzcyAqIFAyWTtcclxuICAgICAgICAgYkIubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkIubV9pbnZJICogKHIyWCAqIFAyWSAtIHIyWSAqIFAyWCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlID0gMC4wO1xyXG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IDAuMDtcclxuICAgICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTIgPSAwLjA7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMlB1bGxleUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHZhciB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICByMVggPSB0WDtcclxuICAgICAgdE1hdCA9IGJCLm1feGYuUjtcclxuICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgcjJYID0gdFg7XHJcbiAgICAgIHZhciB2MVggPSAwO1xyXG4gICAgICB2YXIgdjFZID0gMDtcclxuICAgICAgdmFyIHYyWCA9IDA7XHJcbiAgICAgIHZhciB2MlkgPSAwO1xyXG4gICAgICB2YXIgUDFYID0gMDtcclxuICAgICAgdmFyIFAxWSA9IDA7XHJcbiAgICAgIHZhciBQMlggPSAwO1xyXG4gICAgICB2YXIgUDJZID0gMDtcclxuICAgICAgdmFyIENkb3QgPSAwO1xyXG4gICAgICB2YXIgaW1wdWxzZSA9IDA7XHJcbiAgICAgIHZhciBvbGRJbXB1bHNlID0gMDtcclxuICAgICAgaWYgKHRoaXMubV9zdGF0ZSA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XHJcbiAgICAgICAgIHYxWCA9IGJBLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFZKSk7XHJcbiAgICAgICAgIHYxWSA9IGJBLm1fbGluZWFyVmVsb2NpdHkueSArIChiQS5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIxWCk7XHJcbiAgICAgICAgIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XHJcbiAgICAgICAgIHYyWSA9IGJCLm1fbGluZWFyVmVsb2NpdHkueSArIChiQi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIyWCk7XHJcbiAgICAgICAgIENkb3QgPSAoLSh0aGlzLm1fdTEueCAqIHYxWCArIHRoaXMubV91MS55ICogdjFZKSkgLSB0aGlzLm1fcmF0aW8gKiAodGhpcy5tX3UyLnggKiB2MlggKyB0aGlzLm1fdTIueSAqIHYyWSk7XHJcbiAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fcHVsbGV5TWFzcyAqICgoLUNkb3QpKTtcclxuICAgICAgICAgb2xkSW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlO1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZSA9IGIyTWF0aC5NYXgoMC4wLCB0aGlzLm1faW1wdWxzZSArIGltcHVsc2UpO1xyXG4gICAgICAgICBpbXB1bHNlID0gdGhpcy5tX2ltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG4gICAgICAgICBQMVggPSAoLWltcHVsc2UgKiB0aGlzLm1fdTEueCk7XHJcbiAgICAgICAgIFAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcclxuICAgICAgICAgUDJYID0gKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlICogdGhpcy5tX3UyLngpO1xyXG4gICAgICAgICBQMlkgPSAoLXRoaXMubV9yYXRpbyAqIGltcHVsc2UgKiB0aGlzLm1fdTIueSk7XHJcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQS5tX2ludk1hc3MgKiBQMVg7XHJcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQS5tX2ludk1hc3MgKiBQMVk7XHJcbiAgICAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJBLm1faW52SSAqIChyMVggKiBQMVkgLSByMVkgKiBQMVgpO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gYkIubV9pbnZNYXNzICogUDJYO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gYkIubV9pbnZNYXNzICogUDJZO1xyXG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBiQi5tX2ludkkgKiAocjJYICogUDJZIC0gcjJZICogUDJYKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUxID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcclxuICAgICAgICAgdjFYID0gYkEubV9saW5lYXJWZWxvY2l0eS54ICsgKCgtYkEubV9hbmd1bGFyVmVsb2NpdHkgKiByMVkpKTtcclxuICAgICAgICAgdjFZID0gYkEubV9saW5lYXJWZWxvY2l0eS55ICsgKGJBLm1fYW5ndWxhclZlbG9jaXR5ICogcjFYKTtcclxuICAgICAgICAgQ2RvdCA9ICgtKHRoaXMubV91MS54ICogdjFYICsgdGhpcy5tX3UxLnkgKiB2MVkpKTtcclxuICAgICAgICAgaW1wdWxzZSA9ICgtdGhpcy5tX2xpbWl0TWFzczEgKiBDZG90KTtcclxuICAgICAgICAgb2xkSW1wdWxzZSA9IHRoaXMubV9saW1pdEltcHVsc2UxO1xyXG4gICAgICAgICB0aGlzLm1fbGltaXRJbXB1bHNlMSA9IGIyTWF0aC5NYXgoMC4wLCB0aGlzLm1fbGltaXRJbXB1bHNlMSArIGltcHVsc2UpO1xyXG4gICAgICAgICBpbXB1bHNlID0gdGhpcy5tX2xpbWl0SW1wdWxzZTEgLSBvbGRJbXB1bHNlO1xyXG4gICAgICAgICBQMVggPSAoLWltcHVsc2UgKiB0aGlzLm1fdTEueCk7XHJcbiAgICAgICAgIFAxWSA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS55KTtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS54ICs9IGJBLm1faW52TWFzcyAqIFAxWDtcclxuICAgICAgICAgYkEubV9saW5lYXJWZWxvY2l0eS55ICs9IGJBLm1faW52TWFzcyAqIFAxWTtcclxuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgKz0gYkEubV9pbnZJICogKHIxWCAqIFAxWSAtIHIxWSAqIFAxWCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9saW1pdFN0YXRlMiA9PSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XHJcbiAgICAgICAgIHYyWCA9IGJCLm1fbGluZWFyVmVsb2NpdHkueCArICgoLWJCLm1fYW5ndWxhclZlbG9jaXR5ICogcjJZKSk7XHJcbiAgICAgICAgIHYyWSA9IGJCLm1fbGluZWFyVmVsb2NpdHkueSArIChiQi5tX2FuZ3VsYXJWZWxvY2l0eSAqIHIyWCk7XHJcbiAgICAgICAgIENkb3QgPSAoLSh0aGlzLm1fdTIueCAqIHYyWCArIHRoaXMubV91Mi55ICogdjJZKSk7XHJcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MyICogQ2RvdCk7XHJcbiAgICAgICAgIG9sZEltcHVsc2UgPSB0aGlzLm1fbGltaXRJbXB1bHNlMjtcclxuICAgICAgICAgdGhpcy5tX2xpbWl0SW1wdWxzZTIgPSBiMk1hdGguTWF4KDAuMCwgdGhpcy5tX2xpbWl0SW1wdWxzZTIgKyBpbXB1bHNlKTtcclxuICAgICAgICAgaW1wdWxzZSA9IHRoaXMubV9saW1pdEltcHVsc2UyIC0gb2xkSW1wdWxzZTtcclxuICAgICAgICAgUDJYID0gKC1pbXB1bHNlICogdGhpcy5tX3UyLngpO1xyXG4gICAgICAgICBQMlkgPSAoLWltcHVsc2UgKiB0aGlzLm1fdTIueSk7XHJcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueCArPSBiQi5tX2ludk1hc3MgKiBQMlg7XHJcbiAgICAgICAgIGJCLm1fbGluZWFyVmVsb2NpdHkueSArPSBiQi5tX2ludk1hc3MgKiBQMlk7XHJcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGJCLm1faW52SSAqIChyMlggKiBQMlkgLSByMlkgKiBQMlgpO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJQdWxsZXlKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xyXG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHMxWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjEueDtcclxuICAgICAgdmFyIHMxWSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjEueTtcclxuICAgICAgdmFyIHMyWCA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi54ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueDtcclxuICAgICAgdmFyIHMyWSA9IHRoaXMubV9ncm91bmQubV94Zi5wb3NpdGlvbi55ICsgdGhpcy5tX2dyb3VuZEFuY2hvcjIueTtcclxuICAgICAgdmFyIHIxWCA9IDA7XHJcbiAgICAgIHZhciByMVkgPSAwO1xyXG4gICAgICB2YXIgcjJYID0gMDtcclxuICAgICAgdmFyIHIyWSA9IDA7XHJcbiAgICAgIHZhciBwMVggPSAwO1xyXG4gICAgICB2YXIgcDFZID0gMDtcclxuICAgICAgdmFyIHAyWCA9IDA7XHJcbiAgICAgIHZhciBwMlkgPSAwO1xyXG4gICAgICB2YXIgbGVuZ3RoMSA9IDA7XHJcbiAgICAgIHZhciBsZW5ndGgyID0gMDtcclxuICAgICAgdmFyIEMgPSAwO1xyXG4gICAgICB2YXIgaW1wdWxzZSA9IDA7XHJcbiAgICAgIHZhciBvbGRJbXB1bHNlID0gMDtcclxuICAgICAgdmFyIG9sZExpbWl0UG9zaXRpb25JbXB1bHNlID0gMDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIGxpbmVhckVycm9yID0gMC4wO1xyXG4gICAgICBpZiAodGhpcy5tX3N0YXRlID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcclxuICAgICAgICAgdE1hdCA9IGJBLm1feGYuUjtcclxuICAgICAgICAgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICAgICByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xyXG4gICAgICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XHJcbiAgICAgICAgIHIxWCA9IHRYO1xyXG4gICAgICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICAgICByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgICAgIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgICAgcjJYID0gdFg7XHJcbiAgICAgICAgIHAxWCA9IGJBLm1fc3dlZXAuYy54ICsgcjFYO1xyXG4gICAgICAgICBwMVkgPSBiQS5tX3N3ZWVwLmMueSArIHIxWTtcclxuICAgICAgICAgcDJYID0gYkIubV9zd2VlcC5jLnggKyByMlg7XHJcbiAgICAgICAgIHAyWSA9IGJCLm1fc3dlZXAuYy55ICsgcjJZO1xyXG4gICAgICAgICB0aGlzLm1fdTEuU2V0KHAxWCAtIHMxWCwgcDFZIC0gczFZKTtcclxuICAgICAgICAgdGhpcy5tX3UyLlNldChwMlggLSBzMlgsIHAyWSAtIHMyWSk7XHJcbiAgICAgICAgIGxlbmd0aDEgPSB0aGlzLm1fdTEuTGVuZ3RoKCk7XHJcbiAgICAgICAgIGxlbmd0aDIgPSB0aGlzLm1fdTIuTGVuZ3RoKCk7XHJcbiAgICAgICAgIGlmIChsZW5ndGgxID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV91MS5NdWx0aXBseSgxLjAgLyBsZW5ndGgxKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tX3UxLlNldFplcm8oKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBpZiAobGVuZ3RoMiA+IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCkge1xyXG4gICAgICAgICAgICB0aGlzLm1fdTIuTXVsdGlwbHkoMS4wIC8gbGVuZ3RoMik7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubV91Mi5TZXRaZXJvKCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgQyA9IHRoaXMubV9jb25zdGFudCAtIGxlbmd0aDEgLSB0aGlzLm1fcmF0aW8gKiBsZW5ndGgyO1xyXG4gICAgICAgICBsaW5lYXJFcnJvciA9IGIyTWF0aC5NYXgobGluZWFyRXJyb3IsICgtQykpO1xyXG4gICAgICAgICBDID0gYjJNYXRoLkNsYW1wKEMgKyBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AsICgtYjJTZXR0aW5ncy5iMl9tYXhMaW5lYXJDb3JyZWN0aW9uKSwgMC4wKTtcclxuICAgICAgICAgaW1wdWxzZSA9ICgtdGhpcy5tX3B1bGxleU1hc3MgKiBDKTtcclxuICAgICAgICAgcDFYID0gKC1pbXB1bHNlICogdGhpcy5tX3UxLngpO1xyXG4gICAgICAgICBwMVkgPSAoLWltcHVsc2UgKiB0aGlzLm1fdTEueSk7XHJcbiAgICAgICAgIHAyWCA9ICgtdGhpcy5tX3JhdGlvICogaW1wdWxzZSAqIHRoaXMubV91Mi54KTtcclxuICAgICAgICAgcDJZID0gKC10aGlzLm1fcmF0aW8gKiBpbXB1bHNlICogdGhpcy5tX3UyLnkpO1xyXG4gICAgICAgICBiQS5tX3N3ZWVwLmMueCArPSBiQS5tX2ludk1hc3MgKiBwMVg7XHJcbiAgICAgICAgIGJBLm1fc3dlZXAuYy55ICs9IGJBLm1faW52TWFzcyAqIHAxWTtcclxuICAgICAgICAgYkEubV9zd2VlcC5hICs9IGJBLm1faW52SSAqIChyMVggKiBwMVkgLSByMVkgKiBwMVgpO1xyXG4gICAgICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBwMlg7XHJcbiAgICAgICAgIGJCLm1fc3dlZXAuYy55ICs9IGJCLm1faW52TWFzcyAqIHAyWTtcclxuICAgICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBwMlkgLSByMlkgKiBwMlgpO1xyXG4gICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZTEgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xyXG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xyXG4gICAgICAgICByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgICAgIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XHJcbiAgICAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcclxuICAgICAgICAgcjFYID0gdFg7XHJcbiAgICAgICAgIHAxWCA9IGJBLm1fc3dlZXAuYy54ICsgcjFYO1xyXG4gICAgICAgICBwMVkgPSBiQS5tX3N3ZWVwLmMueSArIHIxWTtcclxuICAgICAgICAgdGhpcy5tX3UxLlNldChwMVggLSBzMVgsIHAxWSAtIHMxWSk7XHJcbiAgICAgICAgIGxlbmd0aDEgPSB0aGlzLm1fdTEuTGVuZ3RoKCk7XHJcbiAgICAgICAgIGlmIChsZW5ndGgxID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV91MS54ICo9IDEuMCAvIGxlbmd0aDE7XHJcbiAgICAgICAgICAgIHRoaXMubV91MS55ICo9IDEuMCAvIGxlbmd0aDE7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubV91MS5TZXRaZXJvKCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgQyA9IHRoaXMubV9tYXhMZW5ndGgxIC0gbGVuZ3RoMTtcclxuICAgICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCAoLUMpKTtcclxuICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XHJcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MxICogQyk7XHJcbiAgICAgICAgIHAxWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91MS54KTtcclxuICAgICAgICAgcDFZID0gKC1pbXB1bHNlICogdGhpcy5tX3UxLnkpO1xyXG4gICAgICAgICBiQS5tX3N3ZWVwLmMueCArPSBiQS5tX2ludk1hc3MgKiBwMVg7XHJcbiAgICAgICAgIGJBLm1fc3dlZXAuYy55ICs9IGJBLm1faW52TWFzcyAqIHAxWTtcclxuICAgICAgICAgYkEubV9zd2VlcC5hICs9IGJBLm1faW52SSAqIChyMVggKiBwMVkgLSByMVkgKiBwMVgpO1xyXG4gICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZTIgPT0gYjJKb2ludC5lX2F0VXBwZXJMaW1pdCkge1xyXG4gICAgICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICAgICByMlggPSB0aGlzLm1fbG9jYWxBbmNob3IyLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgICAgIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgICAgcjJYID0gdFg7XHJcbiAgICAgICAgIHAyWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYO1xyXG4gICAgICAgICBwMlkgPSBiQi5tX3N3ZWVwLmMueSArIHIyWTtcclxuICAgICAgICAgdGhpcy5tX3UyLlNldChwMlggLSBzMlgsIHAyWSAtIHMyWSk7XHJcbiAgICAgICAgIGxlbmd0aDIgPSB0aGlzLm1fdTIuTGVuZ3RoKCk7XHJcbiAgICAgICAgIGlmIChsZW5ndGgyID4gYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMubV91Mi54ICo9IDEuMCAvIGxlbmd0aDI7XHJcbiAgICAgICAgICAgIHRoaXMubV91Mi55ICo9IDEuMCAvIGxlbmd0aDI7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubV91Mi5TZXRaZXJvKCk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgQyA9IHRoaXMubV9tYXhMZW5ndGgyIC0gbGVuZ3RoMjtcclxuICAgICAgICAgbGluZWFyRXJyb3IgPSBiMk1hdGguTWF4KGxpbmVhckVycm9yLCAoLUMpKTtcclxuICAgICAgICAgQyA9IGIyTWF0aC5DbGFtcChDICsgYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wLCAoLWIyU2V0dGluZ3MuYjJfbWF4TGluZWFyQ29ycmVjdGlvbiksIDAuMCk7XHJcbiAgICAgICAgIGltcHVsc2UgPSAoLXRoaXMubV9saW1pdE1hc3MyICogQyk7XHJcbiAgICAgICAgIHAyWCA9ICgtaW1wdWxzZSAqIHRoaXMubV91Mi54KTtcclxuICAgICAgICAgcDJZID0gKC1pbXB1bHNlICogdGhpcy5tX3UyLnkpO1xyXG4gICAgICAgICBiQi5tX3N3ZWVwLmMueCArPSBiQi5tX2ludk1hc3MgKiBwMlg7XHJcbiAgICAgICAgIGJCLm1fc3dlZXAuYy55ICs9IGJCLm1faW52TWFzcyAqIHAyWTtcclxuICAgICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBwMlkgLSByMlkgKiBwMlgpO1xyXG4gICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcclxuICAgfVxyXG4gICBCb3gyRC5wb3N0RGVmcy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIyUHVsbGV5Sm9pbnQuYjJfbWluUHVsbGV5TGVuZ3RoID0gMi4wO1xyXG4gICB9KTtcclxuICAgQm94MkQuaW5oZXJpdChiMlB1bGxleUpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XHJcbiAgIGIyUHVsbGV5Sm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XHJcbiAgIGIyUHVsbGV5Sm9pbnREZWYuYjJQdWxsZXlKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMuZ3JvdW5kQW5jaG9yQiA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMlB1bGxleUpvaW50RGVmLnByb3RvdHlwZS5iMlB1bGxleUpvaW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9fc3VwZXIuYjJKb2ludERlZi5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLnR5cGUgPSBiMkpvaW50LmVfcHVsbGV5Sm9pbnQ7XHJcbiAgICAgIHRoaXMuZ3JvdW5kQW5jaG9yQS5TZXQoKC0xLjApLCAxLjApO1xyXG4gICAgICB0aGlzLmdyb3VuZEFuY2hvckIuU2V0KDEuMCwgMS4wKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEuU2V0KCgtMS4wKSwgMC4wKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckIuU2V0KDEuMCwgMC4wKTtcclxuICAgICAgdGhpcy5sZW5ndGhBID0gMC4wO1xyXG4gICAgICB0aGlzLm1heExlbmd0aEEgPSAwLjA7XHJcbiAgICAgIHRoaXMubGVuZ3RoQiA9IDAuMDtcclxuICAgICAgdGhpcy5tYXhMZW5ndGhCID0gMC4wO1xyXG4gICAgICB0aGlzLnJhdGlvID0gMS4wO1xyXG4gICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSB0cnVlO1xyXG4gICB9XHJcbiAgIGIyUHVsbGV5Sm9pbnREZWYucHJvdG90eXBlLkluaXRpYWxpemUgPSBmdW5jdGlvbiAoYkEsIGJCLCBnYUEsIGdhQiwgYW5jaG9yQSwgYW5jaG9yQiwgcikge1xyXG4gICAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByID0gMDtcclxuICAgICAgdGhpcy5ib2R5QSA9IGJBO1xyXG4gICAgICB0aGlzLmJvZHlCID0gYkI7XHJcbiAgICAgIHRoaXMuZ3JvdW5kQW5jaG9yQS5TZXRWKGdhQSk7XHJcbiAgICAgIHRoaXMuZ3JvdW5kQW5jaG9yQi5TZXRWKGdhQik7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBID0gdGhpcy5ib2R5QS5HZXRMb2NhbFBvaW50KGFuY2hvckEpO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQiA9IHRoaXMuYm9keUIuR2V0TG9jYWxQb2ludChhbmNob3JCKTtcclxuICAgICAgdmFyIGQxWCA9IGFuY2hvckEueCAtIGdhQS54O1xyXG4gICAgICB2YXIgZDFZID0gYW5jaG9yQS55IC0gZ2FBLnk7XHJcbiAgICAgIHRoaXMubGVuZ3RoQSA9IE1hdGguc3FydChkMVggKiBkMVggKyBkMVkgKiBkMVkpO1xyXG4gICAgICB2YXIgZDJYID0gYW5jaG9yQi54IC0gZ2FCLng7XHJcbiAgICAgIHZhciBkMlkgPSBhbmNob3JCLnkgLSBnYUIueTtcclxuICAgICAgdGhpcy5sZW5ndGhCID0gTWF0aC5zcXJ0KGQyWCAqIGQyWCArIGQyWSAqIGQyWSk7XHJcbiAgICAgIHRoaXMucmF0aW8gPSByO1xyXG4gICAgICB2YXIgQyA9IHRoaXMubGVuZ3RoQSArIHRoaXMucmF0aW8gKiB0aGlzLmxlbmd0aEI7XHJcbiAgICAgIHRoaXMubWF4TGVuZ3RoQSA9IEMgLSB0aGlzLnJhdGlvICogYjJQdWxsZXlKb2ludC5iMl9taW5QdWxsZXlMZW5ndGg7XHJcbiAgICAgIHRoaXMubWF4TGVuZ3RoQiA9IChDIC0gYjJQdWxsZXlKb2ludC5iMl9taW5QdWxsZXlMZW5ndGgpIC8gdGhpcy5yYXRpbztcclxuICAgfVxyXG4gICBCb3gyRC5pbmhlcml0KGIyUmV2b2x1dGVKb2ludCwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQpO1xyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludC5wcm90b3R5cGU7XHJcbiAgIGIyUmV2b2x1dGVKb2ludC5iMlJldm9sdXRlSm9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50LmIySm9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5LID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgdGhpcy5LMSA9IG5ldyBiMk1hdDIyKCk7XHJcbiAgICAgIHRoaXMuSzIgPSBuZXcgYjJNYXQyMigpO1xyXG4gICAgICB0aGlzLkszID0gbmV3IGIyTWF0MjIoKTtcclxuICAgICAgdGhpcy5pbXB1bHNlMyA9IG5ldyBiMlZlYzMoKTtcclxuICAgICAgdGhpcy5pbXB1bHNlMiA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5yZWR1Y2VkID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IyID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcclxuICAgICAgdGhpcy5tX21hc3MgPSBuZXcgYjJNYXQzMygpO1xyXG4gICB9O1xyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUEuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IxKTtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEFuY2hvckIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIuR2V0V29ybGRQb2ludCh0aGlzLm1fbG9jYWxBbmNob3IyKTtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueSk7XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5HZXRSZWFjdGlvblRvcnF1ZSA9IGZ1bmN0aW9uIChpbnZfZHQpIHtcclxuICAgICAgaWYgKGludl9kdCA9PT0gdW5kZWZpbmVkKSBpbnZfZHQgPSAwO1xyXG4gICAgICByZXR1cm4gaW52X2R0ICogdGhpcy5tX2ltcHVsc2UuejtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEpvaW50QW5nbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIubV9zd2VlcC5hIC0gdGhpcy5tX2JvZHlBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldEpvaW50U3BlZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYm9keUIubV9hbmd1bGFyVmVsb2NpdHkgLSB0aGlzLm1fYm9keUEubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5Jc0xpbWl0RW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVMaW1pdDtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkVuYWJsZUxpbWl0ID0gZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZmxhZztcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldExvd2VyTGltaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fbG93ZXJBbmdsZTtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkdldFVwcGVyTGltaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fdXBwZXJBbmdsZTtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLlNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcclxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQpIGxvd2VyID0gMDtcclxuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHVwcGVyID0gMDtcclxuICAgICAgdGhpcy5tX2xvd2VyQW5nbGUgPSBsb3dlcjtcclxuICAgICAgdGhpcy5tX3VwcGVyQW5nbGUgPSB1cHBlcjtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLklzTW90b3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fYm9keUEuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9ib2R5Qi5TZXRBd2FrZSh0cnVlKTtcclxuICAgICAgcmV0dXJuIHRoaXMubV9lbmFibGVNb3RvcjtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLkVuYWJsZU1vdG9yID0gZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgdGhpcy5tX2VuYWJsZU1vdG9yID0gZmxhZztcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLlNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcclxuICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHNwZWVkID0gMDtcclxuICAgICAgdGhpcy5tX2JvZHlBLlNldEF3YWtlKHRydWUpO1xyXG4gICAgICB0aGlzLm1fYm9keUIuU2V0QXdha2UodHJ1ZSk7XHJcbiAgICAgIHRoaXMubV9tb3RvclNwZWVkID0gc3BlZWQ7XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5HZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX21vdG9yU3BlZWQ7XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5TZXRNYXhNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uICh0b3JxdWUpIHtcclxuICAgICAgaWYgKHRvcnF1ZSA9PT0gdW5kZWZpbmVkKSB0b3JxdWUgPSAwO1xyXG4gICAgICB0aGlzLm1fbWF4TW90b3JUb3JxdWUgPSB0b3JxdWU7XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5HZXRNb3RvclRvcnF1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcclxuICAgfVxyXG4gICBiMlJldm9sdXRlSm9pbnQucHJvdG90eXBlLmIyUmV2b2x1dGVKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3IxLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvcjIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcclxuICAgICAgdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gZGVmLnJlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9tb3RvckltcHVsc2UgPSAwLjA7XHJcbiAgICAgIHRoaXMubV9sb3dlckFuZ2xlID0gZGVmLmxvd2VyQW5nbGU7XHJcbiAgICAgIHRoaXMubV91cHBlckFuZ2xlID0gZGVmLnVwcGVyQW5nbGU7XHJcbiAgICAgIHRoaXMubV9tYXhNb3RvclRvcnF1ZSA9IGRlZi5tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgdGhpcy5tX21vdG9yU3BlZWQgPSBkZWYubW90b3JTcGVlZDtcclxuICAgICAgdGhpcy5tX2VuYWJsZUxpbWl0ID0gZGVmLmVuYWJsZUxpbWl0O1xyXG4gICAgICB0aGlzLm1fZW5hYmxlTW90b3IgPSBkZWYuZW5hYmxlTW90b3I7XHJcbiAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5Jbml0VmVsb2NpdHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVNb3RvciB8fCB0aGlzLm1fZW5hYmxlTGltaXQpIHt9XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByMVkgPSB0aGlzLm1fbG9jYWxBbmNob3IxLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjFYICsgdE1hdC5jb2wyLnggKiByMVkpO1xyXG4gICAgICByMVkgPSAodE1hdC5jb2wxLnkgKiByMVggKyB0TWF0LmNvbDIueSAqIHIxWSk7XHJcbiAgICAgIHIxWCA9IHRYO1xyXG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICB2YXIgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcclxuICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xyXG4gICAgICByMlggPSB0WDtcclxuICAgICAgdmFyIG0xID0gYkEubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgbTIgPSBiQi5tX2ludk1hc3M7XHJcbiAgICAgIHZhciBpMSA9IGJBLm1faW52STtcclxuICAgICAgdmFyIGkyID0gYkIubV9pbnZJO1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnggPSBtMSArIG0yICsgcjFZICogcjFZICogaTEgKyByMlkgKiByMlkgKiBpMjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yMVkgKiByMVggKiBpMSkgLSByMlkgKiByMlggKiBpMjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMy54ID0gKC1yMVkgKiBpMSkgLSByMlkgKiBpMjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMS55ID0gdGhpcy5tX21hc3MuY29sMi54O1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtMSArIG0yICsgcjFYICogcjFYICogaTEgKyByMlggKiByMlggKiBpMjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMy55ID0gcjFYICogaTEgKyByMlggKiBpMjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMS56ID0gdGhpcy5tX21hc3MuY29sMy54O1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XHJcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueiA9IGkxICsgaTI7XHJcbiAgICAgIHRoaXMubV9tb3Rvck1hc3MgPSAxLjAgLyAoaTEgKyBpMik7XHJcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTW90b3IgPT0gZmFsc2UpIHtcclxuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IDAuMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5tX2VuYWJsZUxpbWl0KSB7XHJcbiAgICAgICAgIHZhciBqb2ludEFuZ2xlID0gYkIubV9zd2VlcC5hIC0gYkEubV9zd2VlcC5hIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICAgICBpZiAoYjJNYXRoLkFicyh0aGlzLm1fdXBwZXJBbmdsZSAtIHRoaXMubV9sb3dlckFuZ2xlKSA8IDIuMCAqIGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfZXF1YWxMaW1pdHM7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA8PSB0aGlzLm1fbG93ZXJBbmdsZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdCkge1xyXG4gICAgICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2F0TG93ZXJMaW1pdDtcclxuICAgICAgICAgfVxyXG4gICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlID49IHRoaXMubV91cHBlckFuZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfYXRVcHBlckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogPSAwLjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tX2xpbWl0U3RhdGUgPSBiMkpvaW50LmVfYXRVcHBlckxpbWl0O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1fbGltaXRTdGF0ZSA9IGIySm9pbnQuZV9pbmFjdGl2ZUxpbWl0O1xyXG4gICAgICAgICAgICB0aGlzLm1faW1wdWxzZS56ID0gMC4wO1xyXG4gICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRoaXMubV9saW1pdFN0YXRlID0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0ZXAud2FybVN0YXJ0aW5nKSB7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgIHZhciBQWCA9IHRoaXMubV9pbXB1bHNlLng7XHJcbiAgICAgICAgIHZhciBQWSA9IHRoaXMubV9pbXB1bHNlLnk7XHJcbiAgICAgICAgIGJBLm1fbGluZWFyVmVsb2NpdHkueCAtPSBtMSAqIFBYO1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbTEgKiBQWTtcclxuICAgICAgICAgYkEubV9hbmd1bGFyVmVsb2NpdHkgLT0gaTEgKiAoKHIxWCAqIFBZIC0gcjFZICogUFgpICsgdGhpcy5tX21vdG9ySW1wdWxzZSArIHRoaXMubV9pbXB1bHNlLnopO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gbTIgKiBQWDtcclxuICAgICAgICAgYkIubV9saW5lYXJWZWxvY2l0eS55ICs9IG0yICogUFk7XHJcbiAgICAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ICs9IGkyICogKChyMlggKiBQWSAtIHIyWSAqIFBYKSArIHRoaXMubV9tb3RvckltcHVsc2UgKyB0aGlzLm1faW1wdWxzZS56KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UuU2V0WmVybygpO1xyXG4gICAgICAgICB0aGlzLm1fbW90b3JJbXB1bHNlID0gMC4wO1xyXG4gICAgICB9XHJcbiAgIH1cclxuICAgYjJSZXZvbHV0ZUpvaW50LnByb3RvdHlwZS5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciBuZXdJbXB1bHNlID0gMDtcclxuICAgICAgdmFyIHIxWCA9IDA7XHJcbiAgICAgIHZhciByMVkgPSAwO1xyXG4gICAgICB2YXIgcjJYID0gMDtcclxuICAgICAgdmFyIHIyWSA9IDA7XHJcbiAgICAgIHZhciB2MSA9IGJBLm1fbGluZWFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciB3MSA9IGJBLm1fYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdjIgPSBiQi5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgdzIgPSBiQi5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIG0xID0gYkEubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgbTIgPSBiQi5tX2ludk1hc3M7XHJcbiAgICAgIHZhciBpMSA9IGJBLm1faW52STtcclxuICAgICAgdmFyIGkyID0gYkIubV9pbnZJO1xyXG4gICAgICBpZiAodGhpcy5tX2VuYWJsZU1vdG9yICYmIHRoaXMubV9saW1pdFN0YXRlICE9IGIySm9pbnQuZV9lcXVhbExpbWl0cykge1xyXG4gICAgICAgICB2YXIgQ2RvdCA9IHcyIC0gdzEgLSB0aGlzLm1fbW90b3JTcGVlZDtcclxuICAgICAgICAgdmFyIGltcHVsc2UgPSB0aGlzLm1fbW90b3JNYXNzICogKCgtQ2RvdCkpO1xyXG4gICAgICAgICB2YXIgb2xkSW1wdWxzZSA9IHRoaXMubV9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgIHZhciBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIHRoaXMubV9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICAgdGhpcy5tX21vdG9ySW1wdWxzZSA9IGIyTWF0aC5DbGFtcCh0aGlzLm1fbW90b3JJbXB1bHNlICsgaW1wdWxzZSwgKC1tYXhJbXB1bHNlKSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgIGltcHVsc2UgPSB0aGlzLm1fbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuICAgICAgICAgdzEgLT0gaTEgKiBpbXB1bHNlO1xyXG4gICAgICAgICB3MiArPSBpMiAqIGltcHVsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMubV9lbmFibGVMaW1pdCAmJiB0aGlzLm1fbGltaXRTdGF0ZSAhPSBiMkpvaW50LmVfaW5hY3RpdmVMaW1pdCkge1xyXG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xyXG4gICAgICAgICByMVggPSB0aGlzLm1fbG9jYWxBbmNob3IxLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgICAgIHIxWSA9IHRoaXMubV9sb2NhbEFuY2hvcjEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMVggKyB0TWF0LmNvbDIueCAqIHIxWSk7XHJcbiAgICAgICAgIHIxWSA9ICh0TWF0LmNvbDEueSAqIHIxWCArIHRNYXQuY29sMi55ICogcjFZKTtcclxuICAgICAgICAgcjFYID0gdFg7XHJcbiAgICAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgICAgIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgICAgcjJZID0gdGhpcy5tX2xvY2FsQW5jaG9yMi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIyWCArIHRNYXQuY29sMi54ICogcjJZKTtcclxuICAgICAgICAgcjJZID0gKHRNYXQuY29sMS55ICogcjJYICsgdE1hdC5jb2wyLnkgKiByMlkpO1xyXG4gICAgICAgICByMlggPSB0WDtcclxuICAgICAgICAgdmFyIENkb3QxWCA9IHYyLnggKyAoKC13MiAqIHIyWSkpIC0gdjEueCAtICgoLXcxICogcjFZKSk7XHJcbiAgICAgICAgIHZhciBDZG90MVkgPSB2Mi55ICsgKHcyICogcjJYKSAtIHYxLnkgLSAodzEgKiByMVgpO1xyXG4gICAgICAgICB2YXIgQ2RvdDIgPSB3MiAtIHcxO1xyXG4gICAgICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTMzKHRoaXMuaW1wdWxzZTMsICgtQ2RvdDFYKSwgKC1DZG90MVkpLCAoLUNkb3QyKSk7XHJcbiAgICAgICAgIGlmICh0aGlzLm1fbGltaXRTdGF0ZSA9PSBiMkpvaW50LmVfZXF1YWxMaW1pdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UuQWRkKHRoaXMuaW1wdWxzZTMpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcclxuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyB0aGlzLmltcHVsc2UzLno7XHJcbiAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9tYXNzLlNvbHZlMjIodGhpcy5yZWR1Y2VkLCAoLUNkb3QxWCksICgtQ2RvdDFZKSk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuaW1wdWxzZTMueCA9IHRoaXMucmVkdWNlZC54O1xyXG4gICAgICAgICAgICAgICB0aGlzLmltcHVsc2UzLnkgPSB0aGlzLnJlZHVjZWQueTtcclxuICAgICAgICAgICAgICAgdGhpcy5pbXB1bHNlMy56ID0gKC10aGlzLm1faW1wdWxzZS56KTtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSB0aGlzLnJlZHVjZWQueDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSB0aGlzLnJlZHVjZWQueTtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcclxuICAgICAgICAgICAgbmV3SW1wdWxzZSA9IHRoaXMubV9pbXB1bHNlLnogKyB0aGlzLmltcHVsc2UzLno7XHJcbiAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlID4gMC4wKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMubV9tYXNzLlNvbHZlMjIodGhpcy5yZWR1Y2VkLCAoLUNkb3QxWCksICgtQ2RvdDFZKSk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuaW1wdWxzZTMueCA9IHRoaXMucmVkdWNlZC54O1xyXG4gICAgICAgICAgICAgICB0aGlzLmltcHVsc2UzLnkgPSB0aGlzLnJlZHVjZWQueTtcclxuICAgICAgICAgICAgICAgdGhpcy5pbXB1bHNlMy56ID0gKC10aGlzLm1faW1wdWxzZS56KTtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueCArPSB0aGlzLnJlZHVjZWQueDtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSArPSB0aGlzLnJlZHVjZWQueTtcclxuICAgICAgICAgICAgICAgdGhpcy5tX2ltcHVsc2UueiA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIHYxLnggLT0gbTEgKiB0aGlzLmltcHVsc2UzLng7XHJcbiAgICAgICAgIHYxLnkgLT0gbTEgKiB0aGlzLmltcHVsc2UzLnk7XHJcbiAgICAgICAgIHcxIC09IGkxICogKHIxWCAqIHRoaXMuaW1wdWxzZTMueSAtIHIxWSAqIHRoaXMuaW1wdWxzZTMueCArIHRoaXMuaW1wdWxzZTMueik7XHJcbiAgICAgICAgIHYyLnggKz0gbTIgKiB0aGlzLmltcHVsc2UzLng7XHJcbiAgICAgICAgIHYyLnkgKz0gbTIgKiB0aGlzLmltcHVsc2UzLnk7XHJcbiAgICAgICAgIHcyICs9IGkyICogKHIyWCAqIHRoaXMuaW1wdWxzZTMueSAtIHIyWSAqIHRoaXMuaW1wdWxzZTMueCArIHRoaXMuaW1wdWxzZTMueik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgICAgIHIxWCA9IHRoaXMubV9sb2NhbEFuY2hvcjEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgICAgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICAgICByMVggPSB0WDtcclxuICAgICAgICAgdE1hdCA9IGJCLm1feGYuUjtcclxuICAgICAgICAgcjJYID0gdGhpcy5tX2xvY2FsQW5jaG9yMi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICAgICByMlkgPSB0aGlzLm1fbG9jYWxBbmNob3IyLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgICAgIHRYID0gKHRNYXQuY29sMS54ICogcjJYICsgdE1hdC5jb2wyLnggKiByMlkpO1xyXG4gICAgICAgICByMlkgPSAodE1hdC5jb2wxLnkgKiByMlggKyB0TWF0LmNvbDIueSAqIHIyWSk7XHJcbiAgICAgICAgIHIyWCA9IHRYO1xyXG4gICAgICAgICB2YXIgQ2RvdFggPSB2Mi54ICsgKCgtdzIgKiByMlkpKSAtIHYxLnggLSAoKC13MSAqIHIxWSkpO1xyXG4gICAgICAgICB2YXIgQ2RvdFkgPSB2Mi55ICsgKHcyICogcjJYKSAtIHYxLnkgLSAodzEgKiByMVgpO1xyXG4gICAgICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTIyKHRoaXMuaW1wdWxzZTIsICgtQ2RvdFgpLCAoLUNkb3RZKSk7XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnggKz0gdGhpcy5pbXB1bHNlMi54O1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS55ICs9IHRoaXMuaW1wdWxzZTIueTtcclxuICAgICAgICAgdjEueCAtPSBtMSAqIHRoaXMuaW1wdWxzZTIueDtcclxuICAgICAgICAgdjEueSAtPSBtMSAqIHRoaXMuaW1wdWxzZTIueTtcclxuICAgICAgICAgdzEgLT0gaTEgKiAocjFYICogdGhpcy5pbXB1bHNlMi55IC0gcjFZICogdGhpcy5pbXB1bHNlMi54KTtcclxuICAgICAgICAgdjIueCArPSBtMiAqIHRoaXMuaW1wdWxzZTIueDtcclxuICAgICAgICAgdjIueSArPSBtMiAqIHRoaXMuaW1wdWxzZTIueTtcclxuICAgICAgICAgdzIgKz0gaTIgKiAocjJYICogdGhpcy5pbXB1bHNlMi55IC0gcjJZICogdGhpcy5pbXB1bHNlMi54KTtcclxuICAgICAgfVxyXG4gICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LlNldFYodjEpO1xyXG4gICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcxO1xyXG4gICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LlNldFYodjIpO1xyXG4gICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSA9IHcyO1xyXG4gICB9XHJcbiAgIGIyUmV2b2x1dGVKb2ludC5wcm90b3R5cGUuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGJhdW1nYXJ0ZSkge1xyXG4gICAgICBpZiAoYmF1bWdhcnRlID09PSB1bmRlZmluZWQpIGJhdW1nYXJ0ZSA9IDA7XHJcbiAgICAgIHZhciBvbGRMaW1pdEltcHVsc2UgPSAwO1xyXG4gICAgICB2YXIgQyA9IDA7XHJcbiAgICAgIHZhciB0TWF0O1xyXG4gICAgICB2YXIgYkEgPSB0aGlzLm1fYm9keUE7XHJcbiAgICAgIHZhciBiQiA9IHRoaXMubV9ib2R5QjtcclxuICAgICAgdmFyIGFuZ3VsYXJFcnJvciA9IDAuMDtcclxuICAgICAgdmFyIHBvc2l0aW9uRXJyb3IgPSAwLjA7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciBpbXB1bHNlWCA9IDA7XHJcbiAgICAgIHZhciBpbXB1bHNlWSA9IDA7XHJcbiAgICAgIGlmICh0aGlzLm1fZW5hYmxlTGltaXQgJiYgdGhpcy5tX2xpbWl0U3RhdGUgIT0gYjJKb2ludC5lX2luYWN0aXZlTGltaXQpIHtcclxuICAgICAgICAgdmFyIGFuZ2xlID0gYkIubV9zd2VlcC5hIC0gYkEubV9zd2VlcC5hIC0gdGhpcy5tX3JlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICAgICB2YXIgbGltaXRJbXB1bHNlID0gMC4wO1xyXG4gICAgICAgICBpZiAodGhpcy5tX2xpbWl0U3RhdGUgPT0gYjJKb2ludC5lX2VxdWFsTGltaXRzKSB7XHJcbiAgICAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoYW5nbGUgLSB0aGlzLm1fbG93ZXJBbmdsZSwgKC1iMlNldHRpbmdzLmIyX21heEFuZ3VsYXJDb3JyZWN0aW9uKSwgYjJTZXR0aW5ncy5iMl9tYXhBbmd1bGFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xyXG4gICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBiMk1hdGguQWJzKEMpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdExvd2VyTGltaXQpIHtcclxuICAgICAgICAgICAgQyA9IGFuZ2xlIC0gdGhpcy5tX2xvd2VyQW5nbGU7XHJcbiAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9ICgtQyk7XHJcbiAgICAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoQyArIGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3AsICgtYjJTZXR0aW5ncy5iMl9tYXhBbmd1bGFyQ29ycmVjdGlvbiksIDAuMCk7XHJcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubV9saW1pdFN0YXRlID09IGIySm9pbnQuZV9hdFVwcGVyTGltaXQpIHtcclxuICAgICAgICAgICAgQyA9IGFuZ2xlIC0gdGhpcy5tX3VwcGVyQW5nbGU7XHJcbiAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IEM7XHJcbiAgICAgICAgICAgIEMgPSBiMk1hdGguQ2xhbXAoQyAtIGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3AsIDAuMCwgYjJTZXR0aW5ncy5iMl9tYXhBbmd1bGFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9ICgtdGhpcy5tX21vdG9yTWFzcyAqIEMpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIGJBLm1fc3dlZXAuYSAtPSBiQS5tX2ludkkgKiBsaW1pdEltcHVsc2U7XHJcbiAgICAgICAgIGJCLm1fc3dlZXAuYSArPSBiQi5tX2ludkkgKiBsaW1pdEltcHVsc2U7XHJcbiAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgIGJCLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgIH0ge1xyXG4gICAgICAgICB0TWF0ID0gYkEubV94Zi5SO1xyXG4gICAgICAgICB2YXIgcjFYID0gdGhpcy5tX2xvY2FsQW5jaG9yMS54IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICAgICB2YXIgcjFZID0gdGhpcy5tX2xvY2FsQW5jaG9yMS55IC0gYkEubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHIxWCArIHRNYXQuY29sMi54ICogcjFZKTtcclxuICAgICAgICAgcjFZID0gKHRNYXQuY29sMS55ICogcjFYICsgdE1hdC5jb2wyLnkgKiByMVkpO1xyXG4gICAgICAgICByMVggPSB0WDtcclxuICAgICAgICAgdE1hdCA9IGJCLm1feGYuUjtcclxuICAgICAgICAgdmFyIHIyWCA9IHRoaXMubV9sb2NhbEFuY2hvcjIueCAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgICAgdmFyIHIyWSA9IHRoaXMubV9sb2NhbEFuY2hvcjIueSAtIGJCLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByMlggKyB0TWF0LmNvbDIueCAqIHIyWSk7XHJcbiAgICAgICAgIHIyWSA9ICh0TWF0LmNvbDEueSAqIHIyWCArIHRNYXQuY29sMi55ICogcjJZKTtcclxuICAgICAgICAgcjJYID0gdFg7XHJcbiAgICAgICAgIHZhciBDWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XHJcbiAgICAgICAgIHZhciBDWSA9IGJCLm1fc3dlZXAuYy55ICsgcjJZIC0gYkEubV9zd2VlcC5jLnkgLSByMVk7XHJcbiAgICAgICAgIHZhciBDTGVuZ3RoU3F1YXJlZCA9IENYICogQ1ggKyBDWSAqIENZO1xyXG4gICAgICAgICB2YXIgQ0xlbmd0aCA9IE1hdGguc3FydChDTGVuZ3RoU3F1YXJlZCk7XHJcbiAgICAgICAgIHBvc2l0aW9uRXJyb3IgPSBDTGVuZ3RoO1xyXG4gICAgICAgICB2YXIgaW52TWFzczEgPSBiQS5tX2ludk1hc3M7XHJcbiAgICAgICAgIHZhciBpbnZNYXNzMiA9IGJCLm1faW52TWFzcztcclxuICAgICAgICAgdmFyIGludkkxID0gYkEubV9pbnZJO1xyXG4gICAgICAgICB2YXIgaW52STIgPSBiQi5tX2ludkk7XHJcbiAgICAgICAgIHZhciBrX2FsbG93ZWRTdHJldGNoID0gMTAuMCAqIGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcDtcclxuICAgICAgICAgaWYgKENMZW5ndGhTcXVhcmVkID4ga19hbGxvd2VkU3RyZXRjaCAqIGtfYWxsb3dlZFN0cmV0Y2gpIHtcclxuICAgICAgICAgICAgdmFyIHVYID0gQ1ggLyBDTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgdVkgPSBDWSAvIENMZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBrID0gaW52TWFzczEgKyBpbnZNYXNzMjtcclxuICAgICAgICAgICAgdmFyIG0gPSAxLjAgLyBrO1xyXG4gICAgICAgICAgICBpbXB1bHNlWCA9IG0gKiAoKC1DWCkpO1xyXG4gICAgICAgICAgICBpbXB1bHNlWSA9IG0gKiAoKC1DWSkpO1xyXG4gICAgICAgICAgICB2YXIga19iZXRhID0gMC41O1xyXG4gICAgICAgICAgICBiQS5tX3N3ZWVwLmMueCAtPSBrX2JldGEgKiBpbnZNYXNzMSAqIGltcHVsc2VYO1xyXG4gICAgICAgICAgICBiQS5tX3N3ZWVwLmMueSAtPSBrX2JldGEgKiBpbnZNYXNzMSAqIGltcHVsc2VZO1xyXG4gICAgICAgICAgICBiQi5tX3N3ZWVwLmMueCArPSBrX2JldGEgKiBpbnZNYXNzMiAqIGltcHVsc2VYO1xyXG4gICAgICAgICAgICBiQi5tX3N3ZWVwLmMueSArPSBrX2JldGEgKiBpbnZNYXNzMiAqIGltcHVsc2VZO1xyXG4gICAgICAgICAgICBDWCA9IGJCLm1fc3dlZXAuYy54ICsgcjJYIC0gYkEubV9zd2VlcC5jLnggLSByMVg7XHJcbiAgICAgICAgICAgIENZID0gYkIubV9zd2VlcC5jLnkgKyByMlkgLSBiQS5tX3N3ZWVwLmMueSAtIHIxWTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICB0aGlzLksxLmNvbDEueCA9IGludk1hc3MxICsgaW52TWFzczI7XHJcbiAgICAgICAgIHRoaXMuSzEuY29sMi54ID0gMC4wO1xyXG4gICAgICAgICB0aGlzLksxLmNvbDEueSA9IDAuMDtcclxuICAgICAgICAgdGhpcy5LMS5jb2wyLnkgPSBpbnZNYXNzMSArIGludk1hc3MyO1xyXG4gICAgICAgICB0aGlzLksyLmNvbDEueCA9IGludkkxICogcjFZICogcjFZO1xyXG4gICAgICAgICB0aGlzLksyLmNvbDIueCA9ICgtaW52STEgKiByMVggKiByMVkpO1xyXG4gICAgICAgICB0aGlzLksyLmNvbDEueSA9ICgtaW52STEgKiByMVggKiByMVkpO1xyXG4gICAgICAgICB0aGlzLksyLmNvbDIueSA9IGludkkxICogcjFYICogcjFYO1xyXG4gICAgICAgICB0aGlzLkszLmNvbDEueCA9IGludkkyICogcjJZICogcjJZO1xyXG4gICAgICAgICB0aGlzLkszLmNvbDIueCA9ICgtaW52STIgKiByMlggKiByMlkpO1xyXG4gICAgICAgICB0aGlzLkszLmNvbDEueSA9ICgtaW52STIgKiByMlggKiByMlkpO1xyXG4gICAgICAgICB0aGlzLkszLmNvbDIueSA9IGludkkyICogcjJYICogcjJYO1xyXG4gICAgICAgICB0aGlzLksuU2V0TSh0aGlzLksxKTtcclxuICAgICAgICAgdGhpcy5LLkFkZE0odGhpcy5LMik7XHJcbiAgICAgICAgIHRoaXMuSy5BZGRNKHRoaXMuSzMpO1xyXG4gICAgICAgICB0aGlzLksuU29sdmUoYjJSZXZvbHV0ZUpvaW50LnRJbXB1bHNlLCAoLUNYKSwgKC1DWSkpO1xyXG4gICAgICAgICBpbXB1bHNlWCA9IGIyUmV2b2x1dGVKb2ludC50SW1wdWxzZS54O1xyXG4gICAgICAgICBpbXB1bHNlWSA9IGIyUmV2b2x1dGVKb2ludC50SW1wdWxzZS55O1xyXG4gICAgICAgICBiQS5tX3N3ZWVwLmMueCAtPSBiQS5tX2ludk1hc3MgKiBpbXB1bHNlWDtcclxuICAgICAgICAgYkEubV9zd2VlcC5jLnkgLT0gYkEubV9pbnZNYXNzICogaW1wdWxzZVk7XHJcbiAgICAgICAgIGJBLm1fc3dlZXAuYSAtPSBiQS5tX2ludkkgKiAocjFYICogaW1wdWxzZVkgLSByMVkgKiBpbXB1bHNlWCk7XHJcbiAgICAgICAgIGJCLm1fc3dlZXAuYy54ICs9IGJCLm1faW52TWFzcyAqIGltcHVsc2VYO1xyXG4gICAgICAgICBiQi5tX3N3ZWVwLmMueSArPSBiQi5tX2ludk1hc3MgKiBpbXB1bHNlWTtcclxuICAgICAgICAgYkIubV9zd2VlcC5hICs9IGJCLm1faW52SSAqIChyMlggKiBpbXB1bHNlWSAtIHIyWSAqIGltcHVsc2VYKTtcclxuICAgICAgICAgYkEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcG9zaXRpb25FcnJvciA8PSBiMlNldHRpbmdzLmIyX2xpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IGIyU2V0dGluZ3MuYjJfYW5ndWxhclNsb3A7XHJcbiAgIH1cclxuICAgQm94MkQucG9zdERlZnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMlJldm9sdXRlSm9pbnQudEltcHVsc2UgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH0pO1xyXG4gICBCb3gyRC5pbmhlcml0KGIyUmV2b2x1dGVKb2ludERlZiwgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYpO1xyXG4gICBiMlJldm9sdXRlSm9pbnREZWYucHJvdG90eXBlLl9fc3VwZXIgPSBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZi5wcm90b3R5cGU7XHJcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5iMlJldm9sdXRlSm9pbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIEJveDJELkR5bmFtaWNzLkpvaW50cy5iMkpvaW50RGVmLmIySm9pbnREZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgYjJWZWMyKCk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xyXG4gICB9O1xyXG4gICBiMlJldm9sdXRlSm9pbnREZWYucHJvdG90eXBlLmIyUmV2b2x1dGVKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX3Jldm9sdXRlSm9pbnQ7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JBLlNldCgwLjAsIDAuMCk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldCgwLjAsIDAuMCk7XHJcbiAgICAgIHRoaXMucmVmZXJlbmNlQW5nbGUgPSAwLjA7XHJcbiAgICAgIHRoaXMubG93ZXJBbmdsZSA9IDAuMDtcclxuICAgICAgdGhpcy51cHBlckFuZ2xlID0gMC4wO1xyXG4gICAgICB0aGlzLm1heE1vdG9yVG9ycXVlID0gMC4wO1xyXG4gICAgICB0aGlzLm1vdG9yU3BlZWQgPSAwLjA7XHJcbiAgICAgIHRoaXMuZW5hYmxlTGltaXQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5lbmFibGVNb3RvciA9IGZhbHNlO1xyXG4gICB9XHJcbiAgIGIyUmV2b2x1dGVKb2ludERlZi5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChiQSwgYkIsIGFuY2hvcikge1xyXG4gICAgICB0aGlzLmJvZHlBID0gYkE7XHJcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSB0aGlzLmJvZHlBLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSB0aGlzLmJvZHlCLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcclxuICAgICAgdGhpcy5yZWZlcmVuY2VBbmdsZSA9IHRoaXMuYm9keUIuR2V0QW5nbGUoKSAtIHRoaXMuYm9keUEuR2V0QW5nbGUoKTtcclxuICAgfVxyXG4gICBCb3gyRC5pbmhlcml0KGIyV2VsZEpvaW50LCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludCk7XHJcbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQucHJvdG90eXBlO1xyXG4gICBiMldlbGRKb2ludC5iMldlbGRKb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnQuYjJKb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JBID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JCID0gbmV3IGIyVmVjMigpO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcclxuICAgICAgdGhpcy5tX21hc3MgPSBuZXcgYjJNYXQzMygpO1xyXG4gICB9O1xyXG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuR2V0QW5jaG9yQSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV9ib2R5QS5HZXRXb3JsZFBvaW50KHRoaXMubV9sb2NhbEFuY2hvckEpO1xyXG4gICB9XHJcbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5HZXRBbmNob3JCID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2JvZHlCLkdldFdvcmxkUG9pbnQodGhpcy5tX2xvY2FsQW5jaG9yQik7XHJcbiAgIH1cclxuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uRm9yY2UgPSBmdW5jdGlvbiAoaW52X2R0KSB7XHJcbiAgICAgIGlmIChpbnZfZHQgPT09IHVuZGVmaW5lZCkgaW52X2R0ID0gMDtcclxuICAgICAgcmV0dXJuIG5ldyBiMlZlYzIoaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueCwgaW52X2R0ICogdGhpcy5tX2ltcHVsc2UueSk7XHJcbiAgIH1cclxuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLkdldFJlYWN0aW9uVG9ycXVlID0gZnVuY3Rpb24gKGludl9kdCkge1xyXG4gICAgICBpZiAoaW52X2R0ID09PSB1bmRlZmluZWQpIGludl9kdCA9IDA7XHJcbiAgICAgIHJldHVybiBpbnZfZHQgKiB0aGlzLm1faW1wdWxzZS56O1xyXG4gICB9XHJcbiAgIGIyV2VsZEpvaW50LnByb3RvdHlwZS5iMldlbGRKb2ludCA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnQuY2FsbCh0aGlzLCBkZWYpO1xyXG4gICAgICB0aGlzLm1fbG9jYWxBbmNob3JBLlNldFYoZGVmLmxvY2FsQW5jaG9yQSk7XHJcbiAgICAgIHRoaXMubV9sb2NhbEFuY2hvckIuU2V0VihkZWYubG9jYWxBbmNob3JCKTtcclxuICAgICAgdGhpcy5tX3JlZmVyZW5jZUFuZ2xlID0gZGVmLnJlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgIHRoaXMubV9tYXNzID0gbmV3IGIyTWF0MzMoKTtcclxuICAgfVxyXG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuSW5pdFZlbG9jaXR5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByQVkgPSB0aGlzLm1fbG9jYWxBbmNob3JBLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckFYICsgdE1hdC5jb2wyLnggKiByQVkpO1xyXG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XHJcbiAgICAgIHJBWCA9IHRYO1xyXG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgckJZID0gdGhpcy5tX2xvY2FsQW5jaG9yQi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJCWCArIHRNYXQuY29sMi54ICogckJZKTtcclxuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xyXG4gICAgICByQlggPSB0WDtcclxuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgbUIgPSBiQi5tX2ludk1hc3M7XHJcbiAgICAgIHZhciBpQSA9IGJBLm1faW52STtcclxuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnggPSBtQSArIG1CICsgckFZICogckFZICogaUEgKyByQlkgKiByQlkgKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yQVkgKiByQVggKiBpQSkgLSByQlkgKiByQlggKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMy54ID0gKC1yQVkgKiBpQSkgLSByQlkgKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMS55ID0gdGhpcy5tX21hc3MuY29sMi54O1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtQSArIG1CICsgckFYICogckFYICogaUEgKyByQlggKiByQlggKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMy55ID0gckFYICogaUEgKyByQlggKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMS56ID0gdGhpcy5tX21hc3MuY29sMy54O1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XHJcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueiA9IGlBICsgaUI7XHJcbiAgICAgIGlmIChzdGVwLndhcm1TdGFydGluZykge1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS54ICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgdGhpcy5tX2ltcHVsc2UueSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgIHRoaXMubV9pbXB1bHNlLnogKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnggLT0gbUEgKiB0aGlzLm1faW1wdWxzZS54O1xyXG4gICAgICAgICBiQS5tX2xpbmVhclZlbG9jaXR5LnkgLT0gbUEgKiB0aGlzLm1faW1wdWxzZS55O1xyXG4gICAgICAgICBiQS5tX2FuZ3VsYXJWZWxvY2l0eSAtPSBpQSAqIChyQVggKiB0aGlzLm1faW1wdWxzZS55IC0gckFZICogdGhpcy5tX2ltcHVsc2UueCArIHRoaXMubV9pbXB1bHNlLnopO1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnggKz0gbUIgKiB0aGlzLm1faW1wdWxzZS54O1xyXG4gICAgICAgICBiQi5tX2xpbmVhclZlbG9jaXR5LnkgKz0gbUIgKiB0aGlzLm1faW1wdWxzZS55O1xyXG4gICAgICAgICBiQi5tX2FuZ3VsYXJWZWxvY2l0eSArPSBpQiAqIChyQlggKiB0aGlzLm1faW1wdWxzZS55IC0gckJZICogdGhpcy5tX2ltcHVsc2UueCArIHRoaXMubV9pbXB1bHNlLnopO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICB0aGlzLm1faW1wdWxzZS5TZXRaZXJvKCk7XHJcbiAgICAgIH1cclxuICAgfVxyXG4gICBiMldlbGRKb2ludC5wcm90b3R5cGUuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgdmFyIHRNYXQ7XHJcbiAgICAgIHZhciB0WCA9IDA7XHJcbiAgICAgIHZhciBiQSA9IHRoaXMubV9ib2R5QTtcclxuICAgICAgdmFyIGJCID0gdGhpcy5tX2JvZHlCO1xyXG4gICAgICB2YXIgdkEgPSBiQS5tX2xpbmVhclZlbG9jaXR5O1xyXG4gICAgICB2YXIgd0EgPSBiQS5tX2FuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHZCID0gYkIubV9saW5lYXJWZWxvY2l0eTtcclxuICAgICAgdmFyIHdCID0gYkIubV9hbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgIHZhciBtQSA9IGJBLm1faW52TWFzcztcclxuICAgICAgdmFyIG1CID0gYkIubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgaUEgPSBiQS5tX2ludkk7XHJcbiAgICAgIHZhciBpQiA9IGJCLm1faW52STtcclxuICAgICAgdE1hdCA9IGJBLm1feGYuUjtcclxuICAgICAgdmFyIHJBWCA9IHRoaXMubV9sb2NhbEFuY2hvckEueCAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueDtcclxuICAgICAgdmFyIHJBWSA9IHRoaXMubV9sb2NhbEFuY2hvckEueSAtIGJBLm1fc3dlZXAubG9jYWxDZW50ZXIueTtcclxuICAgICAgdFggPSAodE1hdC5jb2wxLnggKiByQVggKyB0TWF0LmNvbDIueCAqIHJBWSk7XHJcbiAgICAgIHJBWSA9ICh0TWF0LmNvbDEueSAqIHJBWCArIHRNYXQuY29sMi55ICogckFZKTtcclxuICAgICAgckFYID0gdFg7XHJcbiAgICAgIHRNYXQgPSBiQi5tX3hmLlI7XHJcbiAgICAgIHZhciByQlggPSB0aGlzLm1fbG9jYWxBbmNob3JCLnggLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByQlkgPSB0aGlzLm1fbG9jYWxBbmNob3JCLnkgLSBiQi5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckJYICsgdE1hdC5jb2wyLnggKiByQlkpO1xyXG4gICAgICByQlkgPSAodE1hdC5jb2wxLnkgKiByQlggKyB0TWF0LmNvbDIueSAqIHJCWSk7XHJcbiAgICAgIHJCWCA9IHRYO1xyXG4gICAgICB2YXIgQ2RvdDFYID0gdkIueCAtIHdCICogckJZIC0gdkEueCArIHdBICogckFZO1xyXG4gICAgICB2YXIgQ2RvdDFZID0gdkIueSArIHdCICogckJYIC0gdkEueSAtIHdBICogckFYO1xyXG4gICAgICB2YXIgQ2RvdDIgPSB3QiAtIHdBO1xyXG4gICAgICB2YXIgaW1wdWxzZSA9IG5ldyBiMlZlYzMoKTtcclxuICAgICAgdGhpcy5tX21hc3MuU29sdmUzMyhpbXB1bHNlLCAoLUNkb3QxWCksICgtQ2RvdDFZKSwgKC1DZG90MikpO1xyXG4gICAgICB0aGlzLm1faW1wdWxzZS5BZGQoaW1wdWxzZSk7XHJcbiAgICAgIHZBLnggLT0gbUEgKiBpbXB1bHNlLng7XHJcbiAgICAgIHZBLnkgLT0gbUEgKiBpbXB1bHNlLnk7XHJcbiAgICAgIHdBIC09IGlBICogKHJBWCAqIGltcHVsc2UueSAtIHJBWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XHJcbiAgICAgIHZCLnggKz0gbUIgKiBpbXB1bHNlLng7XHJcbiAgICAgIHZCLnkgKz0gbUIgKiBpbXB1bHNlLnk7XHJcbiAgICAgIHdCICs9IGlCICogKHJCWCAqIGltcHVsc2UueSAtIHJCWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XHJcbiAgICAgIGJBLm1fYW5ndWxhclZlbG9jaXR5ID0gd0E7XHJcbiAgICAgIGJCLm1fYW5ndWxhclZlbG9jaXR5ID0gd0I7XHJcbiAgIH1cclxuICAgYjJXZWxkSm9pbnQucHJvdG90eXBlLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChiYXVtZ2FydGUpIHtcclxuICAgICAgaWYgKGJhdW1nYXJ0ZSA9PT0gdW5kZWZpbmVkKSBiYXVtZ2FydGUgPSAwO1xyXG4gICAgICB2YXIgdE1hdDtcclxuICAgICAgdmFyIHRYID0gMDtcclxuICAgICAgdmFyIGJBID0gdGhpcy5tX2JvZHlBO1xyXG4gICAgICB2YXIgYkIgPSB0aGlzLm1fYm9keUI7XHJcbiAgICAgIHRNYXQgPSBiQS5tX3hmLlI7XHJcbiAgICAgIHZhciByQVggPSB0aGlzLm1fbG9jYWxBbmNob3JBLnggLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLng7XHJcbiAgICAgIHZhciByQVkgPSB0aGlzLm1fbG9jYWxBbmNob3JBLnkgLSBiQS5tX3N3ZWVwLmxvY2FsQ2VudGVyLnk7XHJcbiAgICAgIHRYID0gKHRNYXQuY29sMS54ICogckFYICsgdE1hdC5jb2wyLnggKiByQVkpO1xyXG4gICAgICByQVkgPSAodE1hdC5jb2wxLnkgKiByQVggKyB0TWF0LmNvbDIueSAqIHJBWSk7XHJcbiAgICAgIHJBWCA9IHRYO1xyXG4gICAgICB0TWF0ID0gYkIubV94Zi5SO1xyXG4gICAgICB2YXIgckJYID0gdGhpcy5tX2xvY2FsQW5jaG9yQi54IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci54O1xyXG4gICAgICB2YXIgckJZID0gdGhpcy5tX2xvY2FsQW5jaG9yQi55IC0gYkIubV9zd2VlcC5sb2NhbENlbnRlci55O1xyXG4gICAgICB0WCA9ICh0TWF0LmNvbDEueCAqIHJCWCArIHRNYXQuY29sMi54ICogckJZKTtcclxuICAgICAgckJZID0gKHRNYXQuY29sMS55ICogckJYICsgdE1hdC5jb2wyLnkgKiByQlkpO1xyXG4gICAgICByQlggPSB0WDtcclxuICAgICAgdmFyIG1BID0gYkEubV9pbnZNYXNzO1xyXG4gICAgICB2YXIgbUIgPSBiQi5tX2ludk1hc3M7XHJcbiAgICAgIHZhciBpQSA9IGJBLm1faW52STtcclxuICAgICAgdmFyIGlCID0gYkIubV9pbnZJO1xyXG4gICAgICB2YXIgQzFYID0gYkIubV9zd2VlcC5jLnggKyByQlggLSBiQS5tX3N3ZWVwLmMueCAtIHJBWDtcclxuICAgICAgdmFyIEMxWSA9IGJCLm1fc3dlZXAuYy55ICsgckJZIC0gYkEubV9zd2VlcC5jLnkgLSByQVk7XHJcbiAgICAgIHZhciBDMiA9IGJCLm1fc3dlZXAuYSAtIGJBLm1fc3dlZXAuYSAtIHRoaXMubV9yZWZlcmVuY2VBbmdsZTtcclxuICAgICAgdmFyIGtfYWxsb3dlZFN0cmV0Y2ggPSAxMC4wICogYjJTZXR0aW5ncy5iMl9saW5lYXJTbG9wO1xyXG4gICAgICB2YXIgcG9zaXRpb25FcnJvciA9IE1hdGguc3FydChDMVggKiBDMVggKyBDMVkgKiBDMVkpO1xyXG4gICAgICB2YXIgYW5ndWxhckVycm9yID0gYjJNYXRoLkFicyhDMik7XHJcbiAgICAgIGlmIChwb3NpdGlvbkVycm9yID4ga19hbGxvd2VkU3RyZXRjaCkge1xyXG4gICAgICAgICBpQSAqPSAxLjA7XHJcbiAgICAgICAgIGlCICo9IDEuMDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wxLnggPSBtQSArIG1CICsgckFZICogckFZICogaUEgKyByQlkgKiByQlkgKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMi54ID0gKC1yQVkgKiByQVggKiBpQSkgLSByQlkgKiByQlggKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMy54ID0gKC1yQVkgKiBpQSkgLSByQlkgKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMS55ID0gdGhpcy5tX21hc3MuY29sMi54O1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnkgPSBtQSArIG1CICsgckFYICogckFYICogaUEgKyByQlggKiByQlggKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMy55ID0gckFYICogaUEgKyByQlggKiBpQjtcclxuICAgICAgdGhpcy5tX21hc3MuY29sMS56ID0gdGhpcy5tX21hc3MuY29sMy54O1xyXG4gICAgICB0aGlzLm1fbWFzcy5jb2wyLnogPSB0aGlzLm1fbWFzcy5jb2wzLnk7XHJcbiAgICAgIHRoaXMubV9tYXNzLmNvbDMueiA9IGlBICsgaUI7XHJcbiAgICAgIHZhciBpbXB1bHNlID0gbmV3IGIyVmVjMygpO1xyXG4gICAgICB0aGlzLm1fbWFzcy5Tb2x2ZTMzKGltcHVsc2UsICgtQzFYKSwgKC1DMVkpLCAoLUMyKSk7XHJcbiAgICAgIGJBLm1fc3dlZXAuYy54IC09IG1BICogaW1wdWxzZS54O1xyXG4gICAgICBiQS5tX3N3ZWVwLmMueSAtPSBtQSAqIGltcHVsc2UueTtcclxuICAgICAgYkEubV9zd2VlcC5hIC09IGlBICogKHJBWCAqIGltcHVsc2UueSAtIHJBWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XHJcbiAgICAgIGJCLm1fc3dlZXAuYy54ICs9IG1CICogaW1wdWxzZS54O1xyXG4gICAgICBiQi5tX3N3ZWVwLmMueSArPSBtQiAqIGltcHVsc2UueTtcclxuICAgICAgYkIubV9zd2VlcC5hICs9IGlCICogKHJCWCAqIGltcHVsc2UueSAtIHJCWSAqIGltcHVsc2UueCArIGltcHVsc2Uueik7XHJcbiAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgIGJCLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IGIyU2V0dGluZ3MuYjJfbGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gYjJTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcDtcclxuICAgfVxyXG4gICBCb3gyRC5pbmhlcml0KGIyV2VsZEpvaW50RGVmLCBCb3gyRC5EeW5hbWljcy5Kb2ludHMuYjJKb2ludERlZik7XHJcbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5fX3N1cGVyID0gQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYucHJvdG90eXBlO1xyXG4gICBiMldlbGRKb2ludERlZi5iMldlbGRKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQm94MkQuRHluYW1pY3MuSm9pbnRzLmIySm9pbnREZWYuYjJKb2ludERlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IG5ldyBiMlZlYzIoKTtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgYjJWZWMyKCk7XHJcbiAgIH07XHJcbiAgIGIyV2VsZEpvaW50RGVmLnByb3RvdHlwZS5iMldlbGRKb2ludERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fX3N1cGVyLmIySm9pbnREZWYuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy50eXBlID0gYjJKb2ludC5lX3dlbGRKb2ludDtcclxuICAgICAgdGhpcy5yZWZlcmVuY2VBbmdsZSA9IDAuMDtcclxuICAgfVxyXG4gICBiMldlbGRKb2ludERlZi5wcm90b3R5cGUuSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChiQSwgYkIsIGFuY2hvcikge1xyXG4gICAgICB0aGlzLmJvZHlBID0gYkE7XHJcbiAgICAgIHRoaXMuYm9keUIgPSBiQjtcclxuICAgICAgdGhpcy5sb2NhbEFuY2hvckEuU2V0Vih0aGlzLmJvZHlBLkdldExvY2FsUG9pbnQoYW5jaG9yKSk7XHJcbiAgICAgIHRoaXMubG9jYWxBbmNob3JCLlNldFYodGhpcy5ib2R5Qi5HZXRMb2NhbFBvaW50KGFuY2hvcikpO1xyXG4gICAgICB0aGlzLnJlZmVyZW5jZUFuZ2xlID0gdGhpcy5ib2R5Qi5HZXRBbmdsZSgpIC0gdGhpcy5ib2R5QS5HZXRBbmdsZSgpO1xyXG4gICB9XHJcbn0pKCk7XHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgIHZhciBiMkRlYnVnRHJhdyA9IEJveDJELkR5bmFtaWNzLmIyRGVidWdEcmF3O1xyXG4gICBiMkRlYnVnRHJhdy5iMkRlYnVnRHJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tX2RyYXdTY2FsZSA9IDEuMDtcclxuICAgICAgdGhpcy5tX2xpbmVUaGlja25lc3MgPSAxLjA7XHJcbiAgICAgIHRoaXMubV9hbHBoYSA9IDEuMDtcclxuICAgICAgdGhpcy5tX2ZpbGxBbHBoYSA9IDEuMDtcclxuICAgICAgdGhpcy5tX3hmb3JtU2NhbGUgPSAxLjA7XHJcbiAgICAgIHZhciBfX3RoaXMgPSB0aGlzO1xyXG4gICAgICAvLyNXT1JLQVJPVU5EXHJcbiAgICAgIHRoaXMubV9zcHJpdGUgPSB7XHJcbiAgICAgICAgIGdyYXBoaWNzOiB7XHJcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgIF9fdGhpcy5tX2N0eC5jbGVhclJlY3QoMCwgMCwgX190aGlzLm1fY3R4LmNhbnZhcy53aWR0aCwgX190aGlzLm1fY3R4LmNhbnZhcy5oZWlnaHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuX2NvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBhbHBoYSkge1xyXG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgKChjb2xvciAmIDB4RkYwMDAwKSA+PiAxNikgKyBcIixcIiArICgoY29sb3IgJiAweEZGMDApID4+IDgpICsgXCIsXCIgKyAoY29sb3IgJiAweEZGKSArIFwiLFwiICsgYWxwaGEgKyBcIilcIjtcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLmIyRGVidWdEcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1fZHJhd0ZsYWdzID0gMDtcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XHJcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XHJcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgPSBmbGFncztcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldEZsYWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2RyYXdGbGFncztcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkFwcGVuZEZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XHJcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XHJcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgfD0gZmxhZ3M7XHJcbiAgIH07XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5DbGVhckZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XHJcbiAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSBmbGFncyA9IDA7XHJcbiAgICAgIHRoaXMubV9kcmF3RmxhZ3MgJj0gfmZsYWdzO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuU2V0U3ByaXRlID0gZnVuY3Rpb24gKHNwcml0ZSkge1xyXG4gICAgICB0aGlzLm1fY3R4ID0gc3ByaXRlO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0U3ByaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2N0eDtcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldERyYXdTY2FsZSA9IGZ1bmN0aW9uIChkcmF3U2NhbGUpIHtcclxuICAgICAgaWYgKGRyYXdTY2FsZSA9PT0gdW5kZWZpbmVkKSBkcmF3U2NhbGUgPSAwO1xyXG4gICAgICB0aGlzLm1fZHJhd1NjYWxlID0gZHJhd1NjYWxlO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RHJhd1NjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2RyYXdTY2FsZTtcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldExpbmVUaGlja25lc3MgPSBmdW5jdGlvbiAobGluZVRoaWNrbmVzcykge1xyXG4gICAgICBpZiAobGluZVRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkKSBsaW5lVGhpY2tuZXNzID0gMDtcclxuICAgICAgdGhpcy5tX2xpbmVUaGlja25lc3MgPSBsaW5lVGhpY2tuZXNzO1xyXG4gICAgICB0aGlzLm1fY3R4LnN0cm9rZVdpZHRoID0gbGluZVRoaWNrbmVzcztcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkdldExpbmVUaGlja25lc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fbGluZVRoaWNrbmVzcztcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldEFscGhhID0gZnVuY3Rpb24gKGFscGhhKSB7XHJcbiAgICAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSBhbHBoYSA9IDA7XHJcbiAgICAgIHRoaXMubV9hbHBoYSA9IGFscGhhO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0QWxwaGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1fYWxwaGE7XHJcbiAgIH07XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5TZXRGaWxsQWxwaGEgPSBmdW5jdGlvbiAoYWxwaGEpIHtcclxuICAgICAgaWYgKGFscGhhID09PSB1bmRlZmluZWQpIGFscGhhID0gMDtcclxuICAgICAgdGhpcy5tX2ZpbGxBbHBoYSA9IGFscGhhO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0RmlsbEFscGhhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tX2ZpbGxBbHBoYTtcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLlNldFhGb3JtU2NhbGUgPSBmdW5jdGlvbiAoeGZvcm1TY2FsZSkge1xyXG4gICAgICBpZiAoeGZvcm1TY2FsZSA9PT0gdW5kZWZpbmVkKSB4Zm9ybVNjYWxlID0gMDtcclxuICAgICAgdGhpcy5tX3hmb3JtU2NhbGUgPSB4Zm9ybVNjYWxlO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuR2V0WEZvcm1TY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubV94Zm9ybVNjYWxlO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1BvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xyXG4gICAgICBpZiAoIXZlcnRleENvdW50KSByZXR1cm47XHJcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eDtcclxuICAgICAgdmFyIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XHJcbiAgICAgIHMuYmVnaW5QYXRoKCk7XHJcbiAgICAgIHMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2FscGhhKTtcclxuICAgICAgcy5tb3ZlVG8odmVydGljZXNbMF0ueCAqIGRyYXdTY2FsZSwgdmVydGljZXNbMF0ueSAqIGRyYXdTY2FsZSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xyXG4gICAgICAgICBzLmxpbmVUbyh2ZXJ0aWNlc1tpXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1tpXS55ICogZHJhd1NjYWxlKTtcclxuICAgICAgfVxyXG4gICAgICBzLmxpbmVUbyh2ZXJ0aWNlc1swXS54ICogZHJhd1NjYWxlLCB2ZXJ0aWNlc1swXS55ICogZHJhd1NjYWxlKTtcclxuICAgICAgcy5jbG9zZVBhdGgoKTtcclxuICAgICAgcy5zdHJva2UoKTtcclxuICAgfTtcclxuICAgYjJEZWJ1Z0RyYXcucHJvdG90eXBlLkRyYXdTb2xpZFBvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHZlcnRleENvdW50LCBjb2xvcikge1xyXG4gICAgICBpZiAoIXZlcnRleENvdW50KSByZXR1cm47XHJcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eDtcclxuICAgICAgdmFyIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGU7XHJcbiAgICAgIHMuYmVnaW5QYXRoKCk7XHJcbiAgICAgIHMuc3Ryb2tlU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2FscGhhKTtcclxuICAgICAgcy5maWxsU3R5bGUgPSB0aGlzLl9jb2xvcihjb2xvci5jb2xvciwgdGhpcy5tX2ZpbGxBbHBoYSk7XHJcbiAgICAgIHMubW92ZVRvKHZlcnRpY2VzWzBdLnggKiBkcmF3U2NhbGUsIHZlcnRpY2VzWzBdLnkgKiBkcmF3U2NhbGUpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcclxuICAgICAgICAgcy5saW5lVG8odmVydGljZXNbaV0ueCAqIGRyYXdTY2FsZSwgdmVydGljZXNbaV0ueSAqIGRyYXdTY2FsZSk7XHJcbiAgICAgIH1cclxuICAgICAgcy5saW5lVG8odmVydGljZXNbMF0ueCAqIGRyYXdTY2FsZSwgdmVydGljZXNbMF0ueSAqIGRyYXdTY2FsZSk7XHJcbiAgICAgIHMuY2xvc2VQYXRoKCk7XHJcbiAgICAgIHMuZmlsbCgpO1xyXG4gICAgICBzLnN0cm9rZSgpO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd0NpcmNsZSA9IGZ1bmN0aW9uIChjZW50ZXIsIHJhZGl1cywgY29sb3IpIHtcclxuICAgICAgaWYgKCFyYWRpdXMpIHJldHVybjtcclxuICAgICAgdmFyIHMgPSB0aGlzLm1fY3R4O1xyXG4gICAgICB2YXIgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZTtcclxuICAgICAgcy5iZWdpblBhdGgoKTtcclxuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xyXG4gICAgICBzLmFyYyhjZW50ZXIueCAqIGRyYXdTY2FsZSwgY2VudGVyLnkgKiBkcmF3U2NhbGUsIHJhZGl1cyAqIGRyYXdTY2FsZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICBzLmNsb3NlUGF0aCgpO1xyXG4gICAgICBzLnN0cm9rZSgpO1xyXG4gICB9O1xyXG4gICBiMkRlYnVnRHJhdy5wcm90b3R5cGUuRHJhd1NvbGlkQ2lyY2xlID0gZnVuY3Rpb24gKGNlbnRlciwgcmFkaXVzLCBheGlzLCBjb2xvcikge1xyXG4gICAgICBpZiAoIXJhZGl1cykgcmV0dXJuO1xyXG4gICAgICB2YXIgcyA9IHRoaXMubV9jdHgsXHJcbiAgICAgICAgIGRyYXdTY2FsZSA9IHRoaXMubV9kcmF3U2NhbGUsXHJcbiAgICAgICAgIGN4ID0gY2VudGVyLnggKiBkcmF3U2NhbGUsXHJcbiAgICAgICAgIGN5ID0gY2VudGVyLnkgKiBkcmF3U2NhbGU7XHJcbiAgICAgIHMubW92ZVRvKDAsIDApO1xyXG4gICAgICBzLmJlZ2luUGF0aCgpO1xyXG4gICAgICBzLnN0cm9rZVN0eWxlID0gdGhpcy5fY29sb3IoY29sb3IuY29sb3IsIHRoaXMubV9hbHBoYSk7XHJcbiAgICAgIHMuZmlsbFN0eWxlID0gdGhpcy5fY29sb3IoY29sb3IuY29sb3IsIHRoaXMubV9maWxsQWxwaGEpO1xyXG4gICAgICBzLmFyYyhjeCwgY3ksIHJhZGl1cyAqIGRyYXdTY2FsZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICBzLm1vdmVUbyhjeCwgY3kpO1xyXG4gICAgICBzLmxpbmVUbygoY2VudGVyLnggKyBheGlzLnggKiByYWRpdXMpICogZHJhd1NjYWxlLCAoY2VudGVyLnkgKyBheGlzLnkgKiByYWRpdXMpICogZHJhd1NjYWxlKTtcclxuICAgICAgcy5jbG9zZVBhdGgoKTtcclxuICAgICAgcy5maWxsKCk7XHJcbiAgICAgIHMuc3Ryb2tlKCk7XHJcbiAgIH07XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3U2VnbWVudCA9IGZ1bmN0aW9uIChwMSwgcDIsIGNvbG9yKSB7XHJcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eCxcclxuICAgICAgICAgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZTtcclxuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKGNvbG9yLmNvbG9yLCB0aGlzLm1fYWxwaGEpO1xyXG4gICAgICBzLmJlZ2luUGF0aCgpO1xyXG4gICAgICBzLm1vdmVUbyhwMS54ICogZHJhd1NjYWxlLCBwMS55ICogZHJhd1NjYWxlKTtcclxuICAgICAgcy5saW5lVG8ocDIueCAqIGRyYXdTY2FsZSwgcDIueSAqIGRyYXdTY2FsZSk7XHJcbiAgICAgIHMuY2xvc2VQYXRoKCk7XHJcbiAgICAgIHMuc3Ryb2tlKCk7XHJcbiAgIH07XHJcbiAgIGIyRGVidWdEcmF3LnByb3RvdHlwZS5EcmF3VHJhbnNmb3JtID0gZnVuY3Rpb24gKHhmKSB7XHJcbiAgICAgIHZhciBzID0gdGhpcy5tX2N0eCxcclxuICAgICAgICAgZHJhd1NjYWxlID0gdGhpcy5tX2RyYXdTY2FsZTtcclxuICAgICAgcy5iZWdpblBhdGgoKTtcclxuICAgICAgcy5zdHJva2VTdHlsZSA9IHRoaXMuX2NvbG9yKDB4ZmYwMDAwLCB0aGlzLm1fYWxwaGEpO1xyXG4gICAgICBzLm1vdmVUbyh4Zi5wb3NpdGlvbi54ICogZHJhd1NjYWxlLCB4Zi5wb3NpdGlvbi55ICogZHJhd1NjYWxlKTtcclxuICAgICAgcy5saW5lVG8oKHhmLnBvc2l0aW9uLnggKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMS54KSAqIGRyYXdTY2FsZSwgKHhmLnBvc2l0aW9uLnkgKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMS55KSAqIGRyYXdTY2FsZSk7XHJcblxyXG4gICAgICBzLnN0cm9rZVN0eWxlID0gdGhpcy5fY29sb3IoMHhmZjAwLCB0aGlzLm1fYWxwaGEpO1xyXG4gICAgICBzLm1vdmVUbyh4Zi5wb3NpdGlvbi54ICogZHJhd1NjYWxlLCB4Zi5wb3NpdGlvbi55ICogZHJhd1NjYWxlKTtcclxuICAgICAgcy5saW5lVG8oKHhmLnBvc2l0aW9uLnggKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMi54KSAqIGRyYXdTY2FsZSwgKHhmLnBvc2l0aW9uLnkgKyB0aGlzLm1feGZvcm1TY2FsZSAqIHhmLlIuY29sMi55KSAqIGRyYXdTY2FsZSk7XHJcbiAgICAgIHMuY2xvc2VQYXRoKCk7XHJcbiAgICAgIHMuc3Ryb2tlKCk7XHJcbiAgIH07XHJcbn0pKCk7XHJcbnZhciBpO1xyXG5mb3IgKGkgPSAwOyBpIDwgQm94MkQucG9zdERlZnMubGVuZ3RoOyArK2kpIEJveDJELnBvc3REZWZzW2ldKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJveDJEIl19
